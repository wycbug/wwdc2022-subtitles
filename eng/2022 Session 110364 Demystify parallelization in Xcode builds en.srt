1
00:00:00,501 --> 00:00:08,509
♪ ♪

2
00:00:09,309 --> 00:00:12,579
Hello, and welcome to WWDC 2022.

3
00:00:12,613 --> 00:00:15,749
My name is Ben, and I'm an engineer
on the Xcode build system team.

4
00:00:15,782 --> 00:00:19,152
Hi, my name is Artem, and I'm
an engineer on the Swift Compiler team.

5
00:00:19,186 --> 00:00:22,489
In this talk we're gonna give you
a deep dive into Xcode's build process

6
00:00:22,523 --> 00:00:25,959
to demystify parallelization
inside builds.

7
00:00:25,993 --> 00:00:29,062
Ben is going to start with an introduction
of the core concepts about builds

8
00:00:29,096 --> 00:00:31,565
and look at the available tools
that Xcode offers

9
00:00:31,598 --> 00:00:34,301
to help investigate
build performance issues.

10
00:00:34,334 --> 00:00:39,006
He will then explain how Xcode increases
parallelization while building a target.

11
00:00:39,039 --> 00:00:40,240
Building on top of that,

12
00:00:40,274 --> 00:00:43,610
I will explain how Xcode
parallelizes a build holistically

13
00:00:43,644 --> 00:00:46,280
while building projects
consisting of many targets

14
00:00:46,313 --> 00:00:48,415
and summarize the takeaways in the end.

15
00:00:48,448 --> 00:00:50,551
Ben?

16
00:00:50,584 --> 00:00:55,355
Let's re-iterate on what happens when
pressing CMD+B in Xcode to build an app.

17
00:00:55,389 --> 00:00:57,691
The build system, as part of Xcode,

18
00:00:57,724 --> 00:01:00,661
gets invoked with a representation
of the whole project,

19
00:01:00,694 --> 00:01:02,996
including all source files, assets,

20
00:01:03,030 --> 00:01:07,267
build settings, and other configurations
like the run destination.

21
00:01:07,301 --> 00:01:11,205
The build system is the single source
of truth about how an app should be built.

22
00:01:11,238 --> 00:01:14,141
It knows which tools to invoke
using which settings

23
00:01:14,174 --> 00:01:18,078
and which intermediate files to produce
to eventually create an app.

24
00:01:18,111 --> 00:01:20,881
In the next step,
the build system invokes the tools

25
00:01:20,914 --> 00:01:24,852
to process the project's input files,
for example, the compilers.

26
00:01:26,253 --> 00:01:29,857
Both compilers, Clang and Swift,
will produce object files

27
00:01:29,890 --> 00:01:32,693
that the linker needs
to link the executable program

28
00:01:32,726 --> 00:01:34,728
that represents the app.

29
00:01:34,761 --> 00:01:37,831
While this order makes sense,
it's not obvious where it comes from.

30
00:01:37,865 --> 00:01:40,133
So let's take a look
at one example of that process

31
00:01:40,167 --> 00:01:44,238
and how the build system decides
in which order to execute all tasks.

32
00:01:46,273 --> 00:01:49,343
Using the input source-files,
the Swift compiler captures

33
00:01:49,376 --> 00:01:53,113
the programmer's intent and translates it
into a machine-executable binary,

34
00:01:53,146 --> 00:01:55,949
checking the source code
for errors along the way.

35
00:01:55,983 --> 00:01:58,418
This process can fail,
which would cancel the build,

36
00:01:58,452 --> 00:02:02,789
but if it succeeds,
it creates an object file for each input.

37
00:02:02,823 --> 00:02:05,592
Those object files are used
to invoke the linker

38
00:02:05,626 --> 00:02:08,862
which combines them and adds references
to externally linked libraries

39
00:02:08,896 --> 00:02:11,265
to produce the executable.

40
00:02:11,298 --> 00:02:15,002
The two tasks have a dependency
based on what they consume and produce.

41
00:02:15,035 --> 00:02:19,840
The object files produced by the compiler
get consumed by the linker.

42
00:02:19,873 --> 00:02:22,676
This creates a dependency
on the build system graph.

43
00:02:22,709 --> 00:02:25,879
The file contents itself
are not of interest to the build system,

44
00:02:25,913 --> 00:02:28,749
but the dependency between the tasks is.

45
00:02:28,782 --> 00:02:30,784
While executing the build,
it needs to make sure

46
00:02:30,817 --> 00:02:35,923
that a task that produces another task's
input finishes before said task can start.

47
00:02:35,956 --> 00:02:39,159
And since this core concept
is valid for all kind of tasks,

48
00:02:39,193 --> 00:02:41,328
let's switch to
a more generic visualization

49
00:02:41,361 --> 00:02:44,498
that shows a dependency
between Task A and Task B.

50
00:02:44,531 --> 00:02:48,635
In this case,
A produces some or all of B's inputs.

51
00:02:49,937 --> 00:02:53,106
Compiling and Linking are only
a few of many different task types

52
00:02:53,140 --> 00:02:56,043
that need to be executed
to build a whole target,

53
00:02:56,076 --> 00:02:58,145
so let's add some more generic tasks
to the graph

54
00:02:58,178 --> 00:03:00,914
that represent other types
like compiling assets,

55
00:03:00,948 --> 00:03:03,650
copying files or codesigning.

56
00:03:03,684 --> 00:03:07,454
Together, they represent
building a Framework target.

57
00:03:07,487 --> 00:03:10,224
Again,
those tasks have defined dependencies

58
00:03:10,257 --> 00:03:12,426
based on their inputs and outputs.

59
00:03:12,459 --> 00:03:16,897
So completing executing task A
unblocks running task B and C,

60
00:03:16,930 --> 00:03:21,168
while finishing task B
unblocks task D and E.

61
00:03:21,201 --> 00:03:24,204
Tasks that get unblocked
are called 'downstream'

62
00:03:24,238 --> 00:03:27,274
and tasks that block 'upstream'.

63
00:03:27,307 --> 00:03:30,143
Many projects contain
more than one framework target,

64
00:03:30,177 --> 00:03:34,481
so let's add two more targets representing
an app and an app extension.

65
00:03:34,515 --> 00:03:37,551
Targets define dependencies
between each other in the project

66
00:03:37,584 --> 00:03:39,820
via explicit or implicit dependencies.

67
00:03:39,853 --> 00:03:44,157
For example, by getting added to the
'Link Binary with Libraries' build phase.

68
00:03:45,993 --> 00:03:48,662
In this case,
the app embeds the app extension

69
00:03:48,695 --> 00:03:50,631
and links against the Framework.

70
00:03:50,664 --> 00:03:52,900
The app extension
is not using the Framework,

71
00:03:52,933 --> 00:03:55,068
so they don't have
a dependency relationship.

72
00:03:56,470 --> 00:04:00,741
When executing the build graph, different
tasks take a different amount of time.

73
00:04:00,774 --> 00:04:05,045
This comes down to the level of complexity
that is necessary to complete the work,

74
00:04:05,078 --> 00:04:10,517
depending on the computation that's needed
as well as the size of the input.

75
00:04:10,551 --> 00:04:15,389
Compiling many files takes usually much
more time than copying a few header files,

76
00:04:15,422 --> 00:04:19,526
and taking this into consideration
will end up with something like this.

77
00:04:19,560 --> 00:04:21,762
When the build system executes this build,

78
00:04:21,795 --> 00:04:25,432
it starts by running tasks
that don't have dependencies.

79
00:04:25,465 --> 00:04:29,570
And once those completed,
they unblock downstream tasks and so on,

80
00:04:29,603 --> 00:04:32,906
following this process
until all planned tasks finished.

81
00:04:35,142 --> 00:04:38,312
On following builds,
the build system is able to skip tasks

82
00:04:38,345 --> 00:04:43,050
for which inputs haven't changed
while the output is still up to date.

83
00:04:43,083 --> 00:04:46,019
If a task needs to re-run
due to a changed input,

84
00:04:46,053 --> 00:04:48,355
like B of the App target in this case,

85
00:04:48,388 --> 00:04:52,159
downstream tasks have to re-run too
if its output changed.

86
00:04:52,192 --> 00:04:55,762
Skipping all other tasks allows
for very fast turnaround times

87
00:04:55,796 --> 00:04:58,432
when iteratively working on the project.

88
00:04:58,465 --> 00:05:02,035
This is called an incremental build,
but let's stick to full builds for now.

89
00:05:03,704 --> 00:05:06,640
The dependencies and duration
of the task execution

90
00:05:06,673 --> 00:05:10,177
defines the first possible time
a downstream task can start.

91
00:05:10,210 --> 00:05:13,480
With this information it's possible
to calculate the critical path

92
00:05:13,514 --> 00:05:16,049
which is the shortest time
the build needs to run

93
00:05:16,083 --> 00:05:18,952
with theoretical unlimited resources.

94
00:05:18,986 --> 00:05:22,456
A common pattern throughout this talk
will be to shorten this path

95
00:05:22,489 --> 00:05:25,826
to create a highly parallelizable
and scalable build graph.

96
00:05:25,859 --> 00:05:29,263
A shorter critical path
does not necessarily result

97
00:05:29,296 --> 00:05:30,931
in a shorter overall build time,

98
00:05:30,964 --> 00:05:34,268
but it ensures that the build scales
with the hardware.

99
00:05:34,301 --> 00:05:36,870
The critical build path
defines the limiting factor

100
00:05:36,904 --> 00:05:38,772
of how fast a build can be–

101
00:05:38,805 --> 00:05:43,310
it cannot complete faster,
even if the hardware would allow it.

102
00:05:43,343 --> 00:05:47,881
Shortening the critical path is done by
breaking up dependencies within it.

103
00:05:47,915 --> 00:05:51,652
When looking at how a build performed and
to understand more about its execution,

104
00:05:51,685 --> 00:05:55,589
the data needs to be plotted
based on the time they executed.

105
00:05:55,622 --> 00:05:58,492
The width still indicates
the length of tasks.

106
00:05:58,525 --> 00:06:01,929
Wide elements like these two
indicate a long running task

107
00:06:01,962 --> 00:06:05,899
while narrow elements like these
represent fast finishing tasks.

108
00:06:07,534 --> 00:06:11,004
The height of the graph shows the number
of parallel executing tasks

109
00:06:11,038 --> 00:06:12,439
at a given time.

110
00:06:12,472 --> 00:06:17,144
Be aware that this does not directly map
to CPU or memory utilization.

111
00:06:18,512 --> 00:06:22,082
Empty space originates by tasks blocking
its downstream tasks

112
00:06:22,115 --> 00:06:24,451
like in those two scenarios.

113
00:06:24,484 --> 00:06:29,423
And finally, the color of the elements
represent their associated target.

114
00:06:29,456 --> 00:06:33,527
I'm very excited to announce that
this visualization is new in Xcode 14

115
00:06:33,560 --> 00:06:37,297
and will help understand
a build's performance after it finished.

116
00:06:37,331 --> 00:06:40,367
The Xcode Build Timeline is
a great new addition to the build log.

117
00:06:40,400 --> 00:06:42,736
It visualizes based on
parallelization,

118
00:06:42,769 --> 00:06:46,139
rather than hierarchy
to understand the build's performance.

119
00:06:46,173 --> 00:06:49,910
The number of rows at given time
represents the level of parallelism

120
00:06:49,943 --> 00:06:51,411
during that time.

121
00:06:51,445 --> 00:06:54,248
The horizontal length of individual tasks

122
00:06:54,281 --> 00:06:57,584
represent the duration they needed
to finish their work.

123
00:06:57,618 --> 00:07:00,387
Empty space in the graph
shows where unfinished tasks

124
00:07:00,420 --> 00:07:04,057
blocked downstream tasks
from starting to execute.

125
00:07:04,091 --> 00:07:06,560
Different colors applied
to the timeline elements

126
00:07:06,593 --> 00:07:10,531
help distinguish the different targets
that were part of the build.

127
00:07:10,564 --> 00:07:13,800
And on incremental builds,
the timeline will only contain tasks

128
00:07:13,834 --> 00:07:15,903
that got actually executed,

129
00:07:15,936 --> 00:07:17,738
allowing to spot long-running tasks,

130
00:07:17,771 --> 00:07:21,842
especially ones which might not have
been expected to run during this build.

131
00:07:22,843 --> 00:07:25,712
Here's a demo of the Build Timeline
in Xcode 14.

132
00:07:25,746 --> 00:07:29,550
In this window I opened a copy
of the swift-docc project from Github

133
00:07:29,583 --> 00:07:31,785
which builds the documentation compiler.

134
00:07:31,818 --> 00:07:34,655
To get an overview about the targets
that are built for the scheme,

135
00:07:34,688 --> 00:07:36,590
let's check out the scheme editor.

136
00:07:36,623 --> 00:07:39,426
To open that I click on the scheme
and select "Edit scheme".

137
00:07:40,427 --> 00:07:43,197
The 'build' tab contains a list
of all targets.

138
00:07:43,230 --> 00:07:45,632
Targets can explicitly get added
to the scheme

139
00:07:45,666 --> 00:07:48,268
or implicitly
by being a dependency of a target

140
00:07:48,302 --> 00:07:50,270
that is already part of the scheme.

141
00:07:50,304 --> 00:07:54,007
In this case I'm using a Swift package
with an automatically generated scheme

142
00:07:54,041 --> 00:07:58,612
for the package, so all targets
from the manifest are explicitly defined.

143
00:08:00,881 --> 00:08:04,451
This log represents a build of that scheme
that I executed earlier.

144
00:08:04,484 --> 00:08:08,188
In contains entries for all tasks
that the build system executed.

145
00:08:08,222 --> 00:08:10,557
The entries are organized in a hierarchy

146
00:08:10,591 --> 00:08:14,761
based on the targets they belong to,
like the 'docc' target here.

147
00:08:14,795 --> 00:08:17,397
To successfully build the executable
of that target,

148
00:08:17,431 --> 00:08:21,568
Xcode ran all tasks that are represented
by the children of this node.

149
00:08:21,602 --> 00:08:23,904
Since the build log is currently
in its 'All' state,

150
00:08:23,937 --> 00:08:26,073
it also shows tasks from previous builds

151
00:08:26,106 --> 00:08:28,709
that didn't need to re-run
in an incremental build.

152
00:08:28,742 --> 00:08:32,246
Selecting 'Recent' only shows tasks
that got actually executed,

153
00:08:32,279 --> 00:08:34,848
hiding all skipped tasks.

154
00:08:34,882 --> 00:08:37,718
In addition to that,
the build log also supports filters

155
00:08:37,751 --> 00:08:40,754
to only show tasks
that had issues or even failed.

156
00:08:43,924 --> 00:08:45,859
To open the build timeline for this build,

157
00:08:45,893 --> 00:08:49,696
I go to the editor options
and open the assistant.

158
00:08:49,730 --> 00:08:52,399
The build timeline
opens next to the build log.

159
00:08:52,432 --> 00:08:55,736
Like usual, the editor options
provide settings to show the assistant

160
00:08:55,769 --> 00:08:57,271
on the right or bottom.

161
00:08:57,304 --> 00:08:59,473
I'll stay with bottom for now.

162
00:08:59,506 --> 00:09:02,576
The timeline visualizes the same data
as the 'recent' build log

163
00:09:02,609 --> 00:09:05,179
based on the parallelization of the build.

164
00:09:05,212 --> 00:09:08,715
Selecting an element in one
also selects it in the other.

165
00:09:08,749 --> 00:09:12,920
This enables to see
a task's execution in context.

166
00:09:12,953 --> 00:09:15,088
The timeline here gives a sense
about the tasks

167
00:09:15,122 --> 00:09:18,091
that executed in parallel
to the selected task.

168
00:09:18,125 --> 00:09:21,662
I'm using a pinch gesture
on the trackpad to zoom out again.

169
00:09:26,233 --> 00:09:30,470
Selecting an element in the timeline
shows it in the build log.

170
00:09:30,504 --> 00:09:34,007
And since the build log visualizes
based on the hierarchical structure,

171
00:09:34,041 --> 00:09:36,476
it enables to view
which files were compiled

172
00:09:36,510 --> 00:09:38,579
as part of this compiler invocation.

173
00:09:38,612 --> 00:09:42,482
It also enables to view the whole
command line of that invocation.

174
00:09:46,954 --> 00:09:49,890
Holding down Option while selecting
an area in the build timeline

175
00:09:49,923 --> 00:09:52,960
adjusts the view port
to fit this timeframe.

176
00:09:52,993 --> 00:09:56,463
Here we can verify
that linking of the target ArgumentParser

177
00:09:56,496 --> 00:09:59,499
is in fact waiting for compilation
of the same target.

178
00:09:59,533 --> 00:10:03,504
Holding Option while scrolling up
allows me to zoom out quickly.

179
00:10:03,537 --> 00:10:06,507
The number of rows in the timeline
represents the number of tasks

180
00:10:06,540 --> 00:10:08,609
that ran in parallel at that time.

181
00:10:08,642 --> 00:10:14,081
An empty space like this indicates tasks
waiting for un-produced inputs.

182
00:10:14,114 --> 00:10:18,418
Ideally, the timeline is vertically filled
and has as little empty space as possible.

183
00:10:18,452 --> 00:10:21,388
This scales the build graph the best
and makes builds faster,

184
00:10:21,421 --> 00:10:23,123
the faster the hardware.

185
00:10:23,156 --> 00:10:26,126
To achieve this, Xcode comes with
many improvements this year

186
00:10:26,159 --> 00:10:28,695
to shorten the critical path.

187
00:10:28,729 --> 00:10:32,633
Next, let's check out how Xcode defines
and builds individual targets

188
00:10:32,666 --> 00:10:35,636
as well as how
it can increase parallelization.

189
00:10:35,669 --> 00:10:38,639
When configuring a target,
build phases describe the work

190
00:10:38,672 --> 00:10:41,808
that needs to be done
to produce that target's product.

191
00:10:41,842 --> 00:10:45,312
They are defined in the project editor
and can contain a set of source code files

192
00:10:45,345 --> 00:10:46,813
and assets to compile,

193
00:10:46,847 --> 00:10:49,583
files that need to be copied
like headers or resources,

194
00:10:49,616 --> 00:10:54,221
as well as libraries that should be linked
or scripts that should be executed.

195
00:10:54,254 --> 00:10:57,090
Many build phases describe
tasks with inputs or outputs

196
00:10:57,124 --> 00:11:00,260
from other build phases,
creating dependencies between them.

197
00:11:00,294 --> 00:11:04,865
For example, a target's source files
must be compiled before it is linked.

198
00:11:04,898 --> 00:11:08,602
However,
this doesn't apply to all build phases.

199
00:11:08,635 --> 00:11:11,672
Instead of running tasks from
each build phase in a linear order,

200
00:11:11,705 --> 00:11:15,042
the build system will consider the inputs
and outputs of build phases

201
00:11:15,075 --> 00:11:17,744
to determine if they can run in parallel.

202
00:11:17,778 --> 00:11:21,548
For example, Compilation
and Resource copying can run in parallel

203
00:11:21,582 --> 00:11:24,785
because neither depends
on any outputs of the other.

204
00:11:24,818 --> 00:11:27,654
However,
linking must still follow compilation

205
00:11:27,688 --> 00:11:30,958
because it depends on the object files
produced by that phase.

206
00:11:30,991 --> 00:11:35,028
Now, let's consider a different target
which contains 'Run Script' build phases.

207
00:11:35,062 --> 00:11:38,732
Unlike other build phases,
the inputs and outputs of script phases

208
00:11:38,765 --> 00:11:41,802
must be manually configured
in the target editor.

209
00:11:41,835 --> 00:11:45,305
As a result, the build system
will run consecutive script phases

210
00:11:45,339 --> 00:11:49,443
one at a time to avoid introducing
a data race in the build process.

211
00:11:49,476 --> 00:11:51,445
If the scripts in a target
are configured to run

212
00:11:51,478 --> 00:11:53,247
based on dependency analysis

213
00:11:53,280 --> 00:11:55,983
and specify their complete list
of inputs and outputs,

214
00:11:56,016 --> 00:11:58,285
then the build setting
FUSE_BUILD_SCRIPT_PHASES

215
00:11:58,318 --> 00:11:59,553
can be set to YES

216
00:11:59,586 --> 00:12:03,457
to indicate the build system
should attempt to run them in parallel.

217
00:12:03,490 --> 00:12:06,293
However,
when running script phases in parallel,

218
00:12:06,326 --> 00:12:09,897
the build system has to rely
on the specified inputs and outputs.

219
00:12:09,930 --> 00:12:14,134
So be aware that an incomplete list
of the inputs or outputs of a script phase

220
00:12:14,168 --> 00:12:17,437
can lead to data races
which are very hard to debug.

221
00:12:17,471 --> 00:12:20,707
To mitigate this, Xcode supports
user script sandboxing

222
00:12:20,741 --> 00:12:24,044
to precisely declare the dependencies
of each script phase.

223
00:12:24,077 --> 00:12:27,114
Sandboxing is an opt-in feature
that blocks shell scripts

224
00:12:27,147 --> 00:12:30,617
from accidentally accessing source files
and intermediate build objects,

225
00:12:30,651 --> 00:12:35,122
unless those are explicitly declared
as an input or output for the phase.

226
00:12:35,155 --> 00:12:38,425
In this example,
neither input nor output.txt

227
00:12:38,458 --> 00:12:41,028
are declared as a dependency
for that script phase.

228
00:12:41,061 --> 00:12:43,630
The sandbox will block the script
from reading and writing

229
00:12:43,664 --> 00:12:46,867
to both files when building the project.

230
00:12:46,900 --> 00:12:48,702
When the script violates the sandbox,

231
00:12:48,735 --> 00:12:52,506
it will fail with a non-zero exit code
causing the build to fail.

232
00:12:52,539 --> 00:12:55,209
In addition to that,
Xcode will list all the paths

233
00:12:55,242 --> 00:13:00,180
that the script phase was trying to access
without properly declaring them.

234
00:13:00,214 --> 00:13:03,383
Adding both files as dependency
information to this script phase

235
00:13:03,417 --> 00:13:04,885
fixes this issue.

236
00:13:04,918 --> 00:13:08,188
This way the sandbox ensures
that the script is not mistakenly

237
00:13:08,222 --> 00:13:12,426
accessing any file other than
its declared inputs and outputs.

238
00:13:12,459 --> 00:13:15,562
Now, let's explore an example
with more than one script phase

239
00:13:15,596 --> 00:13:19,766
and see how sandboxing prevents
data races and incorrect builds.

240
00:13:19,800 --> 00:13:21,635
There are two script phases.

241
00:13:21,668 --> 00:13:25,906
The first one reads a text file,
calculates a checksum of its content,

242
00:13:25,939 --> 00:13:30,277
and writes that value to an intermediate
file in DERIVED_FILE_DIR.

243
00:13:30,310 --> 00:13:32,813
The other script reads the same text file

244
00:13:32,846 --> 00:13:34,648
as well as the produced checksum

245
00:13:34,681 --> 00:13:38,819
and injects them into an html file
for later display in the app.

246
00:13:38,852 --> 00:13:42,256
If the precise set of input
and output dependencies for these phases

247
00:13:42,289 --> 00:13:45,792
is not declared,
Xcode will run the two scripts in parallel

248
00:13:45,826 --> 00:13:48,495
when FUSE_BUILD_SCRIPT_PHASES
is on.

249
00:13:48,529 --> 00:13:51,765
Let's inspect this problematic scenario
in detail.

250
00:13:51,798 --> 00:13:55,369
Let's assume "Generate HTML"
is missing the input declaration

251
00:13:55,402 --> 00:13:59,373
of "checksum.txt", but all other inputs
and outputs of both scripts

252
00:13:59,406 --> 00:14:01,375
have been correctly declared.

253
00:14:01,408 --> 00:14:04,878
Without sandboxing, this misconfiguration
might stay unnoticed,

254
00:14:04,912 --> 00:14:07,514
causing problems in the build.

255
00:14:07,548 --> 00:14:10,551
It means Xcode will fail to infer
the dependency relation

256
00:14:10,584 --> 00:14:13,554
between both phases,
and schedule to run them in parallel

257
00:14:13,587 --> 00:14:16,657
when FUSE_BUILD_SCRIPT_PHASES
is switched on.

258
00:14:16,690 --> 00:14:18,225
There are a few hazards here.

259
00:14:18,258 --> 00:14:23,297
Since checksum.txt is not listed as an
input dependency for "Generate HTML"

260
00:14:23,330 --> 00:14:25,999
during a clean build
the script will attempt to read the file

261
00:14:26,033 --> 00:14:29,036
without it being available
on the filesystem.

262
00:14:29,069 --> 00:14:32,573
The other hazard is if checksum.txt
is available on disk

263
00:14:32,606 --> 00:14:34,942
because of previous runs
of "Calculate Checksum",

264
00:14:34,975 --> 00:14:37,744
"Generate HTML"
may pick up the outdated file

265
00:14:37,778 --> 00:14:40,681
when the two scripts run in parallel.

266
00:14:40,714 --> 00:14:43,550
This is a user error,
and executing the scripts in a sandbox

267
00:14:43,584 --> 00:14:45,652
helps preventing this issue.

268
00:14:45,686 --> 00:14:49,323
With sandboxing switched on,
"Generate HTML" will fail immediately

269
00:14:49,356 --> 00:14:51,658
when it attempts to read "checksum.txt".

270
00:14:51,692 --> 00:14:56,363
The error message will guide adding
the missing input for that build phase.

271
00:14:56,396 --> 00:14:58,699
Having the inputs and outputs
correctly defined

272
00:14:58,732 --> 00:15:02,069
guides Xcode to respect the dependency
relation between both phases

273
00:15:02,102 --> 00:15:05,706
so that "calculate checksum"
runs before "Generate HTML".

274
00:15:05,739 --> 00:15:09,743
While unrelated build phases
can still execute in parallel.

275
00:15:09,776 --> 00:15:12,079
To enable Sandboxed Shell Scripts
for a target,

276
00:15:12,112 --> 00:15:15,649
set ENABLE_USER_SCRIPT_SANDBOXING
to YES in the build settings editor

277
00:15:15,682 --> 00:15:17,918
or an xcconfig file.

278
00:15:17,951 --> 00:15:22,122
In summary, sandboxed shell scripts allow
having correct dependency information

279
00:15:22,155 --> 00:15:25,292
to enable faster
and more robust incremental builds

280
00:15:25,325 --> 00:15:28,362
since the build system has the confidence
to skip script phases

281
00:15:28,395 --> 00:15:31,365
if the inputs haven't changed
and the outputs are still valid,

282
00:15:31,398 --> 00:15:34,134
while re-running the script otherwise.

283
00:15:34,168 --> 00:15:37,704
Enabling the build setting for
a script's target blocks access to files

284
00:15:37,738 --> 00:15:41,141
inside the source root of the project
as well as the derived data directory

285
00:15:41,175 --> 00:15:44,678
if they are not explicitly defined
as inputs or outputs of the script

286
00:15:44,711 --> 00:15:46,146
in the project.

287
00:15:46,180 --> 00:15:49,750
The sandbox will not prevent unauthorized
access to any other directory,

288
00:15:49,783 --> 00:15:52,953
so don't consider this a security feature.

289
00:15:52,986 --> 00:15:55,722
Using this feature helps to debug
missing inputs or outputs

290
00:15:55,756 --> 00:15:59,626
of existing script phases
to ensure a valid configuration

291
00:15:59,660 --> 00:16:02,229
And in combination with
the previously explained build setting

292
00:16:02,262 --> 00:16:03,897
FUSE_BUILD_SCRIPT_PHASES,

293
00:16:03,931 --> 00:16:07,367
script phases with correctly defined
dependency edges through sandboxing

294
00:16:07,401 --> 00:16:11,705
can execute in parallel
to reduce the critical path of the build.

295
00:16:11,738 --> 00:16:14,808
That's it for parallelizing
the steps of building a target.

296
00:16:14,842 --> 00:16:17,144
Now Artem is going to
demystify parallelization

297
00:16:17,177 --> 00:16:18,812
hen building many targets.

298
00:16:18,846 --> 00:16:20,214
Artem: Thanks, Ben.

299
00:16:20,247 --> 00:16:22,649
Now that we've covered the basics
of build system tasks

300
00:16:22,683 --> 00:16:25,452
and phases that may go into building
a target in your project,

301
00:16:25,485 --> 00:16:27,054
let's take a more global view

302
00:16:27,087 --> 00:16:30,424
and explore how Xcode uses dependencies
between Swift targets

303
00:16:30,457 --> 00:16:33,493
to extract the maximum amount
of parallelism out of your builds

304
00:16:33,527 --> 00:16:38,131
and how the structure and organization
of your project can affect build times.

305
00:16:38,165 --> 00:16:41,602
There are likely to be several levels
of hierarchy composing your project.

306
00:16:41,635 --> 00:16:45,172
For example, an App target depending
on a collection of local libraries

307
00:16:45,205 --> 00:16:47,975
broken up into targets
along semantic boundaries,

308
00:16:48,008 --> 00:16:49,943
and in several frameworks.

309
00:16:49,977 --> 00:16:52,713
Each target containing
many different build phases and steps,

310
00:16:52,746 --> 00:16:55,182
producing and consuming file dependencies

311
00:16:55,215 --> 00:16:57,784
to and from build phases in other targets.

312
00:16:57,818 --> 00:16:59,586
As the size of your project grows,

313
00:16:59,620 --> 00:17:04,024
these task graphs tend to increase in size
and complexity.

314
00:17:04,057 --> 00:17:06,360
While the Xcode Build System
flattens these hierarchies,

315
00:17:06,393 --> 00:17:08,762
breaking down the build
into a sea of tasks

316
00:17:08,795 --> 00:17:11,164
that correspond to build phases
of all targets.

317
00:17:11,198 --> 00:17:15,769
One kind of task that is special
for a Swift target is compilation.

318
00:17:15,802 --> 00:17:18,872
Building a Swift target's source code
into binary product's

319
00:17:18,906 --> 00:17:22,409
is a complex operation
that typically consists of many sub-tasks

320
00:17:22,442 --> 00:17:26,180
for build planning,
compilation, and linking.

321
00:17:26,213 --> 00:17:29,216
Coordination of these
tasks is delegated to a specialized tool

322
00:17:29,249 --> 00:17:32,152
in the Xcode toolchain–
the Swift Driver.

323
00:17:32,186 --> 00:17:35,222
The Driver has specialized knowledge
on when and how to construct

324
00:17:35,255 --> 00:17:39,092
the required compiler and linker
invocations for the target's source code.

325
00:17:39,126 --> 00:17:41,328
Any target that includes Swift code

326
00:17:41,361 --> 00:17:45,332
also corresponds to a unit
of code distribution: a module.

327
00:17:45,365 --> 00:17:48,802
A binary module file capturing
the public interface of this target

328
00:17:48,836 --> 00:17:52,873
is a build product that is required for
downstream targets to begin a compilation.

329
00:17:52,906 --> 00:17:55,843
Let's take a closer look at an example
of what Swift Driver does

330
00:17:55,876 --> 00:17:58,846
to build one of the targets.

331
00:17:58,879 --> 00:18:02,249
Your target probably consists of
a collection of several source files.

332
00:18:02,282 --> 00:18:05,919
In release or optimized builds
the driver will schedule one compiler task

333
00:18:05,953 --> 00:18:10,257
including all source files to maximize
opportunities for optimization.

334
00:18:10,290 --> 00:18:15,395
This single compile task will also produce
the target's Swift module.

335
00:18:15,429 --> 00:18:17,698
In debug or incremental compilation modes,

336
00:18:17,731 --> 00:18:20,234
the Swift Driver breaks down
the required compilation effort

337
00:18:20,267 --> 00:18:22,970
into smaller sub-tasks
which can run in parallel,

338
00:18:23,003 --> 00:18:26,673
some of which may not need to re-run
on an incremental build.

339
00:18:26,707 --> 00:18:29,843
Producing a Swift module then requires
an additional step

340
00:18:29,877 --> 00:18:33,947
to merge together partial intermediate
products of each compile task.

341
00:18:33,981 --> 00:18:35,816
If, like in this example,

342
00:18:35,849 --> 00:18:38,385
the number of source files
in your target is high,

343
00:18:38,418 --> 00:18:42,389
individual files may also be assigned
to batch compilation sub-tasks,

344
00:18:42,422 --> 00:18:45,192
according to
the build-system's heuristics.

345
00:18:45,225 --> 00:18:47,828
The build log highlights
which source files get assigned

346
00:18:47,861 --> 00:18:49,596
to batch compilation jobs,

347
00:18:49,630 --> 00:18:52,566
with a separate entry
for each file's diagnostics.

348
00:18:52,599 --> 00:18:56,670
Being able to parallelize a target's build
across different source files is crucial

349
00:18:56,703 --> 00:18:59,339
for both faster
and smaller incremental builds,

350
00:18:59,373 --> 00:19:04,244
so make sure your Debug builds are using
the Incremental Compilation Mode setting.

351
00:19:04,278 --> 00:19:06,713
Before Xcode 14,
because of the boundary

352
00:19:06,747 --> 00:19:09,449
between the Xcode Build System
and Swift Driver,

353
00:19:09,483 --> 00:19:11,552
orchestration of target build phases,

354
00:19:11,585 --> 00:19:15,789
and compilation sub-tasks spawned by each
target's instance of the Driver

355
00:19:15,822 --> 00:19:17,658
happened independently of each other,

356
00:19:17,691 --> 00:19:19,493
with each component doing its best

357
00:19:19,526 --> 00:19:22,496
to make the most
of available system resources.

358
00:19:22,529 --> 00:19:24,998
Let's take this example build graph
and dive deeper

359
00:19:25,032 --> 00:19:27,301
into what goes into scheduling
its compilation phases

360
00:19:27,334 --> 00:19:29,970
with respect to each other.

361
00:19:30,003 --> 00:19:33,307
As we've learned earlier,
Swift target dependencies are resolved

362
00:19:33,340 --> 00:19:36,610
by having their dependents provide
a binary module file

363
00:19:36,643 --> 00:19:39,780
that captures the dependent's
public interface.

364
00:19:39,813 --> 00:19:43,383
Resolving these dependency relationships
leads us to the following ordering,

365
00:19:43,417 --> 00:19:46,386
captured in a timeline showing
the top-level Swift Driver tasks

366
00:19:46,420 --> 00:19:49,990
for each target,
as well as their individual sub-tasks.

367
00:19:50,023 --> 00:19:53,827
With Xcode 14, thanks to an entirely new
implementation of Swift Driver–

368
00:19:53,861 --> 00:19:55,562
itself now written in Swift–

369
00:19:55,596 --> 00:19:58,832
the build system
and the compiler are fully integrated.

370
00:19:58,866 --> 00:20:01,902
The Xcode Build System acts
as the central scheduler

371
00:20:01,935 --> 00:20:05,305
for all tasks that must be performed
to compile your code.

372
00:20:05,339 --> 00:20:07,508
This central planning mechanism
allows Xcode

373
00:20:07,541 --> 00:20:09,610
to make fine-grained scheduling decisions

374
00:20:09,643 --> 00:20:12,246
providing better guarantees
that building your project

375
00:20:12,279 --> 00:20:15,115
will use only as much resources
as available,

376
00:20:15,148 --> 00:20:18,952
without oversubscribing your CPU
and reducing overall system performance.

377
00:20:20,387 --> 00:20:23,090
And what was previously a collection
of islands of sub-tasks

378
00:20:23,123 --> 00:20:25,559
outside of Xcode Build System's purview

379
00:20:25,592 --> 00:20:28,662
are now fully in a domain
of the build-system's scheduler.

380
00:20:30,564 --> 00:20:33,834
With all the individual sub-tasks
in a central task pool,

381
00:20:33,867 --> 00:20:37,871
it is important to consider the trade-offs
made by the build scheduler.

382
00:20:37,905 --> 00:20:40,073
For example, on an 8-core machine

383
00:20:40,107 --> 00:20:43,510
the scheduler's default
is to assign available tasks–

384
00:20:43,544 --> 00:20:46,947
those tasks whose dependencies have been
satisfied and are ready to go–

385
00:20:46,980 --> 00:20:49,750
to one of eight available execution slots.

386
00:20:49,783 --> 00:20:51,685
As soon as one of the slots frees up,

387
00:20:51,718 --> 00:20:55,689
the Build System attempts to fill it
with more outstanding work.

388
00:20:55,722 --> 00:20:57,658
On a higher-core-count machine,

389
00:20:57,691 --> 00:20:59,893
we're able to perform
more concurrent work.

390
00:20:59,927 --> 00:21:02,829
But that means we're also more likely
to have idle cores

391
00:21:02,863 --> 00:21:04,932
which are available to perform more work,

392
00:21:04,965 --> 00:21:08,035
but all of the outstanding tasks
are still awaiting their inputs,

393
00:21:08,068 --> 00:21:11,738
as produced by other tasks
that are currently in-flight or waiting.

394
00:21:11,772 --> 00:21:14,541
The new integrated build system
allows the scheduler

395
00:21:14,575 --> 00:21:17,244
to significantly reduce this idle time.

396
00:21:17,277 --> 00:21:20,848
To see how, let's revisit how
a target's dependencies for compilation,

397
00:21:20,881 --> 00:21:23,183
binary module files, are resolved.

398
00:21:25,485 --> 00:21:26,787
As we've covered earlier,

399
00:21:26,820 --> 00:21:28,989
the partial results
of compilation sub-tasks

400
00:21:29,022 --> 00:21:32,025
are merged into a target's
final module product.

401
00:21:32,059 --> 00:21:36,797
Once this product is available,
downstream targets may begin compilation.

402
00:21:36,830 --> 00:21:41,368
New in Xcode 14 and Swift 5.7,
construction of a target's module

403
00:21:41,401 --> 00:21:43,604
is done in a separate emit-module task

404
00:21:43,637 --> 00:21:46,240
directly from all program source files.

405
00:21:46,273 --> 00:21:48,709
This means a target's dependencies
can begin compilation

406
00:21:48,742 --> 00:21:50,878
as soon as the emit-module task
is complete

407
00:21:50,911 --> 00:21:55,115
without waiting for all of the other
compiler tasks of the dependency target.

408
00:21:55,148 --> 00:21:59,253
Being able to unblock downstream
target compilation this much sooner

409
00:21:59,286 --> 00:22:03,423
cuts down on the time spent waiting
for available work with idle CPU cores–

410
00:22:03,457 --> 00:22:07,094
that empty space in between
spurs of activity in the build timeline.

411
00:22:08,495 --> 00:22:10,564
Extending this to the rest of our project

412
00:22:10,597 --> 00:22:14,268
shows that although we are performing
a similar amount of overall work,

413
00:22:14,301 --> 00:22:18,005
the build system is able to use
the computer's resources more efficiently,

414
00:22:18,038 --> 00:22:21,141
often completing
the build significantly faster.

415
00:22:22,276 --> 00:22:24,811
Now, let's take a look at
a second cross-target optimization

416
00:22:24,845 --> 00:22:27,214
the build system can perform
when building Swift–

417
00:22:27,247 --> 00:22:28,782
Eager Linking.

418
00:22:28,815 --> 00:22:30,350
Building on the previous example,

419
00:22:30,384 --> 00:22:32,553
we've added the linker tasks
for each target,

420
00:22:32,586 --> 00:22:34,955
which are both
on the build's critical path.

421
00:22:34,988 --> 00:22:38,292
In this case,
because Target B links Target A,

422
00:22:38,325 --> 00:22:42,863
Target B's link task must wait for
Target A's linked output to be produced

423
00:22:42,896 --> 00:22:46,900
and its own compilation tasks
to complete before it can run.

424
00:22:46,934 --> 00:22:48,769
However, with eager linking,

425
00:22:48,802 --> 00:22:53,640
Target B's link task can depend on
Target A's emit-module task instead.

426
00:22:53,674 --> 00:22:57,044
As a result, Target B can begin
linking earlier in the build,

427
00:22:57,077 --> 00:23:01,281
running in parallel with linking Target A
and shortening the critical path.

428
00:23:01,315 --> 00:23:03,217
How does this work?

429
00:23:03,250 --> 00:23:05,285
Normally,
the dependency graph of two targets

430
00:23:05,319 --> 00:23:09,289
with a linked product dependency
looks something like this.

431
00:23:09,323 --> 00:23:13,560
Linking the dependent target requires
the linked product of its dependencies

432
00:23:13,594 --> 00:23:16,730
in addition to the target's
own compilation outputs.

433
00:23:16,763 --> 00:23:19,600
When linking eagerly,
this dependency is broken,

434
00:23:19,633 --> 00:23:23,470
allowing the dependent target
to start linking earlier.

435
00:23:23,504 --> 00:23:26,373
Instead of depending on a linked
product of the dependency,

436
00:23:26,406 --> 00:23:29,309
it now depends on a text-based
dynamic library stub

437
00:23:29,343 --> 00:23:32,980
produced earlier in the build process
by the emit-module task.

438
00:23:33,013 --> 00:23:35,282
This stub contains a list of symbols
which will appear

439
00:23:35,315 --> 00:23:38,051
in the linked product
for use by dependents.

440
00:23:38,085 --> 00:23:42,322
You can enable this optimization using
the Xcode build setting shown on screen.

441
00:23:42,356 --> 00:23:44,658
Eager Linking applies
to all pure Swift targets

442
00:23:44,691 --> 00:23:47,694
that are dynamically linked
by their dependents.

443
00:23:47,728 --> 00:23:52,032
To summarize, the Xcode Build System
is a sophisticated scheduling engine

444
00:23:52,065 --> 00:23:54,768
that seeks to extract
as much parallelism as possible

445
00:23:54,801 --> 00:23:57,004
by running build phases in parallel.

446
00:23:57,037 --> 00:23:59,940
And features like Script Sandboxing
allow you to ensure your builds

447
00:23:59,973 --> 00:24:03,110
are both maximally parallel and reliable.

448
00:24:03,143 --> 00:24:06,180
Xcode and Swift are more integrated
than ever.

449
00:24:06,213 --> 00:24:10,083
And project structure: its modularization,
the overall shape of the graph

450
00:24:10,117 --> 00:24:12,252
made up of dependencies
between target products

451
00:24:12,286 --> 00:24:15,789
and the number and complexity
of build phases within them,

452
00:24:15,822 --> 00:24:19,493
combined with the available computational
resources of your machine–

453
00:24:19,526 --> 00:24:23,664
all these are contributing factors
to the degree Xcode is able to parallelize

454
00:24:23,697 --> 00:24:25,766
and speed up your builds.

455
00:24:25,799 --> 00:24:29,036
With this knowledge, and powerful
new tools like the build timeline,

456
00:24:29,069 --> 00:24:33,574
you are well equipped to examine your
project and gain insight into your builds.

457
00:24:33,607 --> 00:24:34,908
And if you're curious to learn even more

458
00:24:34,942 --> 00:24:36,944
of the behind-the-scenes
technical details,

459
00:24:36,977 --> 00:24:39,780
many of the technologies we described
that are used by Xcode

460
00:24:39,813 --> 00:24:41,381
are developed in the open-source.

461
00:24:41,415 --> 00:24:45,986
You can find the repository for
Swift Driver on GitHub at the link below.

462
00:24:46,019 --> 00:24:47,621
For more great sessions about Xcode,

463
00:24:47,654 --> 00:24:50,057
check out all new features
and improvements from this year

464
00:24:50,090 --> 00:24:51,892
in "What's new in Xcode".

465
00:24:51,925 --> 00:24:55,295
And learn how Xcode 14's linker
improves link times up to two times

466
00:24:55,329 --> 00:24:59,166
in the session "Link fast:
Improve build and launch times".

467
00:24:59,199 --> 00:25:00,767
Thanks for following along.

468
00:25:00,801 --> 00:25:03,804
We hope you learned some new insights
about Xcode builds.

469
00:25:03,837 --> 00:25:06,006
We can't wait to see
what you're going to create.

470
00:25:06,039 --> 00:25:07,841
Have a great rest of the conference.

