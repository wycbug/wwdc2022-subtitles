1
00:00:00,501 --> 00:00:08,509
♪ ♪

2
00:00:09,843 --> 00:00:13,514
Paul: Hello, and welcome to
Compose Custom Layouts with SwiftUI.

3
00:00:13,547 --> 00:00:16,183
I'm Paul, and I work
on developer documentation.

4
00:00:16,216 --> 00:00:18,919
SwiftUI provides
a rich set of building blocks

5
00:00:18,952 --> 00:00:22,489
that you use to compose
your app's interface.

6
00:00:22,523 --> 00:00:27,761
You can combine built-in views
that display elements like text, images,

7
00:00:27,794 --> 00:00:31,932
and graphics to create
custom, composite views.

8
00:00:31,965 --> 00:00:35,769
To arrange all these elements
in ever more sophisticated groupings

9
00:00:35,802 --> 00:00:37,804
SwiftUI provides layout tools.

10
00:00:39,139 --> 00:00:42,709
Containers like horizontal and
vertical stacks let you tell SwiftUI

11
00:00:42,743 --> 00:00:45,112
where to put views
relative to one another,

12
00:00:45,145 --> 00:00:47,581
while view modifiers give you
additional control

13
00:00:47,614 --> 00:00:50,484
over things like spacing and alignment.

14
00:00:51,218 --> 00:00:53,487
In this talk,
I'm going to introduce some new tools

15
00:00:53,520 --> 00:00:56,590
that will make some common layouts
even easier to build,

16
00:00:56,623 --> 00:00:59,560
and will make
more complicated layouts possible.

17
00:00:59,593 --> 00:01:04,364
Along the way, I'll give you some tips
for working with layout in SwiftUI.

18
00:01:04,398 --> 00:01:06,967
I'll start by showing you a new member
of the grid family

19
00:01:07,000 --> 00:01:09,269
that's perfect for two-dimensional layouts

20
00:01:09,303 --> 00:01:12,372
when you have a static set of views
to display.

21
00:01:12,406 --> 00:01:16,176
Next I'll talk about how you can create
a custom view container type

22
00:01:16,210 --> 00:01:18,979
that lets you interact directly
with the layout engine,

23
00:01:19,012 --> 00:01:21,949
using the new layout protocol.

24
00:01:21,982 --> 00:01:24,318
Then I'll talk about ViewThatFits,

25
00:01:24,351 --> 00:01:27,621
a container type that automatically
selects from a collection of views

26
00:01:27,654 --> 00:01:31,792
for the one that,
well, fits in the available space.

27
00:01:31,825 --> 00:01:34,862
And finally, I'll show you how to add
seamless transitions

28
00:01:34,895 --> 00:01:38,232
between layout types using AnyLayout.

29
00:01:38,265 --> 00:01:40,334
To see all these new features in action,

30
00:01:40,367 --> 00:01:42,703
let's take a look at an app
I've been working on.

31
00:01:44,204 --> 00:01:45,906
In recent years,
there's been some debate

32
00:01:45,939 --> 00:01:50,410
among some of my colleagues about
who makes the best furry companion.

33
00:01:50,444 --> 00:01:54,781
I have my own opinion, but I was curious
to see if we could come to some consensus,

34
00:01:54,815 --> 00:01:58,452
so I decided
to make an app to take a poll.

35
00:01:58,485 --> 00:02:00,754
And I want to include folks
with fur allergies, too,

36
00:02:00,787 --> 00:02:03,357
so I'm throwing in one extra option.

37
00:02:03,390 --> 00:02:07,160
Now, I like to do most of
my interface design in SwiftUI,

38
00:02:07,194 --> 00:02:09,997
because it's so easy to prototype
using previews,

39
00:02:10,030 --> 00:02:14,334
but as a starting point, I drew
a quick sketch of what I'm aiming for.

40
00:02:14,368 --> 00:02:16,737
I expect the voting to go on
over a period of time,

41
00:02:16,770 --> 00:02:20,774
so I want a leaderboard in
the middle showing the current standings.

42
00:02:20,807 --> 00:02:22,676
I'll put buttons for voting at the bottom.

43
00:02:22,709 --> 00:02:26,647
And at the top, I'll display some images
of what folks are voting for.

44
00:02:28,482 --> 00:02:30,751
Okay, the first thing I want to do
is to build the leaderboard.

45
00:02:30,784 --> 00:02:33,554
So let's take a closer look at that.

46
00:02:33,587 --> 00:02:38,559
The leaderboard is a two-dimensional grid
of elements with rows for each contender,

47
00:02:38,592 --> 00:02:43,197
and columns that show names,
percentages, and a vote count.

48
00:02:43,230 --> 00:02:47,367
I have a couple of specific things
I want to achieve here.

49
00:02:47,401 --> 00:02:51,104
First, I want the two text columns
to be only as wide as they need to be

50
00:02:51,138 --> 00:02:54,074
to accommodate the widest cell
in each case

51
00:02:54,107 --> 00:02:56,610
because I want the progress views
that represent percentages

52
00:02:56,643 --> 00:02:58,812
to get as much space as they can.

53
00:02:58,846 --> 00:03:02,349
And this needs to be true
no matter how big the counts get

54
00:03:02,382 --> 00:03:05,018
for my friends that speak other languages

55
00:03:05,052 --> 00:03:09,022
or for anyone who uses
different text sizes on their devices.

56
00:03:09,056 --> 00:03:11,792
Second, I want the names
to be leading edge aligned,

57
00:03:11,825 --> 00:03:14,728
but the amounts to be
trailing edge aligned.

58
00:03:14,761 --> 00:03:20,167
Now, SwiftUI already has lazy grids,
which are great for scrollable content.

59
00:03:20,200 --> 00:03:23,704
These containers are very efficient
when you have a lot of views,

60
00:03:23,737 --> 00:03:27,774
because they only load views
that are visible, or about to be visible.

61
00:03:27,808 --> 00:03:29,776
On the other hand,
that means the container

62
00:03:29,810 --> 00:03:33,080
can't automatically size
its cells in both dimensions.

63
00:03:34,515 --> 00:03:38,118
For example, the LazyHGrid can figure out
how wide to make each column,

64
00:03:38,151 --> 00:03:42,823
because it can measure all the views
in a column before drawing them.

65
00:03:42,856 --> 00:03:46,827
But it can't measure every view in a row
to figure out the row's height.

66
00:03:46,860 --> 00:03:48,795
To make this work,
the lazy grids need you

67
00:03:48,829 --> 00:03:52,366
to provide information about one
of their dimensions at initialization time.

68
00:03:53,867 --> 00:03:58,305
For a closer look at lazy grids and other
existing SwiftUI layout container types,

69
00:03:58,338 --> 00:04:02,176
see the Stacks, grids,
and outlines talk from 2020.

70
00:04:02,209 --> 00:04:06,079
But in my case, I don't need scrolling,
and I'd like to let SwiftUI

71
00:04:06,113 --> 00:04:09,616
figure out both the height
and the width for each cell.

72
00:04:09,650 --> 00:04:14,421
For this kind of layout,
SwiftUI now offers a Grid view.

73
00:04:14,454 --> 00:04:17,891
Unlike the lazy grid,
the grid loads all of its views at once,

74
00:04:17,925 --> 00:04:21,161
so it can automatically size
and align its cells

75
00:04:21,195 --> 00:04:25,265
across both its columns and rows.

76
00:04:25,299 --> 00:04:27,201
Let's take a look at the code for this.

77
00:04:28,135 --> 00:04:31,438
Here's a basic version
of my leaderboard written as a Grid.

78
00:04:31,471 --> 00:04:35,142
This particular grid view
contains three GridRow instances.

79
00:04:35,175 --> 00:04:38,512
Within a row,
each view corresponds to a column.

80
00:04:38,545 --> 00:04:41,815
So in this example,
the first text view in each row

81
00:04:41,849 --> 00:04:43,684
corresponds to the first column,

82
00:04:43,717 --> 00:04:45,919
the progress view is in the second column,

83
00:04:45,953 --> 00:04:49,623
and the last text view
is the third column.

84
00:04:49,656 --> 00:04:53,393
Notice that the grid allocates
as much space to each row and column

85
00:04:53,427 --> 00:04:55,696
as it needs to hold its largest view.

86
00:04:55,729 --> 00:05:00,234
So the first text column is wide enough
for the longest name, but no wider.

87
00:05:00,267 --> 00:05:04,104
Flexible views like the progress indicator
take as much space as the grid offers,

88
00:05:04,137 --> 00:05:06,139
which in this case
is whatever is left over

89
00:05:06,173 --> 00:05:09,343
after allocating space
for the text columns.

90
00:05:09,376 --> 00:05:13,247
I want to adjust this a bit, but first,
let me create a basic data model

91
00:05:13,280 --> 00:05:15,382
to give me somewhere
to store vote counts.

92
00:05:16,683 --> 00:05:20,354
I'll need more logic to manage
and share the data across the network,

93
00:05:20,387 --> 00:05:24,892
but while I'm prototyping the interface,
I just need a simple structure like this.

94
00:05:24,925 --> 00:05:28,195
I'll include Identifiable conformance,
because that'll make it easier

95
00:05:28,228 --> 00:05:30,497
to use this type in a ForEach,

96
00:05:30,531 --> 00:05:34,368
and Equatable conformance
to make it possible to animate changes.

97
00:05:35,869 --> 00:05:41,475
And I'll create a set of example data
to use in my previews while I prototype.

98
00:05:41,508 --> 00:05:44,578
Going back to my grid,
I can create a state variable

99
00:05:44,611 --> 00:05:46,947
and initialize it with my example data.

100
00:05:46,980 --> 00:05:51,218
And using that data,
I can now create rows with a ForEach.

101
00:05:51,251 --> 00:05:53,453
Notice that the rendered output
hasn't changed

102
00:05:53,487 --> 00:05:56,757
because it's still displaying
the same data.

103
00:05:56,790 --> 00:06:00,460
That's already pretty close,
but I need to fix the cell alignment.

104
00:06:00,494 --> 00:06:02,529
Right now,
all the cells are center aligned,

105
00:06:02,563 --> 00:06:05,399
which is the default for a grid,
but if you remember,

106
00:06:05,432 --> 00:06:07,568
I want the names
to be leading edge aligned,

107
00:06:07,601 --> 00:06:09,970
and the values
to be trailing edge aligned.

108
00:06:10,804 --> 00:06:14,808
To do that, I'll initialize the grid
with leading edge alignment.

109
00:06:14,842 --> 00:06:18,512
The value I use here
applies to all the cells in the grid.

110
00:06:18,545 --> 00:06:23,183
That works fine for my first two columns,
but what about the last?

111
00:06:23,217 --> 00:06:25,385
To affect the alignment
of a single column,

112
00:06:25,419 --> 00:06:31,091
I can apply the gridColumnAlignment view
modifier to any one cell in that column.

113
00:06:31,124 --> 00:06:34,862
So I'll do that with the text view
in the last column.

114
00:06:34,895 --> 00:06:37,764
Okay, it's getting there,
but now that I'm looking at it,

115
00:06:37,798 --> 00:06:41,835
I feel like it would be better
with a divider between each row.

116
00:06:41,869 --> 00:06:45,272
If I just add a new row
to the ForEach with a divider,

117
00:06:45,305 --> 00:06:47,407
this isn't exactly what I want,

118
00:06:47,441 --> 00:06:50,677
but notice that this shows
a couple of interesting things.

119
00:06:50,711 --> 00:06:53,814
First, because
the divider is a flexible view,

120
00:06:53,847 --> 00:06:56,550
it's causing the first column
to take more space.

121
00:06:56,583 --> 00:06:59,586
Basically, the grid is now giving
the last column what it needs,

122
00:06:59,620 --> 00:07:03,824
and dividing the remaining space
between the first two columns.

123
00:07:03,857 --> 00:07:08,028
Second, for a grid row that doesn't
have as many views as other grid rows,

124
00:07:08,061 --> 00:07:11,965
the missing views just create empty cells
in the later columns.

125
00:07:11,999 --> 00:07:16,670
But what I really want is to have the
divider span all the columns of the grid,

126
00:07:16,703 --> 00:07:20,440
and SwiftUI has a new view modifier
that lets me do that.

127
00:07:23,744 --> 00:07:27,014
By adding the gridCellColumns
modifier to a view,

128
00:07:27,047 --> 00:07:30,017
I can tell a single view to span
some number of columns;

129
00:07:30,050 --> 00:07:32,719
in this case, all three.

130
00:07:32,753 --> 00:07:35,923
And actually, for the case where
the view should span the entire grid,

131
00:07:35,956 --> 00:07:40,994
I can simplify this by just writing
the view by itself, outside of a grid row.

132
00:07:41,028 --> 00:07:44,264
Okay, my leaderboard is in
pretty good shape

133
00:07:44,298 --> 00:07:47,668
so let me take a look at the buttons
used for voting next.

134
00:07:48,836 --> 00:07:51,338
At first glance,
there's nothing too fancy here.

135
00:07:51,371 --> 00:07:54,641
However,
I do have one special requirement.

136
00:07:54,675 --> 00:07:57,077
On the one hand,
I don't want to bias my participants

137
00:07:57,110 --> 00:08:00,013
with smaller buttons for certain choices.

138
00:08:00,047 --> 00:08:03,050
But I also don't want the buttons
to grow as large as their container,

139
00:08:03,083 --> 00:08:06,386
which could be very large on iPad or Mac.

140
00:08:06,420 --> 00:08:11,825
Instead, the buttons should all have
widths equal to the widest button text.

141
00:08:11,859 --> 00:08:15,462
So what happens
if I try to build this with an Hstack?

142
00:08:15,495 --> 00:08:19,666
What I find is that each button
sizes itself to fit its text label,

143
00:08:19,700 --> 00:08:23,203
and the HStack
packs these together horizontally.

144
00:08:23,237 --> 00:08:27,508
This default stack behavior is exactly
what you want in a lot of cases,

145
00:08:27,541 --> 00:08:30,177
but it doesn't quite meet
my spec for this project.

146
00:08:31,778 --> 00:08:34,781
For a refresher
on layout fundamentals in SwiftUI,

147
00:08:34,815 --> 00:08:39,019
see the Building custom views
with SwiftUI talk from 2019.

148
00:08:39,052 --> 00:08:42,789
Using concepts from that talk,
let's take a look at this view hierarchy

149
00:08:42,823 --> 00:08:45,659
to see what I can change
to get the behavior I want.

150
00:08:47,694 --> 00:08:52,132
First, the stack's container
proposes a size to the stack.

151
00:08:52,165 --> 00:08:56,069
Based on this, the stack proposes a size
to its three buttons,

152
00:08:56,103 --> 00:09:00,674
and then each button passes that size
through to its text label.

153
00:09:00,707 --> 00:09:03,377
The text views calculate the size
they actually want,

154
00:09:03,410 --> 00:09:05,746
which depends on the string they contain

155
00:09:05,779 --> 00:09:08,115
and report this to the button.

156
00:09:08,148 --> 00:09:10,884
The button passes the information
back through.

157
00:09:10,918 --> 00:09:13,387
The stack sizes itself
with this information,

158
00:09:13,420 --> 00:09:18,425
places the buttons in its space, and then
reports its own size to its container.

159
00:09:18,458 --> 00:09:21,028
Okay, so if the buttons
take the size of their text,

160
00:09:21,061 --> 00:09:26,133
what if I wrap each text view in
a flexible frame and allow it to grow?

161
00:09:26,166 --> 00:09:29,770
The text hasn't changed,
but the button sees a flexible subview,

162
00:09:29,803 --> 00:09:33,607
which takes as much space
as the HStack offers.

163
00:09:33,640 --> 00:09:38,178
The stack then distributes its space
equally among the views that it contains.

164
00:09:38,212 --> 00:09:40,714
So the buttons are all the same size now,
which is great,

165
00:09:40,747 --> 00:09:44,117
but their actual size depends
on the stack's container.

166
00:09:44,151 --> 00:09:47,921
The stack will expand to fill
whatever space the container offers,

167
00:09:47,955 --> 00:09:49,590
and that's not what I want.

168
00:09:49,623 --> 00:09:52,793
What I really want is a custom stack type

169
00:09:52,826 --> 00:09:55,562
that asks for the ideal size
of each button,

170
00:09:55,596 --> 00:09:59,800
finds the widest, and then offers
that amount of space to each one.

171
00:09:59,833 --> 00:10:04,471
Fortunately, SwiftUI has a new tool
that lets me do just that.

172
00:10:04,505 --> 00:10:07,841
Using the Layout protocol,
I can define a custom layout container

173
00:10:07,875 --> 00:10:10,777
that participates directly
in the layout process

174
00:10:10,811 --> 00:10:13,981
with behavior
that's tailored to my use case.

175
00:10:14,014 --> 00:10:15,682
Let's see how this works.

176
00:10:16,583 --> 00:10:21,788
Looking at the HStack again,
let me change it to an EqualWidthHStack

177
00:10:21,822 --> 00:10:26,093
a type that I'm going to define
to solve my specific problem.

178
00:10:26,126 --> 00:10:29,129
This type is going to allocate width
to the buttons equally,

179
00:10:29,162 --> 00:10:33,500
in an amount that's as wide
as the widest button's ideal width.

180
00:10:33,534 --> 00:10:36,970
I'll keep the flexible frames
so that buttons with narrower text

181
00:10:37,004 --> 00:10:40,174
can expand to fill the space
that the stack offers.

182
00:10:40,207 --> 00:10:43,310
But the buttons will still have
an ideal size that I can measure,

183
00:10:43,343 --> 00:10:45,779
which is the width of their text.

184
00:10:45,812 --> 00:10:49,316
So let's see how I can implement
MyEqualWidthHStack.

185
00:10:52,052 --> 00:10:56,290
I start by creating a type
that conforms to the Layout protocol.

186
00:10:56,323 --> 00:10:59,693
For a basic layout,
all I need are the two required methods.

187
00:10:59,726 --> 00:11:02,462
Let's add stubs for those.

188
00:11:02,496 --> 00:11:04,831
The first method is sizeThatFits,

189
00:11:04,865 --> 00:11:08,669
where I'll calculate and report
how large my layout container is.

190
00:11:10,571 --> 00:11:12,739
I get a proposed view size input,

191
00:11:12,773 --> 00:11:16,677
which is a size proposal from
my layout's own container view.

192
00:11:16,710 --> 00:11:21,648
And I can propose sizes to my layout's
subviews using the Subviews parameter.

193
00:11:22,883 --> 00:11:25,953
Notice that I can't access
the subviews directly.

194
00:11:25,986 --> 00:11:28,789
Instead, the subviews input
is a collection of proxies

195
00:11:28,822 --> 00:11:32,059
that let me interact in specific ways
with the subviews,

196
00:11:32,092 --> 00:11:34,761
like proposing a size.

197
00:11:34,795 --> 00:11:39,132
Each proxy returns a concrete size
based on the proposal that I’ve made.

198
00:11:39,166 --> 00:11:43,437
I'll collect all those responses
and use them to do some calculations

199
00:11:43,470 --> 00:11:48,041
and then return a concrete size for
the EqualWidthHStack to its container.

200
00:11:49,209 --> 00:11:52,846
The second method that I have to
implement is placeSubviews.

201
00:11:52,880 --> 00:11:56,850
I'll use this to tell my layout's subviews
where to appear.

202
00:11:56,884 --> 00:12:01,054
This method takes the same size proposal
and subviews inputs,

203
00:12:01,088 --> 00:12:04,157
and it also takes a bounds input
that represents the region

204
00:12:04,191 --> 00:12:07,060
that I need to place my subviews into.

205
00:12:07,094 --> 00:12:10,097
Bounds is a rectangle
that has the size that I asked for

206
00:12:10,130 --> 00:12:12,666
in my sizeThatFits implementation.

207
00:12:12,699 --> 00:12:15,202
Remember,
views pick their own size in SwiftUI,

208
00:12:15,235 --> 00:12:19,673
so my layout container
will get the size that it asks for.

209
00:12:19,706 --> 00:12:22,309
The origin of the region
is at the top left,

210
00:12:22,342 --> 00:12:25,812
with positive X to the right,
and positive Y down.

211
00:12:25,846 --> 00:12:28,515
You can assume this for all
your placement calculations,

212
00:12:28,549 --> 00:12:30,851
even in right to left
language environments,

213
00:12:30,884 --> 00:12:34,655
because the framework automatically flips
the x position of each view

214
00:12:34,688 --> 00:12:37,457
when laying out views in that direction.

215
00:12:37,491 --> 00:12:42,596
However, don't assume that the rectangle's
origin has the value (0,0).

216
00:12:42,629 --> 00:12:45,299
Among other things,
allowing for a non-zero origin

217
00:12:45,332 --> 00:12:47,334
enables layout composition,

218
00:12:47,367 --> 00:12:49,536
where the placeSubviews method
of one layout

219
00:12:49,570 --> 00:12:52,206
calls into the same method of another.

220
00:12:52,239 --> 00:12:55,442
To make it a little easier to work with,
the rectangle provides properties

221
00:12:55,475 --> 00:12:57,945
for accessing important parts
of the region,

222
00:12:57,978 --> 00:12:59,980
like the minimum,

223
00:13:00,013 --> 00:13:03,884
center,
and maximum points in each dimension.

224
00:13:05,152 --> 00:13:07,421
Now, before I move on,
notice one other parameter

225
00:13:07,454 --> 00:13:09,356
that these methods both have:

226
00:13:09,389 --> 00:13:11,458
a bidirectional cache that I could use

227
00:13:11,491 --> 00:13:16,363
to share the results of intermediate
calculations across method calls.

228
00:13:16,396 --> 00:13:18,899
For many simple layouts,
you won't need this,

229
00:13:18,932 --> 00:13:22,035
and I'm just going to
ignore the cache for now.

230
00:13:22,069 --> 00:13:25,772
However, if profiling your app with
Instruments shows that you need to improve

231
00:13:25,806 --> 00:13:27,908
the efficiency of your layout code,

232
00:13:27,941 --> 00:13:29,877
you can look into adding one.

233
00:13:29,910 --> 00:13:32,513
Check out the documentation
for more information about that.

234
00:13:34,715 --> 00:13:37,084
Okay, let's implement sizeThatFits.

235
00:13:37,117 --> 00:13:39,419
Remember, I want to return
a size for my container

236
00:13:39,453 --> 00:13:44,825
that fits all of the buttons arranged
horizontally, all at the same width.

237
00:13:44,858 --> 00:13:47,761
So first,
I'll ask each button for its size,

238
00:13:47,794 --> 00:13:51,565
which I do by proposing a size
and seeing what comes back.

239
00:13:51,598 --> 00:13:53,567
To measure the flexibility of a subview,

240
00:13:53,600 --> 00:13:57,137
I can make multiple measurements
using special proposals for minimum,

241
00:13:57,171 --> 00:13:59,406
maximum, and ideal sizes,

242
00:13:59,439 --> 00:14:01,875
or I can propose a specific size.

243
00:14:01,909 --> 00:14:07,347
In this case, I use the unspecified
size proposal to ask for the ideal size.

244
00:14:08,582 --> 00:14:11,318
Then I'll find the largest value
in each dimension

245
00:14:11,351 --> 00:14:13,487
for all the sizes that I get back.

246
00:14:13,520 --> 00:14:15,789
In this case,
the goldfish button sets the width,

247
00:14:15,822 --> 00:14:18,625
and the heights are all the same.

248
00:14:18,659 --> 00:14:20,360
Now let me refactor that into a method,

249
00:14:20,394 --> 00:14:23,964
because I'll need it again
when I place my subviews.

250
00:14:23,997 --> 00:14:27,401
Next, I need to account
for the spacing between views.

251
00:14:27,434 --> 00:14:30,604
I could just use a constant spacing,
like 10 points,

252
00:14:30,637 --> 00:14:33,440
but the layout protocol lets me do better.

253
00:14:33,473 --> 00:14:37,377
In SwiftUI, all views have spacing
preferences that indicate

254
00:14:37,411 --> 00:14:42,015
the amount of space the view prefers
to have between itself and the next view.

255
00:14:42,049 --> 00:14:45,219
These preferences are stored
in a ViewSpacing instance

256
00:14:45,252 --> 00:14:48,488
that's available to layout containers.

257
00:14:48,522 --> 00:14:51,024
The view might prefer different values
on different edges,

258
00:14:51,058 --> 00:14:54,928
and even different values for
different kinds of adjacent views.

259
00:14:54,962 --> 00:14:57,497
For example,
a view might want more or less space

260
00:14:57,531 --> 00:15:02,803
between itself and a text view
than it wants between itself and an image.

261
00:15:02,836 --> 00:15:06,206
And the values can vary
by platform as well.

262
00:15:06,240 --> 00:15:09,743
You can ignore these preferences
if it makes sense for your layout,

263
00:15:09,776 --> 00:15:13,380
which is essentially what's happening
when you initialize a built-in stack

264
00:15:13,413 --> 00:15:15,415
with a custom spacing,

265
00:15:15,449 --> 00:15:17,584
but respecting these preferences
in your own layouts

266
00:15:17,618 --> 00:15:20,487
is a good way to get results
that automatically follow

267
00:15:20,521 --> 00:15:22,489
Apple's interface guidelines,

268
00:15:22,523 --> 00:15:26,527
and as a result,
match the look of the rest of the system.

269
00:15:26,560 --> 00:15:29,796
Now, every view
has preferences on all edges,

270
00:15:29,830 --> 00:15:31,532
and when I bring two views together,

271
00:15:31,565 --> 00:15:35,068
the preferences on a common edge
might not match.

272
00:15:35,102 --> 00:15:37,204
To resolve this,
a built-in layout container

273
00:15:37,237 --> 00:15:39,740
uses the larger of the two preferences.

274
00:15:39,773 --> 00:15:41,942
And I can do the same thing
in my own layout.

275
00:15:43,443 --> 00:15:47,314
The subview proxies give me a way
to ask for each button's preferred spacing

276
00:15:47,347 --> 00:15:50,651
to some other button along a given axis.

277
00:15:50,684 --> 00:15:54,688
So let me create an array of values by
scanning through the subviews

278
00:15:54,721 --> 00:15:59,493
and calling the distance method
on each proxy's spacing instance

279
00:15:59,526 --> 00:16:02,930
to get the spacing
to the next view's spacing instance

280
00:16:02,963 --> 00:16:05,599
along the horizontal axis.

281
00:16:05,632 --> 00:16:07,601
This call takes into account
the preferences

282
00:16:07,634 --> 00:16:11,004
of both views on their common edge.

283
00:16:11,038 --> 00:16:13,407
The first element in this array
tells me how much space

284
00:16:13,440 --> 00:16:17,611
the cat button wants horizontally
to the goldfish button,

285
00:16:17,644 --> 00:16:22,216
and the next tells me how much the
goldfish button wants to the dog button.

286
00:16:22,249 --> 00:16:24,952
I'll force the last element in the array
to be zero

287
00:16:24,985 --> 00:16:28,622
because there aren't any more buttons
to compare against.

288
00:16:28,655 --> 00:16:32,626
Okay, let me refactor that
into a method for later too.

289
00:16:32,659 --> 00:16:36,597
Now I can combine the spacing values
to find the total spacing

290
00:16:36,630 --> 00:16:39,132
and use that that with the width
and height measurements

291
00:16:39,166 --> 00:16:41,168
to return a size value.

292
00:16:41,201 --> 00:16:43,070
This is the size that my layout needs,

293
00:16:43,103 --> 00:16:45,439
given the ideal sizes of its subviews

294
00:16:45,472 --> 00:16:49,376
and each subview's preferred spacing.

295
00:16:49,409 --> 00:16:52,946
The other method that I need
to implement is placeSubviews.

296
00:16:52,980 --> 00:16:55,983
As I mentioned before,
I get both the bounds of the container,

297
00:16:56,016 --> 00:17:01,021
and the collection of subview proxies
that I can use to direct the buttons.

298
00:17:01,054 --> 00:17:04,291
First, I calculate maxSize
and the spacing array

299
00:17:04,324 --> 00:17:06,593
just like I did in sizeThatFits method,

300
00:17:06,627 --> 00:17:10,030
because I'll need those values here too.

301
00:17:10,063 --> 00:17:13,967
Then I'll create a size proposal
that I can use for each of my subviews,

302
00:17:14,001 --> 00:17:16,537
this time based on the size
that I want them to have,

303
00:17:16,570 --> 00:17:18,639
rather than their ideal size.

304
00:17:18,672 --> 00:17:23,443
I only need one proposal, because I want
all the buttons to the be the same size.

305
00:17:23,477 --> 00:17:26,313
And I'll find a starting position
in the horizontal dimension

306
00:17:26,346 --> 00:17:30,250
for my first subview, calculated as
the leading edge of my bounds,

307
00:17:30,284 --> 00:17:32,553
plus half the width of a button.

308
00:17:32,586 --> 00:17:34,955
Notice I'm not relying
on the origin to be zero,

309
00:17:34,988 --> 00:17:39,159
but instead starting
with the minX value instead.

310
00:17:39,193 --> 00:17:42,296
Finally, I can go through
each of the subview proxies

311
00:17:42,329 --> 00:17:45,532
and call its place method with a point,

312
00:17:45,566 --> 00:17:49,036
a statement of what that point represents
in terms of the button,

313
00:17:49,069 --> 00:17:52,105
and the size proposal.

314
00:17:52,139 --> 00:17:55,075
Each time through the loop,
I update the horizontal position

315
00:17:55,108 --> 00:17:58,545
by the width of a view,
plus the spacing for the next view pair,

316
00:17:58,579 --> 00:18:01,114
to get ready for the next iteration.

317
00:18:01,148 --> 00:18:02,549
And that's it.

318
00:18:02,583 --> 00:18:06,053
Now let's see what happens
when I use this new view layout type.

319
00:18:07,454 --> 00:18:08,655
And there it is.

320
00:18:08,689 --> 00:18:11,058
I instantiate my own
custom layout container

321
00:18:11,091 --> 00:18:13,527
just like I would a built-in HStack,

322
00:18:13,560 --> 00:18:18,532
and the buttons are arranged horizontally,
all at the same width.

323
00:18:18,565 --> 00:18:20,467
Now, I want to pause here for a moment

324
00:18:20,501 --> 00:18:22,970
and talk about how the Layout protocol
solves a problem

325
00:18:23,003 --> 00:18:27,040
that you might have tried to use
geometry reader for in the past.

326
00:18:27,074 --> 00:18:31,378
Geometry reader is, after all,
a tool for measuring view sizes.

327
00:18:31,411 --> 00:18:35,015
However,
it's not the best choice in this case.

328
00:18:35,048 --> 00:18:38,919
And that's because a geometry reader
is designed to measure its container view,

329
00:18:38,952 --> 00:18:41,288
and report the that size to its subview.

330
00:18:41,321 --> 00:18:45,792
The subview then uses the information
to draw its own content.

331
00:18:45,826 --> 00:18:48,428
Notice that for the intended use
of a geometry reader,

332
00:18:48,462 --> 00:18:50,330
the information flows downward.

333
00:18:50,364 --> 00:18:52,432
The measurement that the reader makes
has no effect

334
00:18:52,466 --> 00:18:54,701
on the layout of its own container.

335
00:18:55,836 --> 00:18:59,439
This is great for things like drawing
a path that scales with its container.

336
00:18:59,473 --> 00:19:03,143
The geometry reader tells the path logic
how much space it has to work with,

337
00:19:03,177 --> 00:19:07,714
and the path logic inside the subview
adjusts accordingly.

338
00:19:07,748 --> 00:19:10,984
If the container changes size,
so does the path,

339
00:19:11,018 --> 00:19:14,755
because the geometry reader
passes along the new size.

340
00:19:14,788 --> 00:19:17,591
However, for my buttons,
and I'll just focus on one here

341
00:19:17,624 --> 00:19:21,528
to make it easier to see,
I need to measure the text view,

342
00:19:21,562 --> 00:19:26,967
and then use that to decide how to set
a frame that's the text view's container.

343
00:19:27,000 --> 00:19:30,938
So I could add a geometry reader
in an overlay to the text view–

344
00:19:30,971 --> 00:19:33,173
remember, it measures its container–

345
00:19:33,207 --> 00:19:36,343
and then somehow send the measurement data
back up to the frame,

346
00:19:36,376 --> 00:19:38,645
outside of the normal flow.

347
00:19:38,679 --> 00:19:41,548
But notice that if I do this,
I'm bypassing the layout engine,

348
00:19:41,582 --> 00:19:43,784
which might result in a loop.

349
00:19:43,817 --> 00:19:46,887
The reader measures the layout
and changes the frame,

350
00:19:46,920 --> 00:19:51,925
which might change the layout, which could
require another measurement, and so on.

351
00:19:51,959 --> 00:19:54,394
Now it is possible to make this work,

352
00:19:54,428 --> 00:19:57,931
but if I'm not careful,
I could end up crashing my app.

353
00:19:57,965 --> 00:20:00,868
As a result,
this strategy isn't recommended.

354
00:20:00,901 --> 00:20:04,238
Fortunately, the layout protocol gives you
a better way to solve this problem,

355
00:20:04,271 --> 00:20:07,140
by letting you work
within the layout engine.

356
00:20:08,108 --> 00:20:10,711
Okay, let's look at the buttons again.

357
00:20:10,744 --> 00:20:13,013
There's something else I want to do here.

358
00:20:13,046 --> 00:20:14,882
First, to make this
a little easier to read,

359
00:20:14,915 --> 00:20:18,519
I'll refactor the buttons
into their own subview.

360
00:20:18,552 --> 00:20:21,321
Now, I happen to know that one
of my colleagues uses larger type

361
00:20:21,355 --> 00:20:22,990
on their device.

362
00:20:23,023 --> 00:20:27,461
My app automatically supports Dynamic Type
because I've used default fonts,

363
00:20:27,494 --> 00:20:30,898
so I should mostly get
the right behavior for free.

364
00:20:30,931 --> 00:20:35,235
Let's see what happens
if I increase the type size.

365
00:20:35,269 --> 00:20:37,437
Uh-oh, the buttons don't fit anymore.

366
00:20:37,471 --> 00:20:41,041
Remember that my custom stack
doesn't constrain the button widths,

367
00:20:41,074 --> 00:20:43,644
but just lets them have their ideal size,

368
00:20:43,677 --> 00:20:47,080
which in this case
exceeds the width of the display.

369
00:20:47,114 --> 00:20:48,582
So what can I do?

370
00:20:48,615 --> 00:20:51,318
Well, I could modify the layout
to do something more complicated

371
00:20:51,351 --> 00:20:54,421
when the views don't fit,
taking into account the size proposal

372
00:20:54,454 --> 00:20:56,323
from the layout's container.

373
00:20:56,356 --> 00:20:59,626
But for this case,
I can use the new ViewThatFits container

374
00:20:59,660 --> 00:21:01,828
to do most of the work for me.

375
00:21:01,862 --> 00:21:05,499
This new type picks the first view
that fits in the available space

376
00:21:05,532 --> 00:21:07,901
from a list of views that I give it.

377
00:21:09,336 --> 00:21:13,006
By wrapping my custom stack
in a ViewThatFits structure,

378
00:21:13,040 --> 00:21:16,076
and then adding a vertical stack version
of the same content,

379
00:21:16,109 --> 00:21:20,747
I can let SwiftUI figure out when the
buttons need to be arranged differently.

380
00:21:20,781 --> 00:21:24,284
Of course, the built-in VStack
doesn't have the equal width property

381
00:21:24,318 --> 00:21:27,521
that my custom horizontal stack does,

382
00:21:27,554 --> 00:21:31,725
so I've gone ahead and implemented a
vertical version of the custom stack too.

383
00:21:31,758 --> 00:21:34,061
It's very similar to the one
I already described,

384
00:21:34,094 --> 00:21:37,564
except that it places equal width items
along the vertical axis

385
00:21:37,598 --> 00:21:40,067
instead of the horizontal axis.

386
00:21:41,668 --> 00:21:44,771
And of course, when I remove
the dynamic type size override,

387
00:21:44,805 --> 00:21:47,574
it goes back to the horizontal layout.

388
00:21:47,608 --> 00:21:50,010
Now, there's one last piece of the app
I need to build,

389
00:21:50,043 --> 00:21:52,846
and that's the images at the top.

390
00:21:52,880 --> 00:21:56,483
I could do something simple, like
just show a group of profile pictures,

391
00:21:56,517 --> 00:21:59,186
but I thought I'd have a little fun
with it.

392
00:21:59,219 --> 00:22:01,321
So I made another custom layout type

393
00:22:01,355 --> 00:22:04,458
that draws views in a circular arrangement

394
00:22:04,491 --> 00:22:08,028
and then rotates the arrangement
according to rankings.

395
00:22:08,061 --> 00:22:11,031
So this configuration shows
goldfish in first place,

396
00:22:11,064 --> 00:22:13,500
and the other two tied for second.

397
00:22:13,534 --> 00:22:17,070
And then if dog pulls ahead of cat,
I can rotate a bit to show that.

398
00:22:17,104 --> 00:22:19,740
Or I can show
a slightly more realistic result,

399
00:22:19,773 --> 00:22:23,110
all by rotating a radial layout.

400
00:22:23,143 --> 00:22:27,014
Creating this layout is actually quite
straightforward with the layout protocol.

401
00:22:27,047 --> 00:22:30,317
Like before, I just need two methods.

402
00:22:30,350 --> 00:22:33,687
For size that fits, I want my view
to fill the available space,

403
00:22:33,720 --> 00:22:37,724
so I'll return whatever size
the container view proposes.

404
00:22:37,758 --> 00:22:40,360
I'll convert the proposal
into a concrete size

405
00:22:40,394 --> 00:22:44,031
using the replacing-unspecified-dimensions
method.

406
00:22:44,064 --> 00:22:47,234
That method automatically handles
nil values that could be present

407
00:22:47,267 --> 00:22:50,737
if the container asks for an ideal size.

408
00:22:50,771 --> 00:22:53,340
Then inside place subviews method,

409
00:22:53,373 --> 00:22:55,609
I'll offset each subview from the middle

410
00:22:55,642 --> 00:22:59,213
by some radius that's based
on the size of the layout region,

411
00:22:59,246 --> 00:23:03,350
and apply a rotation that depends
on the index of the view.

412
00:23:03,383 --> 00:23:07,588
As a baseline,
this places the views at 0, 1,

413
00:23:07,621 --> 00:23:12,459
and two-thirds of the way around a circle.

414
00:23:12,492 --> 00:23:14,161
To reflect the current rankings,

415
00:23:14,194 --> 00:23:18,365
I'll also apply an offset
that affects all the views equally.

416
00:23:18,398 --> 00:23:20,033
But where do I get the rankings?

417
00:23:20,067 --> 00:23:23,537
Remember, my layout can only access
the subview proxies,

418
00:23:23,570 --> 00:23:27,107
and not the views,
let alone my data model.

419
00:23:27,140 --> 00:23:31,044
Well, it turns out that the layout
protocol has another trick up its sleeve.

420
00:23:31,078 --> 00:23:33,380
It lets you store values on each subview,

421
00:23:33,413 --> 00:23:37,384
and read the values from inside
the layout protocol methods.

422
00:23:37,417 --> 00:23:41,822
Let's see how I can use that
to communicate the rank information.

423
00:23:41,855 --> 00:23:46,593
First, I declare a new type that conforms
to the LayoutValueKey protocol,

424
00:23:46,627 --> 00:23:48,829
and give it a default value.

425
00:23:48,862 --> 00:23:53,166
In addition to providing a value for
a view when you don't explicitly set one,

426
00:23:53,200 --> 00:23:56,303
the default value establishes
the associated value's type,

427
00:23:56,336 --> 00:23:59,339
which is an integer in this case.

428
00:23:59,373 --> 00:24:03,410
Then, I create a convenience method
on View to set the value

429
00:24:03,443 --> 00:24:07,114
using the layoutValue view modifier.

430
00:24:07,147 --> 00:24:08,882
Now in my view hierarchy,

431
00:24:08,916 --> 00:24:13,187
I can apply my convenience rank modifier
to the views in my layout.

432
00:24:13,220 --> 00:24:15,322
Here, I calculate the rank of each pet

433
00:24:15,355 --> 00:24:20,894
and add it to the pet's corresponding
avatar view inside my radial layout.

434
00:24:20,928 --> 00:24:23,597
Finally, back in my place subviews method,

435
00:24:23,630 --> 00:24:27,167
I can add some code to read the values
from each subview

436
00:24:27,201 --> 00:24:31,371
by using the layout value key as an index.

437
00:24:31,405 --> 00:24:34,675
And I can use the ranks
to calculate an offset.

438
00:24:34,708 --> 00:24:37,511
I won't go through that logic here,
but it basically produces

439
00:24:37,544 --> 00:24:40,914
an appropriate angle
for any possible set of rankings.

440
00:24:40,948 --> 00:24:43,283
Well, all except one.

441
00:24:43,317 --> 00:24:45,752
What happens if there's a three-way tie?

442
00:24:45,786 --> 00:24:48,856
There's no way to rotate
the layout to get all the views in a line,

443
00:24:48,889 --> 00:24:53,393
so I'd have to substitute completely
different layout logic for that case.

444
00:24:53,427 --> 00:24:56,330
However, there is already
a layout type that does this,

445
00:24:56,363 --> 00:24:58,498
and that's the built-in HStack.

446
00:24:58,532 --> 00:25:01,168
So what I'd really like
is to transition to an HStack

447
00:25:01,201 --> 00:25:03,604
when I detect a three-way tie.

448
00:25:03,637 --> 00:25:07,107
And it turns out that
there's a new tool for that, too.

449
00:25:07,140 --> 00:25:09,476
The AnyLayout type lets you
apply different layouts

450
00:25:09,510 --> 00:25:12,513
to a single view hierarchy,
so that you maintain the identity

451
00:25:12,546 --> 00:25:16,517
of the views as you transition
from one layout type to another.

452
00:25:17,451 --> 00:25:20,988
So here I have the radial layout
that we saw before,

453
00:25:21,021 --> 00:25:24,057
and all I have to do is replace that
with a new layout type

454
00:25:24,091 --> 00:25:27,528
that depends on whether
there's a three-way tie.

455
00:25:27,561 --> 00:25:31,465
Because the isThreeWayTie property
is derived from state,

456
00:25:31,498 --> 00:25:33,333
SwiftUI notices when it changes

457
00:25:33,367 --> 00:25:36,370
and recognizes
that it needs to redraw this view.

458
00:25:36,403 --> 00:25:39,540
But because the structural identity
of the view hierarchy

459
00:25:39,573 --> 00:25:43,844
always remains the same,
SwiftUI sees this as a view that changes,

460
00:25:43,877 --> 00:25:46,213
rather than as a new view.

461
00:25:46,246 --> 00:25:48,949
As a result,
with only one more line,

462
00:25:48,982 --> 00:25:52,553
I can create smooth transitions
between layout types.

463
00:25:52,586 --> 00:25:55,155
And in fact,
by adding the animation view modifier,

464
00:25:55,189 --> 00:25:59,726
I also get animations between all
the different states of the radial layout,

465
00:25:59,760 --> 00:26:03,931
because the configuration of the radial
layout depends on the same data.

466
00:26:03,964 --> 00:26:06,733
And here's what
all that looks like in action.

467
00:26:06,767 --> 00:26:09,403
As I tap on different buttons
to change the vote counts,

468
00:26:09,436 --> 00:26:13,540
you can see how the avatars move around
smoothly to reflect the current standings.

469
00:26:17,845 --> 00:26:20,447
So those are some of the new tools
that SwiftUI has

470
00:26:20,480 --> 00:26:23,083
for composing your app's view layouts.

471
00:26:23,116 --> 00:26:25,719
You can use the Grid type
to build highly customizable,

472
00:26:25,752 --> 00:26:28,589
two-dimensional layouts
of static information.

473
00:26:28,622 --> 00:26:31,859
You can use the Layout protocol
to define your own general purpose,

474
00:26:31,892 --> 00:26:36,730
reusable layouts, or layouts that are
highly targeted to a particular use case.

475
00:26:36,763 --> 00:26:40,734
You can use ViewThatFits when you want
to let SwiftUI pick from a group of views

476
00:26:40,767 --> 00:26:43,303
to best fit in the available space.

477
00:26:43,337 --> 00:26:48,442
And you can seamlessly transition
between layout types using AnyLayout.

478
00:26:48,475 --> 00:26:51,411
Thanks for joining me today,
and I hope you have as much fun

479
00:26:51,445 --> 00:26:54,214
playing with these new layout tools
as I have.

