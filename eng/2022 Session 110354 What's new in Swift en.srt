1
00:00:00,000 --> 00:00:03,003
♪ Mellow instrumental
hip-hop music ♪

2
00:00:03,003 --> 00:00:09,810
♪

3
00:00:09,810 --> 00:00:11,545
Hi, I'm Angela.

4
00:00:11,545 --> 00:00:13,413
And I'm Becca.

5
00:00:13,413 --> 00:00:15,415
Welcome
to what's new in Swift!

6
00:00:15,415 --> 00:00:17,317
We're really excited
to talk to you today

7
00:00:17,317 --> 00:00:21,154
about all of the great
new features in Swift 5.7.

8
00:00:21,154 --> 00:00:22,956
Many of the things
we'll talk about today

9
00:00:22,956 --> 00:00:28,195
demonstrate Swift's goal to make
your life as a developer easier.

10
00:00:28,195 --> 00:00:29,429
We'll look at new tooling

11
00:00:29,429 --> 00:00:31,732
to help you customize
your workflow

12
00:00:31,732 --> 00:00:35,569
and some amazing
under-the-hood improvements.

13
00:00:35,569 --> 00:00:38,772
Then we'll talk about the latest
in Swift's concurrency model

14
00:00:38,772 --> 00:00:43,243
and the road to Swift 6,
including full-thread safety.

15
00:00:43,243 --> 00:00:44,912
Then I'll finish up
by taking you through

16
00:00:44,912 --> 00:00:47,447
some language improvements
that make Swift easier to read

17
00:00:47,447 --> 00:00:50,784
and write, including cleaner,
simpler generics,

18
00:00:50,784 --> 00:00:54,688
and powerful new
string processing facilities.

19
00:00:54,688 --> 00:00:57,424
But first,
let's start by talking about

20
00:00:57,424 --> 00:01:01,228
one of the things
that makes Swift so special --

21
00:01:01,228 --> 00:01:02,763
all of you.

22
00:01:02,763 --> 00:01:05,499
Your input and contributions
are what have enabled Swift

23
00:01:05,499 --> 00:01:08,268
to expand so rapidly.

24
00:01:08,268 --> 00:01:11,038
Community involvement
is at Swift's core.

25
00:01:11,038 --> 00:01:14,174
This year, more of the Swift
project became available

26
00:01:14,174 --> 00:01:16,209
to the community when docC --

27
00:01:16,209 --> 00:01:19,446
the documentation generation
tool announced last year --

28
00:01:19,446 --> 00:01:23,150
and the Swift.org website
were open sourced.

29
00:01:23,150 --> 00:01:24,651
Open source works best

30
00:01:24,651 --> 00:01:28,889
when you have an active
community shepherding it.

31
00:01:28,889 --> 00:01:31,591
We've been using the workgroup
model for Swift on Server

32
00:01:31,591 --> 00:01:34,528
and Diversity in Swift
to provide stewardship

33
00:01:34,528 --> 00:01:36,196
and support
for community members

34
00:01:36,196 --> 00:01:38,732
interested in specific areas.

35
00:01:38,732 --> 00:01:40,400
This has been working
really well

36
00:01:40,400 --> 00:01:42,336
so we've started
two new workgroups.

37
00:01:42,336 --> 00:01:44,171
One for iterating
on the Swift website

38
00:01:44,171 --> 00:01:46,340
and making it more
of a community resource,

39
00:01:46,340 --> 00:01:49,409
and another
for C++ interoperability,

40
00:01:49,409 --> 00:01:54,581
to shape the design of the model
between C++ and Swift.

41
00:01:54,581 --> 00:01:57,551
As we venture into new areas,
we all need support

42
00:01:57,551 --> 00:02:00,020
from members
within the community.

43
00:02:00,020 --> 00:02:02,856
As a part of that, the
Diversity in Swift workgroup

44
00:02:02,856 --> 00:02:05,792
introduced the Swift
Mentorship Program last year.

45
00:02:05,792 --> 00:02:07,427
The program provides pathways

46
00:02:07,427 --> 00:02:09,563
to contribute to all
of the workgroup areas

47
00:02:09,563 --> 00:02:11,398
for folks who don't know
how to start

48
00:02:11,398 --> 00:02:15,869
or are looking to deepen their
expertise in a particular area.

49
00:02:15,869 --> 00:02:18,805
Last year's program
was a huge success.

50
00:02:18,805 --> 00:02:21,708
There were a lot
of interested mentees;

51
00:02:21,708 --> 00:02:25,912
and with that, we were able
to create 41 mentorship pairs.

52
00:02:25,912 --> 00:02:29,082
This success is why the program
is being brought back

53
00:02:29,082 --> 00:02:30,617
for year two.

54
00:02:30,617 --> 00:02:32,419
The program would love
to include everyone

55
00:02:32,419 --> 00:02:35,655
who's interested;
but to do that, we need you --

56
00:02:35,655 --> 00:02:38,792
the excited and experienced
developers listening now

57
00:02:38,792 --> 00:02:40,827
who are ready to share
their breadth of knowledge

58
00:02:40,827 --> 00:02:42,763
and make new connections.

59
00:02:42,763 --> 00:02:45,599
Because the mentorship program
is not just about the code

60
00:02:45,599 --> 00:02:49,002
but about building relationships
within the community.

61
00:02:49,002 --> 00:02:52,005
And a little guidance
can have a lasting effect.

62
00:02:52,005 --> 00:02:54,641
Don't just take my word for it.

63
00:02:54,641 --> 00:02:58,045
Last year, Amrit participated
in the mentorship program

64
00:02:58,045 --> 00:03:00,847
and focused on compiler
and language design.

65
00:03:00,847 --> 00:03:02,749
What started off
as intrigue for Amrit

66
00:03:02,749 --> 00:03:06,019
transformed into
tangible contributions.

67
00:03:06,019 --> 00:03:09,056
Diving into a new domain
is not easy.

68
00:03:09,056 --> 00:03:12,092
Even so, she walked away
finding success

69
00:03:12,092 --> 00:03:14,828
and feeling inspired
to contribute more.

70
00:03:14,828 --> 00:03:16,229
Like many others,

71
00:03:16,229 --> 00:03:19,499
this experience
opened a door for Amrit.

72
00:03:19,499 --> 00:03:22,202
In addition to compiler
and language design,

73
00:03:22,202 --> 00:03:26,339
last year there were a wide
range of available focus areas,

74
00:03:26,339 --> 00:03:28,008
from technical writing
and testing

75
00:03:28,008 --> 00:03:30,744
to contributing
to Swift packages.

76
00:03:30,744 --> 00:03:33,080
This year,
we're adding even more

77
00:03:33,080 --> 00:03:36,116
and there's always opportunities
for new topics.

78
00:03:36,116 --> 00:03:39,252
If you don't see something
in this list that interests you,

79
00:03:39,252 --> 00:03:42,255
you can still mention it
in your application.

80
00:03:42,255 --> 00:03:45,425
Another addition is that
this year's program will offer

81
00:03:45,425 --> 00:03:48,261
mentorship year-round
for starter bug contributions

82
00:03:48,261 --> 00:03:50,730
to help accommodate anyone
who may have a lower capacity

83
00:03:50,730 --> 00:03:54,734
to participate but is still
excited to get involved.

84
00:03:54,734 --> 00:03:56,503
If you're interested
in applying,

85
00:03:56,503 --> 00:03:58,238
or just eager to hear more,

86
00:03:58,238 --> 00:04:00,474
check out the most
recent Swift blog post.

87
00:04:00,474 --> 00:04:02,809
There, you can find links
to detailed reflections

88
00:04:02,809 --> 00:04:05,512
from the highlighted mentees.

89
00:04:05,512 --> 00:04:08,048
The mentorship program
is just one initiative

90
00:04:08,048 --> 00:04:10,717
under Diversity in Swift
umbrella.

91
00:04:10,717 --> 00:04:12,552
To learn more about
the mentorship program

92
00:04:12,552 --> 00:04:14,754
and other Diversity in Swift
efforts,

93
00:04:14,754 --> 00:04:17,691
you can visit
Swift.org/diversity.

94
00:04:17,691 --> 00:04:20,494
To open the door even further,
we want to make it

95
00:04:20,494 --> 00:04:24,965
as easy as possible to use Swift
with the resources you have!

96
00:04:24,965 --> 00:04:27,868
We have streamlined the Swift
toolchain distribution process

97
00:04:27,868 --> 00:04:29,269
for the Linux platform

98
00:04:29,269 --> 00:04:32,072
by adding support
for Linux package formats.

99
00:04:32,072 --> 00:04:33,940
With the new native
toolchain installers,

100
00:04:33,940 --> 00:04:37,110
you can now download RPMs
for Amazon Linux 2

101
00:04:37,110 --> 00:04:40,380
and CentOS 7
directly from Swift.org.

102
00:04:40,380 --> 00:04:42,115
These toolchains
are experimental,

103
00:04:42,115 --> 00:04:45,418
so be sure to share feedback
on the Swift.org forums.

104
00:04:45,418 --> 00:04:48,155
Swift is primarily used
for building apps.

105
00:04:48,155 --> 00:04:52,626
However, the vision has always
been for Swift to be scalable --

106
00:04:52,626 --> 00:04:54,661
used from everything
from high-level scripts

107
00:04:54,661 --> 00:04:57,531
down to bare-metal environments.

108
00:04:57,531 --> 00:04:58,932
To encourage Swift to be used

109
00:04:58,932 --> 00:05:01,234
where it's never
been used before,

110
00:05:01,234 --> 00:05:04,171
Swift underwent some
major changes this year.

111
00:05:04,171 --> 00:05:05,705
To make the standard
library smaller

112
00:05:05,705 --> 00:05:08,441
for standalone,
statically linked binaries,

113
00:05:08,441 --> 00:05:09,943
we dropped the dependency

114
00:05:09,943 --> 00:05:12,445
on an external
Unicode support library,

115
00:05:12,445 --> 00:05:17,384
replacing it with a faster
native implementation.

116
00:05:17,384 --> 00:05:20,187
Smaller, faster binaries
are a huge benefit

117
00:05:20,187 --> 00:05:22,756
when running on
event-driven server solutions.

118
00:05:22,756 --> 00:05:24,925
You get static linking
on Linux by default

119
00:05:24,925 --> 00:05:28,595
to better support containerized
deployments for the server.

120
00:05:28,595 --> 00:05:30,530
This size reduction
makes Swift suitable

121
00:05:30,530 --> 00:05:32,432
for even restricted
environments,

122
00:05:32,432 --> 00:05:33,633
which allowed us to use it

123
00:05:33,633 --> 00:05:36,269
in Apple's
Secure Enclave Processor.

124
00:05:36,269 --> 00:05:38,738
Swift is useful
from apps to servers

125
00:05:38,738 --> 00:05:41,675
all the way down
to restricted processors;

126
00:05:41,675 --> 00:05:46,713
tying it all together
is the package ecosystem.

127
00:05:46,713 --> 00:05:48,782
This year's new features
in Swift packages

128
00:05:48,782 --> 00:05:50,584
will make your life better.

129
00:05:50,584 --> 00:05:55,655
To start, Swift Package Manager
has introduced TOFU.

130
00:05:55,655 --> 00:05:58,592
No, not the delicious snack.

131
00:05:58,592 --> 00:06:01,928
TOFU is an acronym that stands
for Trust On First Use.

132
00:06:01,928 --> 00:06:04,231
It's a new security protocol
where the fingerprint

133
00:06:04,231 --> 00:06:06,066
of a package
is now being recorded

134
00:06:06,066 --> 00:06:08,468
when the package
is first downloaded.

135
00:06:08,468 --> 00:06:11,037
Subsequent downloads
will validate this fingerprint

136
00:06:11,037 --> 00:06:14,674
and report an error if
the fingerprints are different.

137
00:06:14,674 --> 00:06:17,377
This is just one example
of how trust and security

138
00:06:17,377 --> 00:06:20,146
are built into the core
of the package ecosystem

139
00:06:20,146 --> 00:06:23,383
to help you feel
confident using it.

140
00:06:23,383 --> 00:06:26,353
Command plug-ins are a great way
to improve the workflow

141
00:06:26,353 --> 00:06:28,288
for Swift developers.

142
00:06:28,288 --> 00:06:30,657
They are the first step
in providing more extensible

143
00:06:30,657 --> 00:06:32,926
and secure build tools.

144
00:06:32,926 --> 00:06:35,962
Command plug-ins can be used
for documentation generation,

145
00:06:35,962 --> 00:06:38,632
source code reformatting
and more.

146
00:06:38,632 --> 00:06:41,067
Instead of writing your
automation in a shell script

147
00:06:41,067 --> 00:06:44,437
and having to maintain separate
workflows, you can use Swift!

148
00:06:44,437 --> 00:06:46,906
Think open source
formatters and linters.

149
00:06:46,906 --> 00:06:50,644
Now, all of those open source
tools are available within Xcode

150
00:06:50,644 --> 00:06:53,947
and Swift Package Manager.

151
00:06:53,947 --> 00:06:57,050
Command plug-ins are the glue
between open source tools

152
00:06:57,050 --> 00:06:58,818
and Swift Package Manager.

153
00:06:58,818 --> 00:07:01,054
The Swift project
is embracing developer tools

154
00:07:01,054 --> 00:07:03,957
in the open source community
to provide seamless integration

155
00:07:03,957 --> 00:07:06,693
with your automated workflows.

156
00:07:06,693 --> 00:07:09,296
docC is great tool
to integrate documentation

157
00:07:09,296 --> 00:07:10,697
into your source code.

158
00:07:10,697 --> 00:07:14,734
This year, it got even better
with Objective-C and C support.

159
00:07:14,734 --> 00:07:16,536
Let's take a look
at what it would take

160
00:07:16,536 --> 00:07:19,072
to create a plug-in
with docC.

161
00:07:19,072 --> 00:07:20,907
Plug-ins are just
simple Swift code.

162
00:07:20,907 --> 00:07:23,109
You can define a plug-in
by creating a struct

163
00:07:23,109 --> 00:07:25,478
that conforms to
the CommandPlugin protocol.

164
00:07:25,478 --> 00:07:28,014
And then you just add a function
that tells your plug-in

165
00:07:28,014 --> 00:07:30,250
which tool you'd like to invoke.

166
00:07:30,250 --> 00:07:34,454
Within this function
is where we want to call docC.

167
00:07:34,454 --> 00:07:37,290
Once you've defined your
plug-in, it becomes available

168
00:07:37,290 --> 00:07:39,025
through the Swift PM
command line interface

169
00:07:39,025 --> 00:07:40,927
and Xcode as a menu entry.

170
00:07:40,927 --> 00:07:44,364
Now, we can tell Swift PM
to generate documentation

171
00:07:44,364 --> 00:07:48,568
and it knows to pass this action
to the docC executable.

172
00:07:48,568 --> 00:07:50,337
It doesn't stop there.

173
00:07:50,337 --> 00:07:54,240
There's a second plug-in
known as build tool plug-ins.

174
00:07:54,240 --> 00:07:56,376
These plug-ins
are packages that allow you

175
00:07:56,376 --> 00:07:59,245
to inject additional steps
during the build.

176
00:07:59,245 --> 00:08:01,381
When you implement
a build tool plug-in,

177
00:08:01,381 --> 00:08:02,982
that will create a command
for the build system

178
00:08:02,982 --> 00:08:05,085
to execute in a sandbox.

179
00:08:05,085 --> 00:08:06,786
They differ from
command plug-ins

180
00:08:06,786 --> 00:08:09,089
which you execute
directly at any time

181
00:08:09,089 --> 00:08:11,224
and can be granted
explicit permission

182
00:08:11,224 --> 00:08:13,993
to change files in your package.

183
00:08:13,993 --> 00:08:16,996
Build tool plug-ins can be used
for source code generation

184
00:08:16,996 --> 00:08:20,233
or custom processing
for special types of files.

185
00:08:20,233 --> 00:08:23,570
With build tool plug-ins, this
would be the package layout.

186
00:08:23,570 --> 00:08:25,839
In this example,
the plugin.Swift

187
00:08:25,839 --> 00:08:27,607
is the Swift script
that implements

188
00:08:27,607 --> 00:08:29,142
the package plug-in target.

189
00:08:29,142 --> 00:08:33,480
The plug-in is treated
as a Swift executable.

190
00:08:33,480 --> 00:08:35,482
And you write the plug-in
in the same way

191
00:08:35,482 --> 00:08:38,852
you write any
Swift executable.

192
00:08:38,852 --> 00:08:40,653
You can implement
your plug-in by defining

193
00:08:40,653 --> 00:08:43,456
a set of build commands
that tells the build system

194
00:08:43,456 --> 00:08:46,559
what executable command to run
and what outputs are expected

195
00:08:46,559 --> 00:08:48,294
as a result.

196
00:08:48,294 --> 00:08:50,630
Package plug-ins
are secure solutions

197
00:08:50,630 --> 00:08:53,366
that provide extensibility
in your packages.

198
00:08:53,366 --> 00:08:55,702
You can learn more
about how plug-ins work

199
00:08:55,702 --> 00:08:58,705
and how to implement your own
plug-in, in two sessions,

200
00:08:58,705 --> 00:09:00,206
"Meet Swift Package plugins"

201
00:09:00,206 --> 00:09:03,410
and "Create Swift Package
plugins."

202
00:09:03,410 --> 00:09:05,545
As you expand
your use of packages,

203
00:09:05,545 --> 00:09:08,681
you might have encountered
module collisions.

204
00:09:08,681 --> 00:09:10,283
That's when two
separate packages

205
00:09:10,283 --> 00:09:12,786
define a module
with the same name.

206
00:09:12,786 --> 00:09:14,320
To solve this situation,

207
00:09:14,320 --> 00:09:19,225
Swift 5.7 introduces
module disambiguation.

208
00:09:19,225 --> 00:09:22,896
Module disambiguation
is a feature that allows you

209
00:09:22,896 --> 00:09:26,900
to rename modules from outside
the packages that define them.

210
00:09:26,900 --> 00:09:28,902
Here in our
Stunning application,

211
00:09:28,902 --> 00:09:31,905
we're bringing in two packages
that define a Logging module,

212
00:09:31,905 --> 00:09:33,139
so they clash.

213
00:09:33,139 --> 00:09:35,909
To fix this for
our Stunning application,

214
00:09:35,909 --> 00:09:38,545
you'll just need to add
the moduleAliases keyword

215
00:09:38,545 --> 00:09:42,949
to the dependencies section
of your package manifest.

216
00:09:42,949 --> 00:09:44,717
That way you can use
two different names

217
00:09:44,717 --> 00:09:46,519
to distinguish between modules

218
00:09:46,519 --> 00:09:49,456
that previously had
the same name.

219
00:09:49,456 --> 00:09:53,560
Swift 5.7 brings some fantastic
performance improvements.

220
00:09:53,560 --> 00:09:56,129
Let's start
by looking at build times.

221
00:09:56,129 --> 00:09:58,698
Last year, we told you
about how we had rewritten

222
00:09:58,698 --> 00:10:00,633
the Swift Driver --
the program that coordinates

223
00:10:00,633 --> 00:10:04,103
the compilation
of Swift source code in Swift.

224
00:10:04,103 --> 00:10:05,371
Last year's rearchitecture

225
00:10:05,371 --> 00:10:07,140
unlocked some really
important changes

226
00:10:07,140 --> 00:10:09,442
that speed up builds
significantly.

227
00:10:09,442 --> 00:10:11,611
The driver can now be used
as a framework

228
00:10:11,611 --> 00:10:13,746
directly inside
the Xcode build system

229
00:10:13,746 --> 00:10:16,316
instead of
as a separate executable.

230
00:10:16,316 --> 00:10:18,451
This allows it to coordinate
builds more closely

231
00:10:18,451 --> 00:10:22,622
with the build system to allow
things like parallelization.

232
00:10:22,622 --> 00:10:25,124
If you're someone who loves
the sound of quick builds,

233
00:10:25,124 --> 00:10:26,893
you can get
more details in the

234
00:10:26,893 --> 00:10:31,030
"Demystify parallelization
in Xcode builds" session.

235
00:10:31,030 --> 00:10:33,132
To show you
how much faster builds are,

236
00:10:33,132 --> 00:10:36,002
let's look at some examples
of how long it takes to build

237
00:10:36,002 --> 00:10:39,305
some of the tools we use often
that are written in Swift.

238
00:10:39,305 --> 00:10:41,841
On a 10-core iMac,
the improvements have ranged

239
00:10:41,841 --> 00:10:46,579
from 5 percent
all the way up to 25 percent.

240
00:10:46,579 --> 00:10:49,883
Next, there are improvements
to the speed of type checking.

241
00:10:49,883 --> 00:10:52,585
This year, we improved
the type-checker performance

242
00:10:52,585 --> 00:10:56,155
by reimplementing a key part
of the generics system --

243
00:10:56,155 --> 00:10:58,191
the part that computes
a function signature

244
00:10:58,191 --> 00:11:00,727
from things like protocols
and "where" clauses.

245
00:11:00,727 --> 00:11:03,530
In the old implementation,
time and memory usage

246
00:11:03,530 --> 00:11:07,166
could scale exponentially
as more protocols were involved.

247
00:11:07,166 --> 00:11:10,870
For example, here, we have
a complicated set of protocols

248
00:11:10,870 --> 00:11:13,339
that define a coordinate system,
with a lot

249
00:11:13,339 --> 00:11:16,576
of generic requirements
on the many associated types.

250
00:11:16,576 --> 00:11:20,713
Previously, this would take 17
seconds to type-check this code.

251
00:11:20,713 --> 00:11:24,217
But now, in Swift 5.7,
this example is able

252
00:11:24,217 --> 00:11:28,888
to type-check significantly
quicker, in under a second.

253
00:11:28,888 --> 00:11:32,825
We also have some equally
impressive runtime improvements.

254
00:11:32,825 --> 00:11:36,629
Before Swift 5.7, we've seen
protocol checking on app startup

255
00:11:36,629 --> 00:11:39,632
take as long
as four seconds on iOS.

256
00:11:39,632 --> 00:11:42,969
Protocols needed to be computed
every time we launched apps,

257
00:11:42,969 --> 00:11:44,771
resulting in launch times
that got longer

258
00:11:44,771 --> 00:11:46,739
the more protocols you added.

259
00:11:46,739 --> 00:11:48,708
Now, they're cached.

260
00:11:48,708 --> 00:11:50,643
Depending on how an app
was written

261
00:11:50,643 --> 00:11:52,679
and how many protocols it used,

262
00:11:52,679 --> 00:11:55,715
this can mean launch times
being cut in half in some apps

263
00:11:55,715 --> 00:11:58,051
when running on iOS 16.

264
00:11:58,051 --> 00:12:01,220
The session "Improve app size
and runtime performance"

265
00:12:01,220 --> 00:12:03,356
will dive deeper
into how you can leverage

266
00:12:03,356 --> 00:12:07,160
these improvements
in your own application.

267
00:12:07,160 --> 00:12:09,629
Now, it's time for something
I'm sure a lot of you

268
00:12:09,629 --> 00:12:12,332
have been eager to hear about.

269
00:12:12,332 --> 00:12:15,902
Last year, we introduced
the new concurrency model,

270
00:12:15,902 --> 00:12:19,439
bringing together actors
and async/await.

271
00:12:19,439 --> 00:12:23,409
This had a transformative effect
on the concurrency architecture

272
00:12:23,409 --> 00:12:25,078
of your applications.

273
00:12:25,078 --> 00:12:29,515
Async/await and actors are safer
and easier than callbacks

274
00:12:29,515 --> 00:12:31,718
and manual queue management.

275
00:12:31,718 --> 00:12:34,220
This year, we further
fleshed out the model

276
00:12:34,220 --> 00:12:37,423
with data race safety
at the forefront.

277
00:12:37,423 --> 00:12:39,559
Because concurrency
was such a fundamental

278
00:12:39,559 --> 00:12:41,928
and important improvement
to your app's codebase,

279
00:12:41,928 --> 00:12:44,430
we made it possible
to back-deploy these changes

280
00:12:44,430 --> 00:12:48,201
all the way back to iOS 13
and macOS Catalina.

281
00:12:48,201 --> 00:12:50,503
In order to deploy
to older operating systems,

282
00:12:50,503 --> 00:12:54,207
your app bundles a copy of the
Swift 5.5 concurrency runtime

283
00:12:54,207 --> 00:12:55,975
for older OSes.

284
00:12:55,975 --> 00:12:58,177
This is similar
to back-deploying Swift

285
00:12:58,177 --> 00:13:01,914
to operating systems
before ABI stability.

286
00:13:01,914 --> 00:13:05,151
Next, we've taken this model
in new directions.

287
00:13:05,151 --> 00:13:06,586
We've introduced
language features

288
00:13:06,586 --> 00:13:08,521
and supporting packages.

289
00:13:08,521 --> 00:13:12,759
First, let's talk about
data race avoidance.

290
00:13:12,759 --> 00:13:14,027
Before I jump into that,

291
00:13:14,027 --> 00:13:15,728
I should probably
take a step back

292
00:13:15,728 --> 00:13:18,498
and say that one of the really
important features of Swift,

293
00:13:18,498 --> 00:13:20,867
is memory safety by default.

294
00:13:20,867 --> 00:13:23,870
Swift users can't do things
with unpredictable behavior,

295
00:13:23,870 --> 00:13:25,071
like reading a value

296
00:13:25,071 --> 00:13:27,573
while you're in the middle
of modifying it.

297
00:13:27,573 --> 00:13:31,277
In this example, we're removing
all of the numbers in an array

298
00:13:31,277 --> 00:13:33,446
that match
the same array's count.

299
00:13:33,446 --> 00:13:36,182
Initially,
the array's count is 3,

300
00:13:36,182 --> 00:13:38,985
so we'll remove
the 3 from the array.

301
00:13:38,985 --> 00:13:41,954
But once we've done that,
the count will be 2.

302
00:13:41,954 --> 00:13:44,524
Do we remove the 3
and the 2 from the array,

303
00:13:44,524 --> 00:13:46,526
or just the 3?

304
00:13:46,526 --> 00:13:48,327
The answer is neither.

305
00:13:48,327 --> 00:13:50,163
Swift will prevent you
from doing this

306
00:13:50,163 --> 00:13:52,865
because it's not safe
to access the array's count

307
00:13:52,865 --> 00:13:55,435
while you're in the middle
of modifying it.

308
00:13:55,435 --> 00:13:58,838
Our goal is to do something
similar for thread safety.

309
00:13:58,838 --> 00:14:00,073
We envision a language

310
00:14:00,073 --> 00:14:03,376
that eliminates low-level
data races by default.

311
00:14:03,376 --> 00:14:06,379
In other words, we want
to prevent concurrency bugs

312
00:14:06,379 --> 00:14:09,215
that can cause
unpredictable behavior.

313
00:14:09,215 --> 00:14:10,950
Here's another example.

314
00:14:10,950 --> 00:14:14,620
Using the same number's array,
we create a background task

315
00:14:14,620 --> 00:14:17,223
that appends 0 to the array,

316
00:14:17,223 --> 00:14:20,560
and then we remove
the array's last element.

317
00:14:20,560 --> 00:14:23,062
But wait, does removing
the last element

318
00:14:23,062 --> 00:14:26,566
happen before or after
we append 0?

319
00:14:26,566 --> 00:14:29,669
The answer, again, is neither.

320
00:14:29,669 --> 00:14:32,405
Swift will block you from doing
this because it's not safe

321
00:14:32,405 --> 00:14:34,307
to modify the array
from a background task

322
00:14:34,307 --> 00:14:38,678
without synchronizing access
with something like an actor.

323
00:14:38,678 --> 00:14:42,749
Actors were the first major step
towards eliminating data races.

324
00:14:42,749 --> 00:14:45,184
This year we've refined
the concurrency model

325
00:14:45,184 --> 00:14:49,122
to push us even further
towards the end goal.

326
00:14:49,122 --> 00:14:52,325
You can think of each actor
as its own island,

327
00:14:52,325 --> 00:14:56,095
isolated from everything else
in the sea of concurrency.

328
00:14:56,095 --> 00:14:58,798
But what happens when
different threads want to query

329
00:14:58,798 --> 00:15:03,002
the information stored by
each of the isolated actors?

330
00:15:03,002 --> 00:15:06,072
This metaphor will be explored
in depth in the session

331
00:15:06,072 --> 00:15:10,643
"Eliminate data races
using Swift Concurrency."

332
00:15:10,643 --> 00:15:14,013
From memory safety
to thread safety by default;

333
00:15:14,013 --> 00:15:16,849
that is the goal for Swift 6.

334
00:15:16,849 --> 00:15:19,051
To get us there,
we first improved last year's

335
00:15:19,051 --> 00:15:21,521
concurrency model
with the new language features

336
00:15:21,521 --> 00:15:23,122
I just mentioned.

337
00:15:23,122 --> 00:15:24,991
The second thing
I haven't mentioned yet

338
00:15:24,991 --> 00:15:26,692
is the new opt-in safety checks

339
00:15:26,692 --> 00:15:30,163
that identify
potential data races.

340
00:15:30,163 --> 00:15:32,865
You can experiment with
stricter concurrency checking

341
00:15:32,865 --> 00:15:36,202
by enabling it
in your build settings.

342
00:15:36,202 --> 00:15:38,371
Let's take a look
at actors again.

343
00:15:38,371 --> 00:15:41,641
We can take this notion
of actor isolation,

344
00:15:41,641 --> 00:15:44,544
and take it further
with distributed actors.

345
00:15:44,544 --> 00:15:47,313
Distributed actors put those
islands on different machines

346
00:15:47,313 --> 00:15:49,248
with a network between them.

347
00:15:49,248 --> 00:15:52,185
This new language feature makes
developing distributed systems

348
00:15:52,185 --> 00:15:54,353
much simpler.

349
00:15:54,353 --> 00:15:56,589
Let's say you want
to create a game app;

350
00:15:56,589 --> 00:15:59,425
you can now easily write
the back end in Swift.

351
00:15:59,425 --> 00:16:02,395
Here, the distributed actor
is like an actor

352
00:16:02,395 --> 00:16:04,831
but it might be
on a different machine.

353
00:16:04,831 --> 00:16:07,500
In this example,
we're looking at computer player

354
00:16:07,500 --> 00:16:11,270
that will maintain state
during a game with a user.

355
00:16:11,270 --> 00:16:14,173
The distributed keyword can
also be added to a function

356
00:16:14,173 --> 00:16:15,842
that we expect
will need to be called

357
00:16:15,842 --> 00:16:19,579
on an actor that might be
on a remote machine.

358
00:16:19,579 --> 00:16:22,448
Let's add another function
called endOfRound.

359
00:16:22,448 --> 00:16:26,385
It will loop over the players
and call makeMove on each one.

360
00:16:26,385 --> 00:16:28,921
Some of these players
might be local or remote,

361
00:16:28,921 --> 00:16:30,022
but we have the benefit

362
00:16:30,022 --> 00:16:33,025
of not needing to care
about which is which.

363
00:16:33,025 --> 00:16:35,428
The only difference
from a regular actor call

364
00:16:35,428 --> 00:16:38,197
is that a distributed actor
call can potentially fail

365
00:16:38,197 --> 00:16:40,233
because of network errors.

366
00:16:40,233 --> 00:16:41,968
In the event
of a network failure,

367
00:16:41,968 --> 00:16:44,437
the actor method
would throw an error.

368
00:16:44,437 --> 00:16:46,272
So, you need to add
the try keyword

369
00:16:46,272 --> 00:16:49,108
as well as the usual
await keyword that's needed

370
00:16:49,108 --> 00:16:52,411
when you call a function
outside of the actor.

371
00:16:52,411 --> 00:16:54,413
Building on these core
language primitives,

372
00:16:54,413 --> 00:16:57,416
we also built an open source
Distributed Actors package

373
00:16:57,416 --> 00:16:59,752
that is focused on
building server-side,

374
00:16:59,752 --> 00:17:02,588
clustered distributed
systems in Swift.

375
00:17:02,588 --> 00:17:05,224
The package includes an
integrated networking layer

376
00:17:05,224 --> 00:17:09,195
using SwiftNIO and implements
the SWIM consensus protocol

377
00:17:09,195 --> 00:17:11,597
to manage state
across the cluster.

378
00:17:11,597 --> 00:17:13,633
The "Meet distributed actors
in Swift" session

379
00:17:13,633 --> 00:17:15,568
will go into more details
on how to build

380
00:17:15,568 --> 00:17:19,472
distributed systems
with these new features.

381
00:17:19,472 --> 00:17:23,075
We also launched a new set
of open source algorithms

382
00:17:23,075 --> 00:17:27,113
to provide easy out-of-the-box
solutions to common operations

383
00:17:27,113 --> 00:17:29,515
when dealing with AsyncSequence,

384
00:17:29,515 --> 00:17:32,151
which was released
with Swift 5.5.

385
00:17:32,151 --> 00:17:34,153
Releasing these APIs
as a package

386
00:17:34,153 --> 00:17:37,556
gives developers flexibility
in deploying across platforms

387
00:17:37,556 --> 00:17:40,760
and operating system versions.

388
00:17:40,760 --> 00:17:44,630
There are several ways to
combine multiple async sequences

389
00:17:44,630 --> 00:17:47,366
and to group values
into collections.

390
00:17:47,366 --> 00:17:49,035
These are just some
of the algorithms

391
00:17:49,035 --> 00:17:51,070
included in the package.

392
00:17:51,070 --> 00:17:53,940
Check out the "Meet Swift
Async Algorithms" talk

393
00:17:53,940 --> 00:17:58,110
to see how you can use
this new powerful API.

394
00:17:58,110 --> 00:18:00,646
But there's another aspect
of concurrency,

395
00:18:00,646 --> 00:18:02,515
which is performance.

396
00:18:02,515 --> 00:18:04,817
This year,
with actor prioritization,

397
00:18:04,817 --> 00:18:08,654
actors now execute
the highest-priority work first.

398
00:18:08,654 --> 00:18:10,456
And continuing
our deep integration

399
00:18:10,456 --> 00:18:12,291
with the operating system
scheduler,

400
00:18:12,291 --> 00:18:15,428
the model has priority-inversion
prevention built in,

401
00:18:15,428 --> 00:18:20,299
so less important work can't
block higher-priority work.

402
00:18:20,299 --> 00:18:23,069
Historically, it has been
really hard to visualize

403
00:18:23,069 --> 00:18:26,072
the performance impact
of concurrency in your app.

404
00:18:26,072 --> 00:18:31,410
But now, we have a great
new tool for doing exactly that.

405
00:18:31,410 --> 00:18:34,080
The new Swift Concurrency view
in Instruments

406
00:18:34,080 --> 00:18:36,716
can help you investigate
performance issues.

407
00:18:36,716 --> 00:18:39,552
The Swift Tasks
and Swift Actors instruments

408
00:18:39,552 --> 00:18:42,688
provide a full suite of tools
to help you visualize

409
00:18:42,688 --> 00:18:46,158
and optimize
your concurrency code.

410
00:18:46,158 --> 00:18:49,095
At the top level,
the Swift Tasks Instrument

411
00:18:49,095 --> 00:18:52,131
provides useful statistics,
including the number of tasks

412
00:18:52,131 --> 00:18:54,834
running simultaneously
and the total tasks

413
00:18:54,834 --> 00:18:58,004
that have been created
up until that point in time.

414
00:18:58,004 --> 00:18:59,872
In the bottom half
of this window,

415
00:18:59,872 --> 00:19:03,776
you can see what's referred to
as a Task Forest.

416
00:19:03,776 --> 00:19:06,212
It provides a graphical
representation

417
00:19:06,212 --> 00:19:07,980
of the parent-child
relationships

418
00:19:07,980 --> 00:19:11,550
between tasks
in structured concurrent code.

419
00:19:11,550 --> 00:19:13,519
This is just one
of the detailed views

420
00:19:13,519 --> 00:19:16,989
for the Swift Actor
Instrument.

421
00:19:16,989 --> 00:19:19,492
To learn how to use
this exciting new tool,

422
00:19:19,492 --> 00:19:20,960
you'll want to hop over
to the talk

423
00:19:20,960 --> 00:19:24,196
"Visualize and optimize
Swift concurrency."

424
00:19:24,196 --> 00:19:26,866
And don't forget to give
those new packages a try.

425
00:19:26,866 --> 00:19:29,702
Don't be shy to let us know
how it's going on the forums.

426
00:19:29,702 --> 00:19:32,004
Now, I'll hand it over
to Becca to talk about

427
00:19:32,004 --> 00:19:36,142
the many improvements
to Swift language usability.

428
00:19:36,142 --> 00:19:38,411
Languages are tools,
and there's a funny thing

429
00:19:38,411 --> 00:19:40,546
about tools --
they can really affect

430
00:19:40,546 --> 00:19:42,848
the things you build
with them.

431
00:19:42,848 --> 00:19:44,950
When all you have
is a hammer,

432
00:19:44,950 --> 00:19:48,120
you're going to build things
with nails instead of screws.

433
00:19:48,120 --> 00:19:50,856
And even if you have
a full set of tools,

434
00:19:50,856 --> 00:19:52,658
if your hammer has
a big, grippy handle

435
00:19:52,658 --> 00:19:55,661
while your screwdriver
is plasticky and hard to hold,

436
00:19:55,661 --> 00:19:58,097
you might still lean
towards the nails.

437
00:19:58,097 --> 00:19:59,999
A language is the same way.

438
00:19:59,999 --> 00:20:02,501
If Swift has a good tool
for expressing something,

439
00:20:02,501 --> 00:20:05,204
people will use
it more often.

440
00:20:05,204 --> 00:20:07,540
And this year, Swift's tools
for expressing what you want

441
00:20:07,540 --> 00:20:11,510
your code to do
have improved in many ways.

442
00:20:11,510 --> 00:20:13,579
Some of these changes
are simple conveniences

443
00:20:13,579 --> 00:20:15,414
for things you do often.

444
00:20:15,414 --> 00:20:18,784
For example, it's really common
in Swift to use if let

445
00:20:18,784 --> 00:20:22,154
with the same name on both
sides of the equal sign.

446
00:20:22,154 --> 00:20:24,090
After all, there probably
isn't a better name

447
00:20:24,090 --> 00:20:25,591
for the unwrapped value

448
00:20:25,591 --> 00:20:28,561
than the name you gave
the optional one.

449
00:20:28,561 --> 00:20:30,096
But when the name
is really long,

450
00:20:30,096 --> 00:20:33,099
that repetition starts
to get cumbersome.

451
00:20:33,099 --> 00:20:35,734
You might be tempted
to abbreviate the name,

452
00:20:35,734 --> 00:20:39,105
but then your code
becomes kind of cryptic.

453
00:20:39,105 --> 00:20:41,373
And if you later rename
the optional variable,

454
00:20:41,373 --> 00:20:45,244
the abbreviation
might get out of sync.

455
00:20:45,244 --> 00:20:47,780
Swift 5.7 introduces
a new shorthand

456
00:20:47,780 --> 00:20:49,648
for this common pattern.

457
00:20:49,648 --> 00:20:51,016
If you're unwrapping
an optional

458
00:20:51,016 --> 00:20:53,519
and want the unwrapped value
to have the same name,

459
00:20:53,519 --> 00:20:55,788
just drop
the right-hand side.

460
00:20:55,788 --> 00:20:58,491
Swift will assume
it's the same.

461
00:20:58,491 --> 00:21:00,759
And of course, this also
works with guard, too,

462
00:21:00,759 --> 00:21:04,029
and even while,
for that matter.

463
00:21:04,029 --> 00:21:06,832
We also looked at places where
a feature suddenly stops working

464
00:21:06,832 --> 00:21:09,201
when you make
a minor change.

465
00:21:09,201 --> 00:21:11,370
For instance, Swift has always
been able to figure out

466
00:21:11,370 --> 00:21:13,939
what type a call will return
based on the code

467
00:21:13,939 --> 00:21:16,542
written inside
a one-statement closure.

468
00:21:16,542 --> 00:21:19,512
In this compactMap call,
the closure returns the value

469
00:21:19,512 --> 00:21:22,448
of parseLine,
and the parseLine function

470
00:21:22,448 --> 00:21:25,351
returns a MailmapEntry,
so Swift can figure out

471
00:21:25,351 --> 00:21:30,189
that entries should be
an array of MailmapEntry.

472
00:21:30,189 --> 00:21:32,158
This now works for more
complicated closures

473
00:21:32,158 --> 00:21:35,361
that have multiple statements
or control flow features.

474
00:21:35,361 --> 00:21:37,596
So you can use do-catch,
or if...else,

475
00:21:37,596 --> 00:21:39,798
or just add a print call,
without having

476
00:21:39,798 --> 00:21:43,302
to manually specify
the closure's result type.

477
00:21:43,302 --> 00:21:45,971
Another thing
we looked at is danger flags

478
00:21:45,971 --> 00:21:49,575
that aren't really flagging
any actual danger.

479
00:21:49,575 --> 00:21:52,912
Swift is very concerned
with type and memory safety.

480
00:21:52,912 --> 00:21:54,446
To keep you
from making mistakes,

481
00:21:54,446 --> 00:21:56,015
it never
automatically converts

482
00:21:56,015 --> 00:21:58,317
between pointers
with different pointer types,

483
00:21:58,317 --> 00:22:01,320
nor between raw pointers
and typed pointers.

484
00:22:01,320 --> 00:22:02,922
This is very
different from C,

485
00:22:02,922 --> 00:22:05,257
which allows
certain conversions.

486
00:22:05,257 --> 00:22:07,993
For example, you can change
the signed-ness of the pointee,

487
00:22:07,993 --> 00:22:11,730
or cast any pointer to char star
to access it as bytes,

488
00:22:11,730 --> 00:22:15,401
without violating any
of C's pointer rules.

489
00:22:15,401 --> 00:22:17,770
But sometimes these differences
in pointer behavior

490
00:22:17,770 --> 00:22:22,041
will cause problems when
a C API is imported into Swift.

491
00:22:22,041 --> 00:22:24,176
The original developer may
have designed their APIs

492
00:22:24,176 --> 00:22:26,078
with slight mismatches
that are handled

493
00:22:26,078 --> 00:22:30,783
by automatic conversions in C
but are errors in Swift.

494
00:22:30,783 --> 00:22:33,118
In Swift, accessing
a pointer of one type

495
00:22:33,118 --> 00:22:35,988
as though it were a different
type is very dangerous,

496
00:22:35,988 --> 00:22:39,391
so you have to describe what
you're doing very explicitly.

497
00:22:39,391 --> 00:22:41,160
But that's all pointless
if we're passing the pointer

498
00:22:41,160 --> 00:22:43,829
directly to C,
because in C,

499
00:22:43,829 --> 00:22:47,499
that pointer mismatch
is perfectly legal!

500
00:22:47,499 --> 00:22:50,169
So in this case, we've treated
something really straightforward

501
00:22:50,169 --> 00:22:52,638
as though it were dangerous.

502
00:22:52,638 --> 00:22:55,975
This matters because, as much as
Swift values type safety,

503
00:22:55,975 --> 00:23:00,045
it also values easy access
to C-family code.

504
00:23:00,045 --> 00:23:01,814
That's why C
and Objective-C interop

505
00:23:01,814 --> 00:23:05,084
are so rich and seamless,
and it's why the Swift project

506
00:23:05,084 --> 00:23:08,254
formed the C++ working group
Angela mentioned earlier

507
00:23:08,254 --> 00:23:11,590
to start building equally
capable C++ interop.

508
00:23:11,590 --> 00:23:13,459
We don't want
using C functions like these

509
00:23:13,459 --> 00:23:16,762
to be unnecessarily painful.

510
00:23:16,762 --> 00:23:18,564
So Swift now has
a separate set of rules

511
00:23:18,564 --> 00:23:21,433
for calls to imported
functions and methods.

512
00:23:21,433 --> 00:23:24,169
It allows pointer conversions
that would be legal in C

513
00:23:24,169 --> 00:23:26,972
even though they normally
aren't in Swift.

514
00:23:26,972 --> 00:23:31,510
That way, your Swift code
can use these APIs seamlessly.

515
00:23:31,510 --> 00:23:33,746
So far we've talked
about small improvements

516
00:23:33,746 --> 00:23:35,414
to the tools
you already had.

517
00:23:35,414 --> 00:23:38,150
But this year, Swift also
has a brand-new tool

518
00:23:38,150 --> 00:23:41,587
for extracting information
from strings.

519
00:23:41,587 --> 00:23:43,389
Here's a function
that parses some information

520
00:23:43,389 --> 00:23:45,090
out of a string.

521
00:23:45,090 --> 00:23:46,592
This sort of task
has always been

522
00:23:46,592 --> 00:23:48,794
a bit of a challenge
in Swift.

523
00:23:48,794 --> 00:23:51,797
You end up searching, splitting,
and slicing over and over

524
00:23:51,797 --> 00:23:54,767
until you get what you want.

525
00:23:54,767 --> 00:23:56,568
When people notice this,
they tend to focus

526
00:23:56,568 --> 00:23:58,704
on the little things,
like how wordy it can be

527
00:23:58,704 --> 00:24:00,739
to manipulate
string indices,

528
00:24:00,739 --> 00:24:03,876
but I think that's kind of
missing the bigger picture.

529
00:24:03,876 --> 00:24:06,745
Because even if we changed
this syntax,

530
00:24:06,745 --> 00:24:09,181
it doesn't help you answer
the basic question you're asking

531
00:24:09,181 --> 00:24:12,384
when you look at this code --
what does the line variable

532
00:24:12,384 --> 00:24:15,387
that's passed into it
actually look like?

533
00:24:15,387 --> 00:24:18,457
What sort of string is it
trying to take apart?

534
00:24:18,457 --> 00:24:20,659
If you stare at it long
enough, you might realize

535
00:24:20,659 --> 00:24:23,529
that it's parsing a simplified
version of a mailmap --

536
00:24:23,529 --> 00:24:25,731
a file you put
in a git repository

537
00:24:25,731 --> 00:24:29,068
to correct a developer's
name in old commits.

538
00:24:29,068 --> 00:24:31,837
But extracting that information
by searching and slicing

539
00:24:31,837 --> 00:24:35,841
is so involved that it's
hard to figure that out.

540
00:24:35,841 --> 00:24:38,344
You get so lost in how
to slice up the string

541
00:24:38,344 --> 00:24:42,314
that you kind of lose track
of what that string is.

542
00:24:42,314 --> 00:24:45,951
The problem is not
these two expressions;

543
00:24:45,951 --> 00:24:48,354
the problem is
the whole thing.

544
00:24:48,354 --> 00:24:49,888
We need to rip
out all of this

545
00:24:49,888 --> 00:24:52,091
and replace it
with something better.

546
00:24:52,091 --> 00:24:54,493
We need a
different approach;

547
00:24:54,493 --> 00:24:56,962
one where your code
sort of draws a picture

548
00:24:56,962 --> 00:24:58,831
of the string you want
to match,

549
00:24:58,831 --> 00:25:01,600
and the language figures
out how to do it.

550
00:25:01,600 --> 00:25:05,771
A declarative approach,
not an imperative one.

551
00:25:05,771 --> 00:25:10,809
In Swift 5.7, you can now
do that by writing a regex.

552
00:25:10,809 --> 00:25:14,213
A regex is a way to describe
a pattern in a string.

553
00:25:14,213 --> 00:25:16,715
For over 50 years,
languages and tools

554
00:25:16,715 --> 00:25:18,617
have allowed developers
to write regexes

555
00:25:18,617 --> 00:25:21,587
in a dense,
information-packed syntax.

556
00:25:21,587 --> 00:25:24,490
Some of you already use them
in the Xcode find bar,

557
00:25:24,490 --> 00:25:26,425
in command-line tools
like grep,

558
00:25:26,425 --> 00:25:29,094
in Foundation's
NSRegularExpression class,

559
00:25:29,094 --> 00:25:31,463
or in other
programming languages.

560
00:25:31,463 --> 00:25:34,500
That syntax is now supported
by Swift's regex literals,

561
00:25:34,500 --> 00:25:37,970
and it works just like it does
in any other developer tool.

562
00:25:37,970 --> 00:25:40,172
But some of you haven't
used regexes before

563
00:25:40,172 --> 00:25:42,841
and you're probably going,
"Is that real code

564
00:25:42,841 --> 00:25:46,278
or did a cat walk
across her keyboard?"

565
00:25:46,278 --> 00:25:47,946
And I don't blame you.

566
00:25:47,946 --> 00:25:50,449
Regex literals are written
in symbols and mnemonics

567
00:25:50,449 --> 00:25:53,719
that you have to memorize
in order to read them.

568
00:25:53,719 --> 00:25:55,187
To someone who knows
the language,

569
00:25:55,187 --> 00:25:56,822
even the gnarliest parts
of this regex,

570
00:25:56,822 --> 00:25:59,258
like the part that matches
the developer's name

571
00:25:59,258 --> 00:26:02,761
are just combinations of
several simple matching rules.

572
00:26:02,761 --> 00:26:06,765
But that's a lot of behavior
to cram into 11 characters.

573
00:26:06,765 --> 00:26:10,202
Regex literals are so compact
that even experienced developers

574
00:26:10,202 --> 00:26:13,405
sometimes need a minute to
understand a complicated one.

575
00:26:13,405 --> 00:26:15,808
But what if you could write
the same kind of matching rules,

576
00:26:15,808 --> 00:26:18,944
just with words
instead of symbols?

577
00:26:18,944 --> 00:26:21,914
That seems like it'd be
easier to understand.

578
00:26:21,914 --> 00:26:23,148
In fact, put it
all together,

579
00:26:23,148 --> 00:26:26,885
and you get something
that looks a lot like SwiftUI.

580
00:26:26,885 --> 00:26:30,289
That'd be a great alternative
to a regex literal, wouldn't it?

581
00:26:30,289 --> 00:26:33,459
So it's a good thing
Swift supports that!

582
00:26:33,459 --> 00:26:35,327
The RegexBuilder library
provides a whole new

583
00:26:35,327 --> 00:26:39,064
SwiftUI-style language
for regexes that's easier to use

584
00:26:39,064 --> 00:26:42,234
and more readable
than the traditional syntax.

585
00:26:42,234 --> 00:26:44,670
It can do the same things
a regex literal can,

586
00:26:44,670 --> 00:26:47,339
but it describes its behavior
in words you can understand

587
00:26:47,339 --> 00:26:50,175
or look up, instead of
symbols and abbreviations

588
00:26:50,175 --> 00:26:52,277
you have to memorize.

589
00:26:52,277 --> 00:26:54,413
Regex builders
are great for beginners,

590
00:26:54,413 --> 00:26:57,149
but this is far from
a beginner-only feature.

591
00:26:57,149 --> 00:26:59,251
It has powerful capabilities
that go way beyond

592
00:26:59,251 --> 00:27:01,620
what a regex literal can do.

593
00:27:01,620 --> 00:27:03,455
To start with,
you can turn a regex

594
00:27:03,455 --> 00:27:05,991
into a reusable regex
component,

595
00:27:05,991 --> 00:27:08,494
just as you can turn
a SwiftUI view hierarchy

596
00:27:08,494 --> 00:27:10,596
into a view.

597
00:27:10,596 --> 00:27:12,831
You can use these components
from other regexes

598
00:27:12,831 --> 00:27:14,766
created with
the builder syntax,

599
00:27:14,766 --> 00:27:17,402
and you can even
make them recursive.

600
00:27:17,402 --> 00:27:19,738
Regex builders also support
dropping some Swift types

601
00:27:19,738 --> 00:27:22,140
directly into a regex.

602
00:27:22,140 --> 00:27:24,109
For example,
string literals just match

603
00:27:24,109 --> 00:27:28,547
the exact text inside them --
no special escaping needed.

604
00:27:28,547 --> 00:27:30,215
You can also use
regex literals

605
00:27:30,215 --> 00:27:32,351
in the middle
of a regex builder.

606
00:27:32,351 --> 00:27:34,386
So you can strike a balance
between the clarity

607
00:27:34,386 --> 00:27:38,557
of a regex builder and the
conciseness of a regex literal.

608
00:27:38,557 --> 00:27:41,660
And other types -- like this
Foundation date-format style --

609
00:27:41,660 --> 00:27:44,530
can integrate custom parsing
logic with regex builders,

610
00:27:44,530 --> 00:27:48,700
and even convert the data to a
richer type before capturing it.

611
00:27:48,700 --> 00:27:50,836
Finally, no matter
which syntax you use,

612
00:27:50,836 --> 00:27:54,139
regexes support a bunch
of useful matching methods

613
00:27:54,139 --> 00:27:58,210
and strongly typed captures
that are easy to use.

614
00:27:58,210 --> 00:28:00,112
Now, for the regex nerds
who have been squirming

615
00:28:00,112 --> 00:28:02,381
in their seats,

616
00:28:02,381 --> 00:28:05,217
Swift Regex uses a brand-new
open source matching engine,

617
00:28:05,217 --> 00:28:06,351
with a feature
set comparable

618
00:28:06,351 --> 00:28:09,621
to the most advanced
regex implementations.

619
00:28:09,621 --> 00:28:13,191
The literal syntax is compatible
with the Unicode regex standard,

620
00:28:13,191 --> 00:28:16,261
and it has an uncommon level
of Unicode correctness.

621
00:28:16,261 --> 00:28:19,164
For instance, dot matches
a whole character by default,

622
00:28:19,164 --> 00:28:22,968
not a Unicode.Scalar
or a UTF-8 byte.

623
00:28:22,968 --> 00:28:25,170
To use Swift Regex, your app
will need to be running

624
00:28:25,170 --> 00:28:28,006
on an OS with the Swift
Regex engine built into it,

625
00:28:28,006 --> 00:28:32,210
like macOS 13 or iOS 16.

626
00:28:32,210 --> 00:28:34,513
Swift Regex is
an entire language --

627
00:28:34,513 --> 00:28:36,415
well, two languages, really --

628
00:28:36,415 --> 00:28:38,817
so there's much more
to say about it.

629
00:28:38,817 --> 00:28:40,786
These two sessions --
"Meet Swift Regex"

630
00:28:40,786 --> 00:28:43,155
and "Swift Regex:
Beyond The Basics" --

631
00:28:43,155 --> 00:28:46,792
will give you lots
more details about using it.

632
00:28:46,792 --> 00:28:48,026
Finally, there's one place

633
00:28:48,026 --> 00:28:50,462
where we took a comprehensive
look at the tools we have

634
00:28:50,462 --> 00:28:53,198
and made a bunch of changes
to improve them.

635
00:28:53,198 --> 00:28:56,268
That's in generics
and protocols.

636
00:28:56,268 --> 00:28:58,103
To show you how these tools
have improved,

637
00:28:58,103 --> 00:29:00,472
I'll need an
example protocol.

638
00:29:00,472 --> 00:29:02,207
Let's say you're writing
a git client

639
00:29:02,207 --> 00:29:05,844
and you have to represent
mailmaps in two different ways.

640
00:29:05,844 --> 00:29:08,947
When you're displaying commits,
you use a type with a dictionary

641
00:29:08,947 --> 00:29:11,583
to quickly look up names.

642
00:29:11,583 --> 00:29:13,952
But when you're letting
users edit the mailmap,

643
00:29:13,952 --> 00:29:16,154
you use a type with an array
to keep the entries

644
00:29:16,154 --> 00:29:18,857
in their original order.

645
00:29:18,857 --> 00:29:20,626
And you have a protocol
called Mailmap

646
00:29:20,626 --> 00:29:22,327
that both of
them conform to,

647
00:29:22,327 --> 00:29:26,698
so your mailmap parser can
add entries to either type.

648
00:29:26,698 --> 00:29:28,500
But there are two ways
the parser could use

649
00:29:28,500 --> 00:29:30,702
the Mailmap protocol.

650
00:29:30,702 --> 00:29:31,937
I've written two
different versions

651
00:29:31,937 --> 00:29:34,573
of this addEntries function
to illustrate them,

652
00:29:34,573 --> 00:29:36,174
but it's actually
kind of hard to explain

653
00:29:36,174 --> 00:29:37,476
how they're different,

654
00:29:37,476 --> 00:29:41,613
because Swift is using the same
syntax for two different things.

655
00:29:41,613 --> 00:29:45,350
It turns out that the word
"Mailmap" means one thing here

656
00:29:45,350 --> 00:29:47,753
but it means something
subtly different here.

657
00:29:50,288 --> 00:29:53,058
When you name a protocol
in an inheritance list,

658
00:29:53,058 --> 00:29:56,461
generic parameter list,
generic conformance constraint,

659
00:29:56,461 --> 00:29:58,196
or an opaque result type,

660
00:29:58,196 --> 00:30:01,900
it means "an instance that
conforms to this protocol."

661
00:30:01,900 --> 00:30:04,369
But in a variable type,
a generic argument,

662
00:30:04,369 --> 00:30:06,371
a generic same-type constraint,

663
00:30:06,371 --> 00:30:08,707
or a function parameter
or result type,

664
00:30:08,707 --> 00:30:10,976
it actually means
"a box which contains

665
00:30:10,976 --> 00:30:14,613
an instance that conforms
to this protocol."

666
00:30:14,613 --> 00:30:16,415
This distinction is important
because the box

667
00:30:16,415 --> 00:30:20,252
typically uses more space,
takes more time to operate on,

668
00:30:20,252 --> 00:30:22,020
and doesn't have all
of the capabilities

669
00:30:22,020 --> 00:30:24,389
of the instance inside it.

670
00:30:24,389 --> 00:30:25,991
But the places where
you're using a box

671
00:30:25,991 --> 00:30:28,360
look just like the places
where you aren't,

672
00:30:28,360 --> 00:30:31,163
so it's hard to figure out
if you're using one.

673
00:30:31,163 --> 00:30:34,800
Swift 5.7 fixes
this oversight.

674
00:30:34,800 --> 00:30:36,368
When you're using one
of these boxes

675
00:30:36,368 --> 00:30:38,236
containing
a conforming type,

676
00:30:38,236 --> 00:30:41,973
Swift will now expect you
to write the any keyword.

677
00:30:41,973 --> 00:30:45,877
This is not mandatory in code
that was valid before Swift 5.7,

678
00:30:45,877 --> 00:30:47,946
but it is encouraged
and you will see it

679
00:30:47,946 --> 00:30:50,716
in generated interfaces
and error messages,

680
00:30:50,716 --> 00:30:53,618
even if you don't
write it out explicitly.

681
00:30:53,618 --> 00:30:55,620
So the preferred way
to write all of those things

682
00:30:55,620 --> 00:30:58,824
in the right-hand column
is with the any keyword.

683
00:30:58,824 --> 00:31:00,759
If you do that,
you'll be able to tell

684
00:31:00,759 --> 00:31:03,562
when you're using
one of these boxes.

685
00:31:03,562 --> 00:31:05,330
Now that the any keyword
marks one of the parameters

686
00:31:05,330 --> 00:31:07,833
in this example,
it's a lot easier to explain

687
00:31:07,833 --> 00:31:10,335
the difference between
these two functions.

688
00:31:10,335 --> 00:31:14,072
addEntries1 takes the
Mailmap as a generic type;

689
00:31:14,072 --> 00:31:17,275
addEntries2
takes it as an any type.

690
00:31:17,275 --> 00:31:18,877
And it's also easier
for error messages

691
00:31:18,877 --> 00:31:20,378
to explain what's happening

692
00:31:20,378 --> 00:31:23,448
when you hit one of
the limitations of any types.

693
00:31:23,448 --> 00:31:26,451
For instance, this mergeMailmaps
function tries to pass

694
00:31:26,451 --> 00:31:30,388
an any Mailmap to a generic
Mailmap parameter.

695
00:31:30,388 --> 00:31:31,590
This used to
produce an error

696
00:31:31,590 --> 00:31:34,493
saying that Mailmap
cannot conform to itself,

697
00:31:34,493 --> 00:31:37,763
which always seemed
kind of paradoxical.

698
00:31:37,763 --> 00:31:39,998
But now that we have
the concept of any types,

699
00:31:39,998 --> 00:31:42,801
we can explain what's happening
more clearly.

700
00:31:42,801 --> 00:31:44,870
The problem is
that any Mailmap --

701
00:31:44,870 --> 00:31:47,105
the box containing a mailmap --

702
00:31:47,105 --> 00:31:49,941
doesn't conform
to the Mailmap protocol.

703
00:31:49,941 --> 00:31:51,743
But the box is what
you're trying to pass,

704
00:31:51,743 --> 00:31:55,013
and it doesn't fit
into the generic parameter.

705
00:31:55,013 --> 00:31:57,549
If you want to pass the instance
inside the box here,

706
00:31:57,549 --> 00:32:00,652
you'd have to somehow
open up the box,

707
00:32:00,652 --> 00:32:04,489
take out the mailmap inside
it, and pass that instead.

708
00:32:04,489 --> 00:32:08,460
But actually,
in simple cases like this one,

709
00:32:08,460 --> 00:32:10,629
Swift will now
just do that for you.

710
00:32:10,629 --> 00:32:13,465
Open up the box,
take out the instance inside it,

711
00:32:13,465 --> 00:32:16,101
and pass it
to the generic parameter.

712
00:32:16,101 --> 00:32:17,702
So you won't be seeing
this error message

713
00:32:17,702 --> 00:32:19,638
nearly as much anymore.

714
00:32:19,638 --> 00:32:21,273
But there's an even more
exciting improvement

715
00:32:21,273 --> 00:32:23,875
to any types than that one.

716
00:32:23,875 --> 00:32:26,878
Previously, a protocol could
not be used as an any type

717
00:32:26,878 --> 00:32:30,782
if it either used the self
type or had associated types,

718
00:32:30,782 --> 00:32:32,918
or even just conformed
to a protocol that did,

719
00:32:32,918 --> 00:32:34,886
like Equatable.

720
00:32:34,886 --> 00:32:38,490
But in Swift 5.7,
this error is just --

721
00:32:38,490 --> 00:32:39,791
poof --

722
00:32:39,791 --> 00:32:42,494
gone.

723
00:32:42,494 --> 00:32:44,296
A lot of developers
have struggled with this one,

724
00:32:44,296 --> 00:32:47,499
so we're thrilled to have
fixed it at the source.

725
00:32:47,499 --> 00:32:50,368
Now, that's exciting enough
just for protocols like Mailmap,

726
00:32:50,368 --> 00:32:52,571
but this goes even further.

727
00:32:52,571 --> 00:32:55,640
Because even very sophisticated
protocols, like Collection,

728
00:32:55,640 --> 00:32:58,276
can be used as any types.

729
00:32:58,276 --> 00:33:00,245
You can even specify
the element type,

730
00:33:00,245 --> 00:33:04,249
thanks to a new feature called
"primary associated types."

731
00:33:04,249 --> 00:33:05,417
A lot of associated types

732
00:33:05,417 --> 00:33:08,720
are basically just
implementation details.

733
00:33:08,720 --> 00:33:11,056
You usually don't care
which type a collection uses

734
00:33:11,056 --> 00:33:13,925
for its index, iterator,
or subsequence;

735
00:33:13,925 --> 00:33:16,895
you just need to use
the type it supports.

736
00:33:16,895 --> 00:33:20,065
But its Element
is a different story.

737
00:33:20,065 --> 00:33:21,933
You might not always care
exactly which Element type

738
00:33:21,933 --> 00:33:23,802
a collection uses,
but you're probably

739
00:33:23,802 --> 00:33:25,770
going to do something
with the elements,

740
00:33:25,770 --> 00:33:29,875
so you'll need to constrain them
or return them or something.

741
00:33:29,875 --> 00:33:32,010
When you have an associated
type like Element

742
00:33:32,010 --> 00:33:35,247
that nearly every user
of a protocol will care about,

743
00:33:35,247 --> 00:33:37,015
you can put its name
after the protocol's name

744
00:33:37,015 --> 00:33:41,253
in angle brackets to make it
a primary associated type.

745
00:33:41,253 --> 00:33:43,722
Once you do that, you can
constrain the protocol's

746
00:33:43,722 --> 00:33:46,658
primary associated types
with the angle bracket syntax

747
00:33:46,658 --> 00:33:49,594
pretty much anywhere you can
write the protocol's name,

748
00:33:49,594 --> 00:33:52,163
including in any Collection.

749
00:33:52,163 --> 00:33:54,900
Now, some of you might be
looking at this type and going,

750
00:33:54,900 --> 00:33:57,269
"Wait a minute.

751
00:33:57,269 --> 00:33:59,638
Isn't there already something
called AnyCollection,

752
00:33:59,638 --> 00:34:03,842
just run together
and with the 'any' capitalized?"

753
00:34:03,842 --> 00:34:06,378
And you're right, there is!

754
00:34:06,378 --> 00:34:09,648
The old AnyCollection
is a type-erasing wrapper --

755
00:34:09,648 --> 00:34:12,083
a handwritten struct which
serves the same purpose

756
00:34:12,083 --> 00:34:13,885
as an any type.

757
00:34:13,885 --> 00:34:15,887
The difference is that
the AnyCollection struct

758
00:34:15,887 --> 00:34:18,990
is just line after line of
the most boring boilerplate code

759
00:34:18,990 --> 00:34:22,627
you've ever seen in your
life; whereas the any type

760
00:34:22,627 --> 00:34:24,129
is a built-in
language feature

761
00:34:24,129 --> 00:34:26,064
that does basically
the same thing --

762
00:34:26,064 --> 00:34:27,599
for free!

763
00:34:27,599 --> 00:34:29,434
Now, the AnyCollection
struct will stick around

764
00:34:29,434 --> 00:34:31,336
for backwards compatibility
and because it has

765
00:34:31,336 --> 00:34:34,873
a couple of features that any
types can't quite match yet.

766
00:34:34,873 --> 00:34:36,775
But if you have your own
type-erasing wrappers

767
00:34:36,775 --> 00:34:40,045
in your code, you might want to
see if you can reimplement them

768
00:34:40,045 --> 00:34:44,282
using built-in any types instead
of box classes or closures.

769
00:34:44,282 --> 00:34:47,919
Or maybe even just replace
them with type aliases.

770
00:34:47,919 --> 00:34:51,456
So Swift has dramatically
improved any types.

771
00:34:51,456 --> 00:34:52,991
It's introduced
the any keyword

772
00:34:52,991 --> 00:34:55,593
so you can see
where you're using them.

773
00:34:55,593 --> 00:34:58,863
It allows you to pass them
to generic arguments.

774
00:34:58,863 --> 00:35:01,099
It's abolished the restriction
that kept many protocols

775
00:35:01,099 --> 00:35:03,501
from being used with them.

776
00:35:03,501 --> 00:35:04,602
And it even lets
you constrain

777
00:35:04,602 --> 00:35:08,440
an any type's primary
associated types.

778
00:35:08,440 --> 00:35:10,508
But even with all
of those improvements,

779
00:35:10,508 --> 00:35:13,478
any types still
have limitations.

780
00:35:13,478 --> 00:35:16,514
For example, even though
you can now use any Mailmaps

781
00:35:16,514 --> 00:35:18,850
when Mailmap conforms
to Equatable,

782
00:35:18,850 --> 00:35:21,619
you still can't use the
equals operator with them,

783
00:35:21,619 --> 00:35:24,255
because the equals operator
requires both mailmaps

784
00:35:24,255 --> 00:35:27,459
to have the same concrete type,
but that's not guaranteed

785
00:35:27,459 --> 00:35:30,028
when you're using
two any Mailmaps.

786
00:35:30,028 --> 00:35:32,597
So even though Swift has
improved any types a lot,

787
00:35:32,597 --> 00:35:34,733
they still have
important limitations,

788
00:35:34,733 --> 00:35:37,969
in both capabilities
and performance.

789
00:35:37,969 --> 00:35:41,006
And that's why a lot of the
time, you shouldn't use them --

790
00:35:41,006 --> 00:35:43,375
you should use
generics instead.

791
00:35:43,375 --> 00:35:46,011
So let's go back to the
two versions of addEntries

792
00:35:46,011 --> 00:35:48,013
and apply that wisdom.

793
00:35:48,013 --> 00:35:50,648
Both versions do exactly
the same thing,

794
00:35:50,648 --> 00:35:53,284
but the one on the top
uses generic types,

795
00:35:53,284 --> 00:35:56,755
and the one on the bottom
uses any types.

796
00:35:56,755 --> 00:35:59,157
The generic version
will likely be more efficient

797
00:35:59,157 --> 00:36:02,827
and more capable,
so you ought to use that one.

798
00:36:02,827 --> 00:36:05,597
And yet, you're probably
tempted to use any types,

799
00:36:05,597 --> 00:36:08,733
because they're just so much
easier to read and write.

800
00:36:08,733 --> 00:36:10,001
To write the generic version,

801
00:36:10,001 --> 00:36:12,437
you need to declare
two generic type names,

802
00:36:12,437 --> 00:36:14,639
constrain them both,
and finally,

803
00:36:14,639 --> 00:36:18,743
use those generic type names
as the types of the parameters.

804
00:36:18,743 --> 00:36:21,479
That's just exhausting compared
to writing "any Collection"

805
00:36:21,479 --> 00:36:23,415
and "any Mailmap."

806
00:36:23,415 --> 00:36:27,385
So you'd be tempted to use any
types despite their drawbacks.

807
00:36:27,385 --> 00:36:30,188
But that's the same thing
I was talking about earlier --

808
00:36:30,188 --> 00:36:32,190
using your hammer
instead of your screwdriver

809
00:36:32,190 --> 00:36:34,726
because the hammer
has a big, grippy handle.

810
00:36:34,726 --> 00:36:37,262
You shouldn't have
to make that choice.

811
00:36:37,262 --> 00:36:40,098
So Swift is making generics
just as easy to use

812
00:36:40,098 --> 00:36:42,167
as any types.

813
00:36:42,167 --> 00:36:44,936
If a generic parameter
is only used in one place,

814
00:36:44,936 --> 00:36:48,440
you can now write it with
the some keyword as a shorthand.

815
00:36:48,440 --> 00:36:50,842
And it even supports
primary associated types,

816
00:36:50,842 --> 00:36:53,178
so you can accept all
collections of mailmap entries

817
00:36:53,178 --> 00:36:55,847
with code that's a lot
easier to understand.

818
00:36:55,847 --> 00:36:57,215
With that in your toolbox,

819
00:36:57,215 --> 00:37:00,351
there's no reason
to avoid generics anymore.

820
00:37:00,351 --> 00:37:02,887
If you have a choice between
generics and any types,

821
00:37:02,887 --> 00:37:05,190
generics will be
just as easy to use --

822
00:37:05,190 --> 00:37:07,992
just write "some"
instead of "any".

823
00:37:07,992 --> 00:37:11,196
So you might as well use
the best tool for the job.

824
00:37:11,196 --> 00:37:13,164
I've only scratched
the surface of these changes

825
00:37:13,164 --> 00:37:15,066
to protocols and generics.

826
00:37:15,066 --> 00:37:17,168
For an in-depth look,
as well as a great review

827
00:37:17,168 --> 00:37:19,104
of all of Swift's
generics features,

828
00:37:19,104 --> 00:37:21,339
we have two more talks
for you this year:

829
00:37:21,339 --> 00:37:23,007
"Embrace Swift generics,"

830
00:37:23,007 --> 00:37:25,343
and "Design protocol
interfaces in Swift."

831
00:37:28,179 --> 00:37:29,547
Now, Angela and I
have talked about

832
00:37:29,547 --> 00:37:31,783
nearly two dozen changes
to Swift,

833
00:37:31,783 --> 00:37:35,253
but there are lots more that we
couldn't fit into this session.

834
00:37:35,253 --> 00:37:38,690
Every one of these changes
was pitched, proposed, reviewed,

835
00:37:38,690 --> 00:37:41,559
and accepted publicly
in the Evolution board

836
00:37:41,559 --> 00:37:43,428
on the Swift Forums.

837
00:37:43,428 --> 00:37:45,897
And all of them were shaped
and realized with the help

838
00:37:45,897 --> 00:37:48,833
of community members
from outside Apple.

839
00:37:48,833 --> 00:37:52,704
If you're one of those people,
thank you for making Swift 5.7

840
00:37:52,704 --> 00:37:55,073
the great release it is.

841
00:37:55,073 --> 00:37:57,208
And if you want to help
decide what comes next,

842
00:37:57,208 --> 00:38:02,213
visit Swift.org/contributing
to find out how to participate.

843
00:38:02,213 --> 00:38:03,348
Thanks for your time.

844
00:38:03,348 --> 00:38:04,949
And happy coding.

845
00:38:06,985 --> 00:38:08,753
[LAUGHS]

846
00:38:08,753 --> 00:38:12,824
♪

