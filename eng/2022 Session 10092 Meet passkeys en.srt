1
00:00:00,067 --> 00:00:03,003
♪ Mellow instrumental
hip-hop music ♪

2
00:00:03,003 --> 00:00:09,776
♪

3
00:00:09,776 --> 00:00:11,912
Hi, I'm Garrett,

4
00:00:11,912 --> 00:00:15,148
an engineer on the
Authentication Experience team.

5
00:00:15,148 --> 00:00:19,386
And in this video, I'm excited
to talk about passkeys,

6
00:00:19,386 --> 00:00:23,490
a next-generation
authentication technology.

7
00:00:23,490 --> 00:00:25,359
But first, I need to talk about

8
00:00:25,359 --> 00:00:28,896
today's authentication
technology: passwords.

9
00:00:28,896 --> 00:00:30,397
You're probably used
to signing in

10
00:00:30,397 --> 00:00:33,600
to nearly every app
and website with them.

11
00:00:33,600 --> 00:00:37,137
Passwords are really hard
to use securely.

12
00:00:37,137 --> 00:00:39,940
All of us know
we're supposed to create strong,

13
00:00:39,940 --> 00:00:42,709
unique passwords
for every account,

14
00:00:42,709 --> 00:00:45,779
but not many people actually do.

15
00:00:45,779 --> 00:00:48,782
As you're designing
your apps and websites,

16
00:00:48,782 --> 00:00:52,019
there's this constant tradeoff
between keeping accounts secure

17
00:00:52,019 --> 00:00:55,322
and designing a good experience.

18
00:00:55,322 --> 00:00:59,760
And even if your apps and
websites do everything right,

19
00:00:59,760 --> 00:01:02,996
issues like phishing
and password reuse

20
00:01:02,996 --> 00:01:06,433
can still lead
to account compromise.

21
00:01:06,433 --> 00:01:09,436
In macOS Monterey
and iOS 15,

22
00:01:09,436 --> 00:01:12,606
we announced a developer
preview of the solution --

23
00:01:12,606 --> 00:01:16,310
passkeys -- and got so much
great feedback.

24
00:01:16,310 --> 00:01:19,313
In macOS Ventura and iOS 16,

25
00:01:19,313 --> 00:01:23,083
we're excited to make passkeys
available to everyone.

26
00:01:23,083 --> 00:01:26,086
Now is the time to adopt them.

27
00:01:26,086 --> 00:01:27,387
With passkeys,

28
00:01:27,387 --> 00:01:31,358
not only is the user experience
better than a password,

29
00:01:31,358 --> 00:01:35,329
but also entire categories
of security problems,

30
00:01:35,329 --> 00:01:37,564
like weak and reused
credentials,

31
00:01:37,564 --> 00:01:42,769
credential leaks, and phishing,
are just not possible anymore.

32
00:01:42,769 --> 00:01:45,272
And they're so easy to use.

33
00:01:45,272 --> 00:01:47,975
Let me show you.

34
00:01:47,975 --> 00:01:51,378
Let's start with our favorite
demo app, Shiny.

35
00:01:51,378 --> 00:01:54,781
This app lets me see
one cute picture a day

36
00:01:54,781 --> 00:01:59,386
and has a typical
password-based sign-in flow.

37
00:01:59,386 --> 00:02:01,755
I can tap in the
user name field

38
00:02:01,755 --> 00:02:04,958
and see an AutoFill suggestion
for my account.

39
00:02:04,958 --> 00:02:08,428
I'll select that, sign in.

40
00:02:08,428 --> 00:02:10,664
Then, I can fill in my password.

41
00:02:12,933 --> 00:02:14,968
Then, I wait around
for a little bit

42
00:02:14,968 --> 00:02:18,005
until an SMS message comes in
with my one-time code.

43
00:02:20,374 --> 00:02:22,142
There it is.

44
00:02:22,142 --> 00:02:25,212
And eventually, I'm signed in.

45
00:02:25,212 --> 00:02:28,348
It took a few steps,
but with the help of AutoFill

46
00:02:28,348 --> 00:02:31,051
and my password manager,
I was able to get there.

47
00:02:33,320 --> 00:02:37,524
Now that I'm signed in, I'll add
a passkey to this account.

48
00:02:37,524 --> 00:02:41,228
Account Management, Add passkey.

49
00:02:41,228 --> 00:02:45,332
Here, I get the system sheet
for creating a passkey.

50
00:02:45,332 --> 00:02:47,000
Continue.

51
00:02:47,000 --> 00:02:48,802
Done!

52
00:02:48,802 --> 00:02:52,172
In just a few taps,
my device has generated

53
00:02:52,172 --> 00:02:56,109
a unique, cryptographically
strong key pair for my account

54
00:02:56,109 --> 00:02:58,879
and stored it
in my iCloud Keychain,

55
00:02:58,879 --> 00:03:02,049
so it will sync and work
across all of my devices

56
00:03:02,049 --> 00:03:04,584
running macOS Ventura
and iOS 16.

57
00:03:06,987 --> 00:03:08,688
Now that I have a passkey,

58
00:03:08,688 --> 00:03:11,458
let me show you
how easy it is to use.

59
00:03:11,458 --> 00:03:13,627
I'm going to sign out,

60
00:03:13,627 --> 00:03:18,398
and I'm back at the same
sign-in form I used earlier.

61
00:03:18,398 --> 00:03:21,902
I'm going to focus
the user name field like before.

62
00:03:21,902 --> 00:03:25,572
Now that I have a passkey
saved for my account,

63
00:03:25,572 --> 00:03:28,208
it shows up
in the QuickType bar.

64
00:03:28,208 --> 00:03:31,978
All I have to do is tap it
and I'm signed in.

65
00:03:31,978 --> 00:03:34,247
One step.

66
00:03:34,247 --> 00:03:35,882
When saving the passkey,

67
00:03:35,882 --> 00:03:38,652
I didn't have to come up
with a new password

68
00:03:38,652 --> 00:03:42,689
or try to satisfy
any complexity requirements.

69
00:03:42,689 --> 00:03:45,926
Each passkey
is generated by the system

70
00:03:45,926 --> 00:03:49,663
and guaranteed to be strong
and only ever used

71
00:03:49,663 --> 00:03:52,332
for a single account.

72
00:03:52,332 --> 00:03:54,968
And when I'm signing in with it,
it can be shown

73
00:03:54,968 --> 00:03:57,938
in the existing sign-in flows
I'm used to,

74
00:03:57,938 --> 00:04:00,774
and it's a single tap to use.

75
00:04:00,774 --> 00:04:04,511
And the system will take care
of only letting me use it

76
00:04:04,511 --> 00:04:07,013
in the correct app or website,

77
00:04:07,013 --> 00:04:10,784
with strong built-in
phishing resistance.

78
00:04:10,784 --> 00:04:14,354
Of course, passkeys
work on the web too.

79
00:04:14,354 --> 00:04:17,924
Here I am on Shiny's
website in Safari.

80
00:04:17,924 --> 00:04:21,828
Just like on my phone, when I
focus the user name field,

81
00:04:21,828 --> 00:04:25,298
my passkey is already there
and ready to use,

82
00:04:25,298 --> 00:04:27,334
thanks to iCloud Keychain.

83
00:04:27,334 --> 00:04:30,837
All I have to do is Touch ID
and I'm signed in.

84
00:04:30,837 --> 00:04:32,973
That's it.

85
00:04:32,973 --> 00:04:37,010
Apple's passkey implementation
is built on open standards.

86
00:04:37,010 --> 00:04:39,279
We've been working
with other platform vendors

87
00:04:39,279 --> 00:04:42,182
within the FIDO Alliance
to make sure

88
00:04:42,182 --> 00:04:45,886
that passkey implementations
are compatible cross-platform

89
00:04:45,886 --> 00:04:49,923
and can work on as many
devices as possible.

90
00:04:49,923 --> 00:04:52,893
After upgrading my account
to use a passkey,

91
00:04:52,893 --> 00:04:57,297
I'm still able to sign in to it
on my friend's PC.

92
00:04:57,297 --> 00:05:00,600
Of course, my friend's PC
doesn't have the passkey

93
00:05:00,600 --> 00:05:05,805
saved locally, but I can still
type my user name here.

94
00:05:05,805 --> 00:05:07,307
When I press Sign In,

95
00:05:07,307 --> 00:05:11,077
I get a sheet that's offering
to let me use my phone.

96
00:05:11,077 --> 00:05:14,581
Then I get a QR code.
Let me scan that.

97
00:05:16,883 --> 00:05:19,419
My phone recognizes
that this QR code

98
00:05:19,419 --> 00:05:22,656
is for signing in
with a passkey.

99
00:05:22,656 --> 00:05:24,457
When I select this option,

100
00:05:24,457 --> 00:05:29,062
my phone and the browser
securely connect to each other.

101
00:05:29,062 --> 00:05:34,668
Now I can just Continue,
and I'm signed in.

102
00:05:34,668 --> 00:05:37,270
This cross-platform
sign-in experience

103
00:05:37,270 --> 00:05:39,973
is a first-class system feature

104
00:05:39,973 --> 00:05:43,176
that's part of the standards
behind passkeys.

105
00:05:43,176 --> 00:05:46,680
On the surface,
it appears incredibly simple,

106
00:05:46,680 --> 00:05:49,516
but this is not just a QR code.

107
00:05:49,516 --> 00:05:50,684
Behind the scenes,

108
00:05:50,684 --> 00:05:53,587
the devices are performing
a local key agreement,

109
00:05:53,587 --> 00:05:55,288
proving proximity,

110
00:05:55,288 --> 00:05:59,259
establishing an end-to-end
encrypted communication channel,

111
00:05:59,259 --> 00:06:02,796
all to let you sign in
in a way that's easy

112
00:06:02,796 --> 00:06:07,033
but maintains the strong
phishing resistance of passkeys.

113
00:06:07,033 --> 00:06:10,136
It works great for allowing me
to sign in securely

114
00:06:10,136 --> 00:06:14,541
to my account on any device.

115
00:06:14,541 --> 00:06:17,877
Another important feature
for a password replacement

116
00:06:17,877 --> 00:06:22,382
is the ability to share accounts
between two or more people.

117
00:06:22,382 --> 00:06:24,551
To share a passkey
with someone else,

118
00:06:24,551 --> 00:06:26,386
I can use AirDrop.

119
00:06:28,521 --> 00:06:32,626
My partner and I also have an
account for Shiny that we share,

120
00:06:32,626 --> 00:06:35,962
which I've already upgraded
to use a passkey.

121
00:06:35,962 --> 00:06:39,833
With a passkey, the credential
isn't something I could type,

122
00:06:39,833 --> 00:06:43,169
but I'm still able to share it
with people I trust.

123
00:06:43,169 --> 00:06:46,006
On my phone, I'll open up
the account details.

124
00:06:48,942 --> 00:06:50,644
Here are all of my accounts,

125
00:06:50,644 --> 00:06:54,648
which use both passwords
and passkeys.

126
00:06:54,648 --> 00:06:58,852
I can tap on our shared account
to pull up more details.

127
00:06:58,852 --> 00:07:02,455
Here, I can get some information
about my saved passkey

128
00:07:02,455 --> 00:07:04,824
or add a note to this account.

129
00:07:04,824 --> 00:07:08,428
I can also share my passkey.

130
00:07:08,428 --> 00:07:09,996
There's my partner's phone.

131
00:07:09,996 --> 00:07:11,698
I'll go ahead and select that.

132
00:07:14,868 --> 00:07:17,604
Now my partner
has the passkey too.

133
00:07:19,839 --> 00:07:25,512
And that's how easy it is
to use passkeys everywhere.

134
00:07:25,512 --> 00:07:29,316
I've just gone over the
experience of using a passkey.

135
00:07:29,316 --> 00:07:32,118
Next, I'll talk about
what a passkey is

136
00:07:32,118 --> 00:07:36,323
and some interface guidelines
when using them.

137
00:07:36,323 --> 00:07:39,359
Then I'll show you
how you can integrate passkeys

138
00:07:39,359 --> 00:07:42,929
into your existing sign-in flows
in your apps and websites,

139
00:07:42,929 --> 00:07:45,832
by taking advantage of AutoFill,

140
00:07:45,832 --> 00:07:48,201
followed by some
additional options

141
00:07:48,201 --> 00:07:52,539
that can further streamline
your sign-in process.

142
00:07:52,539 --> 00:07:55,475
After that, I'll go into
some more technical detail

143
00:07:55,475 --> 00:07:58,278
about how passkeys work

144
00:07:58,278 --> 00:08:04,284
and finally, discuss passkeys
and multifactor authentication.

145
00:08:04,284 --> 00:08:07,921
First up,
designing for passkeys.

146
00:08:07,921 --> 00:08:10,490
When it comes to talking
about passkeys,

147
00:08:10,490 --> 00:08:15,862
first and foremost, passkeys are
replacements for passwords.

148
00:08:15,862 --> 00:08:19,399
They're faster to sign in with,
easier to use,

149
00:08:19,399 --> 00:08:23,370
and so much more secure.

150
00:08:23,370 --> 00:08:26,473
Here are some guidelines
for how to refer to passkeys

151
00:08:26,473 --> 00:08:29,342
in your apps and websites.

152
00:08:29,342 --> 00:08:33,246
"Passkey" is a generic,
user-visible term.

153
00:08:33,246 --> 00:08:37,217
This video focuses on
Apple's implementation,

154
00:08:37,217 --> 00:08:40,220
but as I've just shown you,
other major platforms

155
00:08:40,220 --> 00:08:45,091
have already started building
their own support for passkeys.

156
00:08:45,091 --> 00:08:49,195
"Passkey" is also a common noun,
like "password."

157
00:08:49,195 --> 00:08:51,965
In English, this means
it's lowercase

158
00:08:51,965 --> 00:08:54,968
and gets pluralized
like "password" would.

159
00:08:54,968 --> 00:08:59,439
I have a passkey for my account,
and I can go to Settings

160
00:08:59,439 --> 00:09:03,610
to view all of my accounts
with passkeys.

161
00:09:03,610 --> 00:09:07,580
On Apple platforms,
you can also use the SF Symbol

162
00:09:07,580 --> 00:09:11,484
person.key.badge
and the .fill variant

163
00:09:11,484 --> 00:09:15,722
to provide iconography
consistent with the system.

164
00:09:15,722 --> 00:09:18,124
When it comes to offering
passkeys in your apps

165
00:09:18,124 --> 00:09:24,030
and websites, you don't need
to design entire new interfaces.

166
00:09:24,030 --> 00:09:27,534
The user name field is
the center point for most app

167
00:09:27,534 --> 00:09:30,136
and website sign-in today.

168
00:09:30,136 --> 00:09:32,639
Pretty much everyone
knows how to use it,

169
00:09:32,639 --> 00:09:36,376
and many apps and websites
already take advantage of it

170
00:09:36,376 --> 00:09:40,613
to tailor the sign-in experience
per account.

171
00:09:40,613 --> 00:09:45,084
Now the user name field
has another big feature.

172
00:09:45,084 --> 00:09:47,554
While passkeys
bring new paradigms

173
00:09:47,554 --> 00:09:51,858
for how signing in works, the
transition away from passwords

174
00:09:51,858 --> 00:09:55,061
needs to be smooth
and easy too.

175
00:09:55,061 --> 00:09:58,531
You can now present passkeys
using AutoFill

176
00:09:58,531 --> 00:10:01,901
as a first-class feature,
letting you drop them

177
00:10:01,901 --> 00:10:05,238
right in to your existing
sign-in flows,

178
00:10:05,238 --> 00:10:10,276
in an interface that's familiar
and people know how to use.

179
00:10:10,276 --> 00:10:12,145
Presenting passkeys
with AutoFill

180
00:10:12,145 --> 00:10:15,281
is the primary way
you should use them.

181
00:10:15,281 --> 00:10:18,284
For more advanced uses though,
Apple platforms

182
00:10:18,284 --> 00:10:21,921
also have a wide range
of additional UI options

183
00:10:21,921 --> 00:10:25,358
for signing in with passkeys.

184
00:10:25,358 --> 00:10:27,660
Here's how to get started
using passkeys

185
00:10:27,660 --> 00:10:30,530
and presenting them
with AutoFill.

186
00:10:30,530 --> 00:10:33,099
Passkeys are built
on the WebAuthentication --

187
00:10:33,099 --> 00:10:37,670
or WebAuthn standard --
and use public-key cryptography.

188
00:10:37,670 --> 00:10:41,508
Rather than having
a typable word or string,

189
00:10:41,508 --> 00:10:46,679
unique cryptographic key pairs
are generated for every account.

190
00:10:46,679 --> 00:10:49,949
You'll need to adopt WebAuthn
on your server back end

191
00:10:49,949 --> 00:10:52,952
in order to perform
passkey sign-in.

192
00:10:52,952 --> 00:10:55,955
Any standard WebAuthn
server implementation

193
00:10:55,955 --> 00:10:59,859
should work with passkeys.

194
00:10:59,859 --> 00:11:01,861
In apps on Apple platforms,

195
00:11:01,861 --> 00:11:05,598
passkeys are part of the
ASAuthorization API family

196
00:11:05,598 --> 00:11:08,468
in the AuthenticationServices
framework.

197
00:11:08,468 --> 00:11:11,004
This is our API
for working with all kinds

198
00:11:11,004 --> 00:11:14,140
of different credentials,
including passwords,

199
00:11:14,140 --> 00:11:17,744
security keys,
and Sign in with Apple.

200
00:11:17,744 --> 00:11:20,513
We've also added a few
new methods you can use,

201
00:11:20,513 --> 00:11:25,318
like AutoFill support, to make
this API even more flexible

202
00:11:25,318 --> 00:11:30,423
and let you fit it in seamlessly
in your existing sign-in flows.

203
00:11:30,423 --> 00:11:33,726
To get started using
passkeys in your apps,

204
00:11:33,726 --> 00:11:36,496
first, you'll need to set up
associated domains,

205
00:11:36,496 --> 00:11:39,165
using the webcredentials
service.

206
00:11:39,165 --> 00:11:41,301
You can find more
details about that

207
00:11:41,301 --> 00:11:44,237
in the "Introducing Password
AutoFill for Apps"

208
00:11:44,237 --> 00:11:47,607
and "What's new
in Universal Links" videos.

209
00:11:47,607 --> 00:11:51,277
In your app's interface,
make sure your user name field

210
00:11:51,277 --> 00:11:54,914
is using the user name
textContentTtype.

211
00:11:54,914 --> 00:11:59,586
This lets the system know where
to offer passkey suggestions.

212
00:11:59,586 --> 00:12:02,088
Once that's configured,
here's the code needed

213
00:12:02,088 --> 00:12:05,592
to start an AutoFill-assisted
passkey request.

214
00:12:05,592 --> 00:12:09,529
It's just a few simple steps
when you break it down.

215
00:12:09,529 --> 00:12:12,665
As with any WebAuthn request,
you'll first need

216
00:12:12,665 --> 00:12:16,102
to fetch a challenge
from your server.

217
00:12:16,102 --> 00:12:19,472
Then create the provider
and the request.

218
00:12:19,472 --> 00:12:23,142
ASAuthorizationPlatformPublicKey
CredentialProvider

219
00:12:23,142 --> 00:12:25,178
is the
ASAuthorizationProvider

220
00:12:25,178 --> 00:12:28,247
for working
with passkey requests.

221
00:12:28,247 --> 00:12:32,452
In WebAuthn terms, assertions
are used when signing in,

222
00:12:32,452 --> 00:12:35,054
so here, I'm creating
an assertion request

223
00:12:35,054 --> 00:12:38,191
to sign in with
an existing passkey.

224
00:12:38,191 --> 00:12:39,993
ASAuthorizationController

225
00:12:39,993 --> 00:12:42,695
is what actually handles
the request.

226
00:12:42,695 --> 00:12:45,365
Create an instance
with the passkey request

227
00:12:45,365 --> 00:12:50,536
and configure its delegate and
presentationContextProvider.

228
00:12:50,536 --> 00:12:54,273
And finally, call
performAutoFillAssistedRequests

229
00:12:54,273 --> 00:12:56,509
to start the request.

230
00:12:56,509 --> 00:12:59,045
While this request
is running in your app,

231
00:12:59,045 --> 00:13:01,714
whenever a user name field
is focused,

232
00:13:01,714 --> 00:13:05,918
the system will offer available
passkeys in the QuickType bar.

233
00:13:05,918 --> 00:13:09,756
Make sure to start this request
early in your view lifetime

234
00:13:09,756 --> 00:13:11,858
before a user name field
gets focused,

235
00:13:11,858 --> 00:13:15,628
so passkeys are ready
when the keyboard appears.

236
00:13:15,628 --> 00:13:18,464
When an item from
the QuickType bar is selected,

237
00:13:18,464 --> 00:13:21,467
Face ID gets invoked,
then you'll receive

238
00:13:21,467 --> 00:13:24,470
an ASAuthorizationController
Delegate callback

239
00:13:24,470 --> 00:13:26,472
to complete the sign-in.

240
00:13:26,472 --> 00:13:29,575
Nothing actually gets filled
in your text field.

241
00:13:29,575 --> 00:13:32,912
When an authorization succeeds
for any credential type,

242
00:13:32,912 --> 00:13:35,048
you'll get the
didCompleteWithAuthorization

243
00:13:35,048 --> 00:13:37,216
callback.

244
00:13:37,216 --> 00:13:38,785
The first thing you should do

245
00:13:38,785 --> 00:13:41,821
is check the type
of the credential that you got.

246
00:13:41,821 --> 00:13:44,657
In the case of passkey sign-in,
it will be an

247
00:13:44,657 --> 00:13:50,029
ASAuthorizationPlatformPublicKey
CredentialAssertion.

248
00:13:50,029 --> 00:13:52,465
The assertion object will
contain the fields needed

249
00:13:52,465 --> 00:13:55,368
to verify the sign-in
on your back end.

250
00:13:55,368 --> 00:13:59,005
You should read the values,
verify them with your server,

251
00:13:59,005 --> 00:14:01,140
and complete the sign-in.

252
00:14:01,140 --> 00:14:04,977
AutoFill-assisted passkey
requests are powerful.

253
00:14:04,977 --> 00:14:06,813
With that small code change,

254
00:14:06,813 --> 00:14:11,284
your app's sign-in flow
now offers a lot of flexibility.

255
00:14:11,284 --> 00:14:14,153
The primary case, of course,
is to select

256
00:14:14,153 --> 00:14:16,823
the passkey suggestion
from the QuickType bar

257
00:14:16,823 --> 00:14:19,959
to sign in quickly
with that passkey.

258
00:14:19,959 --> 00:14:24,030
This is what you should expect
to happen most often.

259
00:14:24,030 --> 00:14:26,499
There are other options though.

260
00:14:26,499 --> 00:14:29,769
The code I just showed you
also allows passkey sign-in

261
00:14:29,769 --> 00:14:33,439
from nearby devices
with no additional changes.

262
00:14:33,439 --> 00:14:36,175
You can tap the key icon
to bring up a view

263
00:14:36,175 --> 00:14:40,079
that lists all available
passkeys and passwords

264
00:14:40,079 --> 00:14:43,683
and get to the option to sign in
with a nearby device.

265
00:14:43,683 --> 00:14:47,687
Then you can perform a
cross-device passkey sign-in.

266
00:14:47,687 --> 00:14:50,723
In both cases,
if a passkey is used,

267
00:14:50,723 --> 00:14:52,024
you'll receive the same

268
00:14:52,024 --> 00:14:55,061
ASAuthorizationController
Delegate callback.

269
00:14:55,061 --> 00:14:59,165
There's nothing special you need
to do to support this.

270
00:14:59,165 --> 00:15:01,868
If a user doesn't have
any passkeys yet,

271
00:15:01,868 --> 00:15:05,772
they can just use your login
form like they're used to.

272
00:15:05,772 --> 00:15:09,142
They'll get password suggestions
in the QuickType bar,

273
00:15:09,142 --> 00:15:11,978
or they can just type
in the fields.

274
00:15:11,978 --> 00:15:14,347
If a password item is selected,

275
00:15:14,347 --> 00:15:17,750
the credential will still be
filled in to your text fields,

276
00:15:17,750 --> 00:15:21,154
and you can cancel
the running request.

277
00:15:21,154 --> 00:15:23,289
We designed this API
to let you drop it

278
00:15:23,289 --> 00:15:25,992
right in to your existing
sign-in flows

279
00:15:25,992 --> 00:15:30,630
and make it super easy
for your users.

280
00:15:30,630 --> 00:15:34,233
If someone that has already
upgraded to using a passkey

281
00:15:34,233 --> 00:15:36,869
decides to enter
their user name anyway

282
00:15:36,869 --> 00:15:39,305
instead of using
the AutoFill suggestion,

283
00:15:39,305 --> 00:15:41,207
you should cancel
the AutoFill request

284
00:15:41,207 --> 00:15:43,342
and use
ASAuthorizationController

285
00:15:43,342 --> 00:15:46,279
to present a modal passkey
sign-in sheet.

286
00:15:46,279 --> 00:15:48,815
From here,
it's still a single tap,

287
00:15:48,815 --> 00:15:50,316
and you'll receive the same

288
00:15:50,316 --> 00:15:53,920
ASAuthorizationController
Delegate callback.

289
00:15:53,920 --> 00:15:56,122
Here's the code from before.

290
00:15:56,122 --> 00:15:59,792
To switch this from an AutoFill
request to a modal request,

291
00:15:59,792 --> 00:16:03,229
just swap this
performAutoFillAssistedRequests

292
00:16:03,229 --> 00:16:07,600
method call
with a performRequests() call.

293
00:16:07,600 --> 00:16:11,571
This will present a modal sheet
with all available passkeys

294
00:16:11,571 --> 00:16:16,008
as well as the option to use
a passkey from a nearby device.

295
00:16:16,008 --> 00:16:19,278
Those are the only code changes
you need in your app

296
00:16:19,278 --> 00:16:22,081
to support passkeys.

297
00:16:22,081 --> 00:16:25,618
The web platform also supports
both AutoFill-assisted

298
00:16:25,618 --> 00:16:28,287
and modal passkey requests.

299
00:16:28,287 --> 00:16:33,292
On the web, passkeys are used
via standard WebAuthn API,

300
00:16:33,292 --> 00:16:36,696
which is also used
for security keys.

301
00:16:36,696 --> 00:16:40,333
Just like in apps, adopting
AutoFill-assisted requests

302
00:16:40,333 --> 00:16:43,803
allows signing in quickly
with just a Touch ID,

303
00:16:43,803 --> 00:16:47,673
getting to all of your available
passkeys and passwords

304
00:16:47,673 --> 00:16:50,877
or using a passkey
from a nearby device,

305
00:16:50,877 --> 00:16:54,080
all with very little code.

306
00:16:54,080 --> 00:16:57,884
First off, make sure to annotate
your user name field

307
00:16:57,884 --> 00:17:01,020
on your webpage
with both the username

308
00:17:01,020 --> 00:17:04,657
and webauthn
autocomplete detail tokens,

309
00:17:04,657 --> 00:17:07,860
so that both password
and passkey suggestions

310
00:17:07,860 --> 00:17:10,129
are shown in the right place.

311
00:17:10,129 --> 00:17:13,666
Once that's done, here's
a typical WebAuthn sign-in,

312
00:17:13,666 --> 00:17:16,302
in JavaScript.

313
00:17:16,302 --> 00:17:19,472
In WebAuthn,
AutoFill-style requests

314
00:17:19,472 --> 00:17:22,975
are invoked using
conditional mediation.

315
00:17:22,975 --> 00:17:24,210
You should start by using

316
00:17:24,210 --> 00:17:26,545
standard JavaScript
feature detection

317
00:17:26,545 --> 00:17:29,248
to check if it is available.

318
00:17:29,248 --> 00:17:33,319
If it is, you can proceed
making your request.

319
00:17:33,319 --> 00:17:37,056
Just like with a native API,
you'll start by making a request

320
00:17:37,056 --> 00:17:40,693
using a challenge
fetched from your server.

321
00:17:40,693 --> 00:17:42,862
To make it
an AutoFill-assisted request,

322
00:17:42,862 --> 00:17:47,900
add the mediation: "conditional"
parameter to your options.

323
00:17:47,900 --> 00:17:53,406
Then, use navigator.credentials
.get to start the request.

324
00:17:53,406 --> 00:17:56,275
The .get call
returns a promise.

325
00:17:56,275 --> 00:17:59,845
If it resolves, you'll
receive an assertion object,

326
00:17:59,845 --> 00:18:02,682
which you can send back
to your server to verify,

327
00:18:02,682 --> 00:18:04,850
then complete the sign-in.

328
00:18:04,850 --> 00:18:08,354
Like in apps, if someone
manually enters a user name

329
00:18:08,354 --> 00:18:12,058
for an account with a passkey,
you should use the API

330
00:18:12,058 --> 00:18:15,061
to present a modal
sign-in sheet.

331
00:18:15,061 --> 00:18:19,131
To switch to a modal request,
all you need to do is remove

332
00:18:19,131 --> 00:18:22,668
the mediation: "conditional"
parameter.

333
00:18:22,668 --> 00:18:24,837
One thing to note
when using WebAuthn

334
00:18:24,837 --> 00:18:29,809
is how Apple platforms handle
user verification -- or UV.

335
00:18:29,809 --> 00:18:33,546
UV is a Boolean field
in a WebAuthn response

336
00:18:33,546 --> 00:18:35,581
that indicates whether
the authenticator

337
00:18:35,581 --> 00:18:37,883
attempted to verify
that the current user

338
00:18:37,883 --> 00:18:39,952
is the owner of the device.

339
00:18:39,952 --> 00:18:44,557
On Apple devices, a value of
one indicates that biometrics,

340
00:18:44,557 --> 00:18:47,493
or a password
or passcode were used.

341
00:18:47,493 --> 00:18:50,963
Apple platforms will always
require UV for passkeys

342
00:18:50,963 --> 00:18:52,932
when biometrics are available,

343
00:18:52,932 --> 00:18:55,768
so you don't have
to worry about that.

344
00:18:55,768 --> 00:18:57,770
When making WebAuthn requests,

345
00:18:57,770 --> 00:19:02,108
there's an option to specify
a user-verification requirement.

346
00:19:02,108 --> 00:19:06,145
The default value is
userVerification: "preferred".

347
00:19:06,145 --> 00:19:10,483
Always use the default value to
avoid creating a bad experience

348
00:19:10,483 --> 00:19:14,286
on devices without biometrics.

349
00:19:14,286 --> 00:19:18,557
Here are some additional notes
for using passkeys on the web.

350
00:19:18,557 --> 00:19:20,960
When you make
AutoFill-assisted requests,

351
00:19:20,960 --> 00:19:23,396
you should make them
early in the page lifetime,

352
00:19:23,396 --> 00:19:25,731
just like in apps.

353
00:19:25,731 --> 00:19:28,768
For modal WebAuthn requests,
you should trigger them

354
00:19:28,768 --> 00:19:32,905
from a user gesture event,
such as a button click.

355
00:19:32,905 --> 00:19:36,108
A modal request can be
triggered once per page load

356
00:19:36,108 --> 00:19:40,012
outside of a user gesture
event, but WebKit may limit

357
00:19:40,012 --> 00:19:44,083
subsequent calls
on that page if you do so.

358
00:19:44,083 --> 00:19:46,719
AutoFill requests
are not modal,

359
00:19:46,719 --> 00:19:49,088
so they don't require
a user gesture

360
00:19:49,088 --> 00:19:52,358
and have a much longer timeout.

361
00:19:52,358 --> 00:19:55,995
Finally, passkeys are
replacing Safari's legacy

362
00:19:55,995 --> 00:19:58,397
platform authenticator.

363
00:19:58,397 --> 00:20:01,033
Existing credentials
will still work

364
00:20:01,033 --> 00:20:04,270
and still be bound to the
device they were created on,

365
00:20:04,270 --> 00:20:08,841
but new platform credentials
will be created as passkeys.

366
00:20:08,841 --> 00:20:11,310
They can be differentiated
from legacy credentials

367
00:20:11,310 --> 00:20:12,912
during registration,

368
00:20:12,912 --> 00:20:17,316
as passkeys will not provide
an attestation statement.

369
00:20:17,316 --> 00:20:19,985
That's passkeys and AutoFill.

370
00:20:19,985 --> 00:20:23,389
Next up, I'll go over some
additional platform features

371
00:20:23,389 --> 00:20:26,892
that can further streamline
your sign-in experience.

372
00:20:26,892 --> 00:20:29,695
In addition to the
AutoFill-assisted sign-in,

373
00:20:29,695 --> 00:20:31,630
the ASAuthorization API

374
00:20:31,630 --> 00:20:34,467
provides many more
useful features.

375
00:20:34,467 --> 00:20:37,570
I'm going to cover three
additional features of the API

376
00:20:37,570 --> 00:20:39,772
and when you might
want to use them.

377
00:20:39,772 --> 00:20:43,075
Starting with passkey
allow lists.

378
00:20:43,075 --> 00:20:45,478
When presenting
a modal passkey sheet

379
00:20:45,478 --> 00:20:47,513
after a user
name is entered,

380
00:20:47,513 --> 00:20:50,616
it's possible that there are
passkeys for multiple accounts

381
00:20:50,616 --> 00:20:52,184
saved on the device.

382
00:20:52,184 --> 00:20:56,355
All available passkeys will be
shown in the sheet by default.

383
00:20:56,355 --> 00:20:58,491
You can use
a passkey allow list

384
00:20:58,491 --> 00:21:01,660
to restrict which passkeys
are shown in the sheet,

385
00:21:01,660 --> 00:21:05,131
so that only the matching
account is offered.

386
00:21:05,131 --> 00:21:07,933
To add an allow list
to a modal request,

387
00:21:07,933 --> 00:21:10,603
you'll first need
the user name.

388
00:21:10,603 --> 00:21:13,038
You can use that user name
to fetch a list

389
00:21:13,038 --> 00:21:17,776
of matching credential IDs
and turn it into an allow list.

390
00:21:17,776 --> 00:21:22,014
A credential ID is a unique
identifier for a passkey.

391
00:21:22,014 --> 00:21:25,718
A Webauthn server should have
a way to look up credential IDs

392
00:21:25,718 --> 00:21:28,154
for a given user name.

393
00:21:28,154 --> 00:21:32,658
From here, just proceed
with your request like before.

394
00:21:32,658 --> 00:21:35,961
Now, on my device which
has three Shiny accounts

395
00:21:35,961 --> 00:21:38,931
using passkeys,
the sheet only offers

396
00:21:38,931 --> 00:21:42,134
the single account
I'm trying to use.

397
00:21:42,134 --> 00:21:45,571
When making modal requests,
you should use an allow list

398
00:21:45,571 --> 00:21:48,507
when you have additional
context about which account

399
00:21:48,507 --> 00:21:50,809
the user is trying
to sign in with,

400
00:21:50,809 --> 00:21:54,213
such as if they've already
typed in their user name.

401
00:21:54,213 --> 00:21:58,551
Next up, I'll cover what happens
you make a modal passkey request

402
00:21:58,551 --> 00:22:02,555
if there are no passkeys
saved on the current device.

403
00:22:02,555 --> 00:22:05,224
This also applies
if you use an allow list

404
00:22:05,224 --> 00:22:08,561
and none of the saved
passkeys match that list.

405
00:22:08,561 --> 00:22:12,364
By default, when you make
a modal passkey request,

406
00:22:12,364 --> 00:22:14,733
if there are no matching
passkeys available,

407
00:22:14,733 --> 00:22:17,069
the modal sheet
will be displayed

408
00:22:17,069 --> 00:22:19,405
and will immediately show
the QR code

409
00:22:19,405 --> 00:22:23,108
for signing in with a passkey
from a nearby device.

410
00:22:23,108 --> 00:22:26,745
This provides most
flexibility when signing in

411
00:22:26,745 --> 00:22:30,316
and is the best option when you
know a passkey is being used.

412
00:22:30,316 --> 00:22:34,019
But there's a new option
in the API to prefer credentials

413
00:22:34,019 --> 00:22:37,256
that are immediately available
and fall back silently

414
00:22:37,256 --> 00:22:39,925
with a delegate callback
if there aren't any.

415
00:22:39,925 --> 00:22:43,028
This can be used to quickly
offer up existing credentials

416
00:22:43,028 --> 00:22:44,363
when possible,

417
00:22:44,363 --> 00:22:47,700
before even showing
a traditional sign-in form.

418
00:22:47,700 --> 00:22:50,569
This modal request
using the default options

419
00:22:50,569 --> 00:22:52,905
will fall back
to showing a QR code

420
00:22:52,905 --> 00:22:56,742
if there are no matching
passkeys on the current device.

421
00:22:56,742 --> 00:23:00,879
If you use the preferImmediately
AvailableCredentials option,

422
00:23:00,879 --> 00:23:02,915
instead of
getting a QR code,

423
00:23:02,915 --> 00:23:07,453
you'll receive a delegate
callback with an error.

424
00:23:07,453 --> 00:23:10,155
If you receive
an ASAuthorizationError

425
00:23:10,155 --> 00:23:12,691
with a code of canceled,
that means

426
00:23:12,691 --> 00:23:16,729
either the user saw the sheet
and manually dismissed it,

427
00:23:16,729 --> 00:23:20,633
or you passed preferImmediately
AvailableCredentials

428
00:23:20,633 --> 00:23:23,936
and no credentials
were immediately available.

429
00:23:23,936 --> 00:23:26,405
What you do from here
depends on the context

430
00:23:26,405 --> 00:23:28,707
where you were
calling this from.

431
00:23:28,707 --> 00:23:31,443
For example, if you were
using this option

432
00:23:31,443 --> 00:23:33,879
as a way to test
for local credentials

433
00:23:33,879 --> 00:23:36,649
before showing
your normal sign-in form,

434
00:23:36,649 --> 00:23:40,219
this is where would trigger
showing your form.

435
00:23:40,219 --> 00:23:43,455
If there's at least one matching
credential on the device,

436
00:23:43,455 --> 00:23:45,958
the full modal sheet
will be displayed

437
00:23:45,958 --> 00:23:48,894
regardless
of the options used.

438
00:23:48,894 --> 00:23:50,863
Make sure you're also using

439
00:23:50,863 --> 00:23:54,700
either AutoFill-assisted
requests or modal requests

440
00:23:54,700 --> 00:23:57,936
with the default fallback
somewhere in your app,

441
00:23:57,936 --> 00:24:00,806
so that the option to sign in
with a nearby device

442
00:24:00,806 --> 00:24:03,542
is still reachable
if there are no passkeys

443
00:24:03,542 --> 00:24:06,211
on the current device.

444
00:24:06,211 --> 00:24:09,148
The last feature
of the ASAuthorization API

445
00:24:09,148 --> 00:24:13,385
that I'll cover is making
combined credential requests.

446
00:24:13,385 --> 00:24:16,255
In this example,
the app made a request

447
00:24:16,255 --> 00:24:21,193
for passkeys, passwords,
and Sign in with Apple.

448
00:24:21,193 --> 00:24:24,263
My device happens to have
three different credentials

449
00:24:24,263 --> 00:24:26,298
for three different
accounts saved,

450
00:24:26,298 --> 00:24:29,101
so they're all
presented here.

451
00:24:29,101 --> 00:24:30,736
But a more likely scenario

452
00:24:30,736 --> 00:24:34,006
is that someone would only
have a single account.

453
00:24:34,006 --> 00:24:37,576
In that case, this same
combined credential request

454
00:24:37,576 --> 00:24:40,913
will only offer one account
in the sheet.

455
00:24:40,913 --> 00:24:42,948
Adding additional
credential types

456
00:24:42,948 --> 00:24:47,853
to an existing ASAuthorization
request is really easy.

457
00:24:47,853 --> 00:24:50,689
You just need to create
providers and requests

458
00:24:50,689 --> 00:24:52,491
for the additional
request types,

459
00:24:52,491 --> 00:24:56,061
then pass those new requests
to your controller.

460
00:24:56,061 --> 00:24:58,797
Now, the modal sheet will
offer whatever credentials

461
00:24:58,797 --> 00:25:02,935
are available from any
of these credential types.

462
00:25:02,935 --> 00:25:04,570
You'll get the same
delegate callback

463
00:25:04,570 --> 00:25:07,940
regardless of which
credential type is used.

464
00:25:07,940 --> 00:25:10,976
You should check the type
of the credential you received

465
00:25:10,976 --> 00:25:13,078
and finish the sign-in
as appropriate

466
00:25:13,078 --> 00:25:15,314
for that credential type.

467
00:25:15,314 --> 00:25:18,016
So that covers a few
of the more advanced features

468
00:25:18,016 --> 00:25:21,387
of the ASAuthorization
API family.

469
00:25:21,387 --> 00:25:24,056
Now, I'm going to dig in
to some more technical details

470
00:25:24,056 --> 00:25:29,027
about how passkeys actually work
and what makes them so secure.

471
00:25:29,027 --> 00:25:31,764
When you sign in
with a password today,

472
00:25:31,764 --> 00:25:34,233
generally what's actually
happening

473
00:25:34,233 --> 00:25:36,535
is after you enter
that password,

474
00:25:36,535 --> 00:25:40,839
it gets hashed and salted, and
the resulting obfuscated value

475
00:25:40,839 --> 00:25:44,076
is sent to the server,
which stores it.

476
00:25:44,076 --> 00:25:48,714
Later, if you can produce
the same hashed salted value,

477
00:25:48,714 --> 00:25:51,183
you're allowed into the account.

478
00:25:51,183 --> 00:25:53,852
This means the server
is responsible

479
00:25:53,852 --> 00:25:56,922
for storing this derivation
of your password,

480
00:25:56,922 --> 00:25:59,858
which is highly valuable
to attackers.

481
00:25:59,858 --> 00:26:02,528
If they can get it,
it's possible to figure out

482
00:26:02,528 --> 00:26:06,498
what your password is
and gain access to your account.

483
00:26:06,498 --> 00:26:10,269
Passkeys, however,
work very differently.

484
00:26:10,269 --> 00:26:13,205
Rather than having a single,
typeable string,

485
00:26:13,205 --> 00:26:16,575
a passkey is actually
a pair of related keys.

486
00:26:16,575 --> 00:26:19,411
These keys are generated
by your devices,

487
00:26:19,411 --> 00:26:23,549
securely and uniquely,
for every account.

488
00:26:23,549 --> 00:26:27,586
One is public
and is stored on the server.

489
00:26:27,586 --> 00:26:31,490
The other is private
and stays on your devices

490
00:26:31,490 --> 00:26:33,725
even when signing in.

491
00:26:33,725 --> 00:26:36,728
The public key
is not a secret.

492
00:26:36,728 --> 00:26:40,432
It's just as public
as your user name.

493
00:26:40,432 --> 00:26:44,169
The private key is what is
needed to actually sign in.

494
00:26:44,169 --> 00:26:47,339
The server never learns
what your private key is,

495
00:26:47,339 --> 00:26:50,976
and your devices keep it safe.

496
00:26:50,976 --> 00:26:54,446
When you go to sign in,
the server sends your device

497
00:26:54,446 --> 00:26:57,182
a single-use challenge.

498
00:26:57,182 --> 00:27:01,386
WebAuthn allows many different
challenge-response algorithms,

499
00:27:01,386 --> 00:27:07,326
but passkeys on Apple
platforms use standard ES256.

500
00:27:07,326 --> 00:27:10,462
Only your private key
is capable of producing

501
00:27:10,462 --> 00:27:14,933
a valid solution to
the challenge for your account.

502
00:27:14,933 --> 00:27:17,102
Your device produces
this solution --

503
00:27:17,102 --> 00:27:19,872
called a signature -- locally,

504
00:27:19,872 --> 00:27:23,742
and only sends the solution
back to the server.

505
00:27:23,742 --> 00:27:28,947
Your private key stays secret
and only on your devices.

506
00:27:28,947 --> 00:27:34,152
The server then validates the
solution using your public key.

507
00:27:34,152 --> 00:27:37,022
If the solution your device
provided is valid,

508
00:27:37,022 --> 00:27:39,324
you're signed in!

509
00:27:39,324 --> 00:27:43,829
A public key can be used
to check if a solution is valid

510
00:27:43,829 --> 00:27:47,566
but is not able to produce
a solution itself.

511
00:27:47,566 --> 00:27:49,801
This means
the server can be sure

512
00:27:49,801 --> 00:27:51,970
that you have
the right private key,

513
00:27:51,970 --> 00:27:55,974
without knowing what
the private key actually is.

514
00:27:55,974 --> 00:27:59,511
And since the server doesn't
know any private keys,

515
00:27:59,511 --> 00:28:02,014
it's a less valuable target
for attackers,

516
00:28:02,014 --> 00:28:06,084
because there are
no user credentials to leak.

517
00:28:06,084 --> 00:28:08,754
All of this cryptography
and key protection

518
00:28:08,754 --> 00:28:13,191
is totally transparent
and performed by the devices.

519
00:28:13,191 --> 00:28:17,296
Your customers never have
to know or think about it.

520
00:28:17,296 --> 00:28:20,566
From their perspective,
passkeys are super simple

521
00:28:20,566 --> 00:28:23,569
and just work, everywhere.

522
00:28:23,569 --> 00:28:27,639
Passkeys can also be used
to sign in across devices

523
00:28:27,639 --> 00:28:30,709
in a secure,
phishing-resistant manner.

524
00:28:30,709 --> 00:28:33,011
Here's how that works.

525
00:28:33,011 --> 00:28:34,813
There are two devices here.

526
00:28:34,813 --> 00:28:37,649
The client, which is the
device or web browser

527
00:28:37,649 --> 00:28:40,619
where I'm signing in,
and the authenticator,

528
00:28:40,619 --> 00:28:44,289
which is the device
which has my passkey.

529
00:28:44,289 --> 00:28:46,892
First, the client
shows a QR code,

530
00:28:46,892 --> 00:28:49,294
which the
authenticator scans.

531
00:28:49,294 --> 00:28:51,797
This QR code contains a URL

532
00:28:51,797 --> 00:28:56,468
that encodes a pair
of single-use encryption keys.

533
00:28:56,468 --> 00:29:00,238
Then, the authenticator produces
a Bluetooth advertisement

534
00:29:00,238 --> 00:29:04,443
containing routing information
for a network relay server.

535
00:29:04,443 --> 00:29:07,179
This local exchange
allows selecting a server

536
00:29:07,179 --> 00:29:09,214
and sharing routing
information,

537
00:29:09,214 --> 00:29:13,085
but also serves
two additional functions.

538
00:29:13,085 --> 00:29:15,621
It performs an out-of-band
key agreement

539
00:29:15,621 --> 00:29:18,857
that the server can't see,
so everything

540
00:29:18,857 --> 00:29:21,960
going over the network
is end-to-end encrypted

541
00:29:21,960 --> 00:29:25,163
and the server
can't read anything.

542
00:29:25,163 --> 00:29:27,699
It also provides a strong claim

543
00:29:27,699 --> 00:29:31,536
that these two devices
are in physical proximity.

544
00:29:31,536 --> 00:29:35,273
That means a QR code
sent in an email

545
00:29:35,273 --> 00:29:39,511
or generated on a fake
website won't work,

546
00:29:39,511 --> 00:29:42,714
because a remote attacker
won't be able receive

547
00:29:42,714 --> 00:29:47,052
the Bluetooth advertisement
and complete the local exchange.

548
00:29:47,052 --> 00:29:49,121
So that's the local part.

549
00:29:49,121 --> 00:29:52,457
Once the local exchange
and key agreement have happened,

550
00:29:52,457 --> 00:29:54,993
the two devices connect
to a relay server

551
00:29:54,993 --> 00:29:57,029
picked by the phone.

552
00:29:57,029 --> 00:30:01,466
From there, they perform
a standard FIDO CTAP operation,

553
00:30:01,466 --> 00:30:04,202
which is encrypted using
the keys from earlier,

554
00:30:04,202 --> 00:30:07,539
so the relay server can't see
anything that's going on.

555
00:30:09,408 --> 00:30:12,444
This whole process is
performed by the device

556
00:30:12,444 --> 00:30:14,179
and the web browser.

557
00:30:14,179 --> 00:30:17,416
The website is not involved
at any point

558
00:30:17,416 --> 00:30:19,618
in the cross-device
communication.

559
00:30:19,618 --> 00:30:23,655
Cross-device cross-platform
sign-in is a system feature

560
00:30:23,655 --> 00:30:28,260
that just works anywhere
passkeys can be used.

561
00:30:28,260 --> 00:30:31,663
So that's a more technical
look into how passkeys work

562
00:30:31,663 --> 00:30:35,033
and how they can make such
strong security guarantees,

563
00:30:35,033 --> 00:30:37,102
even across devices.

564
00:30:37,102 --> 00:30:40,706
Next up,
multifactor authentication.

565
00:30:40,706 --> 00:30:44,042
A common way to think about
authentication today

566
00:30:44,042 --> 00:30:46,411
is in terms of factors.

567
00:30:46,411 --> 00:30:48,714
Different factors
are strong or weak

568
00:30:48,714 --> 00:30:51,083
against different kinds
of attacks,

569
00:30:51,083 --> 00:30:52,517
and combining factors

570
00:30:52,517 --> 00:30:55,353
can provide better
collective coverage.

571
00:30:55,353 --> 00:30:59,925
But with passkeys, you don't
need to think like that anymore.

572
00:30:59,925 --> 00:31:02,027
Here are some
of the most common methods

573
00:31:02,027 --> 00:31:04,262
used to sign in today.

574
00:31:04,262 --> 00:31:05,630
Passwords in your head

575
00:31:05,630 --> 00:31:08,467
are vulnerable
to pretty much everything.

576
00:31:08,467 --> 00:31:09,801
Password managers

577
00:31:09,801 --> 00:31:14,106
are good at generating unique,
high-entropy strings,

578
00:31:14,106 --> 00:31:17,042
may have local protections
against device theft,

579
00:31:17,042 --> 00:31:20,779
and offer some hints
about phishing.

580
00:31:20,779 --> 00:31:23,715
Adding an SMS
or time-based code

581
00:31:23,715 --> 00:31:27,152
can help with theft or phishing
in some circumstances

582
00:31:27,152 --> 00:31:29,788
but doesn't really
solve either.

583
00:31:29,788 --> 00:31:31,223
With passkeys though,

584
00:31:31,223 --> 00:31:36,161
every passkey is a unique,
device-generated key pair.

585
00:31:36,161 --> 00:31:39,698
On Apple devices, they're
built on a strong foundation

586
00:31:39,698 --> 00:31:42,467
of local device protections.

587
00:31:42,467 --> 00:31:45,771
Passkeys also
completely eliminate

588
00:31:45,771 --> 00:31:48,073
the human factor
from phishing.

589
00:31:48,073 --> 00:31:51,443
And they can't be leaked
by an app or website server,

590
00:31:51,443 --> 00:31:55,447
because the servers
don't have the private keys.

591
00:31:55,447 --> 00:31:58,617
Adding factors to
a password-based sign-in flow

592
00:31:58,617 --> 00:32:01,653
makes sense,
as together they can protect

593
00:32:01,653 --> 00:32:05,223
against more types of attacks
than passwords alone.

594
00:32:05,223 --> 00:32:08,827
But a passkey alone protects
against so much more

595
00:32:08,827 --> 00:32:12,464
that it doesn't need
additional factors.

596
00:32:12,464 --> 00:32:16,568
I'm looking forward to
a future without passwords.

597
00:32:16,568 --> 00:32:20,705
Here's how you can get
started making that happen.

598
00:32:20,705 --> 00:32:24,242
First off, you'll need to adopt
WebAuthn on your server,

599
00:32:24,242 --> 00:32:26,711
if you haven't already done so.

600
00:32:26,711 --> 00:32:27,979
Passkeys should work

601
00:32:27,979 --> 00:32:32,517
with any standard WebAuthn
server implementation.

602
00:32:32,517 --> 00:32:34,452
Once your server
is ready to go,

603
00:32:34,452 --> 00:32:38,223
adopt our new API
in your apps and websites.

604
00:32:38,223 --> 00:32:41,193
AutoFill-assisted passkey
requests can be dropped

605
00:32:41,193 --> 00:32:44,529
right in to your existing
sign-in flows,

606
00:32:44,529 --> 00:32:47,999
plus we have a range of more
advanced UI options as well,

607
00:32:47,999 --> 00:32:50,235
if you need them.

608
00:32:50,235 --> 00:32:56,174
And finally, transition your
users away from passwords.

609
00:32:56,174 --> 00:32:59,511
Passkeys are
an industry-standard solution

610
00:32:59,511 --> 00:33:01,713
to the convenience
and security problem

611
00:33:01,713 --> 00:33:05,784
of securely signing in
to apps and websites.

612
00:33:05,784 --> 00:33:08,486
By guiding your customers
to passkeys

613
00:33:08,486 --> 00:33:11,456
and away from passwords,
you can give them

614
00:33:11,456 --> 00:33:15,327
an incredibly quick and
convenient sign-in experience

615
00:33:15,327 --> 00:33:18,496
while raising the security bar
for everyone.

616
00:33:18,496 --> 00:33:19,464
Thank you.

617
00:33:19,464 --> 00:33:23,301
♪

