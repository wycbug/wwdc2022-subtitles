1
00:00:00,167 --> 00:00:03,003
♪ Mellow instrumental
hip-hop music ♪

2
00:00:03,003 --> 00:00:09,977
♪

3
00:00:09,977 --> 00:00:14,281
Devin Clary: Hi. I'm Devin, an
engineer on the Messages team.

4
00:00:14,281 --> 00:00:17,017
Lance Parker: And I'm Lance,
also a Messages engineer.

5
00:00:17,017 --> 00:00:20,053
Devin: Welcome to "Integrate
your custom collaboration app

6
00:00:20,053 --> 00:00:22,222
with Messages."

7
00:00:22,222 --> 00:00:24,625
Collaboration starts
with a conversation,

8
00:00:24,625 --> 00:00:27,227
and in iOS 16
and macOS Ventura,

9
00:00:27,227 --> 00:00:29,897
you can bring your app's
custom collaboration experience

10
00:00:29,897 --> 00:00:32,466
right into the fabric
of the conversation.

11
00:00:32,466 --> 00:00:36,870
In this video, we'll go over the
life cycle of a collaboration.

12
00:00:36,870 --> 00:00:38,438
Then, we'll show you
how to prepare

13
00:00:38,438 --> 00:00:42,809
your app's collaborative content
to be shared through Messages.

14
00:00:42,809 --> 00:00:45,879
Next, we'll give you everything
you need to instantly verify

15
00:00:45,879 --> 00:00:49,650
recipient access, and respond
to participant changes,

16
00:00:49,650 --> 00:00:52,619
all without
compromising privacy.

17
00:00:52,619 --> 00:00:55,355
Finally, we'll show you
how your app can post notices

18
00:00:55,355 --> 00:00:59,293
about the content right
to the Messages conversation.

19
00:00:59,293 --> 00:01:00,928
This video assumes your app

20
00:01:00,928 --> 00:01:03,263
has existing collaboration
infrastructure,

21
00:01:03,263 --> 00:01:06,066
and has already adopted
universal links.

22
00:01:06,066 --> 00:01:08,268
We'll also build on some
concepts introduced in

23
00:01:08,268 --> 00:01:09,870
"Add Shared with You
to your app"

24
00:01:09,870 --> 00:01:14,574
and "Enhance collaboration
experiences with Messages."

25
00:01:14,574 --> 00:01:16,677
First up,
I'll go over the life cycle

26
00:01:16,677 --> 00:01:18,979
of a custom
collaboration message

27
00:01:18,979 --> 00:01:21,515
to illustrate how this API
allows your users

28
00:01:21,515 --> 00:01:24,818
to start collaborating
faster than ever.

29
00:01:24,818 --> 00:01:26,987
When a user decides
to share a collaboration

30
00:01:26,987 --> 00:01:29,756
from your app through Messages,

31
00:01:29,756 --> 00:01:33,427
you first create metadata
to represent the content.

32
00:01:33,427 --> 00:01:36,463
The metadata includes share
options the user can configure

33
00:01:36,463 --> 00:01:37,965
prior to sending the message,

34
00:01:37,965 --> 00:01:41,301
and a number of other properties
you can customize.

35
00:01:41,301 --> 00:01:43,971
Next, you provide that metadata
to the share sheet,

36
00:01:43,971 --> 00:01:46,039
or to drag and drop.

37
00:01:46,039 --> 00:01:48,375
This allows a draft
of the content to be staged

38
00:01:48,375 --> 00:01:51,144
in the Messages compose field.

39
00:01:51,144 --> 00:01:55,215
The collaboration needs to be
represented by a universal link.

40
00:01:55,215 --> 00:01:57,918
That can be created immediately,
but it's best deferred

41
00:01:57,918 --> 00:02:00,721
until right before
the message is sent.

42
00:02:00,721 --> 00:02:02,422
This is useful
if your app's link creation

43
00:02:02,422 --> 00:02:05,325
depends on the selected
share options, or recipients,

44
00:02:05,325 --> 00:02:08,395
as configured in
the Messages compose field.

45
00:02:08,395 --> 00:02:11,365
The user chooses the recipients
and share options

46
00:02:11,365 --> 00:02:14,201
and taps the send button.

47
00:02:14,201 --> 00:02:15,569
Before the message is sent,

48
00:02:15,569 --> 00:02:17,971
Messages asks your app
for the universal link

49
00:02:17,971 --> 00:02:21,575
and a device independent
identifier for the content.

50
00:02:21,575 --> 00:02:23,877
Using that identifier,
Messages provides a set of

51
00:02:23,877 --> 00:02:26,747
cryptographic identities
representing the recipients

52
00:02:26,747 --> 00:02:29,916
of that specific
collaboration message.

53
00:02:29,916 --> 00:02:31,685
Your app will
use these identities later

54
00:02:31,685 --> 00:02:34,087
to allow the recipients
to immediately open the link

55
00:02:34,087 --> 00:02:38,725
on any of their devices.

56
00:02:38,725 --> 00:02:41,261
Your app stores those
identities on its servers

57
00:02:41,261 --> 00:02:44,364
and associates them
with the shared content.

58
00:02:44,364 --> 00:02:46,033
Once your app
finishes this step,

59
00:02:46,033 --> 00:02:50,470
the message is sent
to the recipients.

60
00:02:50,470 --> 00:02:53,440
Now, here's what happens
on the receiving device.

61
00:02:53,440 --> 00:02:56,009
The goal is to instantly
verify access,

62
00:02:56,009 --> 00:02:59,913
pairing a recipient identity
with an account on your server.

63
00:02:59,913 --> 00:03:01,681
When the recipient
opens the link,

64
00:03:01,681 --> 00:03:04,351
your app receives
a call to open the URL,

65
00:03:04,351 --> 00:03:08,388
just like it does
for any other link.

66
00:03:08,388 --> 00:03:10,090
When your app detects
that a user account

67
00:03:10,090 --> 00:03:12,325
doesn't yet have access
to the document,

68
00:03:12,325 --> 00:03:15,262
it queries the system
for a proof of user identity

69
00:03:15,262 --> 00:03:18,865
cryptographically signed
by the recipient device.

70
00:03:18,865 --> 00:03:20,901
Your app sends
that signed identity proof

71
00:03:20,901 --> 00:03:23,870
to your server for validation.

72
00:03:23,870 --> 00:03:26,373
If the signature is valid,
the server compares the proof

73
00:03:26,373 --> 00:03:28,308
against the identities
previously provided

74
00:03:28,308 --> 00:03:30,310
by the sending device.

75
00:03:30,310 --> 00:03:33,213
If there's a match,
your server grants access

76
00:03:33,213 --> 00:03:35,215
to the user's account.

77
00:03:35,215 --> 00:03:36,716
And with that,
the recipient has gained

78
00:03:36,716 --> 00:03:39,419
instant and secure access
to the content,

79
00:03:39,419 --> 00:03:42,022
all without exchanging
account information!

80
00:03:42,022 --> 00:03:45,826
And that's the life cycle
of a collaboration message!

81
00:03:45,826 --> 00:03:47,561
Next,
let's look more closely

82
00:03:47,561 --> 00:03:51,198
at the API
for starting a collaboration.

83
00:03:51,198 --> 00:03:55,168
The system needs some metadata
about the collaboration.

84
00:03:55,168 --> 00:03:56,970
And for that,
you use a new class

85
00:03:56,970 --> 00:04:01,575
in the Shared with You framework
called SWCollaborationMetadata.

86
00:04:01,575 --> 00:04:05,011
This class has a few properties
for you to configure:

87
00:04:05,011 --> 00:04:08,148
the content's title,
a local identifier

88
00:04:08,148 --> 00:04:10,851
to reference the content
before its been shared;

89
00:04:10,851 --> 00:04:13,220
the initiator name
and account handle,

90
00:04:13,220 --> 00:04:14,788
to provide transparency
to the user

91
00:04:14,788 --> 00:04:16,890
about the account
they're sharing from;

92
00:04:16,890 --> 00:04:21,528
and the default share options,
for the user to configure.

93
00:04:21,528 --> 00:04:23,330
Here's how to create
a metadata object

94
00:04:23,330 --> 00:04:27,033
and configure its properties.

95
00:04:27,033 --> 00:04:31,104
Create a local identifier using
SWLocalCollaborationIdentifier

96
00:04:31,104 --> 00:04:33,874
initialized with a string.

97
00:04:33,874 --> 00:04:36,143
The string only needs
to be sufficient for your app

98
00:04:36,143 --> 00:04:41,114
to identify the content locally,
not across devices.

99
00:04:41,114 --> 00:04:43,183
Initialize
a new metadata instance

100
00:04:43,183 --> 00:04:47,020
using the local identifier.

101
00:04:47,020 --> 00:04:52,025
Set the content title,
the initiator's account handle,

102
00:04:52,025 --> 00:04:54,628
and their name
using PersonNameComponents

103
00:04:54,628 --> 00:04:57,164
from the foundation framework.

104
00:04:57,164 --> 00:04:59,566
The handle and name
are only displayed locally

105
00:04:59,566 --> 00:05:04,371
so the user can confirm the
account they're sharing from.

106
00:05:04,371 --> 00:05:07,474
Next,
set the defaultShareOptions.

107
00:05:07,474 --> 00:05:08,942
Before I show you
how to do that,

108
00:05:08,942 --> 00:05:12,012
I'll first describe
how options work.

109
00:05:12,012 --> 00:05:14,548
Share options are
the settings a user configures

110
00:05:14,548 --> 00:05:18,251
on the collaboration
in Messages or the share sheet.

111
00:05:18,251 --> 00:05:20,620
The options selected by the user
are provided to you

112
00:05:20,620 --> 00:05:23,323
before the message is sent.

113
00:05:23,323 --> 00:05:25,325
Share options
might include settings like

114
00:05:25,325 --> 00:05:27,694
who can make edits
to a collaboration

115
00:05:27,694 --> 00:05:32,199
or who should have access
to the content.

116
00:05:32,199 --> 00:05:34,768
You use a few classes
to define options,

117
00:05:34,768 --> 00:05:38,238
starting with
SWCollaborationOption.

118
00:05:38,238 --> 00:05:39,639
Depending on how
they're grouped,

119
00:05:39,639 --> 00:05:42,209
options represent
individual switches,

120
00:05:42,209 --> 00:05:46,279
or mutually exclusive values
for a setting.

121
00:05:46,279 --> 00:05:48,715
Options have a title
and an identifier,

122
00:05:48,715 --> 00:05:53,920
and they are either
selected or unselected.

123
00:05:53,920 --> 00:05:58,091
There are two classes
to represent a group of options:

124
00:05:58,091 --> 00:06:00,060
SWCollaborationOptionsGroup

125
00:06:00,060 --> 00:06:04,197
and SWCollaborationOptions
PickerGroup.

126
00:06:04,197 --> 00:06:06,766
You use
SWCollaborationOptionsGroup

127
00:06:06,766 --> 00:06:09,269
to represent
a collection of switches,

128
00:06:09,269 --> 00:06:11,905
while SWCollaborationOptions
PickerGroup

129
00:06:11,905 --> 00:06:16,610
represents mutually exclusive
values for a setting.

130
00:06:16,610 --> 00:06:19,246
Finally,
SWCollaborationShareOptions

131
00:06:19,246 --> 00:06:21,681
defines the full set
of option groups,

132
00:06:21,681 --> 00:06:25,252
to be set on the metadata's
defaultShareOptions property.

133
00:06:25,252 --> 00:06:29,489
You can also provide a summary
string to describe the options.

134
00:06:29,489 --> 00:06:31,658
Now that I've described
the option classes,

135
00:06:31,658 --> 00:06:34,661
here's an example
showing how to use them.

136
00:06:34,661 --> 00:06:38,765
This code defines
two option groups.

137
00:06:38,765 --> 00:06:41,368
The first group is initialized
with an identifier

138
00:06:41,368 --> 00:06:43,937
and two possible options.

139
00:06:43,937 --> 00:06:45,972
The identifier is
an arbitrary string

140
00:06:45,972 --> 00:06:50,710
you later use to identify which
option was selected by the user.

141
00:06:50,710 --> 00:06:52,145
Since this is a picker group,

142
00:06:52,145 --> 00:06:54,914
the options are
mutually exclusive.

143
00:06:54,914 --> 00:06:56,883
This group represents
the permission settings

144
00:06:56,883 --> 00:07:00,787
for the content:
readwrite or readonly.

145
00:07:00,787 --> 00:07:06,092
Then, the first option in that
group is selected by default.

146
00:07:06,092 --> 00:07:11,231
And the title is set to a string
describing this group.

147
00:07:11,231 --> 00:07:13,667
The second option group
is initialized the same way,

148
00:07:13,667 --> 00:07:16,202
and also contains two options.

149
00:07:16,202 --> 00:07:18,305
But since this is
a generic option group,

150
00:07:18,305 --> 00:07:19,673
the user will be able
to configure

151
00:07:19,673 --> 00:07:23,710
whether to allow mentions
and comments independently.

152
00:07:23,710 --> 00:07:26,546
Finally, the two option groups
are used to initialize

153
00:07:26,546 --> 00:07:30,183
an instance of
SWCollaborationShareOptions,

154
00:07:30,183 --> 00:07:34,454
which is then set
on the metadata.

155
00:07:34,454 --> 00:07:37,090
Next, the metadata is provided
to the share sheet

156
00:07:37,090 --> 00:07:39,626
or drag and drop,
depending on how the user

157
00:07:39,626 --> 00:07:42,362
decides to share the content.

158
00:07:42,362 --> 00:07:46,032
If your app uses SwiftUI,
SWCollaborationMetadata

159
00:07:46,032 --> 00:07:49,536
is compatible
with the new ShareLink API.

160
00:07:49,536 --> 00:07:52,105
Watch "Meet Transferable"
and "What's new in SwiftUI"

161
00:07:52,105 --> 00:07:58,244
to learn more about
Transferable and ShareLink.

162
00:07:58,244 --> 00:08:00,814
Here's how easy it is
to support collaboration

163
00:08:00,814 --> 00:08:05,552
on a proxy representation
in SwiftUI!

164
00:08:05,552 --> 00:08:08,288
From within
a Transferable model object,

165
00:08:08,288 --> 00:08:10,090
set up a ProxyRepresentation

166
00:08:10,090 --> 00:08:15,395
to return a collaboration
metadata instance.

167
00:08:15,395 --> 00:08:16,629
Then, from a view,

168
00:08:16,629 --> 00:08:22,836
initialize ShareLink
with that model object.

169
00:08:22,836 --> 00:08:26,673
For UIKit and AppKit apps,
you use NSItemProvider

170
00:08:26,673 --> 00:08:28,408
to support sharing.

171
00:08:28,408 --> 00:08:31,010
And SWCollaborationMetadata
conforms to

172
00:08:31,010 --> 00:08:33,780
NSItemProviderReading
and writing.

173
00:08:33,780 --> 00:08:36,216
So you simply register
a metadata instance

174
00:08:36,216 --> 00:08:39,853
with an item provider,
to support collaboration.

175
00:08:39,853 --> 00:08:41,254
It's also good practice

176
00:08:41,254 --> 00:08:43,757
to register multiple
representations of the content

177
00:08:43,757 --> 00:08:47,527
to support sharing through
as many channels as possible.

178
00:08:47,527 --> 00:08:49,596
For example,
Messages automatically

179
00:08:49,596 --> 00:08:52,232
offers an option to send
the content as a copy

180
00:08:52,232 --> 00:08:55,969
if you provide
a file representation.

181
00:08:55,969 --> 00:08:58,671
You'll use
the NSItemProvider API with

182
00:08:58,671 --> 00:09:03,476
UIActivityViewController and
UIDragItem on iOS and iPadOS

183
00:09:03,476 --> 00:09:08,281
and NSSharingServicePicker
on macOS.

184
00:09:08,281 --> 00:09:12,519
Here's how to set that up
with the share sheet on iOS.

185
00:09:12,519 --> 00:09:16,189
Create an NSItemProvider
instance.

186
00:09:16,189 --> 00:09:18,091
Register
the collaboration metadata

187
00:09:18,091 --> 00:09:19,826
created in the previous example,

188
00:09:19,826 --> 00:09:25,031
with visibility set
to all processes on the system.

189
00:09:25,031 --> 00:09:27,734
Initialize
UIActivityItemsConfiguration

190
00:09:27,734 --> 00:09:30,603
with the item provider,

191
00:09:30,603 --> 00:09:32,972
then initialize
UIActivityViewController

192
00:09:32,972 --> 00:09:36,042
with that configuration.

193
00:09:36,042 --> 00:09:40,947
And finally,
present the view controller.

194
00:09:40,947 --> 00:09:44,918
It's just as easy
to support drag and drop.

195
00:09:44,918 --> 00:09:46,186
Initialize NSItemProvider

196
00:09:46,186 --> 00:09:50,590
and register the metadata
the same way,

197
00:09:50,590 --> 00:09:53,359
then create a UIDragItem
with the item provider

198
00:09:53,359 --> 00:09:58,565
to use
with the drag and drop APIs.

199
00:09:58,565 --> 00:10:03,236
The API is similar on macOS
for the sharing popover.

200
00:10:03,236 --> 00:10:06,573
Again, set up the item provider.

201
00:10:06,573 --> 00:10:08,241
And this time,
use it to initialize

202
00:10:08,241 --> 00:10:11,878
NSSharingServicePicker.

203
00:10:11,878 --> 00:10:17,183
And then show the picker
relative to a target view.

204
00:10:17,183 --> 00:10:20,620
Drag and drop on macOS
utilizes NSPasteboardItem

205
00:10:20,620 --> 00:10:22,822
rather than NSItemProvider.

206
00:10:22,822 --> 00:10:24,624
To support this,
SharedWithYou exports

207
00:10:24,624 --> 00:10:29,329
an NSPasteboardItem extension.

208
00:10:29,329 --> 00:10:31,865
Using that extension,
set the collaboration metadata

209
00:10:31,865 --> 00:10:34,834
directly on a new
NSPasteboardItem instance

210
00:10:34,834 --> 00:10:39,105
in order to support
drag and drop.

211
00:10:39,105 --> 00:10:40,640
And that's all you need
for a draft

212
00:10:40,640 --> 00:10:45,745
of your collaborative content
to be staged in Messages!

213
00:10:45,745 --> 00:10:47,981
Next, when the user
taps the send button,

214
00:10:47,981 --> 00:10:52,552
the system coordinates with
your app to set up the share.

215
00:10:52,552 --> 00:10:54,387
It does this through
a new class called

216
00:10:54,387 --> 00:10:57,390
SWCollaborationCoordinator.

217
00:10:57,390 --> 00:11:00,193
SWCollaborationCoordinator
is a singleton,

218
00:11:00,193 --> 00:11:03,229
meaning there is
a global shared instance.

219
00:11:03,229 --> 00:11:05,498
That shared instance
coordinates the collaboration

220
00:11:05,498 --> 00:11:09,335
through a delegate you define
called an actionHandler.

221
00:11:09,335 --> 00:11:11,137
To ensure your app
is always available

222
00:11:11,137 --> 00:11:12,805
to coordinate collaborations,

223
00:11:12,805 --> 00:11:15,174
it will be launched
in the background when needed.

224
00:11:15,174 --> 00:11:17,677
So you should register
the delegate soon after launch

225
00:11:17,677 --> 00:11:22,181
and handle actions
immediately to avoid timeouts.

226
00:11:22,181 --> 00:11:24,250
Here's how to set up
the collaboration coordinator

227
00:11:24,250 --> 00:11:28,021
after your app
finishes launching.

228
00:11:28,021 --> 00:11:30,256
Access the singleton
coordinator instance

229
00:11:30,256 --> 00:11:33,593
through the shared property.

230
00:11:33,593 --> 00:11:34,827
Then, in the app delegate's

231
00:11:34,827 --> 00:11:36,963
didFinishLaunchingWithOptions
method,

232
00:11:36,963 --> 00:11:38,264
set the actionHandler property

233
00:11:38,264 --> 00:11:39,799
to an object
that conforms to the

234
00:11:39,799 --> 00:11:44,370
SWCollaborationActionHandler
protocol.

235
00:11:44,370 --> 00:11:46,873
The action handler
protocol uses a new class

236
00:11:46,873 --> 00:11:49,175
called SWAction.

237
00:11:49,175 --> 00:11:53,813
SWActions represent work
your app is expected to perform.

238
00:11:53,813 --> 00:11:56,115
You fulfill actions
to mark them as complete,

239
00:11:56,115 --> 00:11:59,018
and fail them otherwise.

240
00:11:59,018 --> 00:12:01,087
The first action your app
needs to handle

241
00:12:01,087 --> 00:12:03,923
is the start collaboration
action.

242
00:12:03,923 --> 00:12:05,558
SWStartCollaborationAction

243
00:12:05,558 --> 00:12:08,595
contains the collaboration
metadata you set up earlier,

244
00:12:08,595 --> 00:12:12,298
updated with the user's
selected share options.

245
00:12:12,298 --> 00:12:14,233
Once you've performed
the necessary setup,

246
00:12:14,233 --> 00:12:17,036
you fulfill the start action
with the universal link

247
00:12:17,036 --> 00:12:18,972
and a device-independent
identifier

248
00:12:18,972 --> 00:12:20,974
for the collaboration.

249
00:12:20,974 --> 00:12:23,276
If you explicitly
fail the start action,

250
00:12:23,276 --> 00:12:26,012
the message is canceled.

251
00:12:26,012 --> 00:12:28,281
Here's an implementation
to handle the start action

252
00:12:28,281 --> 00:12:32,218
using an example
server request.

253
00:12:32,218 --> 00:12:34,287
First,
retrieve the local identifier,

254
00:12:34,287 --> 00:12:36,022
and user-selected share options

255
00:12:36,022 --> 00:12:40,226
from the action's
metadata property.

256
00:12:40,226 --> 00:12:42,795
Set up a server request
to prepare the collaboration

257
00:12:42,795 --> 00:12:47,333
using the identifier
and options.

258
00:12:47,333 --> 00:12:50,169
Then, send the request
to the server.

259
00:12:50,169 --> 00:12:54,507
This example uses async await.

260
00:12:54,507 --> 00:12:56,976
Finally, fulfill the action
with the universal link

261
00:12:56,976 --> 00:13:01,714
and the device independent
identifier from the response.

262
00:13:01,714 --> 00:13:03,116
Or, if there was an error,

263
00:13:03,116 --> 00:13:05,952
fail the action
to cancel the message.

264
00:13:05,952 --> 00:13:07,954
If the start action
was successful,

265
00:13:07,954 --> 00:13:10,223
the system sends your app
a second action

266
00:13:10,223 --> 00:13:13,092
to update
the collaboration participants.

267
00:13:13,092 --> 00:13:15,461
The SWUpdateCollaboration
ParticipantsAction

268
00:13:15,461 --> 00:13:17,664
contains
the cryptographic identities

269
00:13:17,664 --> 00:13:19,866
for the participants.

270
00:13:19,866 --> 00:13:22,468
The identities are derived from
the collaboration identifier

271
00:13:22,468 --> 00:13:26,839
fulfilled by the start action
in the previous step.

272
00:13:26,839 --> 00:13:28,474
Store the identities
on your server

273
00:13:28,474 --> 00:13:30,877
associated with the content.

274
00:13:30,877 --> 00:13:32,879
You'll use this data
for verifying access

275
00:13:32,879 --> 00:13:35,381
on the recipient devices.

276
00:13:35,381 --> 00:13:36,949
Finally,
fulfilling this action

277
00:13:36,949 --> 00:13:40,586
will send the universal link
in Messages.

278
00:13:40,586 --> 00:13:42,088
This example shows
how to handle

279
00:13:42,088 --> 00:13:45,024
the update participants action.

280
00:13:45,024 --> 00:13:46,592
Retrieve
the collaboration identifier

281
00:13:46,592 --> 00:13:49,162
from the action's metadata.

282
00:13:49,162 --> 00:13:50,730
This is the identifier
you fulfilled

283
00:13:50,730 --> 00:13:53,999
while handling the start action.

284
00:13:53,999 --> 00:13:57,203
Next, retrieve the participant
data to store on your servers

285
00:13:57,203 --> 00:14:01,074
using the action's
addedIdentities property.

286
00:14:01,074 --> 00:14:05,111
Each identity has a Data
property called a root hash.

287
00:14:05,111 --> 00:14:06,713
This is the data you should
store on your server

288
00:14:06,713 --> 00:14:09,315
for later use.

289
00:14:09,315 --> 00:14:10,783
Lance will go over
more of the details

290
00:14:10,783 --> 00:14:16,189
about this property in
the Verifying Access section.

291
00:14:16,189 --> 00:14:18,424
Set up another server
request, this time to add

292
00:14:18,424 --> 00:14:20,393
the participants
to the collaboration

293
00:14:20,393 --> 00:14:23,930
with the target identifier.

294
00:14:23,930 --> 00:14:26,666
And just like before,
send the request to your server,

295
00:14:26,666 --> 00:14:29,502
and fulfill or fail the action.

296
00:14:29,502 --> 00:14:34,474
This time, the fulfill method
does not take any parameters.

297
00:14:34,474 --> 00:14:36,442
Now that you've set up
the collaboration,

298
00:14:36,442 --> 00:14:39,545
your app has everything it needs
to grant immediate access

299
00:14:39,545 --> 00:14:42,048
to the recipients
of the message.

300
00:14:42,048 --> 00:14:44,817
I'll hand it over to Lance
to show you how to do that!

301
00:14:44,817 --> 00:14:47,253
Lance: Thanks, Devin.
In this section,

302
00:14:47,253 --> 00:14:49,689
I'll show how to provide
immediate access

303
00:14:49,689 --> 00:14:52,125
to the recipients using
the identity data

304
00:14:52,125 --> 00:14:56,329
you stored on your server
in the previous step.

305
00:14:56,329 --> 00:14:58,998
The rootHash property
on SWPersonIdentity

306
00:14:58,998 --> 00:15:02,135
is used to do this verification.

307
00:15:02,135 --> 00:15:05,938
A rootHash is a secure value
used to uniquely identify

308
00:15:05,938 --> 00:15:08,941
a participant on their devices.

309
00:15:08,941 --> 00:15:11,043
In order to perform
verification,

310
00:15:11,043 --> 00:15:14,213
you'll need to understand
how to compute a root hash.

311
00:15:14,213 --> 00:15:16,883
I'll take you through that now.

312
00:15:16,883 --> 00:15:18,951
When a collaboration
message is sent,

313
00:15:18,951 --> 00:15:24,590
it's actually sent individually
to each of a person's devices.

314
00:15:24,590 --> 00:15:26,492
Messages identifies each device

315
00:15:26,492 --> 00:15:29,562
using a cryptographic
public key.

316
00:15:29,562 --> 00:15:31,464
Since the goal
is to allow access

317
00:15:31,464 --> 00:15:35,134
only on this set of devices,
the root hash is derived

318
00:15:35,134 --> 00:15:39,972
from the set of public keys
registered to each recipient.

319
00:15:39,972 --> 00:15:42,575
The root hash is the root node
of a data structure

320
00:15:42,575 --> 00:15:45,077
called a Merkle tree.

321
00:15:45,077 --> 00:15:47,580
A Merkle tree is
a binary tree that is built

322
00:15:47,580 --> 00:15:51,784
by performing a sequence
of hashing operations.

323
00:15:51,784 --> 00:15:54,620
In order to derive an identity
for the user based on their

324
00:15:54,620 --> 00:15:59,458
public keys, the keys are used
as the leaves of this tree.

325
00:15:59,458 --> 00:16:02,628
The hashing algorithm used
in the Merkle tree ensures

326
00:16:02,628 --> 00:16:07,900
that the root node can only be
computed from that set of keys.

327
00:16:07,900 --> 00:16:11,838
In this example,
this user has three devices

328
00:16:11,838 --> 00:16:15,174
and three public keys.

329
00:16:15,174 --> 00:16:18,277
The keys will be unique for
each collaboration identifier

330
00:16:18,277 --> 00:16:19,846
provided by your app,

331
00:16:19,846 --> 00:16:24,317
using a process called
key diversification.

332
00:16:24,317 --> 00:16:28,054
To prevent tracking the number
of devices registered to a user,

333
00:16:28,054 --> 00:16:31,958
the set is padded with
random keys up to a fixed size.

334
00:16:31,958 --> 00:16:34,627
The leaf nodes of the tree
are created by hashing

335
00:16:34,627 --> 00:16:38,431
the padded set
of diversified keys.

336
00:16:38,431 --> 00:16:41,968
The SHA256 algorithm is used
for the hashing operations

337
00:16:41,968 --> 00:16:44,170
in this tree.

338
00:16:44,170 --> 00:16:47,406
Then, each pair of leaf nodes
are concatenated

339
00:16:47,406 --> 00:16:51,944
and then hashed to derive
their parent nodes.

340
00:16:51,944 --> 00:16:56,048
This process is repeated
with the parent nodes

341
00:16:56,048 --> 00:17:00,653
and repeated again until
a single root node remains.

342
00:17:00,653 --> 00:17:03,789
This is the root hash
used to uniquely represent

343
00:17:03,789 --> 00:17:09,896
this recipient's identity
across their devices.

344
00:17:09,896 --> 00:17:12,565
Notice that it's possible
to generate a root hash

345
00:17:12,565 --> 00:17:17,203
using a subset of the nodes
from a complete Merkle tree.

346
00:17:17,203 --> 00:17:20,740
The root hash in this tree
can be reproduced using just

347
00:17:20,740 --> 00:17:25,144
the hashes H4, 7, and 11,

348
00:17:25,144 --> 00:17:29,315
along with the diversified
public key P3.

349
00:17:29,315 --> 00:17:35,688
First, hash the public key
to get the missing leaf node H3.

350
00:17:35,688 --> 00:17:39,892
Use H3 and H4 to generate H8.

351
00:17:39,892 --> 00:17:44,697
Use the given H7 node
with H8 to generate H10.

352
00:17:44,697 --> 00:17:49,969
And finally, H10 and H11
produce the root hash.

353
00:17:49,969 --> 00:17:53,205
It's important to note that you
can prove the public key P3

354
00:17:53,205 --> 00:17:55,775
was used to generate
a given root hash,

355
00:17:55,775 --> 00:17:59,645
without needing
to reconstruct the entire tree.

356
00:17:59,645 --> 00:18:01,781
The subset of nodes
needed to do this is called

357
00:18:01,781 --> 00:18:05,351
a proof of inclusion.

358
00:18:05,351 --> 00:18:08,254
Verification begins
when a universal link

359
00:18:08,254 --> 00:18:10,489
is opened in your app.

360
00:18:10,489 --> 00:18:12,091
To do this,
you first need to check

361
00:18:12,091 --> 00:18:15,027
that the link is collaborative.

362
00:18:15,027 --> 00:18:18,497
SWCollaborationHighlight
represents a collaborative link

363
00:18:18,497 --> 00:18:22,501
and is retrieved
from SWHighlightCenter.

364
00:18:22,501 --> 00:18:24,070
Use that collaboration highlight

365
00:18:24,070 --> 00:18:28,741
to generate
the proof of inclusion.

366
00:18:28,741 --> 00:18:31,310
To represent
a proof of inclusion,

367
00:18:31,310 --> 00:18:35,348
use a class called
SWPersonIdentityProof.

368
00:18:35,348 --> 00:18:37,550
To perform verification,
you'll first generate

369
00:18:37,550 --> 00:18:40,553
this object along
with a cryptographic signature

370
00:18:40,553 --> 00:18:43,089
to send to your server.

371
00:18:43,089 --> 00:18:46,325
Retrieve the proof using the
getSignedIdentityProof method

372
00:18:46,325 --> 00:18:48,861
on SWHighlightCenter.

373
00:18:48,861 --> 00:18:51,731
It takes an
SWCollaborationHighlight

374
00:18:51,731 --> 00:18:57,403
and some arbitrary data
to be signed by the device.

375
00:18:57,403 --> 00:19:00,840
Use the signature to ensure
the request cannot be replayed

376
00:19:00,840 --> 00:19:05,911
by a bad actor to gain access
to your collaboration.

377
00:19:05,911 --> 00:19:09,148
The data could be a challenge
you request from your server,

378
00:19:09,148 --> 00:19:13,185
or a nonce generated
on the device.

379
00:19:13,185 --> 00:19:16,555
This example uses
the challenge approach.

380
00:19:16,555 --> 00:19:19,458
The URL is passed
to this method on your app's

381
00:19:19,458 --> 00:19:22,194
UIApplicationDelegate.

382
00:19:22,194 --> 00:19:24,063
This URL is the universal link

383
00:19:24,063 --> 00:19:28,234
associated
with the collaboration.

384
00:19:28,234 --> 00:19:31,003
The URL is used
to fetch the associated

385
00:19:31,003 --> 00:19:36,909
SWCollaborationHighlight
from the SWHighlightCenter.

386
00:19:36,909 --> 00:19:39,912
Next, I'll request the challenge
from my server,

387
00:19:39,912 --> 00:19:41,914
and pass the data I get back

388
00:19:41,914 --> 00:19:46,719
to the getSignedIdentityProof
method on SWHighlightCenter,

389
00:19:46,719 --> 00:19:50,189
along with the highlight.

390
00:19:50,189 --> 00:19:53,626
This method returns
a signed identity proof.

391
00:19:53,626 --> 00:19:55,428
I'll discuss
what your server should do

392
00:19:55,428 --> 00:19:58,531
to validate this data later on.

393
00:19:58,531 --> 00:20:03,035
Now I can send the signed proof
to my server for verification.

394
00:20:03,035 --> 00:20:09,175
Finally, I update my user
interface with the result.

395
00:20:09,175 --> 00:20:11,544
The app sends
the proof to the server,

396
00:20:11,544 --> 00:20:16,716
along with the public key
and the signed data.

397
00:20:16,716 --> 00:20:18,517
The data is signed
using the elliptic curve

398
00:20:18,517 --> 00:20:23,055
digital signature algorithm
over the P-256 elliptic curve,

399
00:20:23,055 --> 00:20:27,293
using SHA256
as a hash function.

400
00:20:27,293 --> 00:20:29,495
Verify the signature on the data

401
00:20:29,495 --> 00:20:32,932
using the public key
in the identity proof.

402
00:20:32,932 --> 00:20:35,034
You can do this
with most commonly used

403
00:20:35,034 --> 00:20:38,571
encryption libraries.

404
00:20:38,571 --> 00:20:40,573
Once you have verified
the signature,

405
00:20:40,573 --> 00:20:43,409
you can trust
that the identity proof was sent

406
00:20:43,409 --> 00:20:46,979
from the device associated
with that public key.

407
00:20:46,979 --> 00:20:52,251
Next, you use the identity proof
to recompute the root hash.

408
00:20:52,251 --> 00:20:55,321
Here is an example of what
an SWPersonIdentityProof

409
00:20:55,321 --> 00:20:59,825
would contain using the example
tree we looked at before.

410
00:20:59,825 --> 00:21:04,029
Use it to reconstruct
the root hash of a Merkle tree.

411
00:21:04,029 --> 00:21:06,932
The public key is P3.

412
00:21:06,932 --> 00:21:12,004
The inclusion hashes are
H4, 7, and 11.

413
00:21:12,004 --> 00:21:15,007
A local key index of 2
indicates the position

414
00:21:15,007 --> 00:21:19,111
of the public key in the tree.

415
00:21:19,111 --> 00:21:21,580
Here is an example
implementation that reconstructs

416
00:21:21,580 --> 00:21:26,285
a root hash from the properties
on the proof.

417
00:21:26,285 --> 00:21:28,320
A recursive algorithm
works nicely when working

418
00:21:28,320 --> 00:21:32,758
with tree data structures,
so that's what I've done here.

419
00:21:32,758 --> 00:21:37,830
On the initial invocation, pass
in the hash of the public key,

420
00:21:37,830 --> 00:21:44,537
the set of inclusion hashes,
and the public key index.

421
00:21:44,537 --> 00:21:49,008
Next, the first inclusion hash
is pulled out.

422
00:21:49,008 --> 00:21:51,710
The public key index
is checked to see if the key

423
00:21:51,710 --> 00:21:56,482
is on the left or the right
of its sibling.

424
00:21:56,482 --> 00:21:58,784
The selected hashes
are concatenated

425
00:21:58,784 --> 00:22:03,088
in the correct order,
and then hashed.

426
00:22:03,088 --> 00:22:06,525
Next, the consumed node
in the inclusionHashes array

427
00:22:06,525 --> 00:22:09,028
is removed,
and the rest are passed

428
00:22:09,028 --> 00:22:14,133
to a recursive call
to this same function.

429
00:22:14,133 --> 00:22:16,235
The public key index
is also updated

430
00:22:16,235 --> 00:22:20,806
so that it's ready
for the next node in the tree.

431
00:22:20,806 --> 00:22:23,409
With this simple function,
you can quickly compute

432
00:22:23,409 --> 00:22:28,547
a root hash given
an identity proof.

433
00:22:28,547 --> 00:22:31,183
The server can now check
that this generated root hash

434
00:22:31,183 --> 00:22:33,986
is in the list of root hashes
the owner of the document

435
00:22:33,986 --> 00:22:36,388
uploaded during sending.

436
00:22:36,388 --> 00:22:38,924
The hash is present
in the list of known hashes,

437
00:22:38,924 --> 00:22:42,561
so the server can grant access
to the document.

438
00:22:42,561 --> 00:22:46,265
Now you can grant access
to the document with confidence!

439
00:22:46,265 --> 00:22:49,735
To recap the steps you'll follow
to verify an identity:

440
00:22:49,735 --> 00:22:51,971
first, look up
the collaboration highlight

441
00:22:51,971 --> 00:22:55,441
for your content while handling
its universal link.

442
00:22:55,441 --> 00:22:59,745
Next, sign some data and
retrieve the proof of inclusion.

443
00:22:59,745 --> 00:23:04,016
Send the signed data
and proof to your server.

444
00:23:04,016 --> 00:23:07,586
Verify the signature
on the data.

445
00:23:07,586 --> 00:23:11,523
Using the proof of inclusion,
generate the root hash.

446
00:23:11,523 --> 00:23:14,860
Finally, compare the root hash
to the list of known identities

447
00:23:14,860 --> 00:23:19,832
associated with that content.

448
00:23:19,832 --> 00:23:22,134
Now that you know
all about verifying access

449
00:23:22,134 --> 00:23:24,503
to your collaboration links,
I'll talk about

450
00:23:24,503 --> 00:23:28,307
how to coordinate participant
changes with Messages.

451
00:23:28,307 --> 00:23:31,143
When the participants
in a Messages group change,

452
00:23:31,143 --> 00:23:33,746
and that group
is collaborating together,

453
00:23:33,746 --> 00:23:37,283
a user can choose to propagate
those changes to your app,

454
00:23:37,283 --> 00:23:40,352
right from a banner
in the Messages thread.

455
00:23:40,352 --> 00:23:42,855
In this scenario,
your app receives another

456
00:23:42,855 --> 00:23:46,191
SWUpdateCollaboration
ParticipantsAction

457
00:23:46,191 --> 00:23:50,562
containing the added
and removed identities.

458
00:23:50,562 --> 00:23:53,565
You'll use the same code
you wrote to handle this action

459
00:23:53,565 --> 00:23:55,434
when setting up
a collaboration,

460
00:23:55,434 --> 00:24:00,039
but you'll also need
to handle removed participants.

461
00:24:00,039 --> 00:24:02,741
For removal, simply look up
any account associated

462
00:24:02,741 --> 00:24:06,946
with a removed identity
and revoke their access.

463
00:24:06,946 --> 00:24:09,248
If no account is yet associated,

464
00:24:09,248 --> 00:24:12,885
simply delete the root hash
from your database.

465
00:24:12,885 --> 00:24:14,186
Here's
the implementation for

466
00:24:14,186 --> 00:24:19,224
the update participants action
that Devin went over earlier.

467
00:24:19,224 --> 00:24:20,392
This example uses

468
00:24:20,392 --> 00:24:24,964
the removed identities property
on the action

469
00:24:24,964 --> 00:24:28,834
and passes them to
a similar removal API request.

470
00:24:28,834 --> 00:24:33,072
Note that this code only shows
handling removed identities,

471
00:24:33,072 --> 00:24:34,907
but a complete implementation
should handle

472
00:24:34,907 --> 00:24:38,577
both added
and removed identities.

473
00:24:38,577 --> 00:24:42,481
And that's all you need
to handle participant changes!

474
00:24:42,481 --> 00:24:45,818
Lastly, when changes
are made to a collaboration,

475
00:24:45,818 --> 00:24:48,320
your app posts notices
about those changes

476
00:24:48,320 --> 00:24:50,923
to be shown
directly in Messages.

477
00:24:50,923 --> 00:24:53,125
There are a few types
of supported notices

478
00:24:53,125 --> 00:24:55,294
I'll go over in this section.

479
00:24:55,294 --> 00:24:57,129
Notices are displayed
as a banner

480
00:24:57,129 --> 00:25:01,133
right in the conversation
where the link was shared.

481
00:25:01,133 --> 00:25:03,936
The banner includes
a description of what changed,

482
00:25:03,936 --> 00:25:07,573
as well as who made the change.

483
00:25:07,573 --> 00:25:09,808
In this conversation,
Charlie made edits

484
00:25:09,808 --> 00:25:12,778
to the Baking Recipes document.

485
00:25:12,778 --> 00:25:14,580
Tapping the show button
connects them

486
00:25:14,580 --> 00:25:17,516
right back to the content.

487
00:25:17,516 --> 00:25:19,885
To represent a notice,
the SharedWithYou framework

488
00:25:19,885 --> 00:25:24,423
has a protocol named
SWHighlightEvent.

489
00:25:24,423 --> 00:25:27,226
Highlight events are
initialized with SWHighlights

490
00:25:27,226 --> 00:25:31,730
retrieved
from the SWHighlightCenter API.

491
00:25:31,730 --> 00:25:36,201
Messages supports
several categories of events.

492
00:25:36,201 --> 00:25:40,239
A change event
for content updates or comments,

493
00:25:40,239 --> 00:25:44,243
a membership event when
a participant joins or leaves,

494
00:25:44,243 --> 00:25:49,448
a mention event when a user
is mentioned in a collaboration,

495
00:25:49,448 --> 00:25:54,019
and a persistence event when
content is moved or deleted.

496
00:25:54,019 --> 00:25:56,655
Here's an example showing
how to post a change event

497
00:25:56,655 --> 00:25:59,758
for an edit to a collaboration.

498
00:25:59,758 --> 00:26:02,161
Using the highlight center API,

499
00:26:02,161 --> 00:26:03,929
retrieve
a collaboration highlight

500
00:26:03,929 --> 00:26:06,098
for the target identifier.

501
00:26:06,098 --> 00:26:09,768
Remember, this identifier
is one you defined during

502
00:26:09,768 --> 00:26:13,172
the collaboration initiation,
so your app should have this

503
00:26:13,172 --> 00:26:17,109
available for use when
a content change is made.

504
00:26:17,109 --> 00:26:21,747
Next, create a highlight change
event instance.

505
00:26:21,747 --> 00:26:23,749
The initializer
takes a highlight,

506
00:26:23,749 --> 00:26:25,951
and a trigger enum value;

507
00:26:25,951 --> 00:26:30,122
in this case,
set it to the edit type.

508
00:26:30,122 --> 00:26:32,858
Finally, again using
the highlight center,

509
00:26:32,858 --> 00:26:36,195
post the notice for that event.

510
00:26:36,195 --> 00:26:39,298
Similarly,
for membership changes,

511
00:26:39,298 --> 00:26:41,100
post a membership event,

512
00:26:41,100 --> 00:26:44,203
this time passing
the addedCollaborator

513
00:26:44,203 --> 00:26:49,174
or removedCollaborator
trigger type.

514
00:26:49,174 --> 00:26:52,344
Next, if your app
supports user mentions,

515
00:26:52,344 --> 00:26:55,180
you can post a mention event.

516
00:26:55,180 --> 00:26:56,815
Initialize a person identity

517
00:26:56,815 --> 00:27:00,085
with the root hash
of the mentioned user.

518
00:27:00,085 --> 00:27:02,621
Recall that you associated
a person identity

519
00:27:02,621 --> 00:27:07,759
with a user account in your app
while verifying access.

520
00:27:07,759 --> 00:27:11,430
Then, post the mention event
in the same way,

521
00:27:11,430 --> 00:27:15,634
this time passing the mentioned
identity as a parameter.

522
00:27:15,634 --> 00:27:17,803
This notice will only be shown
in Messages

523
00:27:17,803 --> 00:27:21,840
to the mentioned user.

524
00:27:21,840 --> 00:27:24,543
Finally,
use the persistence event type

525
00:27:24,543 --> 00:27:29,748
when content is moved,
renamed, or deleted.

526
00:27:29,748 --> 00:27:32,117
Here, the renamed
trigger type is used,

527
00:27:32,117 --> 00:27:37,789
to signify that the user
changed the name of the content.

528
00:27:37,789 --> 00:27:41,159
And that is how your app
can notify collaborators,

529
00:27:41,159 --> 00:27:46,231
and they will get those
updates right in Messages.

530
00:27:46,231 --> 00:27:48,100
Devin: And with that,
you're ready to integrate

531
00:27:48,100 --> 00:27:50,669
your app's collaboration
experience with messages

532
00:27:50,669 --> 00:27:52,771
by following a few steps.

533
00:27:52,771 --> 00:27:55,674
Set up your content
to be shared collaboratively,

534
00:27:55,674 --> 00:27:58,644
cryptographically verify
participant access,

535
00:27:58,644 --> 00:28:00,779
keep track
of participant changes,

536
00:28:00,779 --> 00:28:03,782
and post notices in Messages
to connect your users

537
00:28:03,782 --> 00:28:06,552
right back to the content.

538
00:28:06,552 --> 00:28:07,953
Be sure to check out

539
00:28:07,953 --> 00:28:11,256
the "Enhance collaboration
experiences with Messages" video

540
00:28:11,256 --> 00:28:13,191
to learn more about
the new UI elements

541
00:28:13,191 --> 00:28:15,994
you can display
for collaborations.

542
00:28:15,994 --> 00:28:18,297
Lance: We can't wait to get
collaborating with your apps!

543
00:28:18,297 --> 00:28:20,966
Devin and Lance,
cryptographically signing off.

544
00:28:20,966 --> 00:28:22,334
Devin: Thanks for watching!

545
00:28:22,334 --> 00:28:25,938
♪

