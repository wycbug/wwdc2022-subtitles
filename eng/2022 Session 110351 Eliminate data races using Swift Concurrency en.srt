1
00:00:00,033 --> 00:00:03,003
♪ Mellow instrumental
hip-hop music ♪

2
00:00:03,003 --> 00:00:09,443
♪

3
00:00:09,443 --> 00:00:10,444
Hello.

4
00:00:10,444 --> 00:00:13,213
I'm Doug from the Swift team,
and I'm here to talk about

5
00:00:13,213 --> 00:00:17,150
Swift Concurrency's approach
to eliminating data races.

6
00:00:17,150 --> 00:00:20,554
We introduced Swift Concurrency
as a set of language features

7
00:00:20,554 --> 00:00:23,590
that make it easier to write
concurrent programs.

8
00:00:23,590 --> 00:00:27,060
For the mechanics of these
individual language features,

9
00:00:27,060 --> 00:00:32,399
we refer you to the 2021 WWDC
talks covering each of them.

10
00:00:32,399 --> 00:00:33,800
This talk takes a different,

11
00:00:33,800 --> 00:00:36,336
more holistic view
of Swift Concurrency

12
00:00:36,336 --> 00:00:38,505
as a way of structuring
your program to make

13
00:00:38,505 --> 00:00:42,576
efficient use of concurrency
without introducing data races.

14
00:00:42,576 --> 00:00:45,345
But to do so,
we need a great analogy,

15
00:00:45,345 --> 00:00:50,918
so we invite you to sail with us
on the high seas of concurrency.

16
00:00:50,918 --> 00:00:53,020
The sea of concurrency
is unpredictable,

17
00:00:53,020 --> 00:00:55,055
with many things
going on at once,

18
00:00:55,055 --> 00:00:58,091
but with you at the helm
and Swift helping you navigate

19
00:00:58,091 --> 00:01:01,161
the waters,
it can produce amazing things.

20
00:01:01,161 --> 00:01:02,829
Let's dive in!

21
00:01:02,829 --> 00:01:05,999
We'll start
by talking about isolation,

22
00:01:05,999 --> 00:01:09,469
which is one of the key ideas
of Swift's concurrency model,

23
00:01:09,469 --> 00:01:11,972
ensuring that data
is not shared in a manner

24
00:01:11,972 --> 00:01:14,241
that can introduce data races.

25
00:01:14,241 --> 00:01:17,644
Let's start with task isolation.

26
00:01:17,644 --> 00:01:22,716
In our sea of concurrency,
tasks are represented by boats.

27
00:01:22,716 --> 00:01:25,819
Boats are our main workers --
they have a job to do,

28
00:01:25,819 --> 00:01:29,589
which they perform sequentially
from start to finish.

29
00:01:29,589 --> 00:01:32,926
They are asynchronous,
and their work can be suspended

30
00:01:32,926 --> 00:01:37,931
any number of times at
"await" operations in the code.

31
00:01:37,931 --> 00:01:40,400
Finally,
they are self-contained:

32
00:01:40,400 --> 00:01:44,738
each task has its own resources,
so it can operate by itself,

33
00:01:44,738 --> 00:01:48,542
independently of all
of the other boats in the sea.

34
00:01:48,542 --> 00:01:51,278
If our boats are
completely independent,

35
00:01:51,278 --> 00:01:54,281
we have concurrency
without data races,

36
00:01:54,281 --> 00:01:59,753
but it's not very useful
without some way to communicate.

37
00:01:59,753 --> 00:02:01,922
Let's add some communication!

38
00:02:01,922 --> 00:02:03,857
For example, one boat might have

39
00:02:03,857 --> 00:02:07,794
a pineapple that it wants
to share with another boat.

40
00:02:07,794 --> 00:02:09,997
So the boats meet
on the open sea,

41
00:02:09,997 --> 00:02:13,600
and we transfer the pineapple
from one boat to the other.

42
00:02:13,600 --> 00:02:15,435
Now, this is where
the physical analogy

43
00:02:15,435 --> 00:02:18,071
breaks down a little bit,
because this pineapple

44
00:02:18,071 --> 00:02:22,142
is not a physical item that
moves from one boat to the next.

45
00:02:22,142 --> 00:02:25,445
It's data, and in Swift we have
a couple of different ways

46
00:02:25,445 --> 00:02:29,116
we could represent that data.

47
00:02:29,116 --> 00:02:31,685
How do we define
our pineapple type?

48
00:02:31,685 --> 00:02:34,888
We like value types in Swift,
so let's make the pineapple

49
00:02:34,888 --> 00:02:39,626
a struct that's defined
by its weight and ripeness.

50
00:02:39,626 --> 00:02:41,528
Let's see how this works.

51
00:02:41,528 --> 00:02:43,630
When the boats meet
on the open sea,

52
00:02:43,630 --> 00:02:46,867
we're really passing a copy
of the pineapple instance

53
00:02:46,867 --> 00:02:48,869
from one boat to the next,

54
00:02:48,869 --> 00:02:52,906
and each boat goes away
with its own copy.

55
00:02:52,906 --> 00:02:55,142
If you were to
mutate the copies,

56
00:02:55,142 --> 00:02:58,178
such as by calling
the slice() and ripen() methods,

57
00:02:58,178 --> 00:03:01,348
it won't have any effect
on the other one.

58
00:03:01,348 --> 00:03:03,550
Swift has always
preferred value types

59
00:03:03,550 --> 00:03:05,819
for exactly this reason --

60
00:03:05,819 --> 00:03:09,289
mutations have
only local effects.

61
00:03:09,289 --> 00:03:14,294
That principle helps
value types maintain isolation.

62
00:03:14,294 --> 00:03:18,398
Now, let's extend our data model
a bit and add chickens!

63
00:03:18,398 --> 00:03:20,367
Unlike pineapples,
which are pretty much

64
00:03:20,367 --> 00:03:23,503
only good for eating,
chickens are beautiful creatures

65
00:03:23,503 --> 00:03:26,339
with their own
unique personalities.

66
00:03:26,339 --> 00:03:30,844
So, we're going to model
them with a class, like this.

67
00:03:30,844 --> 00:03:34,648
Let's have our intrepid
seafarers exchange a chicken.

68
00:03:34,648 --> 00:03:37,417
When our boats meet,
we share the chicken,

69
00:03:37,417 --> 00:03:40,253
except that copying
a reference type like chicken

70
00:03:40,253 --> 00:03:43,323
doesn't give you another
full copy of the chicken,

71
00:03:43,323 --> 00:03:47,594
it gives you a reference
to that specific object.

72
00:03:47,594 --> 00:03:49,963
So once our boats have
gone their separate ways,

73
00:03:49,963 --> 00:03:52,699
we can see
that we have a problem:

74
00:03:52,699 --> 00:03:55,836
both boats are doing
their work concurrently,

75
00:03:55,836 --> 00:03:57,237
but they are not independent

76
00:03:57,237 --> 00:04:00,373
because they both reference
the same chicken object.

77
00:04:00,373 --> 00:04:04,311
That shared mutable data
is prone to data races,

78
00:04:04,311 --> 00:04:06,813
such as when one boat
is trying to feed the chicken

79
00:04:06,813 --> 00:04:08,715
and the other
wants to play with it,

80
00:04:08,715 --> 00:04:12,052
leading to one
very confused chicken.

81
00:04:12,052 --> 00:04:15,589
We need a way to know that it
was safe to share pineapples

82
00:04:15,589 --> 00:04:18,191
amongst boats, but not chickens.

83
00:04:18,191 --> 00:04:21,828
And then we need some checking
in place in the Swift compiler

84
00:04:21,828 --> 00:04:24,164
to ensure that chickens
aren't accidentally passed

85
00:04:24,164 --> 00:04:27,000
from one boat to another.

86
00:04:27,000 --> 00:04:30,570
Swift protocols are a great way
of categorizing types

87
00:04:30,570 --> 00:04:33,473
so you can reason
about their behavior.

88
00:04:33,473 --> 00:04:36,176
The Sendable protocol
is used to describe types

89
00:04:36,176 --> 00:04:40,280
that can safely be shared across
different isolation domains,

90
00:04:40,280 --> 00:04:43,416
without creating data races.

91
00:04:43,416 --> 00:04:47,020
A type can be made Sendable
by writing a conformance.

92
00:04:47,020 --> 00:04:49,389
The Pineapple struct
conforms to Sendable

93
00:04:49,389 --> 00:04:53,093
because it's a value type,
but the Chicken class cannot

94
00:04:53,093 --> 00:04:58,031
because it's an unsynchronized
reference type.

95
00:04:58,031 --> 00:05:01,234
Modeling Sendable as a protocol
allows us to describe

96
00:05:01,234 --> 00:05:03,703
the places where data
is going to be shared

97
00:05:03,703 --> 00:05:06,273
across isolation domains.

98
00:05:06,273 --> 00:05:09,276
For example,
when a task returns a value,

99
00:05:09,276 --> 00:05:12,045
this value is provided
to any of the tasks

100
00:05:12,045 --> 00:05:15,015
that are waiting for that value.

101
00:05:15,015 --> 00:05:18,552
Here, we are trying to return
a Chicken from our Task,

102
00:05:18,552 --> 00:05:21,188
and we get an error
stating that this is unsafe

103
00:05:21,188 --> 00:05:25,158
because Chicken is not Sendable.

104
00:05:25,158 --> 00:05:28,495
The actual Sendable constraint
comes from the definition

105
00:05:28,495 --> 00:05:31,765
of the Task struct itself,
which specifies that

106
00:05:31,765 --> 00:05:35,101
the result type of a Task,
called Success,

107
00:05:35,101 --> 00:05:37,771
must conform
to the Sendable protocol.

108
00:05:37,771 --> 00:05:39,406
You should use
Sendable constraints

109
00:05:39,406 --> 00:05:41,541
where you have
generic parameters whose values

110
00:05:41,541 --> 00:05:45,845
will be passed across
different isolation domains.

111
00:05:45,845 --> 00:05:50,717
Now, let's revisit the idea
of sharing data among boats.

112
00:05:50,717 --> 00:05:54,354
When two boats meet on the high
seas and want to share data,

113
00:05:54,354 --> 00:05:57,324
we need someone to consistently
check all of the goods

114
00:05:57,324 --> 00:06:00,160
to make sure
they're safe to share.

115
00:06:00,160 --> 00:06:02,996
That's the role of our friendly
customs inspector --

116
00:06:02,996 --> 00:06:05,198
played here
by the Swift compiler --

117
00:06:05,198 --> 00:06:09,002
to make sure that only
Sendable types are exchanged.

118
00:06:09,002 --> 00:06:12,105
The pineapple is fine
and can be exchanged freely,

119
00:06:12,105 --> 00:06:14,040
because it's Sendable.

120
00:06:14,040 --> 00:06:16,977
However, the chicken
cannot be exchanged,

121
00:06:16,977 --> 00:06:19,646
and our friendly customs
inspector will prevent us

122
00:06:19,646 --> 00:06:23,183
from making that mistake.

123
00:06:23,183 --> 00:06:25,952
The compiler is involved
in checking Sendable correctness

124
00:06:25,952 --> 00:06:28,488
at many different points.

125
00:06:28,488 --> 00:06:31,625
Sendable types must be
correct by construction,

126
00:06:31,625 --> 00:06:35,895
and cannot allow any shared data
to be smuggled through them.

127
00:06:35,895 --> 00:06:39,099
Enums and structs
generally define value types,

128
00:06:39,099 --> 00:06:41,801
which copy all of their
instance data along with them

129
00:06:41,801 --> 00:06:44,137
to produce independent values.

130
00:06:44,137 --> 00:06:46,339
Therefore, they can be Sendable

131
00:06:46,339 --> 00:06:51,745
so long as all of their
instance data is also Sendable.

132
00:06:51,745 --> 00:06:54,281
Sendable can be propagated
through collections

133
00:06:54,281 --> 00:06:57,651
and other generic types
using conditional conformance.

134
00:06:57,651 --> 00:07:00,086
An array of Sendable types
is Sendable,

135
00:07:00,086 --> 00:07:04,691
so a Crate full of pineapples
is also Sendable.

136
00:07:04,691 --> 00:07:07,060
All of these Sendable
conformances can even be

137
00:07:07,060 --> 00:07:10,563
inferred by the Swift compiler
for non-public types,

138
00:07:10,563 --> 00:07:12,532
so Ripeness,
Pineapple, and Crate

139
00:07:12,532 --> 00:07:15,135
are all implicitly Sendable.

140
00:07:15,135 --> 00:07:19,539
But let's say we create a coop
to house our flock of chickens.

141
00:07:19,539 --> 00:07:22,075
This type cannot
be marked as Sendable,

142
00:07:22,075 --> 00:07:24,811
because it contains
non-Sendable state:

143
00:07:24,811 --> 00:07:27,213
Chicken isn't Sendable,
so the array of chickens

144
00:07:27,213 --> 00:07:29,015
isn't Sendable.

145
00:07:29,015 --> 00:07:31,084
We'll get an error message
from our compiler to indicate

146
00:07:31,084 --> 00:07:35,322
that this type
cannot safely be shared.

147
00:07:35,322 --> 00:07:38,658
Classes are reference types,
so they can only be

148
00:07:38,658 --> 00:07:42,095
made Sendable under
very narrow circumstances,

149
00:07:42,095 --> 00:07:46,099
such as when a final class
only has immutable storage.

150
00:07:46,099 --> 00:07:48,535
Our attempt to make
the Chicken class Sendable

151
00:07:48,535 --> 00:07:53,406
will produce an error because
it contains mutable state.

152
00:07:53,406 --> 00:07:55,842
Now, it is possible
to implement reference types

153
00:07:55,842 --> 00:07:59,145
that do their own internal
synchronization, for example,

154
00:07:59,145 --> 00:08:01,414
by using a lock consistently.

155
00:08:01,414 --> 00:08:04,184
These types are
conceptually Sendable,

156
00:08:04,184 --> 00:08:07,687
but there is no way for Swift
to reason about that.

157
00:08:07,687 --> 00:08:12,058
Use unchecked Sendable to
disable the compiler's checking.

158
00:08:12,058 --> 00:08:14,427
Be careful with this,
because smuggling mutable state

159
00:08:14,427 --> 00:08:16,029
through @unchecked Sendable

160
00:08:16,029 --> 00:08:21,167
undermines the data race safety
guarantees Swift is providing.

161
00:08:21,167 --> 00:08:25,038
Task creation involves
executing a closure in a new,

162
00:08:25,038 --> 00:08:30,377
independent task, like sending
off a rowboat from your boat.

163
00:08:30,377 --> 00:08:33,813
When we do this, we can capture
values from the original task

164
00:08:33,813 --> 00:08:36,383
and pass them
into the new task,

165
00:08:36,383 --> 00:08:38,218
so we need Sendable checking

166
00:08:38,218 --> 00:08:41,488
to ensure we don't
introduce data races.

167
00:08:41,488 --> 00:08:44,257
If we do try to share
a non-Sendable type

168
00:08:44,257 --> 00:08:47,394
across this boundary, the
Swift compiler has us covered,

169
00:08:47,394 --> 00:08:51,398
producing an error message
like this one.

170
00:08:51,398 --> 00:08:53,833
This isn't magic
for task creation.

171
00:08:53,833 --> 00:08:57,737
The closure is being inferred
to be a Sendable closure,

172
00:08:57,737 --> 00:09:01,374
which could have been written
explicitly with At-Sendable.

173
00:09:01,374 --> 00:09:07,113
Sendable closures are values
of Sendable function type.

174
00:09:07,113 --> 00:09:10,216
At-Sendable can be written
on a function type to indicate

175
00:09:10,216 --> 00:09:13,753
that the function type conforms
to the Sendable protocol.

176
00:09:13,753 --> 00:09:16,089
That implies that values
of that function type

177
00:09:16,089 --> 00:09:19,459
can be passed to other isolation
domains and called there

178
00:09:19,459 --> 00:09:23,163
without introducing data races
on their captured state.

179
00:09:23,163 --> 00:09:26,332
Normally, function types
cannot conform to protocols,

180
00:09:26,332 --> 00:09:29,335
but Sendable is special
because the compiler validates

181
00:09:29,335 --> 00:09:31,971
the semantic requirements
for it.

182
00:09:31,971 --> 00:09:34,707
There is similar support
for tuples of Sendable types

183
00:09:34,707 --> 00:09:36,910
conforming to the
Sendable protocol,

184
00:09:36,910 --> 00:09:38,344
which allows Sendable
to be used

185
00:09:38,344 --> 00:09:41,915
throughout the entire language.

186
00:09:41,915 --> 00:09:44,984
The system we've described
has many concurrently executing

187
00:09:44,984 --> 00:09:48,655
tasks that are isolated
from each other.

188
00:09:48,655 --> 00:09:50,623
The Sendable protocol
describes types

189
00:09:50,623 --> 00:09:52,959
that can be safely shared
among tasks,

190
00:09:52,959 --> 00:09:55,261
and the Swift compiler
checks Sendable conformances

191
00:09:55,261 --> 00:09:59,566
at every level to maintain
isolation of the tasks.

192
00:09:59,566 --> 00:10:03,603
However, without any notion
of shared mutable data anywhere,

193
00:10:03,603 --> 00:10:04,804
it's hard for the tasks

194
00:10:04,804 --> 00:10:07,073
to coordinate
in a meaningful manner.

195
00:10:07,073 --> 00:10:10,276
So we need some way
to share data amongst our tasks

196
00:10:10,276 --> 00:10:13,480
that doesn't re-introduce
data races.

197
00:10:13,480 --> 00:10:16,416
This is where actors come in.

198
00:10:16,416 --> 00:10:19,285
Actors provide a way
to isolate state

199
00:10:19,285 --> 00:10:21,855
that can be accessed
by different tasks,

200
00:10:21,855 --> 00:10:26,793
but in a coordinated manner
that eliminates data races.

201
00:10:26,793 --> 00:10:30,830
Actors are the islands
in our sea of concurrency.

202
00:10:30,830 --> 00:10:33,967
Like boats,
each island is self-contained,

203
00:10:33,967 --> 00:10:36,002
with its own state
that is isolated

204
00:10:36,002 --> 00:10:38,671
from everything else in the sea.

205
00:10:38,671 --> 00:10:41,374
To access that state,
your code needs to be running

206
00:10:41,374 --> 00:10:43,109
on the island.

207
00:10:43,109 --> 00:10:45,044
For example,
the advanceTime method

208
00:10:45,044 --> 00:10:47,113
is isolated to this island.

209
00:10:47,113 --> 00:10:49,148
It lives on the island
and has access

210
00:10:49,148 --> 00:10:51,918
to all of the island's state.

211
00:10:51,918 --> 00:10:56,422
To actually run code
on an island, you need a boat.

212
00:10:56,422 --> 00:10:59,325
A boat can visit the island
to run code on the island,

213
00:10:59,325 --> 00:11:02,962
at which point it has
access to that state.

214
00:11:02,962 --> 00:11:07,066
Only one boat can visit the
island to run code at a time,

215
00:11:07,066 --> 00:11:09,335
which ensures that
there is no concurrent access

216
00:11:09,335 --> 00:11:11,304
to the island's state.

217
00:11:11,304 --> 00:11:14,207
If other boats show up,
they must await their turn

218
00:11:14,207 --> 00:11:16,009
to visit the island.

219
00:11:16,009 --> 00:11:19,245
And because it might be
a long time before a given boat

220
00:11:19,245 --> 00:11:22,382
gets a chance to visit the
island, entering into an actor

221
00:11:22,382 --> 00:11:27,053
is a potential suspension point
marked by the “await” keyword.

222
00:11:27,053 --> 00:11:30,356
Once the island frees up --
again, at a suspension point --

223
00:11:30,356 --> 00:11:34,227
another boat can visit.

224
00:11:34,227 --> 00:11:36,996
Just like with two boats
meeting on the open sea,

225
00:11:36,996 --> 00:11:40,433
interactions between a boat
and an island need to maintain

226
00:11:40,433 --> 00:11:43,336
isolation of both,
by making sure

227
00:11:43,336 --> 00:11:47,140
that non-Sendable types
don't pass between the two.

228
00:11:47,140 --> 00:11:50,276
For example, perhaps we try
to add a chicken from our boat

229
00:11:50,276 --> 00:11:52,378
to the flock on the island.

230
00:11:52,378 --> 00:11:55,415
This would create two references
to the same chicken object

231
00:11:55,415 --> 00:11:57,650
from different
isolation domains,

232
00:11:57,650 --> 00:12:00,553
so the Swift compiler
rejects it.

233
00:12:00,553 --> 00:12:03,890
Similarly, if we try to adopt
a pet chicken from the island

234
00:12:03,890 --> 00:12:06,960
and take it away on our boat,
Sendable checking ensures

235
00:12:06,960 --> 00:12:11,898
that we cannot create
this data race.

236
00:12:11,898 --> 00:12:15,702
Actors are reference types,
but unlike classes, they isolate

237
00:12:15,702 --> 00:12:19,606
all of their properties and code
to prevent concurrent access.

238
00:12:19,606 --> 00:12:21,975
Therefore,
having a reference to an actor

239
00:12:21,975 --> 00:12:25,511
from a different
isolation domain is safe.

240
00:12:25,511 --> 00:12:28,047
It's like having a map
to an island:

241
00:12:28,047 --> 00:12:30,583
you can use the map
to go visit the island,

242
00:12:30,583 --> 00:12:32,885
but you still need to go
through the docking procedure

243
00:12:32,885 --> 00:12:34,921
to access its state.

244
00:12:34,921 --> 00:12:40,660
Therefore, all actor types
are implicitly Sendable.

245
00:12:40,660 --> 00:12:42,795
You might be wondering
how to know

246
00:12:42,795 --> 00:12:46,599
what code is isolated to
the actor and what code isn't.

247
00:12:46,599 --> 00:12:50,470
Actor isolation is determined
by the context you're in.

248
00:12:50,470 --> 00:12:52,138
The instance properties
of an actor

249
00:12:52,138 --> 00:12:54,841
are isolated to that actor.

250
00:12:54,841 --> 00:12:58,144
Instance methods on the actor
or an extension of the actor

251
00:12:58,144 --> 00:13:03,249
are also isolated by default,
like this advanceTime method.

252
00:13:03,249 --> 00:13:06,886
Closures that are not Sendable,
such as the closure passed

253
00:13:06,886 --> 00:13:09,789
to the reduce algorithm,
stay on the actor and are

254
00:13:09,789 --> 00:13:14,260
actor-isolated when they are
in an actor-isolated context.

255
00:13:14,260 --> 00:13:17,330
The task initializer
also inherits actor isolation

256
00:13:17,330 --> 00:13:20,033
from its context,
so the created task will be

257
00:13:20,033 --> 00:13:23,603
scheduled on the same actor
as it was initiated from.

258
00:13:23,603 --> 00:13:27,540
Here, that grants
access to the flock.

259
00:13:27,540 --> 00:13:29,809
On the other hand,
a detached task

260
00:13:29,809 --> 00:13:33,046
does not inherit actor isolation
from its context,

261
00:13:33,046 --> 00:13:35,181
because it is completely
independent of the context

262
00:13:35,181 --> 00:13:37,116
where it was created.

263
00:13:37,116 --> 00:13:38,985
We can see that the code
in the closure here

264
00:13:38,985 --> 00:13:42,388
is considered to be outside
the actor because it needs

265
00:13:42,388 --> 00:13:46,759
to use “await” to refer
to the isolated “food” property.

266
00:13:46,759 --> 00:13:52,265
We have a term for this closure:
it's non-isolated code.

267
00:13:52,265 --> 00:13:53,700
No-isolated code is code

268
00:13:53,700 --> 00:13:56,502
that does not run
on any actor at all.

269
00:13:56,502 --> 00:13:58,738
You can explicitly make
a function that's within

270
00:13:58,738 --> 00:14:02,875
an actor non-isolated by using
the non-isolated keyword,

271
00:14:02,875 --> 00:14:05,011
putting it outside of the actor.

272
00:14:05,011 --> 00:14:07,714
Just like what happened
implicitly with the closure used

273
00:14:07,714 --> 00:14:10,016
for the detached task.

274
00:14:10,016 --> 00:14:12,652
That means if we want to read
some of the state

275
00:14:12,652 --> 00:14:16,489
that's isolated to the actor,
we'll need to use “await”

276
00:14:16,489 --> 00:14:20,860
to visit the island and grab
a copy of the state we need.

277
00:14:20,860 --> 00:14:22,762
Non-isolated async code

278
00:14:22,762 --> 00:14:26,165
always runs
on the global cooperative pool.

279
00:14:26,165 --> 00:14:29,836
Think of it as only running when
a boat is out on the open sea,

280
00:14:29,836 --> 00:14:33,773
so you have to leave the island
you're visiting to do the work.

281
00:14:33,773 --> 00:14:35,508
That means checking to ensure

282
00:14:35,508 --> 00:14:39,178
that you aren't taking any
non-Sendable data with you!

283
00:14:39,178 --> 00:14:42,482
Here, the compiler detects
the potential data race,

284
00:14:42,482 --> 00:14:44,717
where an instance
of the non-Sendable Chicken

285
00:14:44,717 --> 00:14:47,887
is trying to leave the island.

286
00:14:47,887 --> 00:14:52,191
Let's consider one more case
of non-isolated code.

287
00:14:52,191 --> 00:14:56,028
The “greet” operation is
non-isolated, synchronous code.

288
00:14:56,028 --> 00:14:58,531
It knows nothing
about boats or islands

289
00:14:58,531 --> 00:15:00,767
or concurrency in general.

290
00:15:00,767 --> 00:15:01,968
And here, we're calling it

291
00:15:01,968 --> 00:15:04,470
from the actor-isolated
greetOne function,

292
00:15:04,470 --> 00:15:05,805
and that's okay!

293
00:15:05,805 --> 00:15:07,140
This synchronous code,

294
00:15:07,140 --> 00:15:10,176
when called from the island,
will stay on the island,

295
00:15:10,176 --> 00:15:14,180
so it's free to operate
on the chicken from the flock.

296
00:15:14,180 --> 00:15:17,517
If instead we had a non-isolated
async operation

297
00:15:17,517 --> 00:15:18,818
that calls “greet,”

298
00:15:18,818 --> 00:15:23,089
then “greet” will run there,
on a boat, in the open sea.

299
00:15:23,089 --> 00:15:25,057
Most Swift code is like this:

300
00:15:25,057 --> 00:15:27,760
synchronous,
non-isolated to any actor,

301
00:15:27,760 --> 00:15:30,530
and only operates on
the parameters it's been given,

302
00:15:30,530 --> 00:15:35,868
so it stays in the isolation
domain where it is called.

303
00:15:35,868 --> 00:15:37,870
Actors hold state
that is isolated

304
00:15:37,870 --> 00:15:40,206
from the rest of the program.

305
00:15:40,206 --> 00:15:43,509
Only one task can run
on an actor at a time,

306
00:15:43,509 --> 00:15:47,180
so there is no concurrent
access to that state.

307
00:15:47,180 --> 00:15:49,215
Sendable checking
applies any time

308
00:15:49,215 --> 00:15:52,819
a task enters or exits
an actor to ensure

309
00:15:52,819 --> 00:15:56,856
that no unsynchronized
mutable state escapes.

310
00:15:56,856 --> 00:15:59,892
Altogether, this makes actors
one of the building blocks

311
00:15:59,892 --> 00:16:04,230
for a concurrent program
in Swift.

312
00:16:04,230 --> 00:16:06,866
There's another special actor
we often talk about

313
00:16:06,866 --> 00:16:09,202
called the main actor.

314
00:16:09,202 --> 00:16:11,704
Think of the main actor
as a big island

315
00:16:11,704 --> 00:16:13,606
in the middle of the sea.

316
00:16:13,606 --> 00:16:16,609
It represents the main thread,
where all of the drawing

317
00:16:16,609 --> 00:16:19,712
and interaction for
your user interface occurs.

318
00:16:19,712 --> 00:16:20,913
So if you want to draw
something,

319
00:16:20,913 --> 00:16:24,450
you need to run the code
on the main actor's island.

320
00:16:24,450 --> 00:16:26,519
It's so important for your UI,

321
00:16:26,519 --> 00:16:32,124
that maybe we should even
call it the “U-I-land."

322
00:16:32,124 --> 00:16:34,594
When we say
that the main actor is “big,”

323
00:16:34,594 --> 00:16:37,330
what we mean is that
it contains a lot of state

324
00:16:37,330 --> 00:16:39,866
related to the program's
user interface.

325
00:16:39,866 --> 00:16:40,999
There's a lot of code,

326
00:16:40,999 --> 00:16:43,636
both in the UI frameworks
and in your apps,

327
00:16:43,636 --> 00:16:45,805
that needs to run on it.

328
00:16:45,805 --> 00:16:47,907
However, it's still an actor,

329
00:16:47,907 --> 00:16:51,310
so it only runs one job
at a time.

330
00:16:51,310 --> 00:16:53,613
So you have to be careful
not to put too much

331
00:16:53,613 --> 00:16:55,781
or long-running work
on the main actor,

332
00:16:55,781 --> 00:17:00,052
because it can make
your UI unresponsive.

333
00:17:00,052 --> 00:17:01,554
Isolation to the main actor

334
00:17:01,554 --> 00:17:04,657
is expressed with
the MainActor attribute.

335
00:17:04,657 --> 00:17:07,994
This attribute can be applied
to a function or closure

336
00:17:07,994 --> 00:17:12,131
to indicate that the code
must run on the main actor.

337
00:17:12,131 --> 00:17:16,636
Then, we say that this code
is isolated to the main actor.

338
00:17:16,636 --> 00:17:18,471
The Swift compiler
will guarantee

339
00:17:18,471 --> 00:17:21,340
that main-actor-isolated code
will only be executed

340
00:17:21,340 --> 00:17:24,143
on the main thread,
using the same mechanism

341
00:17:24,143 --> 00:17:28,281
that ensures mutually exclusive
access to other actors.

342
00:17:28,281 --> 00:17:29,882
If one calls updateView

343
00:17:29,882 --> 00:17:32,818
from a context that isn't
isolated to the main actor,

344
00:17:32,818 --> 00:17:34,954
it will need to introduce
an “await”

345
00:17:34,954 --> 00:17:39,191
to account for the switch
over to the main actor.

346
00:17:39,191 --> 00:17:42,528
The main actor attribute
can also be applied to types,

347
00:17:42,528 --> 00:17:45,064
in which case the instances
of those types

348
00:17:45,064 --> 00:17:47,566
will be isolated
to the main actor.

349
00:17:47,566 --> 00:17:50,369
Again, this is just like
any other actor --

350
00:17:50,369 --> 00:17:52,204
the properties
are only accessible

351
00:17:52,204 --> 00:17:55,074
while on the main actor,
and the methods are isolated

352
00:17:55,074 --> 00:17:58,711
to the main actor
unless they explicitly opt out.

353
00:17:58,711 --> 00:17:59,946
Like normal actors,

354
00:17:59,946 --> 00:18:03,549
references to main-actor classes
are themselves Sendable,

355
00:18:03,549 --> 00:18:07,019
because their data is isolated.

356
00:18:07,019 --> 00:18:09,422
This makes the main actor
annotation suitable

357
00:18:09,422 --> 00:18:12,224
for your UI views
and view controllers,

358
00:18:12,224 --> 00:18:14,694
which are necessarily
tied to the main thread

359
00:18:14,694 --> 00:18:16,963
by the frameworks themselves.

360
00:18:16,963 --> 00:18:18,798
You can share a reference
to your view controller

361
00:18:18,798 --> 00:18:21,801
with other tasks
and actors in your program,

362
00:18:21,801 --> 00:18:24,737
and they can asynchronously call
back into the view controller

363
00:18:24,737 --> 00:18:26,272
to post results.

364
00:18:26,272 --> 00:18:30,910
This has a direct effect
on your app's architecture.

365
00:18:30,910 --> 00:18:31,811
In your app,

366
00:18:31,811 --> 00:18:35,881
your views and view controllers
will be on the main actor.

367
00:18:35,881 --> 00:18:39,251
Other program logic should be
separated from that main actor,

368
00:18:39,251 --> 00:18:42,288
using other actors
to safely model shared state

369
00:18:42,288 --> 00:18:45,658
and tasks to describe
independent work.

370
00:18:45,658 --> 00:18:48,260
And those tasks can shuttle
between the main actor

371
00:18:48,260 --> 00:18:51,430
and other actors as necessary.

372
00:18:51,430 --> 00:18:53,899
There's a lot going on
in a concurrent app,

373
00:18:53,899 --> 00:18:57,136
so we've built some great tools
to help you make sense of it.

374
00:18:57,136 --> 00:18:58,604
I invite you to check out

375
00:18:58,604 --> 00:19:01,173
the "Visualize and Optimize
Swift Concurrency" talk

376
00:19:01,173 --> 00:19:03,642
to learn more.

377
00:19:03,642 --> 00:19:08,547
Let's dive into some deeper
waters to talk about atomicity.

378
00:19:08,547 --> 00:19:10,383
The goal of the
Swift Concurrency model

379
00:19:10,383 --> 00:19:12,651
is to eliminate data races.

380
00:19:12,651 --> 00:19:15,054
What that really means
is that it eliminates

381
00:19:15,054 --> 00:19:18,624
low-level data races,
which involve data corruption.

382
00:19:18,624 --> 00:19:23,329
You still need to reason about
atomicity at a high level.

383
00:19:23,329 --> 00:19:24,663
As we've talked about before,

384
00:19:24,663 --> 00:19:28,134
actors only run
one task at a time.

385
00:19:28,134 --> 00:19:30,569
However, when you stop
running on an actor,

386
00:19:30,569 --> 00:19:32,905
the actor can run other tasks.

387
00:19:32,905 --> 00:19:35,441
This ensures that the program
makes progress,

388
00:19:35,441 --> 00:19:38,244
eliminating the potential
for deadlocks.

389
00:19:38,244 --> 00:19:41,113
However, it requires you to
consider your actor's invariants

390
00:19:41,113 --> 00:19:43,682
carefully around
await statements.

391
00:19:43,682 --> 00:19:47,119
Otherwise, you can end up
with a high-level data race

392
00:19:47,119 --> 00:19:49,622
where the program
is in an unexpected state,

393
00:19:49,622 --> 00:19:52,992
even though no data
is actually corrupted.

394
00:19:52,992 --> 00:19:56,395
Let's break down
an example of this.

395
00:19:56,395 --> 00:19:58,731
Here we have a function
that intends to deposit

396
00:19:58,731 --> 00:20:01,600
some additional pineapples
on an island.

397
00:20:01,600 --> 00:20:06,539
It's outside of an actor,
so it's non-isolated async code.

398
00:20:06,539 --> 00:20:10,042
That means it runs out here
in the open sea.

399
00:20:10,042 --> 00:20:13,512
It's been given some pineapples
and a map to the island

400
00:20:13,512 --> 00:20:16,649
where it should deposit
those pineapples.

401
00:20:16,649 --> 00:20:18,751
The first interesting
operation here

402
00:20:18,751 --> 00:20:22,021
gets a copy of the food array
from the island.

403
00:20:22,021 --> 00:20:24,790
To do that, the boat needs
to visit the island,

404
00:20:24,790 --> 00:20:27,326
signaled by the “await” keyword.

405
00:20:27,326 --> 00:20:29,428
As soon as it has a copy
of the food,

406
00:20:29,428 --> 00:20:31,464
the boat heads back out
to the open sea

407
00:20:31,464 --> 00:20:33,432
to continue its work.

408
00:20:33,432 --> 00:20:36,435
That means adding the pineapple
from the pineapples parameter

409
00:20:36,435 --> 00:20:39,138
to the two it got
from the island.

410
00:20:39,138 --> 00:20:43,375
Now, we can move along to the last line
of the function.

411
00:20:43,375 --> 00:20:46,645
Our boat now needs
to visit the island again

412
00:20:46,645 --> 00:20:50,649
to set the island's food array
to those three pineapples.

413
00:20:50,649 --> 00:20:52,518
Here, everything
worked out fine,

414
00:20:52,518 --> 00:20:55,287
and we have the three pineapples
on the island!

415
00:20:55,287 --> 00:20:58,724
But things could
have gone a bit differently.

416
00:20:58,724 --> 00:21:03,395
Let's say a pirate ship snuck in
and stole all of the pineapples

417
00:21:03,395 --> 00:21:07,299
while our first boat was waiting
its turn to visit the island.

418
00:21:07,299 --> 00:21:10,236
Now, our original ship
deposits its three pineapples

419
00:21:10,236 --> 00:21:13,205
on the island,
and we notice a problem.

420
00:21:13,205 --> 00:21:15,341
The three pineapples
have suddenly turned

421
00:21:15,341 --> 00:21:17,977
into five pineapples!

422
00:21:17,977 --> 00:21:19,645
What happened here?

423
00:21:19,645 --> 00:21:22,448
Well, notice that we have
two awaits

424
00:21:22,448 --> 00:21:25,551
for access to state
on the same actor,

425
00:21:25,551 --> 00:21:27,520
and we're making
an assumption here

426
00:21:27,520 --> 00:21:29,388
that the food array
on the island

427
00:21:29,388 --> 00:21:32,758
doesn't change
between those two awaits.

428
00:21:32,758 --> 00:21:34,226
But these are awaits,

429
00:21:34,226 --> 00:21:36,929
meaning that our task
could get suspended here

430
00:21:36,929 --> 00:21:39,565
and the actor could do other
higher-priority work,

431
00:21:39,565 --> 00:21:42,501
like battling pirates.

432
00:21:42,501 --> 00:21:45,471
In this specific case,
the Swift compiler will reject

433
00:21:45,471 --> 00:21:49,775
an attempt to outright modify
the state on another actor.

434
00:21:49,775 --> 00:21:52,545
However, we should really
rewrite our deposit operation

435
00:21:52,545 --> 00:21:56,949
as synchronous code
on the actor, like this.

436
00:21:56,949 --> 00:21:58,951
Because this
is synchronous code,

437
00:21:58,951 --> 00:22:01,720
it will run on the actor
without interruption.

438
00:22:01,720 --> 00:22:03,856
So we can be sure
that the state of the island

439
00:22:03,856 --> 00:22:09,795
will be unchanged by anyone else
throughout the entire function.

440
00:22:09,795 --> 00:22:11,130
When you are writing your actor,

441
00:22:11,130 --> 00:22:14,567
think in terms of synchronous,
transactional operations

442
00:22:14,567 --> 00:22:17,102
that can be interleaved
in any way.

443
00:22:17,102 --> 00:22:19,538
Every one of them
should ensure that the actor

444
00:22:19,538 --> 00:22:23,075
is in a good state
when it exits.

445
00:22:23,075 --> 00:22:26,579
For async actor operations,
keep them simple,

446
00:22:26,579 --> 00:22:28,914
forming them primarily
from your synchronous,

447
00:22:28,914 --> 00:22:31,050
transactional operations,

448
00:22:31,050 --> 00:22:33,586
and take care that your actor
is in a good state

449
00:22:33,586 --> 00:22:35,921
at each await operation.

450
00:22:35,921 --> 00:22:38,657
This way, you can make full use
of actors to eliminate

451
00:22:38,657 --> 00:22:42,628
both low-level
and high-level data races.

452
00:22:42,628 --> 00:22:44,230
In a concurrent program,

453
00:22:44,230 --> 00:22:46,265
many things
are happening at once,

454
00:22:46,265 --> 00:22:48,167
so the order in which
those things happen

455
00:22:48,167 --> 00:22:51,837
can vary from one execution
to the next.

456
00:22:51,837 --> 00:22:55,074
And yet programs often rely
on handling events

457
00:22:55,074 --> 00:22:56,875
in a consistent order.

458
00:22:56,875 --> 00:22:58,477
For example,
the stream of events

459
00:22:58,477 --> 00:23:02,548
that come in from user input
or messages from a server.

460
00:23:02,548 --> 00:23:04,149
When these
event streams come in,

461
00:23:04,149 --> 00:23:07,686
we expect their effects
to happen in order.

462
00:23:07,686 --> 00:23:11,156
Swift Concurrency provides tools
for ordering operations,

463
00:23:11,156 --> 00:23:14,927
however, actors are not
the tool for doing so.

464
00:23:14,927 --> 00:23:17,696
Actors execute the
highest-priority work first,

465
00:23:17,696 --> 00:23:20,466
to help the overall system
stay responsive.

466
00:23:20,466 --> 00:23:22,635
This eliminates
priority inversions

467
00:23:22,635 --> 00:23:24,703
where lower-priority work
ends up happening

468
00:23:24,703 --> 00:23:28,807
before higher-priority work
on the same actor.

469
00:23:28,807 --> 00:23:31,243
Note that this
is a significant difference

470
00:23:31,243 --> 00:23:33,279
from serial Dispatch queues,

471
00:23:33,279 --> 00:23:38,617
which execute in a strictly
First-In, First-Out order.

472
00:23:38,617 --> 00:23:41,620
Swift Concurrency has several
tools for ordering work.

473
00:23:41,620 --> 00:23:45,824
The first we've been talking
about a lot already -- tasks.

474
00:23:45,824 --> 00:23:48,560
Tasks execute
from beginning to end,

475
00:23:48,560 --> 00:23:50,963
with the normal control flow
you're used to,

476
00:23:50,963 --> 00:23:54,099
so they naturally order work.

477
00:23:54,099 --> 00:23:58,270
AsyncStream can be used to model
an actual stream of events.

478
00:23:58,270 --> 00:24:01,006
One task can iterate
over the stream of events

479
00:24:01,006 --> 00:24:05,811
with a for-await-in loop,
processing each event in turn.

480
00:24:05,811 --> 00:24:07,446
An AsyncStream can be shared

481
00:24:07,446 --> 00:24:09,615
with any number
of event producers,

482
00:24:09,615 --> 00:24:11,283
which can add elements
to the stream

483
00:24:11,283 --> 00:24:14,820
while maintaining order.

484
00:24:14,820 --> 00:24:17,856
We've talked a lot about
how Swift's concurrency model

485
00:24:17,856 --> 00:24:20,025
is designed to eliminate
data races

486
00:24:20,025 --> 00:24:23,095
using the notion of isolation,
which is maintained

487
00:24:23,095 --> 00:24:26,799
by Sendable checking
at task and actor boundaries.

488
00:24:26,799 --> 00:24:29,635
However, we cannot all
just stop what we are doing

489
00:24:29,635 --> 00:24:32,905
to go mark all of the
Sendable types everywhere.

490
00:24:32,905 --> 00:24:36,141
Instead, we need
an incremental approach.

491
00:24:36,141 --> 00:24:39,445
Swift 5.7 introduces
a build setting to specify

492
00:24:39,445 --> 00:24:44,550
how strictly the Swift compiler
should check for Sendability.

493
00:24:44,550 --> 00:24:46,618
The default setting is Minimal

494
00:24:46,618 --> 00:24:49,321
meaning that the compiler
will only diagnose places

495
00:24:49,321 --> 00:24:53,225
where one has explicitly tried
to mark something as Sendable.

496
00:24:53,225 --> 00:24:56,729
This is similar to how Swift 5.5
and 5.6 behaved,

497
00:24:56,729 --> 00:25:00,733
and for the above, there won't
be any warnings or errors.

498
00:25:00,733 --> 00:25:03,635
Now, if you add
a Sendable conformance,

499
00:25:03,635 --> 00:25:06,138
the compiler will complain
that the Coop type

500
00:25:06,138 --> 00:25:09,708
cannot be Sendable because
Chicken isn't Sendable.

501
00:25:09,708 --> 00:25:13,579
However, this -- and other
Sendable-related problems --

502
00:25:13,579 --> 00:25:17,282
will be presented as warnings
in Swift 5, not errors,

503
00:25:17,282 --> 00:25:22,054
to make it easier to work
through the problems one by one.

504
00:25:22,054 --> 00:25:24,623
To move further
toward data race safety,

505
00:25:24,623 --> 00:25:28,026
enable the “targeted”
strict concurrency setting.

506
00:25:28,026 --> 00:25:30,462
This setting enables Sendable
checking for code

507
00:25:30,462 --> 00:25:33,132
that has already adopted
Swift Concurrency features

508
00:25:33,132 --> 00:25:37,069
like async/await, tasks,
or actors.

509
00:25:37,069 --> 00:25:38,804
This will identify, for example,

510
00:25:38,804 --> 00:25:41,740
attempts to capture values
of non-Sendable type

511
00:25:41,740 --> 00:25:45,477
in a newly created task.

512
00:25:45,477 --> 00:25:50,082
Sometimes the non-Sendable types
come from another module.

513
00:25:50,082 --> 00:25:52,551
Perhaps it's some package
that hasn't been updated

514
00:25:52,551 --> 00:25:55,287
for Sendable yet,
or even your own module

515
00:25:55,287 --> 00:25:57,956
that you just haven't
gotten around to.

516
00:25:57,956 --> 00:26:01,293
For those, you can temporarily
disable the Sendable warnings

517
00:26:01,293 --> 00:26:03,061
for types that come
from that module

518
00:26:03,061 --> 00:26:07,433
using the @preconcurrency
attribute.

519
00:26:07,433 --> 00:26:10,369
This will silence Sendable
warnings for the Chicken type

520
00:26:10,369 --> 00:26:12,638
within this source file.

521
00:26:12,638 --> 00:26:14,573
At some point,
the FarmAnimals module

522
00:26:14,573 --> 00:26:17,142
will get updated
with Sendable conformances.

523
00:26:17,142 --> 00:26:19,812
Then, one of two things
will happen:

524
00:26:19,812 --> 00:26:22,347
either Chicken
becomes Sendable somehow,

525
00:26:22,347 --> 00:26:25,484
in which case the preconcurrency
attribute can be removed

526
00:26:25,484 --> 00:26:27,352
from the import.

527
00:26:27,352 --> 00:26:30,589
Or Chicken will be known
to be non-Sendable,

528
00:26:30,589 --> 00:26:33,225
in which case the warning
will come back,

529
00:26:33,225 --> 00:26:35,961
indicating that your assumptions
about Chicken being Sendable

530
00:26:35,961 --> 00:26:38,964
are, in fact, not correct.

531
00:26:38,964 --> 00:26:42,100
The targeted strictness setting
tries to strike a balance

532
00:26:42,100 --> 00:26:44,870
between compatibility
with existing code

533
00:26:44,870 --> 00:26:47,806
and identifying potential
data races.

534
00:26:47,806 --> 00:26:49,441
However, if you'd like to see

535
00:26:49,441 --> 00:26:51,443
everywhere that races
could occur,

536
00:26:51,443 --> 00:26:55,747
there is one more option:
complete checking.

537
00:26:55,747 --> 00:26:59,251
Complete checking approximates
the intended Swift 6 semantics

538
00:26:59,251 --> 00:27:01,753
to completely eliminate
data races.

539
00:27:01,753 --> 00:27:04,656
It checks everything
that the earlier two modes check

540
00:27:04,656 --> 00:27:07,759
but does so for all code
in the module.

541
00:27:07,759 --> 00:27:09,261
Here, we're not
actually making use

542
00:27:09,261 --> 00:27:11,563
of Swift's concurrency
features at all.

543
00:27:11,563 --> 00:27:14,199
Rather, it's performing work
on a dispatch queue,

544
00:27:14,199 --> 00:27:17,636
which will execute
that code concurrently.

545
00:27:17,636 --> 00:27:20,005
The async operation
on a dispatch queue

546
00:27:20,005 --> 00:27:22,608
is actually known to take
a Sendable closure,

547
00:27:22,608 --> 00:27:25,043
so the compiler produces
a warning indicating

548
00:27:25,043 --> 00:27:27,913
that there is a data race
when the non-Sendable body

549
00:27:27,913 --> 00:27:31,884
is captured by the code
running on the dispatch queue.

550
00:27:31,884 --> 00:27:36,889
We can fix this by making
the body parameter Sendable.

551
00:27:36,889 --> 00:27:38,991
That change eliminates
this warning,

552
00:27:38,991 --> 00:27:41,793
and now all of the callers
of doWork know

553
00:27:41,793 --> 00:27:45,564
that they need to provide
a Sendable closure.

554
00:27:45,564 --> 00:27:48,433
That means we get better
checking for data races,

555
00:27:48,433 --> 00:27:50,736
and we can see
that the visit function now

556
00:27:50,736 --> 00:27:53,472
is the source of a data race.

557
00:27:53,472 --> 00:27:55,474
Complete checking
will help flush out

558
00:27:55,474 --> 00:28:00,045
the potential data races
in your program.

559
00:28:00,045 --> 00:28:03,415
To achieve Swift's goal
of eliminating data races,

560
00:28:03,415 --> 00:28:06,818
we'll eventually need to get
to complete checking.

561
00:28:06,818 --> 00:28:10,822
We encourage you to work
incrementally toward that goal:

562
00:28:10,822 --> 00:28:12,691
adopt Swift's concurrency model

563
00:28:12,691 --> 00:28:15,294
to architect your app
for data race safety,

564
00:28:15,294 --> 00:28:18,297
then enable progressively
stricter concurrency checking

565
00:28:18,297 --> 00:28:21,433
to eliminate classes
of errors from your code.

566
00:28:21,433 --> 00:28:24,836
And don't fret over marking your
imports with @preconcurrency

567
00:28:24,836 --> 00:28:27,339
to suppress warnings
for imported types.

568
00:28:27,339 --> 00:28:30,509
As those modules adopt
stricter concurrency checking,

569
00:28:30,509 --> 00:28:33,912
the compiler will recheck
your assumptions.

570
00:28:33,912 --> 00:28:36,281
At the end of this road,
your code will benefit

571
00:28:36,281 --> 00:28:39,351
from both memory safety
and data race safety,

572
00:28:39,351 --> 00:28:42,854
helping you focus
on building great apps.

573
00:28:42,854 --> 00:28:47,225
And thank you for sailing with me
on the sea of concurrency.

574
00:28:47,225 --> 00:28:51,730
♪

