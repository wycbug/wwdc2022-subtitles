1
00:00:00,334 --> 00:00:07,341
♪ ♪

2
00:00:09,309 --> 00:00:11,545
Hi, my name is Yi.

3
00:00:11,578 --> 00:00:13,814
Hi, my name is Dominik.

4
00:00:13,847 --> 00:00:16,283
And we are GPU software engineers.

5
00:00:16,316 --> 00:00:20,287
Today, Dominik and I are going to talk
about the performance enhancements

6
00:00:20,320 --> 00:00:23,690
and features we've added
to the Metal Ray Tracing API this year

7
00:00:23,724 --> 00:00:27,060
to help you maximize the performance
of your ray tracing applications.

8
00:00:27,094 --> 00:00:30,731
Ray tracing applications simulate
individual rays of light

9
00:00:30,764 --> 00:00:33,000
bouncing around a scene.

10
00:00:33,033 --> 00:00:36,570
This is used in games
and offline rendering to produce

11
00:00:36,603 --> 00:00:41,975
photorealistic reflections,
shadows, global illumination, and more.

12
00:00:42,009 --> 00:00:44,545
This requires simulating a lot of rays,

13
00:00:44,578 --> 00:00:47,814
so performance is critical
for these applications.

14
00:00:47,848 --> 00:00:51,585
Fortunately, Metal has
built-in support for ray tracing

15
00:00:51,618 --> 00:00:54,388
optimized for all Apple devices.

16
00:00:54,421 --> 00:00:57,357
Let's briefly review
how ray tracing works in Metal.

17
00:00:57,391 --> 00:01:01,662
The Metal ray tracing API
is available from within shader functions

18
00:01:01,695 --> 00:01:05,265
such as compute or fragment functions.

19
00:01:05,299 --> 00:01:09,503
We start by generating some rays
which are emitted into the scene.

20
00:01:09,536 --> 00:01:13,473
Next, we create an intersector object
and use it to check

21
00:01:13,507 --> 00:01:18,011
for intersections between our rays
and the geometry in the scene.

22
00:01:18,045 --> 00:01:21,114
A bit later,
I will describe some of the new features

23
00:01:21,148 --> 00:01:24,418
we've added this year
to speed up the intersection search.

24
00:01:24,451 --> 00:01:26,920
This process depends
on a special data structure

25
00:01:26,954 --> 00:01:29,056
called an acceleration structure,

26
00:01:29,089 --> 00:01:32,292
which also represents
the geometry in the scene.

27
00:01:32,326 --> 00:01:36,129
I will also talk about several new
features and performance improvements

28
00:01:36,163 --> 00:01:38,732
focused on acceleration structures today.

29
00:01:38,765 --> 00:01:41,835
The intersector returns
an intersection result object

30
00:01:41,869 --> 00:01:45,038
describing the primitive each ray hit.

31
00:01:45,072 --> 00:01:50,711
The intersection result is used to produce
a color to write into the output image.

32
00:01:50,744 --> 00:01:53,514
It can also be used
to produce additional rays

33
00:01:53,547 --> 00:01:55,749
which go through the process again.

34
00:01:55,782 --> 00:01:58,485
We can repeat this process
as many times as we'd like

35
00:01:58,519 --> 00:02:01,054
to simulate light
bouncing around the scene.

36
00:02:01,088 --> 00:02:05,392
If you want to learn more about
the basics of the Metal ray tracing API,

37
00:02:05,425 --> 00:02:09,796
I recommend you review
our previous WWDC sessions.

38
00:02:09,830 --> 00:02:14,334
We first introduced the Metal
ray tracing API at WWDC20,

39
00:02:14,368 --> 00:02:19,139
and last year, we introduced new features
including support for motion blur.

40
00:02:19,173 --> 00:02:22,576
Today, I'm going to talk
about three things.

41
00:02:22,609 --> 00:02:26,680
First, I will tell you about new features
which enable you to improve

42
00:02:26,713 --> 00:02:29,082
ray tracing performance
in your applications.

43
00:02:30,817 --> 00:02:33,954
Next, I will talk about
improvements and features

44
00:02:33,987 --> 00:02:36,323
we've added
to the acceleration structure API.

45
00:02:38,258 --> 00:02:40,994
Finally, Dominik will tell you
about improvements

46
00:02:41,028 --> 00:02:43,897
to our GPU tools for ray tracing.

47
00:02:43,931 --> 00:02:46,266
This year, we've added three new features

48
00:02:46,300 --> 00:02:48,802
aimed at either improving
ray tracing performance

49
00:02:48,836 --> 00:02:51,004
or simplifying your code.

50
00:02:51,038 --> 00:02:54,708
They are per-primitive data,
the ability to retrieve buffers

51
00:02:54,741 --> 00:02:56,844
from intersection function tables,

52
00:02:56,877 --> 00:02:59,980
and support for ray tracing
from indirect command buffers.

53
00:03:01,949 --> 00:03:04,484
Let's start with per-primitive data.

54
00:03:04,518 --> 00:03:08,956
Applications usually have data associated
with the primitive in their scene

55
00:03:08,989 --> 00:03:12,559
such as vertex colors, normals,
and texture coordinates.

56
00:03:13,894 --> 00:03:16,296
This year,
we've added the ability to store

57
00:03:16,330 --> 00:03:21,235
small amounts of data for each primitive
directly in the acceleration structure.

58
00:03:21,268 --> 00:03:25,305
This data can be accessed with fewer
memory indirections and cache misses,

59
00:03:25,339 --> 00:03:27,374
improving performance.

60
00:03:27,407 --> 00:03:31,645
This also reduces the need to store
complicated auxiliary data structure

61
00:03:31,678 --> 00:03:35,883
which are typically required to look up
the data associated with your primitives.

62
00:03:37,184 --> 00:03:38,785
Let's look at an example.

63
00:03:39,853 --> 00:03:42,823
Alpha testing is a technique
used to add complexity

64
00:03:42,856 --> 00:03:47,127
to transparent geometry
without increasing the triangle count.

65
00:03:47,160 --> 00:03:51,064
In this technique, the alpha channel
of a texture mapped onto a triangle

66
00:03:51,098 --> 00:03:55,435
is used to determine if the ray should
hit the triangle or continue further.

67
00:03:56,670 --> 00:03:59,573
To achieve this,
you need to configure the intersector

68
00:03:59,606 --> 00:04:03,477
to call your custom intersection function
when a triangle is hit by the ray.

69
00:04:04,645 --> 00:04:08,982
The ultimate goal is to sample from
the texture associated with the triangle

70
00:04:09,016 --> 00:04:13,187
and test if the alpha value allows the ray
to continue through the primitive.

71
00:04:13,220 --> 00:04:16,757
To get there,
you need two pieces of information:

72
00:04:16,790 --> 00:04:20,093
the texture object and the UV coordinates.

73
00:04:20,127 --> 00:04:22,829
In a typical implementation
of alpha testing,

74
00:04:22,863 --> 00:04:25,832
you would need to access
a number of intermediate buffers

75
00:04:25,866 --> 00:04:29,002
in Metal device memory
in order to get this information.

76
00:04:30,370 --> 00:04:34,341
First, you would store the texture
associated with the primitive

77
00:04:34,374 --> 00:04:36,410
in some kind of material structure.

78
00:04:37,878 --> 00:04:41,081
Several materials would be
packed into a buffer.

79
00:04:41,114 --> 00:04:45,052
It would be impractical to store
material structure for every primitive,

80
00:04:45,085 --> 00:04:48,856
as they may be pretty big
and there may be a lot of primitives.

81
00:04:48,889 --> 00:04:52,125
Instead, you would want to store
just the material IDs

82
00:04:52,159 --> 00:04:56,630
for each primitive in a buffer
and use them to look up the materials.

83
00:04:56,663 --> 00:05:00,200
Next, to calculate UVs,
you need to load the UVs

84
00:05:00,234 --> 00:05:04,104
for each vertex from another buffer
and interpolate them.

85
00:05:04,137 --> 00:05:07,875
Finally, let's say you are
using instanced geometry.

86
00:05:07,908 --> 00:05:12,279
You may want each instance
to have its own materials and UV mappings.

87
00:05:12,312 --> 00:05:14,848
To support that, you would store pointers

88
00:05:14,882 --> 00:05:19,119
to UV and Material ID buffers
in an Instance Data buffer,

89
00:05:19,152 --> 00:05:22,556
adding yet another level
of indirection to your function.

90
00:05:22,589 --> 00:05:26,827
This approach requires you to maintain
a fairly complex buffer setup

91
00:05:26,860 --> 00:05:31,798
and involves many layers of indirection
to get to the data that you need.

92
00:05:31,832 --> 00:05:33,901
This may also lead to cache misses

93
00:05:33,934 --> 00:05:37,371
that would negatively affect
the performance.

94
00:05:37,404 --> 00:05:40,908
Let's look at the code needed
to implement this diagram.

95
00:05:40,941 --> 00:05:44,278
Then I will show you
how you can simplify it step-by-step

96
00:05:44,311 --> 00:05:46,180
using per-primitive data.

97
00:05:46,213 --> 00:05:50,817
This is the original implementation of
the alpha testing intersection function.

98
00:05:50,851 --> 00:05:54,922
This function is invoked when
the ray hits an alpha tested triangle.

99
00:05:54,955 --> 00:05:58,859
The function starts by loading
the instance data from the memory.

100
00:05:58,892 --> 00:06:02,896
This is the buffer that contains pointers
to UV and material buffers

101
00:06:02,930 --> 00:06:04,464
used by the instance.

102
00:06:04,498 --> 00:06:07,267
Next, the function loads
the UV coordinates

103
00:06:07,301 --> 00:06:10,237
from the UV buffer and interpolates them.

104
00:06:10,270 --> 00:06:12,105
This is another memory load.

105
00:06:12,139 --> 00:06:15,976
Then, the function loads
the material index from another buffer.

106
00:06:16,009 --> 00:06:18,445
And finally,
the function loads the material

107
00:06:18,478 --> 00:06:20,681
and samples the corresponding texture.

108
00:06:20,714 --> 00:06:24,051
At this point, the function has
the alpha value it needs

109
00:06:24,084 --> 00:06:26,086
and can compare it to the threshold.

110
00:06:26,119 --> 00:06:29,656
Now, I will show you
how you can simplify this code

111
00:06:29,690 --> 00:06:33,327
and improve its performance
using per-primitive data.

112
00:06:33,360 --> 00:06:35,829
Instead of using
a complicated buffer setup

113
00:06:35,863 --> 00:06:38,198
with multiple layers of indirection,

114
00:06:38,232 --> 00:06:41,702
you can simply store only the data
the intersection function will need

115
00:06:41,735 --> 00:06:45,405
for each primitive
directly in the acceleration structure.

116
00:06:45,439 --> 00:06:47,941
In this example, you can create a struct

117
00:06:47,975 --> 00:06:51,645
containing the texture and UV coordinates
for each primitive.

118
00:06:51,678 --> 00:06:54,815
You provide this data when building
the acceleration structure

119
00:06:54,848 --> 00:06:57,384
and the intersection function
simply receives a pointer

120
00:06:57,417 --> 00:07:00,254
to that data
when a ray hits the primitive.

121
00:07:00,287 --> 00:07:03,190
You can store anything you like
in the per-primitive data,

122
00:07:03,223 --> 00:07:07,327
but keeping the size small will
help achieve the best performance.

123
00:07:07,361 --> 00:07:10,597
I will start with the inputs
to the intersection function.

124
00:07:10,631 --> 00:07:13,901
Having access to all of them gives you
a lot of flexibility

125
00:07:13,934 --> 00:07:15,869
when it comes to the implementation,

126
00:07:15,903 --> 00:07:19,406
but it can also increase
the register usage on the GPU.

127
00:07:19,439 --> 00:07:22,676
With per-primitive data,
instead of all the buffers,

128
00:07:22,709 --> 00:07:26,146
you only need to access
the primitive data pointer.

129
00:07:26,180 --> 00:07:30,317
This is the data you store
directly in the acceleration structure.

130
00:07:30,350 --> 00:07:34,354
In this case, each primitive has
its own texture object and UVs

131
00:07:34,388 --> 00:07:36,757
for all of its vertices.

132
00:07:36,790 --> 00:07:41,461
Next up are the loads from the global
material buffer and instance data buffer.

133
00:07:41,495 --> 00:07:43,063
You won't need either of them.

134
00:07:43,096 --> 00:07:47,467
Instead, you can do one load
from the per-primitive data pointer.

135
00:07:47,501 --> 00:07:51,004
This is the only device memory access
needed in this function.

136
00:07:51,038 --> 00:07:52,606
Next up are the UVs.

137
00:07:52,639 --> 00:07:56,343
Instead of dereferencing a pointer
retrieved from the instance data,

138
00:07:56,376 --> 00:08:01,014
you can simply access the data embedded
in the per-primitive data structure.

139
00:08:01,048 --> 00:08:04,785
The change in the code is subtle,
but is important for performance,

140
00:08:04,818 --> 00:08:07,721
as no additional
memory loads are involved.

141
00:08:07,754 --> 00:08:10,424
Finally, there are
the material properties.

142
00:08:10,457 --> 00:08:13,794
Since the only part of the material
needed is the texture,

143
00:08:13,827 --> 00:08:15,729
you can encode the primitive's texture

144
00:08:15,762 --> 00:08:18,098
directly in the per-primitive
data structure.

145
00:08:18,131 --> 00:08:20,767
This means you don't need to access
the material

146
00:08:20,801 --> 00:08:22,936
and material index buffers anymore.

147
00:08:22,970 --> 00:08:24,972
You can simply use the texture directly

148
00:08:25,005 --> 00:08:28,442
without paying the cost
of additional memory dereferences.

149
00:08:28,475 --> 00:08:31,178
This is how much simpler
your intersection code can be

150
00:08:31,211 --> 00:08:33,313
when using per-primitive data.

151
00:08:33,347 --> 00:08:35,916
All the costly memory accesses
are replaced

152
00:08:35,949 --> 00:08:39,486
with just one load
from the primitive data pointer.

153
00:08:39,520 --> 00:08:43,524
On top of that, the code is
much simpler and easier to follow.

154
00:08:44,224 --> 00:08:47,160
Next, I will show you
how to store the primitive data

155
00:08:47,194 --> 00:08:49,363
in the acceleration structure.

156
00:08:49,396 --> 00:08:53,233
You will need to do this before you can
access it from an intersection function.

157
00:08:53,267 --> 00:08:55,369
You will need to set a few fields

158
00:08:55,402 --> 00:08:57,804
in the acceleration structure
geometry descriptor.

159
00:08:57,838 --> 00:09:01,008
First, set the Metal buffer
where all the data is stored.

160
00:09:01,041 --> 00:09:05,345
Next, specify the size of the data
that will be stored for each primitive.

161
00:09:05,379 --> 00:09:07,814
If your data is not tightly packed
in the buffer

162
00:09:07,848 --> 00:09:10,284
or doesn't start
at the beginning of the buffer,

163
00:09:10,317 --> 00:09:13,287
you can also specify
the stride and the offset.

164
00:09:13,320 --> 00:09:17,591
Otherwise, these values default to 0
so you don't need to set them.

165
00:09:17,624 --> 00:09:20,527
You have already seen
how you can use per-primitive data

166
00:09:20,561 --> 00:09:21,828
in an intersection function.

167
00:09:21,862 --> 00:09:24,398
It's simply passed
into the function as a pointer.

168
00:09:24,431 --> 00:09:28,402
But that's not all–you have access
to this data wherever you need it.

169
00:09:28,435 --> 00:09:32,306
That includes the final intersection
result returned by the intersector.

170
00:09:32,339 --> 00:09:36,844
And if you are using intersection query,
the primitive data is also available

171
00:09:36,877 --> 00:09:39,746
for both candidate
and committed intersections.

172
00:09:39,780 --> 00:09:43,116
This means you can use per-primitive data
for shading

173
00:09:43,150 --> 00:09:45,319
in addition to intersection testing.

174
00:09:45,352 --> 00:09:48,021
Per-primitive data can
improve the performance

175
00:09:48,055 --> 00:09:50,657
of both your intersection code
and your shading code

176
00:09:50,691 --> 00:09:54,828
by reducing the number
of memory accesses and indirections.

177
00:09:54,862 --> 00:09:58,265
In fact, we found
in one of our own test applications

178
00:09:58,298 --> 00:10:03,704
that using per-primitive data resulted
in a 10% to 16% performance improvement.

179
00:10:03,737 --> 00:10:05,472
We can't wait for you to try it out

180
00:10:05,506 --> 00:10:08,008
and see what kinds of improvements
you can get

181
00:10:08,041 --> 00:10:11,712
in performance and code quality.

182
00:10:11,745 --> 00:10:14,748
This year, we've also added
another convenience feature

183
00:10:14,781 --> 00:10:18,952
to the Metal shading language to help you
simplify your ray tracing kernels.

184
00:10:18,986 --> 00:10:22,322
Applications often pass
the same set of bindings

185
00:10:22,356 --> 00:10:26,593
to both their intersection functions
and their main ray tracing kernel.

186
00:10:26,627 --> 00:10:29,530
For example,
our ray tracing sample code uses

187
00:10:29,563 --> 00:10:32,065
an intersection function
to render spheres.

188
00:10:32,099 --> 00:10:35,068
This intersection function
accesses a resource buffer

189
00:10:35,102 --> 00:10:37,471
containing information about each sphere.

190
00:10:37,504 --> 00:10:40,174
In order to pass this buffer
into the intersection function,

191
00:10:40,207 --> 00:10:43,477
the app binds the buffer
to the intersection function table.

192
00:10:43,510 --> 00:10:48,315
However, the main ray tracing kernel
also needs access to the resource buffer,

193
00:10:48,348 --> 00:10:50,851
so the app binds the buffer there as well.

194
00:10:50,884 --> 00:10:53,554
This year,
the Metal shading language allows you

195
00:10:53,587 --> 00:10:57,191
to access the buffers
bound to intersection function tables.

196
00:10:57,224 --> 00:10:59,726
With this new feature,
you can save the effort

197
00:10:59,760 --> 00:11:03,797
of binding the buffer for the kernel,
and instead access it directly

198
00:11:03,830 --> 00:11:05,699
from the intersection function table.

199
00:11:05,732 --> 00:11:08,468
You can do this by calling
the get_buffer method

200
00:11:08,502 --> 00:11:11,839
on the intersection function table,
providing its pointer type.

201
00:11:11,872 --> 00:11:15,642
You can also access visible
function tables by their function type.

202
00:11:15,676 --> 00:11:20,180
Indirect command buffers allow you to
encode GPU work independently on the GPU

203
00:11:20,214 --> 00:11:24,618
and represent a fundamental element
of GPU driven pipelines.

204
00:11:24,651 --> 00:11:26,653
To learn more about
indirect command buffers

205
00:11:26,687 --> 00:11:29,756
and GPU-driven rendering,
we recommend you review

206
00:11:29,790 --> 00:11:33,894
the "Modern rendering with Metal"
session from WWDC 2019.

207
00:11:33,927 --> 00:11:37,464
Enabling ray tracing support
in an indirect command buffer is easy.

208
00:11:37,497 --> 00:11:40,601
All you have to do is to set
the supportRayTracing flag

209
00:11:40,634 --> 00:11:42,069
on the descriptor.

210
00:11:42,102 --> 00:11:46,139
Indirect command buffers
dispatch graphics and compute functions,

211
00:11:46,173 --> 00:11:50,344
so you can simply use ray tracing
from those functions as usual.

212
00:11:50,377 --> 00:11:53,881
That's a rundown of all
the new features we've added this year

213
00:11:53,914 --> 00:11:58,218
to help you get improved ray tracing
performance in your applications.

214
00:11:58,252 --> 00:12:01,755
Next, let's talk
about acceleration structures.

215
00:12:01,788 --> 00:12:04,424
We've implemented several
performance improvements

216
00:12:04,458 --> 00:12:08,228
and added features focused
on building acceleration structures.

217
00:12:08,262 --> 00:12:10,631
Let's recap what they are used for.

218
00:12:10,664 --> 00:12:13,033
Acceleration structures
are data structures

219
00:12:13,066 --> 00:12:15,802
which accelerate the ray tracing process.

220
00:12:15,836 --> 00:12:18,805
They do this
by recursively partitioning space

221
00:12:18,839 --> 00:12:23,343
so we can quickly find which triangles
are likely to intersect a ray.

222
00:12:23,377 --> 00:12:25,412
To support building complex scenes,

223
00:12:25,445 --> 00:12:28,549
Metal supports two types
of acceleration structures:

224
00:12:28,582 --> 00:12:31,518
primitive and instance
acceleration structures.

225
00:12:31,552 --> 00:12:34,221
Individual pieces of geometry
are represented

226
00:12:34,254 --> 00:12:36,690
using primitive acceleration structures.

227
00:12:36,723 --> 00:12:40,194
They can be something simple
like a plane or a cube,

228
00:12:40,227 --> 00:12:44,398
or something more complex
like a sphere or a triangle mesh.

229
00:12:44,431 --> 00:12:48,635
You can create more complex scenes
using an instance acceleration structure.

230
00:12:48,669 --> 00:12:51,338
Instance acceleration structures
create copies

231
00:12:51,371 --> 00:12:53,140
of primitive acceleration structures.

232
00:12:53,173 --> 00:12:58,078
First, define transformation matrices
for each object in your scene.

233
00:12:58,111 --> 00:13:01,014
Then, use the array
of transformation matrices

234
00:13:01,048 --> 00:13:02,916
and primitive acceleration structures

235
00:13:02,950 --> 00:13:05,619
to build
an instance acceleration structure.

236
00:13:05,652 --> 00:13:09,823
That's how you can build a static scene
using acceleration structures.

237
00:13:09,857 --> 00:13:12,659
Next, let's see how dynamic applications

238
00:13:12,693 --> 00:13:15,128
like a game would use
acceleration structures.

239
00:13:16,196 --> 00:13:18,131
Let's start at the beginning:

240
00:13:18,165 --> 00:13:19,933
there are several tasks you need to do

241
00:13:19,967 --> 00:13:22,970
when first launching a game
or loading a new level.

242
00:13:23,003 --> 00:13:27,674
This includes the normal tasks
like loading models and textures.

243
00:13:27,708 --> 00:13:31,612
With ray tracing, you also need to build
primitive acceleration structures

244
00:13:31,645 --> 00:13:34,515
for all of the models which will be used.

245
00:13:34,548 --> 00:13:37,951
We recommend that you build as many
of your primitive acceleration structures

246
00:13:37,985 --> 00:13:42,189
as possible at load time
to save time in your main rendering loop.

247
00:13:42,222 --> 00:13:44,391
You can use
an instance acceleration structure

248
00:13:44,424 --> 00:13:48,529
to add or remove these objects
from the scene as needed.

249
00:13:48,562 --> 00:13:51,765
Once your app is done loading,
it enters the main loop.

250
00:13:51,798 --> 00:13:54,868
Every frame,
it renders the scene using a combination

251
00:13:54,902 --> 00:13:58,438
of rasterization, ray tracing,
and post-processing.

252
00:13:58,472 --> 00:14:01,041
However, since games are very dynamic,

253
00:14:01,074 --> 00:14:05,045
you will probably need to update
some of the acceleration structures.

254
00:14:05,078 --> 00:14:08,348
This typically includes refitting
a handful of deforming

255
00:14:08,382 --> 00:14:11,518
or animated models
such as skinned characters.

256
00:14:11,552 --> 00:14:14,688
Refitting an existing
acceleration structure is much faster

257
00:14:14,721 --> 00:14:18,859
than a full rebuild, so we recommend
using it for cases like this.

258
00:14:18,892 --> 00:14:22,563
You should also do a full rebuild
of the instance acceleration structure.

259
00:14:22,596 --> 00:14:26,500
This is necessary since objects may have
been added or removed

260
00:14:26,533 --> 00:14:30,504
from the scene since the last frame,
or they may have moved significantly.

261
00:14:30,537 --> 00:14:33,974
Doing a full rebuild is fine in this case
since there's only one

262
00:14:34,007 --> 00:14:35,576
instance acceleration structure

263
00:14:35,609 --> 00:14:39,246
and it usually only contains at most
a few thousand objects.

264
00:14:39,279 --> 00:14:43,483
This year, we've improved performance
for all of these cases.

265
00:14:43,517 --> 00:14:46,253
First, acceleration structure builds

266
00:14:46,286 --> 00:14:49,957
are now up to 2.3 times faster
on Apple Silicon.

267
00:14:49,990 --> 00:14:53,427
Second, refitting is also
up to 38% faster.

268
00:14:54,428 --> 00:14:58,832
This means that both load times
and per-frame overhead are reduced.

269
00:14:58,866 --> 00:15:00,534
But it gets even better.

270
00:15:00,567 --> 00:15:03,370
Some applications build hundreds
or even thousands

271
00:15:03,403 --> 00:15:05,606
of small primitive
acceleration structures.

272
00:15:05,639 --> 00:15:08,475
These small builds
don't do enough work individually

273
00:15:08,509 --> 00:15:13,547
to fill up the GPU, resulting in
long periods of low GPU utilization.

274
00:15:13,580 --> 00:15:16,450
Therefore, multiple builds are
now automatically performed

275
00:15:16,483 --> 00:15:19,520
in parallel whenever possible
on Apple Silicon.

276
00:15:19,553 --> 00:15:22,322
This results
in up to 2.8 times faster builds

277
00:15:22,356 --> 00:15:24,224
when they run in parallel.

278
00:15:24,258 --> 00:15:26,426
This further reduces load times.

279
00:15:26,460 --> 00:15:28,395
And this doesn't just apply to builds:

280
00:15:28,428 --> 00:15:31,365
it applies to all
of the acceleration structure operations

281
00:15:31,398 --> 00:15:34,134
including compacting and refitting,

282
00:15:34,168 --> 00:15:37,504
so your per-frame overhead
is reduced as well.

283
00:15:37,538 --> 00:15:39,840
There are a few guidelines
you will need to follow

284
00:15:39,873 --> 00:15:43,043
to ensure that you can benefit
from this optimization.

285
00:15:43,076 --> 00:15:46,780
Here is an example that builds
an array of acceleration structures.

286
00:15:46,813 --> 00:15:49,850
To build them in parallel,
you will need to ensure that you use

287
00:15:49,883 --> 00:15:53,387
the same acceleration structure
command encoder for many builds.

288
00:15:53,420 --> 00:15:58,492
Additionally, builds which use the same
scratch buffer can't run in parallel.

289
00:15:58,525 --> 00:16:02,396
Therefore, you will want to ensure
that you are looping through a small pool

290
00:16:02,429 --> 00:16:06,033
of scratch buffers rather than using
the same scratch buffer for each build.

291
00:16:07,234 --> 00:16:09,369
Those are all the performance improvements

292
00:16:09,403 --> 00:16:12,606
we've made to building
acceleration structures.

293
00:16:12,639 --> 00:16:14,675
We've also added three new features

294
00:16:14,708 --> 00:16:18,212
to make building acceleration structures
easier and more efficient.

295
00:16:19,546 --> 00:16:24,284
They are support for additional
vertex formats, transformation matrices,

296
00:16:24,318 --> 00:16:26,954
and acceleration structure allocation
from heaps.

297
00:16:29,089 --> 00:16:32,326
Let's start with vertex formats.

298
00:16:32,359 --> 00:16:35,596
A common performance optimization
is to use quantized

299
00:16:35,629 --> 00:16:39,166
or reduced precision formats
for vertex data,

300
00:16:39,199 --> 00:16:41,468
resulting in lower memory usage.

301
00:16:41,502 --> 00:16:44,137
This year, you can build
acceleration structures

302
00:16:44,171 --> 00:16:46,607
from a wide range of vertex formats.

303
00:16:46,640 --> 00:16:50,577
This includes half precision
floating point formats,

304
00:16:50,611 --> 00:16:53,981
two component vertex formats
for planar geometry,

305
00:16:54,014 --> 00:16:57,584
and all the usual
normalized integer formats.

306
00:16:57,618 --> 00:17:00,687
Previously,
acceleration structures have required

307
00:17:00,721 --> 00:17:04,191
three component,
full-precision floating point vertex data.

308
00:17:04,224 --> 00:17:07,427
In this example,
the application has vertex data

309
00:17:07,461 --> 00:17:10,097
in a half precision vertex format.

310
00:17:10,130 --> 00:17:14,067
This data needs to be unpacked
and copied into a temporary buffer

311
00:17:14,101 --> 00:17:16,537
just to build the acceleration structure.

312
00:17:16,570 --> 00:17:18,605
With the new vertex formats feature,

313
00:17:18,639 --> 00:17:21,808
acceleration structure builds
can now consume vertex data

314
00:17:21,842 --> 00:17:24,111
in any of the supported formats,

315
00:17:24,144 --> 00:17:27,281
eliminating the need to create
a temporary copy.

316
00:17:27,314 --> 00:17:29,850
Setting the vertex format
couldn't be simpler.

317
00:17:29,883 --> 00:17:34,121
All you need to do is set the property
on your geometry descriptor.

318
00:17:34,154 --> 00:17:37,357
Next, let's talk about
transformation matrices.

319
00:17:37,391 --> 00:17:40,227
This feature complements
the new vertex formats,

320
00:17:40,260 --> 00:17:42,629
so that you can pre-transform
your vertex data

321
00:17:42,663 --> 00:17:45,199
before building
the acceleration structure.

322
00:17:45,232 --> 00:17:47,701
For example, you might want to use them

323
00:17:47,734 --> 00:17:51,505
to unpack complex meshes
stored in a normalized format.

324
00:17:51,538 --> 00:17:54,808
Let's consider
the Red Panda model in this scene.

325
00:17:54,842 --> 00:17:58,712
To normalize the geometry to use
one of our compressed formats,

326
00:17:58,745 --> 00:18:01,715
you take the mesh, calculate its bounds,

327
00:18:01,748 --> 00:18:04,952
and then scale them
to a zero to one range.

328
00:18:04,985 --> 00:18:09,189
You can then use one of the normalized
integer vertex formats to store the mesh,

329
00:18:09,223 --> 00:18:13,760
reducing the amount of space
it takes up on disk and in memory.

330
00:18:13,794 --> 00:18:17,598
At runtime,
you provide a matrix that will scale

331
00:18:17,631 --> 00:18:21,134
and offset each vertex
to the final position.

332
00:18:21,168 --> 00:18:25,038
Applying that matrix
retrieves the original model.

333
00:18:25,072 --> 00:18:28,509
Now let's walk through
how to set up acceleration structure

334
00:18:28,542 --> 00:18:30,611
passing a transformation matrix.

335
00:18:30,644 --> 00:18:33,714
You start by creating
the transform buffer.

336
00:18:33,747 --> 00:18:38,519
One way of doing this is to create
an MTLPackedFloat4x3 object

337
00:18:38,552 --> 00:18:41,889
containing the scale
and offset transformation matrix.

338
00:18:41,922 --> 00:18:46,193
Then, create a Metal Buffer
big enough to hold the matrix.

339
00:18:46,226 --> 00:18:49,796
And finally,
copy the matrix to the Buffer.

340
00:18:49,830 --> 00:18:52,666
Next, set up the acceleration structure.

341
00:18:52,699 --> 00:18:55,536
First, create
a triangle geometry descriptor.

342
00:18:55,569 --> 00:18:58,705
Then, specify
the transformation Matrix Buffer.

343
00:18:58,739 --> 00:19:01,575
And finally the Buffer Offset.

344
00:19:01,608 --> 00:19:05,179
That's all you need to do to set up
the transformation matrix.

345
00:19:05,212 --> 00:19:09,550
These matrices can also be used
to combine simple acceleration structures

346
00:19:09,583 --> 00:19:11,985
to improve ray tracing performance.

347
00:19:12,019 --> 00:19:14,188
Let's see an example scene.

348
00:19:14,221 --> 00:19:19,092
Here, the boxes and the spheres
are all relatively simple meshes.

349
00:19:19,126 --> 00:19:22,729
This presents an opportunity
to optimize the acceleration structure

350
00:19:22,763 --> 00:19:25,566
for this group at the front of the scene.

351
00:19:25,599 --> 00:19:28,535
Focusing on
the instance acceleration structure,

352
00:19:28,569 --> 00:19:32,272
there is an overhead for each instance
that your rays hit.

353
00:19:32,306 --> 00:19:34,441
There is a cost for transforming the ray

354
00:19:34,474 --> 00:19:38,412
and then switching from the instance
to the primitive acceleration structure.

355
00:19:38,445 --> 00:19:42,316
This occurs more often
with overlapping instances.

356
00:19:42,349 --> 00:19:44,151
To reduce the instance count,

357
00:19:44,184 --> 00:19:46,954
you can generate
a single primitive acceleration structure

358
00:19:46,987 --> 00:19:50,591
that contains
both the boxes and the sphere.

359
00:19:50,624 --> 00:19:53,427
To do this,
you can create a geometry descriptor

360
00:19:53,460 --> 00:19:57,397
for each object,
each with its own transformation matrix.

361
00:19:57,431 --> 00:20:00,834
The resulting primitive acceleration
structure is a single instance

362
00:20:00,868 --> 00:20:05,606
in the instance acceleration structure
and contains the boxes and sphere.

363
00:20:05,639 --> 00:20:09,309
This should result in a better
performing acceleration structure.

364
00:20:09,343 --> 00:20:11,378
Let's see how to set this up in code.

365
00:20:12,779 --> 00:20:16,416
You start with the descriptor
that defines the sphere geometry.

366
00:20:16,450 --> 00:20:20,721
Next, set the vertex buffer,
index buffer, and other properties

367
00:20:20,754 --> 00:20:24,024
as usual
for a primitive acceleration structure.

368
00:20:24,057 --> 00:20:26,927
The difference is, you also specify
the transform buffer

369
00:20:26,960 --> 00:20:30,797
that contains the transformation matrix
used for the copy of the sphere.

370
00:20:32,466 --> 00:20:35,502
For the boxes,
you have multiple geometry descriptors

371
00:20:35,536 --> 00:20:38,372
sharing a vertex and index buffer.

372
00:20:38,405 --> 00:20:42,609
You just need to specify different
transform buffers for each copy.

373
00:20:42,643 --> 00:20:47,114
Finally, when creating the descriptor
for the primitive acceleration structure,

374
00:20:47,147 --> 00:20:49,750
add all the geometry descriptors.

375
00:20:49,783 --> 00:20:52,419
This will result
in a primitive acceleration structure

376
00:20:52,452 --> 00:20:56,123
that you can instance into the scene
with an identity transform.

377
00:20:56,156 --> 00:20:59,393
This primitive acceleration structure
will take less time to build

378
00:20:59,426 --> 00:21:03,330
than separate acceleration structures
and will be faster to intersect.

379
00:21:04,998 --> 00:21:08,502
Finally, heap allocation
of acceleration structures has been

380
00:21:08,535 --> 00:21:11,605
one of our most requested features.

381
00:21:11,638 --> 00:21:14,041
With this feature,
you now have more control

382
00:21:14,074 --> 00:21:16,577
over acceleration structure allocation.

383
00:21:16,610 --> 00:21:20,047
It also allows you to reuse
heap memory between allocations,

384
00:21:20,080 --> 00:21:23,250
avoiding expensive buffer allocations.

385
00:21:23,283 --> 00:21:27,054
Heaps can also help improve performance
by reducing calls

386
00:21:27,087 --> 00:21:31,525
to the useResource: method when using
instance acceleration structures.

387
00:21:31,558 --> 00:21:33,794
Going back to the example scene,

388
00:21:33,827 --> 00:21:36,430
the instance acceleration structure
references

389
00:21:36,463 --> 00:21:39,132
primitive acceleration structures
indirectly.

390
00:21:39,166 --> 00:21:42,870
This means that each time you want to use
an instance acceleration structure

391
00:21:42,903 --> 00:21:46,507
with a command encoder,
you need to call useResource: method

392
00:21:46,540 --> 00:21:49,243
for each primitive acceleration structure.

393
00:21:49,276 --> 00:21:52,346
For large scenes,
this could require thousands of calls

394
00:21:52,379 --> 00:21:56,116
to useResource: each time you use
the instance acceleration structure.

395
00:21:56,149 --> 00:21:58,852
Knowing that you have
so many useResource: calls,

396
00:21:58,886 --> 00:22:02,656
you could call useResources:
to reduce the number of API calls,

397
00:22:02,689 --> 00:22:06,260
but you still need to maintain
an array of your acceleration structures

398
00:22:06,293 --> 00:22:09,062
and Metal still needs to loop
through the array.

399
00:22:09,096 --> 00:22:11,064
Instead, you can allocate

400
00:22:11,098 --> 00:22:14,668
all of these primitive acceleration
structures from the same heap.

401
00:22:14,701 --> 00:22:17,704
When you want to use
the instance acceleration structure,

402
00:22:17,738 --> 00:22:20,874
you can simply make a single call
to the useHeap: method

403
00:22:20,908 --> 00:22:24,077
to reference all
of the primitive acceleration structures.

404
00:22:24,111 --> 00:22:27,147
We saw a small performance improvement
in one application

405
00:22:27,181 --> 00:22:29,816
simply by replacing the calls
to useResource:

406
00:22:29,850 --> 00:22:32,186
with a single call to useHeap:.

407
00:22:32,219 --> 00:22:35,455
Let's see how you can allocate
an acceleration structure from a heap.

408
00:22:35,489 --> 00:22:39,793
You can directly allocate an acceleration
structure by calling a method on the heap

409
00:22:39,826 --> 00:22:43,197
that takes the acceleration structure
descriptor as the input.

410
00:22:43,230 --> 00:22:46,066
If you are not allocating
using the descriptor,

411
00:22:46,099 --> 00:22:49,703
the Metal device determines
the size and alignment requirement

412
00:22:49,736 --> 00:22:52,606
for allocating
the acceleration structure from a heap.

413
00:22:52,639 --> 00:22:55,309
You can get this information
from the Metal device

414
00:22:55,342 --> 00:22:59,012
by providing the descriptor
or acceleration structure size.

415
00:22:59,046 --> 00:23:01,148
Once the final size is determined,

416
00:23:01,181 --> 00:23:04,351
you can allocate the acceleration
structure from the heap.

417
00:23:04,384 --> 00:23:07,621
There are a few things to remember
when using heaps.

418
00:23:07,654 --> 00:23:12,025
First, remember to call useHeap:
to make all of the acceleration structures

419
00:23:12,059 --> 00:23:15,596
in the heap resident
for the duration of the ray tracing pass.

420
00:23:15,629 --> 00:23:20,734
Second, by default, Metal doesn't track
resources you allocate from a heap.

421
00:23:20,767 --> 00:23:23,570
You can either opt-in
to resource hazard tracking,

422
00:23:23,604 --> 00:23:27,407
or you can manually manage
your own synchronization.

423
00:23:27,441 --> 00:23:31,512
You can use MTLFences to synchronize
across command encoders

424
00:23:31,545 --> 00:23:35,215
and MTLEvents to synchronize
across command buffers.

425
00:23:35,249 --> 00:23:38,352
Those are the new features
and performance improvements

426
00:23:38,385 --> 00:23:40,921
in the Metal ray tracing API this year.

427
00:23:40,954 --> 00:23:43,991
Next, Dominik will talk about improvements

428
00:23:44,024 --> 00:23:47,294
to Xcode's Metal tools
that will boost your productivity

429
00:23:47,327 --> 00:23:49,196
when developing ray tracing applications.

430
00:23:49,229 --> 00:23:50,964
Dominik: Thanks, Yi.

431
00:23:50,998 --> 00:23:54,401
There are a lot of enhancements
to the Metal tools in Xcode 14,

432
00:23:54,434 --> 00:23:57,104
but here, I would like to highlight
just a few

433
00:23:57,137 --> 00:24:00,674
that are especially useful
when developing ray tracing applications

434
00:24:01,642 --> 00:24:04,678
Starting with the Metal debugger,
I'll talk about improvements

435
00:24:04,711 --> 00:24:09,583
to the Acceleration Structure Viewer,
Shader Profiler, and Shader Debugger.

436
00:24:10,551 --> 00:24:14,388
Then I'll round it up
with the runtime Shader Validation.

437
00:24:16,523 --> 00:24:21,161
First, let's take a look
at the Acceleration Structure Viewer.

438
00:24:21,195 --> 00:24:25,999
The Acceleration Structure Viewer in
the Metal Debugger enables you to inspect,

439
00:24:26,033 --> 00:24:29,169
in great detail,
all of the geometries and instances

440
00:24:29,203 --> 00:24:32,573
of all the meshes that make up
your acceleration structure.

441
00:24:34,141 --> 00:24:37,744
Xcode 14 now supports
debugging acceleration structures

442
00:24:37,778 --> 00:24:41,982
with primitive or instanced motion
and a new highlight mode

443
00:24:42,015 --> 00:24:46,954
for visualizing primitives
with an inspector for per-primitive data.

444
00:24:46,987 --> 00:24:48,722
Let's see them in action.

445
00:24:49,523 --> 00:24:52,593
If you are using
acceleration structures with motion,

446
00:24:52,626 --> 00:24:55,095
you now have a scrubber in the bottom bar

447
00:24:55,128 --> 00:24:58,899
for viewing your acceleration structure
at different points in time.

448
00:24:58,932 --> 00:25:02,135
On the right of the scrubber
is a "play" button.

449
00:25:02,169 --> 00:25:05,339
You can use it to play the animation
back and forth in a loop.

450
00:25:05,372 --> 00:25:08,976
Now let me show you
how to inspect individual primitives

451
00:25:09,009 --> 00:25:11,144
in your acceleration structure.

452
00:25:11,178 --> 00:25:15,516
This is especially useful if you are
using the new per-primitive data API.

453
00:25:15,549 --> 00:25:19,853
And so there's a new highlight mode
just for this.

454
00:25:19,887 --> 00:25:23,790
Primitive highlight mode gives you access
to all primitive data...

455
00:25:25,292 --> 00:25:29,296
And allows you to select specific
primitives for detailed inspection.

456
00:25:30,631 --> 00:25:34,468
In the left sidebar,
you can find arrows next to the data rows.

457
00:25:35,736 --> 00:25:38,438
Clicking on an arrow will reveal a popover

458
00:25:38,472 --> 00:25:41,308
that displays the corresponding data
for the primitive.

459
00:25:41,341 --> 00:25:44,178
These additions
to the acceleration structure viewer

460
00:25:44,211 --> 00:25:47,581
ensure you have full access,
down to each primitive,

461
00:25:47,614 --> 00:25:51,952
to all of the components
that make up your acceleration structure.

462
00:25:51,985 --> 00:25:55,522
Next, let's talk about improvements
to the Shader Profiler.

463
00:25:55,556 --> 00:26:00,160
The Shader Profiler gives you insights
into the performance of your shader,

464
00:26:00,194 --> 00:26:03,297
providing per-pipeline
execution timing costs,

465
00:26:03,330 --> 00:26:07,968
and on Apple GPUs, it provides
more granularity at the source level,

466
00:26:08,001 --> 00:26:13,240
showing the execution costs per-line
distributed across instruction categories.

467
00:26:13,273 --> 00:26:17,477
In Xcode 14,
profiling GPU captures has been updated

468
00:26:17,511 --> 00:26:22,516
to support intersection functions,
visible functions, and dynamic libraries.

469
00:26:23,884 --> 00:26:28,388
Here we have a ray tracing kernel
using an intersection function.

470
00:26:28,422 --> 00:26:31,091
You can now view
the per-line profiling results

471
00:26:31,124 --> 00:26:33,861
inside of the intersection function.

472
00:26:33,894 --> 00:26:36,496
This includes a breakdown
of the instruction categories

473
00:26:36,530 --> 00:26:38,365
that contribute to the cost.

474
00:26:41,969 --> 00:26:45,005
Profiling visible functions
works the same way.

475
00:26:46,306 --> 00:26:49,409
And similarly,
detailed profiling information

476
00:26:49,443 --> 00:26:53,180
is now available for shader code
from linked dynamic libraries.

477
00:26:53,213 --> 00:26:56,283
With these additions,
you now have the full breakdown

478
00:26:56,316 --> 00:26:59,953
of the performance of your pipeline,
down to each line of code.

479
00:27:02,122 --> 00:27:04,024
Moving on to the Shader Debugger.

480
00:27:04,057 --> 00:27:05,158
The Shader Debugger provides

481
00:27:05,192 --> 00:27:07,528
a unique
and incredibly productive workflow

482
00:27:07,561 --> 00:27:10,397
for debugging the correctness
of your shader code.

483
00:27:10,430 --> 00:27:13,634
Just like with the Shader Profiler,
we've also extended support

484
00:27:13,667 --> 00:27:17,271
to enable debugging of Linked functions
and Dynamic libraries.

485
00:27:17,304 --> 00:27:19,806
Here we have a ray tracing kernel
that calls out

486
00:27:19,840 --> 00:27:24,011
to a linked visible function passed in
through a visible function table.

487
00:27:27,247 --> 00:27:30,250
You are now able to follow
the execution of a kernel

488
00:27:30,284 --> 00:27:32,920
all the way
into your visible function code

489
00:27:32,953 --> 00:27:36,123
to verify that the code behaves
as you expect it to.

490
00:27:37,257 --> 00:27:41,195
Again, the same applies
to debugging dynamic libraries.

491
00:27:41,228 --> 00:27:45,265
You are also able to jump into
and out of any executed dynamic libraries

492
00:27:45,299 --> 00:27:47,134
that are linked to your pipeline.

493
00:27:47,167 --> 00:27:48,802
With these additions, you now have

494
00:27:48,836 --> 00:27:51,104
a complete picture
of your shader execution

495
00:27:51,138 --> 00:27:54,141
across linked functions
and libraries in your pipeline.

496
00:27:55,943 --> 00:27:59,379
Now, before you capture
and jump into the Shader Debugger,

497
00:27:59,413 --> 00:28:03,050
it is often a good idea to enable
Shader Validation at runtime.

498
00:28:05,686 --> 00:28:10,324
Shader validation is a great way
to diagnose runtime errors on the GPU,

499
00:28:10,357 --> 00:28:14,027
catching issues
such as out-of-bound memory accesses,

500
00:28:14,061 --> 00:28:16,463
null texture reads, and more.

501
00:28:16,496 --> 00:28:20,534
To enable Shader Validation in Xcode,
all you need to do is to go

502
00:28:20,567 --> 00:28:24,037
to the "Edit Scheme" dialog,
select the "Run" action,

503
00:28:24,071 --> 00:28:28,775
and under the "diagnostics" tab
tick the "Shader Validation" checkbox.

504
00:28:28,809 --> 00:28:31,044
And you are all set to go.

505
00:28:31,078 --> 00:28:34,748
In Metal 3, we have added
Stack Overflow detection

506
00:28:34,781 --> 00:28:36,350
which will help you quickly find issues

507
00:28:36,383 --> 00:28:40,220
that would otherwise result
in undefined behavior.

508
00:28:40,254 --> 00:28:43,524
I'll quickly elaborate
on the function stack in Metal shaders

509
00:28:43,557 --> 00:28:45,726
and the problem of Stack Overflow.

510
00:28:45,759 --> 00:28:48,795
The call stack is a region
in device memory

511
00:28:48,829 --> 00:28:53,267
where Metal stores the values of local
data used in your shader functions.

512
00:28:53,300 --> 00:28:56,103
If the called function is
not known at compile time,

513
00:28:56,136 --> 00:28:58,405
Metal needs your help in estimating

514
00:28:58,438 --> 00:29:01,642
the amount of memory required
for the stack.

515
00:29:01,675 --> 00:29:05,345
An example of a call to a function
that is unknown at compile time

516
00:29:05,379 --> 00:29:08,448
may be a ray tracing
intersection function.

517
00:29:08,482 --> 00:29:11,051
If you are using
custom intersection functions,

518
00:29:11,084 --> 00:29:16,123
maximum call stack depth should be
set to 1, to allocate space for it.

519
00:29:16,156 --> 00:29:19,826
This is the default value, so there is
nothing more that you need to do.

520
00:29:19,860 --> 00:29:24,231
However, if you are using Function Tables
to call into a Visible function,

521
00:29:24,264 --> 00:29:28,302
this is another example of a function call
unknown at compile time.

522
00:29:28,335 --> 00:29:31,038
If you perform such a call
from an intersection function,

523
00:29:31,071 --> 00:29:34,708
like in this example,
your call stack will be two levels deep.

524
00:29:36,376 --> 00:29:39,813
Another example are calls
to dynamic libraries

525
00:29:39,847 --> 00:29:43,250
and calling a local function
using a function pointer.

526
00:29:43,283 --> 00:29:47,020
In this example, our call stack has
four levels with nested calls

527
00:29:47,054 --> 00:29:48,789
to different types of functions

528
00:29:48,822 --> 00:29:51,625
that cannot be resolved
when the shader is compiled.

529
00:29:51,658 --> 00:29:55,095
To properly configure Metal
to allocate the right amount of memory,

530
00:29:55,128 --> 00:29:59,633
you need to specify a maximum
call stack depth of 4 yourself.

531
00:29:59,666 --> 00:30:02,469
The important thing to remember
is that when the value

532
00:30:02,503 --> 00:30:05,772
of the max Call Stack Depth is set
too low for your program,

533
00:30:05,806 --> 00:30:09,843
Stack Overflow can happen,
resulting in undefined behavior.

534
00:30:09,877 --> 00:30:13,313
But if you are running
with Shader Validation enabled,

535
00:30:13,347 --> 00:30:15,582
such situations will be caught early,

536
00:30:15,616 --> 00:30:20,254
and you will see information in Xcode
about where the Stack Overflow occurred.

537
00:30:20,287 --> 00:30:22,856
You can then go and fix your shader code,

538
00:30:22,890 --> 00:30:26,560
or adjust your maximum call stack depth
in the pipeline descriptor.

539
00:30:26,593 --> 00:30:30,297
All of these new improvements
to the Metal tools in Xcode 14

540
00:30:30,330 --> 00:30:33,133
ensure you have an even more
complete picture and insight

541
00:30:33,166 --> 00:30:37,304
into the performance and correctness
of your ray tracing applications.

542
00:30:37,337 --> 00:30:40,340
For more on how to get the most
out of the Metal tools for debugging

543
00:30:40,374 --> 00:30:43,243
and profiling,
check out these other sessions

544
00:30:45,412 --> 00:30:48,782
This session has been all about
maximizing Metal ray tracing performance

545
00:30:48,815 --> 00:30:50,284
for your applications.

546
00:30:50,317 --> 00:30:52,953
We talked about
how you can squeeze out more performance

547
00:30:52,986 --> 00:30:57,558
and simplify your code using new features
such as per-primitive data.

548
00:30:57,591 --> 00:31:00,627
We also described
optimization techniques and features

549
00:31:00,661 --> 00:31:04,097
that make building accelerations
structures faster and more convenient

550
00:31:04,131 --> 00:31:05,832
than ever before.

551
00:31:05,866 --> 00:31:09,236
Finally, we covered all the new
enhancements to the Metal tools

552
00:31:09,269 --> 00:31:11,405
in Xcode 14 that will provide you

553
00:31:11,438 --> 00:31:14,107
with deeper insight
during your development.

554
00:31:14,141 --> 00:31:15,809
Thanks for watching.

