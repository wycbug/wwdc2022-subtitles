1
00:00:00,501 --> 00:00:08,509
♪ ♪

2
00:00:09,810 --> 00:00:13,046
Welcome to Profile and
Optimize Your Game's Memory.

3
00:00:13,080 --> 00:00:16,149
I'm Jack Xu (许) from GPU Software team
at Apple.

4
00:00:16,183 --> 00:00:18,952
We're joined by my colleague Seth Lù (陆).

5
00:00:18,986 --> 00:00:21,688
In the last few years,
our teams have been working

6
00:00:21,722 --> 00:00:23,490
with game developers like you

7
00:00:23,524 --> 00:00:26,560
to understand
and improve game memory together.

8
00:00:26,593 --> 00:00:28,996
Today, we want to share our learnings,

9
00:00:29,029 --> 00:00:32,933
so you can also have a head start
when you debug your game's memory

10
00:00:32,966 --> 00:00:36,803
and create awesome games
with the best player experience.

11
00:00:37,905 --> 00:00:42,943
We're going to break down memory usage in
your game, from both CPU and GPU objects.

12
00:00:43,877 --> 00:00:46,680
Plus, analyze allocations in your game,

13
00:00:46,713 --> 00:00:48,549
actual use on physical memory,

14
00:00:48,582 --> 00:00:51,285
and references between objects.

15
00:00:51,318 --> 00:00:53,554
Because there are many facets of memory,

16
00:00:53,587 --> 00:00:58,292
our developer tools also reveal
memory mysteries from different angles.

17
00:00:58,325 --> 00:01:02,296
We'll take a guided tour,
and experience how we use all of them,

18
00:01:02,329 --> 00:01:06,800
including Xcode, Instruments,
and command line tools in Terminal.

19
00:01:06,834 --> 00:01:12,039
In today's guided tour, we will begin
with a prelude to understand game memory.

20
00:01:12,072 --> 00:01:15,275
And start to profile memory
and memory growth,

21
00:01:15,309 --> 00:01:18,679
where Seth will tell us about Instruments.

22
00:01:18,712 --> 00:01:23,383
After taking the temporal approach with
Instruments, we will further our journey,

23
00:01:23,417 --> 00:01:28,488
and analyze the memory graph of your game
using tools in Xcode and Terminal.

24
00:01:28,522 --> 00:01:31,658
These workflows focus on
the current state of memory use,

25
00:01:31,692 --> 00:01:35,329
and the breakdown
of the total game memory.

26
00:01:35,362 --> 00:01:38,765
Finally, Seth will share
how you can use Metal Debugger

27
00:01:38,799 --> 00:01:40,734
to optimize Metal resources,

28
00:01:40,767 --> 00:01:45,739
which is a somewhat standalone,
yet core area in game memory.

29
00:01:45,772 --> 00:01:50,177
Now, let's start rolling
with understanding game memory.

30
00:01:51,044 --> 00:01:53,213
When you launch your game from Xcode,

31
00:01:53,247 --> 00:01:56,316
such as the Modern Rendering
with Metal sample code,

32
00:01:56,350 --> 00:02:00,420
you can open this Memory Report
in Xcode's debug navigator.

33
00:02:00,454 --> 00:02:04,825
It is your first view on the game's
current and recent memory usage,

34
00:02:04,858 --> 00:02:07,127
and its impact level on the system.

35
00:02:08,862 --> 00:02:12,866
The number on the gauge shows you
the current memory use of the game.

36
00:02:12,900 --> 00:02:15,002
An important first step
in memory debugging

37
00:02:15,035 --> 00:02:17,504
is to understand what this number means.

38
00:02:19,173 --> 00:02:20,707
To put it in one line,

39
00:02:20,741 --> 00:02:25,979
actual memory use in your game
is not the same as allocations.

40
00:02:26,013 --> 00:02:28,682
Actual memory use is on physical memory.

41
00:02:28,715 --> 00:02:31,952
While allocations
is the memory requested by the game,

42
00:02:31,985 --> 00:02:34,221
on the virtual memory address space.

43
00:02:34,254 --> 00:02:38,125
And different kinds of allocations
are naturally calculated separately.

44
00:02:41,061 --> 00:02:42,896
When your game allocates memory,

45
00:02:42,930 --> 00:02:47,134
those new allocations do not immediately
nor directly take up space

46
00:02:47,167 --> 00:02:48,602
on physical memory.

47
00:02:48,635 --> 00:02:53,006
On the contrary, they will reserve some
space on virtual memory address space,

48
00:02:53,040 --> 00:02:56,577
which the system provides
for each process.

49
00:02:56,610 --> 00:02:59,646
And when the program actually
uses this allocation later,

50
00:02:59,680 --> 00:03:02,850
will the system prepare space
on physical memory.

51
00:03:04,518 --> 00:03:08,055
Allocations of the same kind
are grouped into categories,

52
00:03:08,088 --> 00:03:11,291
and sparsely occupy
the virtual address space.

53
00:03:11,325 --> 00:03:13,760
These categories may include:

54
00:03:13,794 --> 00:03:16,363
the program's executable binary;

55
00:03:16,396 --> 00:03:18,799
all the libraries and frameworks;

56
00:03:18,832 --> 00:03:22,002
the stack, providing storage
for local and temporary variables

57
00:03:22,035 --> 00:03:24,872
as well as some function arguments;

58
00:03:24,905 --> 00:03:27,641
dynamic memory regions also known as heap;

59
00:03:27,674 --> 00:03:29,543
including class instance storage

60
00:03:29,576 --> 00:03:32,679
and memory the program manually allocates;

61
00:03:32,713 --> 00:03:37,017
regions mapped from read-only resources
such as game asset files;

62
00:03:37,050 --> 00:03:39,620
and of course, Metal objects in your game,

63
00:03:39,653 --> 00:03:44,691
such as buffers, textures,
and pipeline state objects.

64
00:03:44,725 --> 00:03:48,729
And these categories are made of regions.

65
00:03:48,762 --> 00:03:53,767
Under the hood, memory operations
work at the granularity of memory pages,

66
00:03:53,800 --> 00:03:57,905
which are 16 kibibytes each
on modern Apple devices.

67
00:03:57,938 --> 00:04:01,708
This means each region takes up
one or more pages,

68
00:04:01,742 --> 00:04:04,344
and is at least 16 kibibytes large.

69
00:04:05,646 --> 00:04:10,017
As the game continues,
the state of its memory keeps evolving;

70
00:04:10,050 --> 00:04:11,952
new objects get allocated,

71
00:04:11,985 --> 00:04:14,021
old items get destroyed,

72
00:04:14,054 --> 00:04:16,757
the regions keep changing.

73
00:04:16,790 --> 00:04:20,227
But only used pages on the regions
are on physical memory,

74
00:04:20,260 --> 00:04:23,263
which the system diligently charges
to your game,

75
00:04:23,297 --> 00:04:25,332
as to any other apps.

76
00:04:27,234 --> 00:04:30,070
Memory pages in your game
can be one of three kinds:

77
00:04:30,103 --> 00:04:32,973
dirty, compressed, and clean.

78
00:04:33,006 --> 00:04:35,776
Let's check out what they are.

79
00:04:35,809 --> 00:04:39,980
Dirty memory pages includes memory
that your game has written to.

80
00:04:40,013 --> 00:04:42,850
This includes memory allocations in heap,

81
00:04:42,883 --> 00:04:47,888
and frameworks, once your game modifies
those variables or symbols.

82
00:04:47,921 --> 00:04:49,890
On devices with Apple silicon,

83
00:04:49,923 --> 00:04:53,660
accessed Metal resources
also fall into this category,

84
00:04:53,694 --> 00:04:59,132
this is because CPU and GPU share
the same pool of fast unified memory.

85
00:05:00,501 --> 00:05:04,071
However, if some dirty pages
are not used for a long time,

86
00:05:04,104 --> 00:05:07,207
the system might reduce
their presence on physical memory

87
00:05:07,241 --> 00:05:10,944
by compressing these pages
or storing them on flash or disk,

88
00:05:10,978 --> 00:05:12,913
which we call swapping.

89
00:05:12,946 --> 00:05:17,050
This will allow the device
to run more apps and services.

90
00:05:17,084 --> 00:05:20,387
Later, when your game asks
for these pages again,

91
00:05:20,420 --> 00:05:24,024
the system will decompress
or page in them from disk.

92
00:05:24,057 --> 00:05:29,663
Note, your game will still get charged
for their uncompressed size.

93
00:05:29,696 --> 00:05:31,598
For clean memory pages,

94
00:05:31,632 --> 00:05:34,635
they include read-only files
mapped from disk,

95
00:05:34,668 --> 00:05:37,804
such as texture or audio assets,

96
00:05:37,838 --> 00:05:40,874
and frameworks loaded into the process.

97
00:05:40,908 --> 00:05:45,279
The system can empty or reload them
from disk at any time,

98
00:05:45,312 --> 00:05:48,582
so they don't count towards
your game's memory footprint.

99
00:05:48,615 --> 00:05:51,852
However, they may be resident on memory,

100
00:05:51,885 --> 00:05:57,057
and excessive use will slow down
the system and your game.

101
00:05:57,090 --> 00:06:01,361
It's usually the most interesting
to look at the first two parts,

102
00:06:01,395 --> 00:06:04,064
which combined, we call memory footprint.

103
00:06:04,097 --> 00:06:07,868
And the system uses this
to enforce memory limit.

104
00:06:09,970 --> 00:06:13,507
In some terminologies,
people say "dirty memory"

105
00:06:13,540 --> 00:06:18,345
when they mean memory footprint,
as dirty is the opposite of clean.

106
00:06:18,378 --> 00:06:21,281
But don't worry, when things become fuzzy,

107
00:06:21,315 --> 00:06:24,184
we will call out which one we mean.

108
00:06:24,218 --> 00:06:29,089
So now you know how memory works,
and how system charges it to the game.

109
00:06:29,990 --> 00:06:32,292
Besides this Xcode memory gauge,

110
00:06:32,326 --> 00:06:36,129
you can find memory footprint
in many places on the system,

111
00:06:36,163 --> 00:06:39,433
including the Activity Monitor app on Mac.

112
00:06:39,466 --> 00:06:43,770
And some Apple platforms use it
for app memory limits.

113
00:06:43,804 --> 00:06:47,908
Your game can also use this metric
to guide its memory use.

114
00:06:47,941 --> 00:06:53,413
There are useful APIs to query
current footprint and available memory.

115
00:06:53,447 --> 00:06:54,915
Here's a quick look.

116
00:06:54,948 --> 00:07:00,153
To get available system memory
for your iOS, iPadOS or tvOS game,

117
00:07:00,187 --> 00:07:05,459
call os_proc_available_memory,
which is in os/proc.h header file.

118
00:07:07,261 --> 00:07:10,264
And for memory footprint
on any Apple platform,

119
00:07:10,297 --> 00:07:13,100
you can get it via proc_pid_rusage,

120
00:07:13,133 --> 00:07:15,802
with process ID from "get pid",

121
00:07:15,836 --> 00:07:19,573
"rusage_info_current",
which is version 6 at the moment,

122
00:07:19,606 --> 00:07:22,543
and the data store.

123
00:07:22,576 --> 00:07:26,847
And retrieve its physical footprint or
lifetime max physical footprint property.

124
00:07:28,148 --> 00:07:33,687
To recap, in this first section,
we reviewed some concepts about memory.

125
00:07:33,720 --> 00:07:37,624
Allocations in your game happen
on virtual memory address space,

126
00:07:37,658 --> 00:07:42,496
and they will take up physical
memory space as 16 kibibyte pages,

127
00:07:42,529 --> 00:07:45,299
once they're accessed by your game.

128
00:07:45,332 --> 00:07:50,771
Memory footprint is the primary
and universal metric on Apple platforms

129
00:07:50,804 --> 00:07:53,574
to determine your game's
actual memory use.

130
00:07:53,607 --> 00:07:58,779
Memory footprint contains dirty,
compressed, and swapped pages.

131
00:07:58,812 --> 00:08:03,183
It includes both CPU and GPU objects
on Apple silicon.

132
00:08:03,217 --> 00:08:06,920
And it's used for
memory limit enforcement.

133
00:08:06,954 --> 00:08:12,893
Your game can call system APIs to
get its footprint, and available memory.

134
00:08:12,926 --> 00:08:16,063
Now that you know how memory works
behind the scenes,

135
00:08:16,096 --> 00:08:18,332
let's find out how it looks in your game.

136
00:08:18,365 --> 00:08:21,869
Let me hand over to Seth,
to tell you more.

137
00:08:21,902 --> 00:08:23,170
Seth Lù: Thanks, Jack.

138
00:08:23,203 --> 00:08:26,573
Now, let's get started with capturing
the memory growth for a game.

139
00:08:26,607 --> 00:08:30,611
And I'll continue to use
the Modern Renderer sample project.

140
00:08:30,644 --> 00:08:32,446
When you run a game from Xcode,

141
00:08:32,479 --> 00:08:36,183
the Memory Gauge shows you
the memory footprint over time.

142
00:08:36,216 --> 00:08:39,286
However, you can get a much more detailed
look at the memory use

143
00:08:39,319 --> 00:08:42,289
by profiling the game in Instruments.

144
00:08:42,322 --> 00:08:46,260
Because oftentimes a game could
allocate a lot of memory at launch time,

145
00:08:46,293 --> 00:08:48,495
you may want to begin profiling
from a new game launch

146
00:08:48,529 --> 00:08:51,732
instead of attaching to an existing run.

147
00:08:51,765 --> 00:08:54,968
From Xcode,
to quickly begin profiling your game,

148
00:08:55,002 --> 00:08:59,206
press and hold the run button,
then choose "Profile".

149
00:08:59,239 --> 00:09:02,109
This will automatically bring you
to Instruments.

150
00:09:02,142 --> 00:09:05,012
The Instruments app includes
a collection of profiling tools

151
00:09:05,045 --> 00:09:07,447
that record different aspects
of the system

152
00:09:07,481 --> 00:09:10,517
and visualizes the recorded data
on a timeline.

153
00:09:10,551 --> 00:09:12,853
New this year is the Game Memory template

154
00:09:12,886 --> 00:09:15,856
that can help you better understand
the memory growth in your Metal game.

155
00:09:17,291 --> 00:09:21,428
This template comes with the Allocations
and Metal Resource Events instruments

156
00:09:21,461 --> 00:09:24,531
to record memory allocations with history,

157
00:09:24,565 --> 00:09:27,801
VM Tracker to record memory footprint,

158
00:09:27,835 --> 00:09:31,605
Virtual Memory Trace
to record virtual memory activity,

159
00:09:31,638 --> 00:09:35,442
and Metal Application and GPU
to record Metal-related events.

160
00:09:37,477 --> 00:09:40,814
And in this demo, I'll highlight
the first three instruments:

161
00:09:40,848 --> 00:09:44,685
Allocations, Metal Resource Events,
and VM Tracker.

162
00:09:44,718 --> 00:09:47,955
But first,
let's record a trace for the game.

163
00:09:47,988 --> 00:09:51,391
You can press the record button here
to start recording.

164
00:09:51,425 --> 00:09:53,193
And later, to stop recording,

165
00:09:53,227 --> 00:09:57,130
you can press the same button
or simply quit the game.

166
00:09:57,164 --> 00:09:59,399
While Instruments is recording
the Modern Renderer,

167
00:09:59,433 --> 00:10:03,036
let me show you an alternative way
to record a trace.

168
00:10:03,070 --> 00:10:06,974
The xctrace command allows you
to programmatically perform recordings,

169
00:10:07,007 --> 00:10:09,376
which may be useful
in automation workflows.

170
00:10:10,944 --> 00:10:13,514
Additionally,
you can specify the device name

171
00:10:13,547 --> 00:10:17,751
to choose an iPhone,
iPad, or Apple TV as the target.

172
00:10:18,819 --> 00:10:21,021
Now that I have captured
an Instruments trace,

173
00:10:21,054 --> 00:10:23,624
let's first take a look at Allocations.

174
00:10:23,657 --> 00:10:27,261
The Allocations instrument gives you
a detailed view of memory allocations,

175
00:10:27,294 --> 00:10:30,330
their sizes, and object reference counts.

176
00:10:30,364 --> 00:10:34,067
However, it doesn't include
private Metal resources.

177
00:10:34,101 --> 00:10:38,338
The Statistics view displays
all heap allocations and anonymous VM.

178
00:10:40,274 --> 00:10:45,779
The All Heap Allocations include malloc'ed
buffers which may contain objects,

179
00:10:45,812 --> 00:10:50,617
and All Anonymous VM includes
interesting VM regions that may be dirty.

180
00:10:50,651 --> 00:10:54,388
And we'll see in a moment that some
Metal resources belong to this category.

181
00:10:56,123 --> 00:10:59,660
Now, let's take a look
inside All Heap Allocations.

182
00:10:59,693 --> 00:11:03,964
Usually, the larger allocations
are more interesting for optimization.

183
00:11:03,997 --> 00:11:07,634
To find the single largest allocation, you
can click on the Size table column

184
00:11:07,668 --> 00:11:09,837
to sort the allocations by size.

185
00:11:11,238 --> 00:11:13,774
For an allocation,
you can click on this arrow

186
00:11:13,807 --> 00:11:17,878
to see the reference count changes
for Swift and Objective-C objects.

187
00:11:20,147 --> 00:11:22,583
And with this large allocation selected
in the list,

188
00:11:22,616 --> 00:11:26,887
there is the stack trace of
the allocation history in the inspector.

189
00:11:26,920 --> 00:11:31,592
Clicking on the button allows
hiding the system libraries or frameworks.

190
00:11:31,625 --> 00:11:34,228
And here, according to the stack trace,

191
00:11:34,261 --> 00:11:37,531
the allocation happened
when Modern Renderer loaded the assets.

192
00:11:38,866 --> 00:11:43,136
Double clicking on the frame
can also bring you to the source code.

193
00:11:43,170 --> 00:11:47,374
Now, let's go back and take a look inside
the "All Anonymous VM" category.

194
00:11:48,809 --> 00:11:52,646
In Metal games, you may find
a lot of allocations in the IOAccelerator

195
00:11:52,679 --> 00:11:55,582
and IOSurface categories.

196
00:11:55,616 --> 00:11:59,453
Allocations in IOAccelerator
correspond to Metal resources.

197
00:12:00,854 --> 00:12:04,892
From the stack trace, you can see this
allocation happened while loading assets.

198
00:12:06,493 --> 00:12:10,497
Allocations in IOSurface
correspond to drawables.

199
00:12:10,531 --> 00:12:14,401
And here, the stack trace shows
the MetalKit view requested the drawable.

200
00:12:16,036 --> 00:12:20,307
The Allocations instrument, by default,
visualizes the allocation size.

201
00:12:20,340 --> 00:12:23,544
However, it also comes with
alternative looks.

202
00:12:23,577 --> 00:12:26,013
You can on the arrow button
in the Allocations track

203
00:12:26,046 --> 00:12:29,616
to customize the display mode
to visualize Allocation Density.

204
00:12:29,650 --> 00:12:33,520
This will update the graph to show you the
amount of allocations performed over time

205
00:12:33,554 --> 00:12:36,657
and reveal spikes for memory allocations.

206
00:12:36,690 --> 00:12:39,726
These spikes may be sources
of memory growth.

207
00:12:39,760 --> 00:12:43,263
So the data shown in Allocations
is quite low-level.

208
00:12:43,297 --> 00:12:46,300
To get a better understanding
of the allocated Metal resources,

209
00:12:46,333 --> 00:12:50,003
let's move on to Metal Resource Events.

210
00:12:50,037 --> 00:12:54,775
The Metal Resource Events instrument
is designed around Metal resources.

211
00:12:54,808 --> 00:12:56,310
In the Resource Events view,

212
00:12:56,343 --> 00:13:00,681
you can find a history of Metal resource
allocations and deallocations.

213
00:13:00,714 --> 00:13:04,218
Here, you could also identify
the Metal resources by their labels

214
00:13:04,251 --> 00:13:08,222
which you can specify programmatically
through the Metal API.

215
00:13:08,255 --> 00:13:10,290
And similar to the Allocations instrument,

216
00:13:10,324 --> 00:13:13,894
you can find a stack trace for
the allocation history in the inspector.

217
00:13:15,929 --> 00:13:19,399
This instrument also adds the Allocation
and the Deallocations track

218
00:13:19,433 --> 00:13:21,034
under the Metal device.

219
00:13:21,068 --> 00:13:23,804
They help visualize the density of events.

220
00:13:23,837 --> 00:13:26,740
So far,
Allocations and Metal Resource Events

221
00:13:26,773 --> 00:13:29,676
can help understand memory allocations.

222
00:13:29,710 --> 00:13:33,814
However, allocations don't always
translate to memory footprint.

223
00:13:33,847 --> 00:13:37,351
So let's move on to VM Tracker
to investigate the actual memory use.

224
00:13:38,352 --> 00:13:41,154
The VM Tracker instrument
shows the non-compressed dirty

225
00:13:41,188 --> 00:13:44,057
and compressed or swapped memory.

226
00:13:44,091 --> 00:13:48,061
The Dirty Size represents
the non-compressed dirty memory.

227
00:13:48,095 --> 00:13:52,165
And the Swapped Size represents
the compressed or swapped memory.

228
00:13:52,199 --> 00:13:54,868
In this recording, there's no compressed
or swapped memory use

229
00:13:54,902 --> 00:13:57,538
from the Modern Renderer.

230
00:13:57,571 --> 00:14:00,874
The detailed Summary view
shows the VM regions.

231
00:14:00,908 --> 00:14:04,244
And in the "mapped file" region,
you may find some memory-mapped resources

232
00:14:04,278 --> 00:14:06,280
like your game assets.

233
00:14:06,313 --> 00:14:10,384
Here, Modern Renderer maps
the bistro asset file into memory.

234
00:14:10,417 --> 00:14:13,320
So that's a brief overview
of the Allocations,

235
00:14:13,353 --> 00:14:17,090
Metal Resource Events
and VM Tracker in Instruments.

236
00:14:17,124 --> 00:14:20,394
To quickly recap
how you can profile memory growth:

237
00:14:20,427 --> 00:14:22,930
First, choose the Game Memory template,

238
00:14:22,963 --> 00:14:25,766
and then, record and analyze the trace.

239
00:14:25,799 --> 00:14:28,168
Sometimes, you may repeat this process
a few times

240
00:14:28,202 --> 00:14:31,839
when reproducing or verifying
memory growth patterns.

241
00:14:31,872 --> 00:14:34,474
We hope the new Game Memory template
can help you better understand

242
00:14:34,508 --> 00:14:37,945
the memory allocation
or footprint growth in your game.

243
00:14:37,978 --> 00:14:42,115
And please check out these other videos
to learn more about using Instruments.

244
00:14:42,149 --> 00:14:43,917
Now, back to Jack.

245
00:14:45,619 --> 00:14:48,055
The game Memory template
looks really cool,

246
00:14:48,088 --> 00:14:51,491
and it's going to be so useful
to help with understanding changes

247
00:14:51,525 --> 00:14:53,861
of memory use over time.

248
00:14:53,894 --> 00:14:57,631
In addition, you might also want
to capture the memory state of the game

249
00:14:57,664 --> 00:15:01,268
at a given time, so you can dig deeper
into that memory state

250
00:15:01,301 --> 00:15:04,571
and examine it through different lenses.

251
00:15:04,605 --> 00:15:08,275
And for that, we have memory graphs
and a suite of tools.

252
00:15:09,710 --> 00:15:13,347
Memory graph is a file
to efficiently store a complete snapshot

253
00:15:13,380 --> 00:15:15,082
of your game's memory state,

254
00:15:15,115 --> 00:15:17,150
including object creation history,

255
00:15:17,184 --> 00:15:20,153
references,
and any compression or swapping.

256
00:15:21,788 --> 00:15:23,957
You can take a snapshot anytime you want,

257
00:15:23,991 --> 00:15:27,160
such as when an issue occurs,
or a pair of those,

258
00:15:27,194 --> 00:15:31,865
before and after an issue happened
for comparison.

259
00:15:31,899 --> 00:15:35,035
To spice things up,
let's use a cookbook analogy

260
00:15:35,068 --> 00:15:38,739
on how to analyze memory
with memory graphs.

261
00:15:38,772 --> 00:15:41,909
It includes an ingredient
and a preparation part.

262
00:15:43,710 --> 00:15:47,080
For the Ingredients, well,
you would need your game;

263
00:15:47,114 --> 00:15:49,550
something called Malloc Stack Logging;

264
00:15:49,583 --> 00:15:52,586
and, a captured memory graph.

265
00:15:52,619 --> 00:15:55,055
It's quick to configure
Malloc Stack Logging

266
00:15:55,088 --> 00:15:56,723
and to capture a memory graph.

267
00:15:58,592 --> 00:16:03,030
Malloc Stack Logging records allocation
information in the game process.

268
00:16:03,063 --> 00:16:05,299
You can find it in Scheme settings.

269
00:16:05,332 --> 00:16:08,669
Choose the Run action,
go to Diagnostics,

270
00:16:08,702 --> 00:16:11,271
and tick the Malloc Stack Logging
checkbox.

271
00:16:13,040 --> 00:16:15,642
In case you wonder what the two
options are;

272
00:16:15,676 --> 00:16:19,313
All Allocation and Free History
keeps track of all objects

273
00:16:19,346 --> 00:16:22,049
even after they are deallocated.

274
00:16:22,082 --> 00:16:24,351
The logging data may take up more memory,

275
00:16:24,384 --> 00:16:28,622
but it's useful for debugging issues
such as fragmentation.

276
00:16:28,655 --> 00:16:33,160
On the other hand, Live Allocation Only
discards deallocated objects

277
00:16:33,193 --> 00:16:36,263
from its history, so it's lighter.

278
00:16:36,296 --> 00:16:39,199
In this case,
I'm only investigating references,

279
00:16:39,233 --> 00:16:43,437
which are on live objects,
so I can pick this option.

280
00:16:43,470 --> 00:16:45,572
In fact, most of the time,

281
00:16:45,606 --> 00:16:49,209
Live Allocation Only will be
your recommended option.

282
00:16:50,677 --> 00:16:56,049
Alternatively, you can set environment
variable if not launching from Xcode.

283
00:16:56,083 --> 00:17:00,187
Check out the malloc manual page
for some additional recording modes.

284
00:17:00,220 --> 00:17:03,190
After that, also prepare a memory graph.

285
00:17:03,223 --> 00:17:05,626
Just click on
the debug memory graph button

286
00:17:05,659 --> 00:17:07,895
in the debug area.

287
00:17:07,928 --> 00:17:09,863
Xcode will take a memory snapshot,

288
00:17:09,897 --> 00:17:13,667
process it, and enter the memory debugger.

289
00:17:13,700 --> 00:17:18,505
Xcode Memory Debugger provides intuitive
perspectives into the game's memory use.

290
00:17:18,539 --> 00:17:22,142
Let's take a minute to explore the view.

291
00:17:22,176 --> 00:17:25,445
On the left side,
Debug Navigator gives you

292
00:17:25,479 --> 00:17:28,482
a hierarchical list of object instances.

293
00:17:30,484 --> 00:17:34,421
On the right, File Inspector provides
useful information

294
00:17:34,454 --> 00:17:38,625
such as memory footprint,
uptime, and capture date.

295
00:17:40,928 --> 00:17:44,164
In the middle area
shines the memory graph view

296
00:17:44,198 --> 00:17:47,134
where you have the selected object
from the left,

297
00:17:47,167 --> 00:17:50,771
and how references connect to this object.

298
00:17:50,804 --> 00:17:53,740
I'll come back to this graph in a bit.

299
00:17:56,109 --> 00:17:59,847
And the File menu gives you the option
to save this memory graph

300
00:17:59,880 --> 00:18:03,517
for future analysis,
or to easily share with your team.

301
00:18:05,118 --> 00:18:07,888
For a Mac game,
you can also capture a memory graph

302
00:18:07,921 --> 00:18:12,659
with the leaks command line program,
using process ID or name.

303
00:18:12,693 --> 00:18:16,163
This means you could do it remotely
in a secure shell,

304
00:18:16,196 --> 00:18:18,031
so the cursor stays in the game,

305
00:18:18,065 --> 00:18:23,103
in case your game is running fullscreen
and needs to stay in focus.

306
00:18:23,136 --> 00:18:26,907
So that's what you'll need
to start memory graph analysis.

307
00:18:28,275 --> 00:18:32,880
Now it's time to examine this memory graph
using Xcode Memory Debugger,

308
00:18:32,913 --> 00:18:36,083
plus some versatile command line tools
in Terminal,

309
00:18:36,116 --> 00:18:41,121
to find out allocations,
footprint, and even more.

310
00:18:41,154 --> 00:18:45,759
A good first step
is to break down memory use by categories.

311
00:18:45,792 --> 00:18:48,629
The footprint program does just that.

312
00:18:50,430 --> 00:18:56,203
Footprint uses information in the memory
graph to recreate this high level summary.

313
00:18:56,236 --> 00:19:01,241
Typically, you will want to first focus
on the larger categories.

314
00:19:01,275 --> 00:19:05,812
For game memory graphs such as this one
from the Modern Rendering sample code,

315
00:19:05,846 --> 00:19:09,783
IOAccelerator is usually the largest one.

316
00:19:09,816 --> 00:19:14,988
As Seth said, it includes Metal resources.

317
00:19:15,022 --> 00:19:20,494
Here, heap allocations go to several
MALLOC_(prefixed) categories,

318
00:19:20,527 --> 00:19:25,899
since the system groups heap allocations
to size pools to improve performance.

319
00:19:25,933 --> 00:19:30,170
These objects may come from many places,
such as third-party plugins,

320
00:19:30,204 --> 00:19:34,875
or libraries, where your game does
sound effects or physics simulation.

321
00:19:36,343 --> 00:19:39,479
Here's a memory graph
from an awesome Apple Arcade game,

322
00:19:39,513 --> 00:19:43,283
Manifold Garden,
created by William "Cheer" Studio.

323
00:19:43,317 --> 00:19:46,753
I'm glad they allow me to show you
the game's memory usage.

324
00:19:46,787 --> 00:19:51,558
If your game uses a game engine,
like Manifold Garden using Unity,

325
00:19:51,592 --> 00:19:54,528
or a custom allocator
on top of memory map,

326
00:19:54,561 --> 00:19:58,899
that memory would be shown as
untagged VM_ALLOCATE like this.

327
00:19:58,932 --> 00:20:01,702
Here's a pro tip: on Apple platforms,

328
00:20:01,735 --> 00:20:04,872
your game can use
up to 16 app-specific tags,

329
00:20:04,905 --> 00:20:08,442
so you can have more clarity
when drilling down memory usage.

330
00:20:08,475 --> 00:20:11,144
It's as easy as a one line change.

331
00:20:12,312 --> 00:20:16,283
First, make the tag
from one of 16 options.

332
00:20:16,316 --> 00:20:21,522
Then replace the minus one with
this new tag as the "file descriptor",

333
00:20:21,555 --> 00:20:24,091
when calling "em map".

334
00:20:24,124 --> 00:20:28,562
Check out "em map's" manual page to learn
how tags and categories are defined.

335
00:20:30,597 --> 00:20:32,833
If you use "mach VM allocate",

336
00:20:32,866 --> 00:20:37,171
include the same flag in
the flag argument when allocating.

337
00:20:39,573 --> 00:20:41,642
In the world of footprint program,

338
00:20:41,675 --> 00:20:45,245
the dirty size also includes swap
and compressed,

339
00:20:45,279 --> 00:20:48,982
so think of it as total charged
for each category.

340
00:20:50,250 --> 00:20:53,754
That's a brief idea of the composition
of current memory use,

341
00:20:53,787 --> 00:20:56,857
and how it makes up the footprint.

342
00:20:56,890 --> 00:21:01,361
Some of this memory is less used
and become compressed or swapped.

343
00:21:01,395 --> 00:21:04,364
They might be sources of memory savings.

344
00:21:04,398 --> 00:21:07,167
The next step is to find out
how much compressed

345
00:21:07,201 --> 00:21:10,871
or swapped memory the game uses,
and optimize.

346
00:21:12,773 --> 00:21:16,610
For this, you can run the memory graph
with vmmap.

347
00:21:16,643 --> 00:21:19,580
It gives you dirty and swapped sizes,

348
00:21:19,613 --> 00:21:22,082
instead of two combined.

349
00:21:22,115 --> 00:21:24,985
This dirty column includes
currently not swapped

350
00:21:25,018 --> 00:21:27,487
or compressed regular dirty memory,

351
00:21:27,521 --> 00:21:30,524
while the swapped column includes
the original size

352
00:21:30,557 --> 00:21:33,694
of compressed or swapped memory.

353
00:21:33,727 --> 00:21:37,965
The system adds these two columns together
to determine footprint.

354
00:21:37,998 --> 00:21:42,636
But since content in the swapped size
column isn't used as often,

355
00:21:42,669 --> 00:21:45,772
it is a good indicator
for what to look for

356
00:21:45,806 --> 00:21:48,442
to optimize your game's memory.

357
00:21:48,475 --> 00:21:51,345
Oh, by the way,
here is the allocation size,

358
00:21:51,378 --> 00:21:54,114
with the virtual size column.

359
00:21:54,147 --> 00:21:58,285
And the resident size includes clean pages
such as executables

360
00:21:58,318 --> 00:22:00,521
and memory mapped files.

361
00:22:02,422 --> 00:22:07,294
Conveniently, vmmap shows
heap allocations with a separate table.

362
00:22:07,327 --> 00:22:09,363
At the bottom of its output,

363
00:22:09,396 --> 00:22:13,300
vmmap groups heap memory by zones.

364
00:22:13,333 --> 00:22:18,172
These zones reflect their usage
or lifecycle in your game.

365
00:22:18,205 --> 00:22:20,674
Because I turned on MallocStackLogging,

366
00:22:20,707 --> 00:22:24,811
allocations on the heap
are in the tool's zone.

367
00:22:24,845 --> 00:22:27,714
Otherwise,
they would be in two default zones:

368
00:22:27,748 --> 00:22:33,887
MallocHelperZone and DefaultMallocZone,
based on the allocation size.

369
00:22:33,921 --> 00:22:40,594
And usually you could skip smaller system
utility zones such as QuartzCore zone.

370
00:22:42,196 --> 00:22:47,334
Also, if you suspect fragmentation,
indicated by high fragmentation size

371
00:22:47,367 --> 00:22:52,439
or percentage,
like dozens or hundreds of megabytes,

372
00:22:52,472 --> 00:22:57,411
the WWDC 2021 session covers more
about fragmentation issues.

373
00:22:58,645 --> 00:23:02,282
And running vmmap
without dash dash summary,

374
00:23:02,316 --> 00:23:04,718
or to use vmmap in standard mode,

375
00:23:04,751 --> 00:23:09,223
shows each vm region within
those categories line by line.

376
00:23:09,256 --> 00:23:14,595
Just like how the virtual address space
looks like, as we discussed earlier.

377
00:23:14,628 --> 00:23:21,068
So with vmmap, you can distill less used
dirty memory from actively used ones.

378
00:23:21,101 --> 00:23:23,871
And typically,
there are also a good amount

379
00:23:23,904 --> 00:23:27,207
of dynamic allocations of various sizes,

380
00:23:27,241 --> 00:23:30,010
or malloc'd heap memory usage in the game.

381
00:23:30,043 --> 00:23:32,045
They need a special look.

382
00:23:32,880 --> 00:23:36,550
Heap tool groups malloc'd resources
by their classes,

383
00:23:36,583 --> 00:23:39,253
and sorts them by instance count.

384
00:23:39,286 --> 00:23:43,524
These classes are determined in
C++ with a VTable,

385
00:23:43,557 --> 00:23:45,993
Objective-C, or Swift.

386
00:23:47,628 --> 00:23:49,997
We are using the —quiet argument

387
00:23:50,030 --> 00:23:53,734
to skip the header about some metadata.

388
00:23:53,767 --> 00:23:59,206
New this year, heap is more intelligent
at identifying object types.

389
00:23:59,239 --> 00:24:02,676
It uses information recorded
by Malloc Stack Logging

390
00:24:02,709 --> 00:24:05,979
to present the caller
or responsible library,

391
00:24:06,013 --> 00:24:09,683
so a huge non-object
is a thing of the past.

392
00:24:10,584 --> 00:24:14,888
And here is the memory graph
from Manifold Garden again.

393
00:24:14,922 --> 00:24:18,392
In this example,
it is revealed for the first time

394
00:24:18,425 --> 00:24:23,463
how much heap usage is taken up
by plugins like FMOD Studio,

395
00:24:23,497 --> 00:24:27,801
and game components
such as GameAssembly.dylib.

396
00:24:27,835 --> 00:24:32,306
So now you can be more informed
on how the memory is spread out.

397
00:24:32,339 --> 00:24:38,078
And it also hints which direction to go
for getting more info on these objects.

398
00:24:38,111 --> 00:24:42,216
In this example,
the developer can open FMOD Studio

399
00:24:42,249 --> 00:24:45,919
to fine tune the soundtrack
and sound effects in the game,

400
00:24:45,953 --> 00:24:50,691
or go to Unity to look for
game code optimizations, and so on.

401
00:24:52,593 --> 00:24:55,295
Sometimes,
sorting by class total size

402
00:24:55,329 --> 00:24:58,765
rather than class instance count
is more helpful.

403
00:24:58,799 --> 00:25:01,535
In the memory graph
of the Modern Rendering sample project,

404
00:25:01,568 --> 00:25:07,641
the top contributor is a class
using over 258 million bytes.

405
00:25:07,674 --> 00:25:11,512
To continue looking for larger objects
in the Modern Rendering sample,

406
00:25:11,545 --> 00:25:17,584
use heap to sort objects by class
total size with —sortBySize,

407
00:25:17,618 --> 00:25:21,688
and list all objects
with —showSizes,

408
00:25:21,722 --> 00:25:24,725
rather than a summary of each class.

409
00:25:24,758 --> 00:25:28,629
And, there is one object of
NSConcreteMutableData

410
00:25:28,662 --> 00:25:34,201
in Bytes Storage with a size
of 255 million bytes:

411
00:25:34,234 --> 00:25:37,971
that looks like one worth looking at.

412
00:25:38,005 --> 00:25:40,908
Next, I want to find out what it is.

413
00:25:40,941 --> 00:25:44,278
And I want to know
its address for a start.

414
00:25:44,311 --> 00:25:49,816
I add —address and enter
the pattern NSConcreteMutableData

415
00:25:49,850 --> 00:25:53,153
followed by wildcard–
dot star,

416
00:25:53,187 --> 00:25:55,355
and a size filter in the bracket

417
00:25:55,389 --> 00:26:00,093
to only list objects
10 megabytes large and upwards.

418
00:26:00,127 --> 00:26:02,796
And here is the address of the object.

419
00:26:02,829 --> 00:26:07,334
I'll use it in the following steps
for more in-depth analysis.

420
00:26:07,367 --> 00:26:13,407
So that's heap tool, with improved
object identification for instances.

421
00:26:13,440 --> 00:26:16,276
So far, you've seen three tools
to understand

422
00:26:16,310 --> 00:26:18,979
what objects are using memory in the game,

423
00:26:19,012 --> 00:26:21,548
and they all provide different views.

424
00:26:21,582 --> 00:26:24,351
What I showed was just one workflow.

425
00:26:24,384 --> 00:26:26,620
Depending on
the particular memory patterns,

426
00:26:26,653 --> 00:26:28,889
or technologies used in your game,

427
00:26:28,922 --> 00:26:31,692
you can use them
in any way that suits your needs.

428
00:26:33,894 --> 00:26:36,163
With discoveries for objects

429
00:26:36,196 --> 00:26:39,066
that we are not quite sure
of their existence,

430
00:26:39,099 --> 00:26:41,835
the next step is to get its origin,

431
00:26:41,869 --> 00:26:44,104
which is its allocation call stack.

432
00:26:45,172 --> 00:26:48,575
In the case of the 200 million bytes
object in Modern Rendering,

433
00:26:48,609 --> 00:26:50,944
I use the —callTree mode

434
00:26:50,978 --> 00:26:54,915
and pass in its address to malloc_history.

435
00:26:54,948 --> 00:26:57,451
Together with additional invert argument,

436
00:26:57,484 --> 00:27:01,655
I can focus on functions
closest to the allocation.

437
00:27:01,688 --> 00:27:03,156
And voila.

438
00:27:03,190 --> 00:27:06,793
Here is the back trace of the allocation.

439
00:27:06,827 --> 00:27:12,065
Similarly, Xcode Memory Debugger shows
the allocation history of an object too

440
00:27:12,099 --> 00:27:13,600
in the inspector.

441
00:27:13,634 --> 00:27:17,371
Just select an object,
click on the Memory Inspector,

442
00:27:17,404 --> 00:27:20,774
and there it is.

443
00:27:20,807 --> 00:27:24,344
As another example,
pass in VM_ALLOCATE

444
00:27:24,378 --> 00:27:27,281
as the class pattern
instead of an address,

445
00:27:27,314 --> 00:27:31,084
to check for anonymous VM usage
in your game or plugin,

446
00:27:31,118 --> 00:27:34,888
such as debugging a custom allocator.

447
00:27:34,922 --> 00:27:37,958
Whether using Xcode or malloc_history,

448
00:27:37,991 --> 00:27:40,294
you can know the allocation back trace,

449
00:27:40,327 --> 00:27:43,030
and decide if you want to dig deeper,

450
00:27:43,063 --> 00:27:46,800
including setting a breakpoint
at the line, for a start.

451
00:27:48,802 --> 00:27:55,475
And last but not least, it's also helpful
to investigate object references.

452
00:27:55,509 --> 00:27:58,846
Memory graph always records
object references,

453
00:27:58,879 --> 00:28:04,017
even when MallocStackLogging
is not enabled for various reasons.

454
00:28:04,051 --> 00:28:08,689
We've used leaks before to capture
a memory graph outside of Xcode.

455
00:28:08,722 --> 00:28:10,190
Leaks does more.

456
00:28:10,224 --> 00:28:12,993
It checks for all references
in the memory graph,

457
00:28:13,026 --> 00:28:17,431
and that is why it knows about leaks
and retain cycles.

458
00:28:17,464 --> 00:28:20,634
Leaks gets this tree of references
to the object

459
00:28:20,667 --> 00:28:24,905
by using the trace tree argument
and the object address from heap.

460
00:28:24,938 --> 00:28:28,909
However, because this is a rather
large tree in this example,

461
00:28:28,942 --> 00:28:32,679
there is a somewhat better way
to view it than in Terminal.

462
00:28:34,281 --> 00:28:37,751
With Xcode 14,
we redesigned the memory graph view

463
00:28:37,784 --> 00:28:42,289
to show both ingoing and outgoing edges
of the selected object.

464
00:28:43,357 --> 00:28:46,059
It even has a new
neighbor selection popover,

465
00:28:46,093 --> 00:28:49,396
to choose the edges
you want Xcode to draw.

466
00:28:49,429 --> 00:28:52,132
This is going to greatly improve
productivity

467
00:28:52,165 --> 00:28:56,603
when trying to understand object
references in complex game states.

468
00:28:58,105 --> 00:29:00,541
After exploring around for a little bit,

469
00:29:00,574 --> 00:29:05,345
I'm pretty sure the texture manager
is what is accessing this object.

470
00:29:05,379 --> 00:29:07,814
For your game,
consider using leaks tool

471
00:29:07,848 --> 00:29:12,386
and the memory graph view to find
important object reference relationships,

472
00:29:12,419 --> 00:29:16,190
to learn how these objects
are accessed in the game.

473
00:29:16,223 --> 00:29:18,992
So that how to view and find out
important references

474
00:29:19,026 --> 00:29:22,729
of an object using leaks or Xcode.

475
00:29:22,763 --> 00:29:24,565
Please check out leaks' manual page,

476
00:29:24,598 --> 00:29:28,268
and Xcode help
for more usage of these tools.

477
00:29:29,603 --> 00:29:32,039
In this memory graph analysis cookbook,

478
00:29:32,072 --> 00:29:35,375
each step uses some specific tools.

479
00:29:35,409 --> 00:29:40,047
All of them work together to complete
the analysis on a memory graph.

480
00:29:41,548 --> 00:29:45,552
To summarize, the first thing
is to enable MallocStackLogging

481
00:29:45,586 --> 00:29:50,991
when you expect to capture and analyze
memory with a memory graph.

482
00:29:51,024 --> 00:29:54,595
Then capture a memory graph
with Xcode for your game,

483
00:29:54,628 --> 00:29:58,765
or alternatively use leaks tool
for your Mac game.

484
00:29:58,799 --> 00:30:02,870
Next, find large and troublesome objects.

485
00:30:02,903 --> 00:30:07,474
Footprint, vmmap, and heap tools
provide breakdown of memory,

486
00:30:07,508 --> 00:30:11,111
both on a high level and in details.

487
00:30:11,144 --> 00:30:15,282
With malloc_history, you can find out
where objects are allocated

488
00:30:15,315 --> 00:30:19,820
and leaks can analyze object usage
or references.

489
00:30:19,853 --> 00:30:22,756
These previous sessions
include in-depth walkthroughs

490
00:30:22,789 --> 00:30:26,260
as well as demos
of more usage of these tools.

491
00:30:26,293 --> 00:30:30,063
Until now, we have deferred probing
into Metal resources.

492
00:30:30,097 --> 00:30:32,533
Well, now is the time.

493
00:30:32,566 --> 00:30:35,769
To tell you more, here's Seth.

494
00:30:35,802 --> 00:30:37,104
Hi again!

495
00:30:37,137 --> 00:30:40,807
In games, Metal resources
can use a big chunk of memory.

496
00:30:40,841 --> 00:30:43,310
But there are ways to optimize
their memory use.

497
00:30:44,411 --> 00:30:46,513
Here I've summarized a list
of memory savings

498
00:30:46,547 --> 00:30:50,551
that you can use when optimizing
the Metal resources in your game.

499
00:30:50,584 --> 00:30:54,254
We'll take a look at how Metal Debugger
can help you with auditing the resources

500
00:30:54,288 --> 00:30:58,025
and learn some advanced techniques
for further reducing your game memory.

501
00:30:59,026 --> 00:31:03,230
Metal Debugger is the one stop shop
for debugging your Metal games.

502
00:31:03,263 --> 00:31:05,365
After taking a GPU frame capture,

503
00:31:05,399 --> 00:31:07,334
you can find a summary page.

504
00:31:07,367 --> 00:31:10,604
This provides you with some general stats
about the captured workload.

505
00:31:12,172 --> 00:31:13,740
In the lower half of the page,

506
00:31:13,774 --> 00:31:17,477
there is a list of insights
divided in four categories.

507
00:31:17,511 --> 00:31:22,115
Insights in the "Memory" category
suggest memory savings for your game.

508
00:31:22,149 --> 00:31:25,752
There aren't many memory insights
particular for this trace;

509
00:31:25,786 --> 00:31:29,356
we can save just a few megabytes
of memory after addressing these insights.

510
00:31:31,225 --> 00:31:35,095
However, there may be more memory savings
specific to your game.

511
00:31:35,128 --> 00:31:38,265
To get a more complete picture of
the memory used by Metal resources,

512
00:31:38,298 --> 00:31:41,435
you can use the Memory Viewer
from clicking on the Show Memory button.

513
00:31:42,903 --> 00:31:47,441
The Memory Viewer offers you a full list
of resources captured from the game.

514
00:31:47,474 --> 00:31:50,844
The upper half shows
different categories for filtering.

515
00:31:50,878 --> 00:31:54,681
You can quickly use this to
look up resources, say, textures.

516
00:31:54,715 --> 00:31:58,785
And in the lower half,
the table displays just the textures.

517
00:31:58,819 --> 00:32:01,755
Let's take out the filter for now.

518
00:32:01,788 --> 00:32:06,059
The resource table has a collection
of columns to help you optimize your game.

519
00:32:06,093 --> 00:32:09,329
And I'd like to highlight a few columns
that may help you quickly identify

520
00:32:09,363 --> 00:32:10,964
some interesting resources.

521
00:32:13,100 --> 00:32:17,337
The Insights column is similar to
what we just saw on the summary page.

522
00:32:17,371 --> 00:32:19,706
You may quickly view all the resources
with insights

523
00:32:19,740 --> 00:32:23,343
when sorting the table by this column.

524
00:32:23,377 --> 00:32:26,313
And clicking on an insight icon
will reveal a popover

525
00:32:26,346 --> 00:32:30,717
explaining the finding
and providing some possible actions.

526
00:32:30,751 --> 00:32:34,288
Right next to this column
is Allocated Size.

527
00:32:34,321 --> 00:32:37,991
You can sort by this column
to see the largest resources.

528
00:32:38,025 --> 00:32:41,361
It may be useful to audit if some
resources actually make good use

529
00:32:41,395 --> 00:32:43,397
of their memory size.

530
00:32:43,430 --> 00:32:47,601
For example, some textures may be resized
to smaller resolutions

531
00:32:47,634 --> 00:32:51,305
and some models loaded in buffers
may use a lower poly count,

532
00:32:51,338 --> 00:32:55,242
given that doing so won't affect
the visual quality of the game.

533
00:32:55,275 --> 00:32:57,377
There are some alternative ways
to save texture memory

534
00:32:57,411 --> 00:32:59,680
that I'll mention in a minute.

535
00:32:59,713 --> 00:33:03,050
Another interesting column here
is Time Since Last Bound.

536
00:33:03,083 --> 00:33:08,222
You can sort the resources by this column
to find which haven't been used recently.

537
00:33:08,255 --> 00:33:09,857
If a resource is never used,

538
00:33:09,890 --> 00:33:14,428
it may be a good idea to double check
if it's worth loading the asset.

539
00:33:14,461 --> 00:33:16,763
For a resource
that hasn't been bound for a while,

540
00:33:16,797 --> 00:33:20,734
you may consider releasing it
if it won't be used again in the future.

541
00:33:20,767 --> 00:33:24,972
Alternatively, you can set
its purgeable state to volatile.

542
00:33:25,005 --> 00:33:28,475
A Metal resource may be in
one of the three purgeable states:

543
00:33:28,509 --> 00:33:32,346
non-volatile, volatile, and empty.

544
00:33:32,379 --> 00:33:35,949
By default, resources are non-volatile.

545
00:33:35,983 --> 00:33:37,918
By setting the purgeable state
to volatile,

546
00:33:37,951 --> 00:33:39,887
Metal may evict the resource from memory

547
00:33:39,920 --> 00:33:42,656
in case of high memory pressure
in the system.

548
00:33:42,689 --> 00:33:45,325
Once the resource is empty,
the system will no longer charge it

549
00:33:45,359 --> 00:33:47,995
towards the game's footprint.

550
00:33:48,028 --> 00:33:49,663
When your game needs the resource again,

551
00:33:49,696 --> 00:33:53,367
check if the content's still there,
and reload if needed.

552
00:33:53,400 --> 00:33:56,870
Consider only using volatile
for infrequently used resources,

553
00:33:56,904 --> 00:33:59,339
so the purgeable state
doesn't work against you.

554
00:34:01,375 --> 00:34:05,012
So those are some of the general notes
for all resources.

555
00:34:05,045 --> 00:34:08,015
And now,
let's take a closer look at textures.

556
00:34:08,949 --> 00:34:12,219
Not all columns are shown by default
in Memory Viewer.

557
00:34:12,252 --> 00:34:15,289
Right clicking on the table header
will allow showing and hiding columns

558
00:34:15,322 --> 00:34:18,158
like texture's Pixel Format.

559
00:34:18,192 --> 00:34:23,163
You may get different amount of savings by
optimizing the pixel format for a texture.

560
00:34:23,197 --> 00:34:27,000
Many textures in a game could use
a 16-bit half precision pixel format

561
00:34:27,034 --> 00:34:29,837
to reduce memory use and bandwidth.

562
00:34:29,870 --> 00:34:32,940
In cases when you need a texture
with a single alpha component,

563
00:34:32,973 --> 00:34:35,642
you may avoid multiple color channels.

564
00:34:35,676 --> 00:34:39,146
And lastly, some read-only textures
may benefit from block compression

565
00:34:39,179 --> 00:34:41,615
for lower memory use.

566
00:34:41,648 --> 00:34:43,717
For block compressed pixel formats,

567
00:34:43,750 --> 00:34:46,687
there are options such as ASTC and BC.

568
00:34:46,720 --> 00:34:49,122
Additionally, since A15 Bionic,

569
00:34:49,156 --> 00:34:51,892
you can use lossy compression for textures
and render targets

570
00:34:51,925 --> 00:34:55,562
to save memory while preserving
quality wherever possible.

571
00:34:55,596 --> 00:34:58,432
Please check out these previous
videos for more details.

572
00:35:00,634 --> 00:35:03,203
And those are some of the memory savings
you can quickly discover

573
00:35:03,237 --> 00:35:05,172
from using Memory Viewer.

574
00:35:05,205 --> 00:35:07,341
But there are a few additional techniques
you may take

575
00:35:07,374 --> 00:35:09,977
to further optimize your game.

576
00:35:10,010 --> 00:35:12,546
If a texture is only used by single pass,

577
00:35:12,579 --> 00:35:14,648
you can set its storage mode to memoryless

578
00:35:14,681 --> 00:35:16,783
to save memory and bandwidth.

579
00:35:16,817 --> 00:35:19,620
Memoryless textures work well
for temporary render targets,

580
00:35:19,653 --> 00:35:23,156
like depth, stencil,
or multi-sampled textures.

581
00:35:23,190 --> 00:35:26,293
Otherwise, if the texture
is only used by the GPU,

582
00:35:26,326 --> 00:35:28,061
you can set its storage mode to private,

583
00:35:28,095 --> 00:35:31,131
or else shared or managed.

584
00:35:31,164 --> 00:35:34,601
As a reminder, managed mode is not needed
on Apple silicon Macs,

585
00:35:34,635 --> 00:35:37,371
just like on iPhone and iPad.

586
00:35:37,404 --> 00:35:39,473
Here's an example case.

587
00:35:39,506 --> 00:35:42,876
The game has
a Depth32Float_Stencil8 texture.

588
00:35:42,910 --> 00:35:46,079
The depth texture is used across passes,

589
00:35:46,113 --> 00:35:48,215
but the stencil texture's content
is discarded

590
00:35:48,248 --> 00:35:51,318
and won't be used later in the frame.

591
00:35:51,351 --> 00:35:54,154
So instead,
the game could use two textures

592
00:35:54,188 --> 00:35:57,925
and make the stencil texture memoryless,
to save memory and bandwidth.

593
00:35:59,359 --> 00:36:02,930
Lastly, I'd like to mention another
technique that might be interesting to you

594
00:36:02,963 --> 00:36:05,432
for making the most out of the memory
in your game.

595
00:36:05,465 --> 00:36:07,901
You may use aliased resources
from a heap

596
00:36:07,935 --> 00:36:09,937
if your game doesn't use them
at the same time.

597
00:36:09,970 --> 00:36:12,973
They can share the memory backed
by the same allocation.

598
00:36:13,006 --> 00:36:17,411
But be extra careful when synchronizing
the accesses to those resources.

599
00:36:17,444 --> 00:36:19,780
You can check out
the "Go bindless with Metal 3" talk

600
00:36:19,813 --> 00:36:23,317
to learn more about using resources
allocated from a heap.

601
00:36:23,350 --> 00:36:26,820
So that wraps up our checklist
of memory savings.

602
00:36:26,854 --> 00:36:30,190
And I hope this checklist will help you
audit the Metal resources in your game.

603
00:36:31,725 --> 00:36:33,861
To learn more about using
Metal Debugger for optimizing

604
00:36:33,894 --> 00:36:38,031
your game memory,
please check out these other WWDC talks.

605
00:36:38,065 --> 00:36:39,499
And back to you, Jack.

606
00:36:41,235 --> 00:36:42,503
Thank you, Seth.

607
00:36:42,536 --> 00:36:46,340
Today, we took a guided tour
and explored many interesting things

608
00:36:46,373 --> 00:36:50,177
you can do to understand and improve
your game's memory usage.

609
00:36:50,210 --> 00:36:53,981
First, memory footprint
is the primary metric

610
00:36:54,014 --> 00:36:56,650
in understanding your game's memory usage,

611
00:36:56,683 --> 00:37:01,722
and it includes dirty plus compressed
and swapped memory.

612
00:37:01,755 --> 00:37:05,859
Then, we experienced powerful
memory debugging tools.

613
00:37:05,893 --> 00:37:09,496
Seth showed us how Instruments
empower memory profiling

614
00:37:09,530 --> 00:37:11,865
with useful telemetry tracks.

615
00:37:11,899 --> 00:37:16,537
The new Game Memory template
is exactly tailored for this job.

616
00:37:16,570 --> 00:37:22,442
After that, I presented memory graph
to store a snapshot of game memory state.

617
00:37:22,476 --> 00:37:25,712
There are flexible and powerful
command line programs

618
00:37:25,746 --> 00:37:28,315
to analyze memory graphs for objects,

619
00:37:28,348 --> 00:37:31,652
references, and allocation history.

620
00:37:31,685 --> 00:37:35,822
Improvements in the heap tool
and redesigned Xcode Memory Debugger

621
00:37:35,856 --> 00:37:38,825
will supercharge game memory analysis.

622
00:37:38,859 --> 00:37:42,329
Lastly, Seth shared
a memory savings checklist

623
00:37:42,362 --> 00:37:44,231
for Metal resources,

624
00:37:44,264 --> 00:37:47,334
and how Metal Debugger
can help answer questions

625
00:37:47,367 --> 00:37:51,138
about Metal resource usage in your game.

626
00:37:51,171 --> 00:37:54,575
You could also learn more
from other WWDC sessions,

627
00:37:54,608 --> 00:37:57,444
documentation, and manual pages.

628
00:37:58,445 --> 00:38:02,349
We are constantly advancing
our best and most flexible tools for you.

629
00:38:02,382 --> 00:38:04,318
So why not try them out?

630
00:38:04,351 --> 00:38:06,720
They may just be what you are looking for.

631
00:38:07,955 --> 00:38:11,525
And don't hesitate to share with us
any feedback you may have,

632
00:38:11,558 --> 00:38:15,162
via any channels
such as the Feedback Assistant.

633
00:38:15,195 --> 00:38:17,064
Have fun in your memory journey,

634
00:38:17,097 --> 00:38:18,465
and thanks for watching.  ♪ ♪

