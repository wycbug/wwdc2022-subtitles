1
00:00:00,000 --> 00:00:03,837
♪ instrumental hip hop music ♪

2
00:00:03,837 --> 00:00:09,977
♪

3
00:00:09,977 --> 00:00:12,613
Welcome to the "Adopt
declarative device management"

4
00:00:12,613 --> 00:00:13,614
session.

5
00:00:13,614 --> 00:00:15,249
My name is Cyrus Daboo,

6
00:00:15,249 --> 00:00:18,352
and I am an engineer
on the Device Management team.

7
00:00:18,352 --> 00:00:21,421
I am here to tell you about
the exciting new features

8
00:00:21,421 --> 00:00:24,458
in declarative
device management.

9
00:00:24,458 --> 00:00:26,760
At WWDC21,

10
00:00:26,760 --> 00:00:30,530
my colleague Melissa introduced
declarative device management,

11
00:00:30,530 --> 00:00:33,400
a new paradigm
for managing Apple devices,

12
00:00:33,400 --> 00:00:37,337
reenvisioning
the MDM protocol itself.

13
00:00:37,337 --> 00:00:39,239
As we learned in that session,

14
00:00:39,239 --> 00:00:41,508
declarative device management
is powerful

15
00:00:41,508 --> 00:00:45,412
because it enables devices
to be autonomous and proactive.

16
00:00:45,412 --> 00:00:47,147
The device is autonomous,

17
00:00:47,147 --> 00:00:49,716
as it reacts to its own
state changes

18
00:00:49,716 --> 00:00:52,452
and then applies
management logic to itself,

19
00:00:52,452 --> 00:00:54,788
without prompting
from the server.

20
00:00:54,788 --> 00:00:56,290
The device is proactive,

21
00:00:56,290 --> 00:00:58,859
with the status channel
asynchronously reporting

22
00:00:58,859 --> 00:01:01,862
to the server when important
state changes occur,

23
00:01:01,862 --> 00:01:06,166
avoiding the need for servers
to poll devices.

24
00:01:06,166 --> 00:01:07,901
There are two key elements

25
00:01:07,901 --> 00:01:10,704
to the declarative device
management data model:

26
00:01:10,704 --> 00:01:13,173
declarations and status.

27
00:01:13,173 --> 00:01:16,510
Declarations encompass
activations and predicates,

28
00:01:16,510 --> 00:01:20,113
configurations, assets,
and management types.

29
00:01:20,113 --> 00:01:24,518
And status covers status items
and status reporting.

30
00:01:24,518 --> 00:01:26,987
Let's take a moment
to talk about why this matters,

31
00:01:26,987 --> 00:01:28,855
what it means for you,

32
00:01:28,855 --> 00:01:32,092
and the organizations
that use your products.

33
00:01:32,092 --> 00:01:34,061
We have created this technology

34
00:01:34,061 --> 00:01:36,897
to support new complex
management strategies,

35
00:01:36,897 --> 00:01:40,567
enhance the overall user
experience of managed devices,

36
00:01:40,567 --> 00:01:44,771
alleviate the repetitive and
tedious tasks of an IT admin,

37
00:01:44,771 --> 00:01:47,307
and empower devices
to be the driver

38
00:01:47,307 --> 00:01:50,043
in their own
management state.

39
00:01:50,043 --> 00:01:53,647
For you, as a developer
of a device management solution,

40
00:01:53,647 --> 00:01:56,083
the declarative approach
allows your servers

41
00:01:56,083 --> 00:01:58,719
to be lightweight and reactive.

42
00:01:58,719 --> 00:02:00,721
And with
the declarative data model

43
00:02:00,721 --> 00:02:03,957
more closely mapping to how
organizations are structured,

44
00:02:03,957 --> 00:02:08,495
that means changes to devices
becomes more intuitive.

45
00:02:08,495 --> 00:02:11,264
Status reports provide
a rich feedback channel,

46
00:02:11,264 --> 00:02:14,935
which enable your servers
to monitor devices more closely,

47
00:02:14,935 --> 00:02:17,204
and present
pertinent information

48
00:02:17,204 --> 00:02:19,740
in a more timely
and reliable fashion,

49
00:02:19,740 --> 00:02:22,242
without the need
for complex strategies

50
00:02:22,242 --> 00:02:24,478
used to implement polling.

51
00:02:24,478 --> 00:02:27,080
All of this means a simpler
development effort,

52
00:02:27,080 --> 00:02:30,417
enabling you to focus on
the device management features

53
00:02:30,417 --> 00:02:33,053
that add value
where it matters most,

54
00:02:33,053 --> 00:02:37,391
and create a solution
your customers will love.

55
00:02:37,391 --> 00:02:39,292
For IT admins,

56
00:02:39,292 --> 00:02:41,762
the declarative approach
inspires more confidence

57
00:02:41,762 --> 00:02:44,498
that the device
is in the expected state.

58
00:02:44,498 --> 00:02:47,234
And in the situations
where it is not,

59
00:02:47,234 --> 00:02:48,935
that it is in a safe state

60
00:02:48,935 --> 00:02:51,972
that protects
any sensitive organization data,

61
00:02:51,972 --> 00:02:55,942
even when connectivity
to the server is lost.

62
00:02:55,942 --> 00:03:00,113
It provides critical feedback
from devices via status reports,

63
00:03:00,113 --> 00:03:02,849
that also improves
efficiency for admins

64
00:03:02,849 --> 00:03:04,918
through less utilization
of resources

65
00:03:04,918 --> 00:03:07,187
such as network bandwidth.

66
00:03:07,187 --> 00:03:09,222
For the organization's users,

67
00:03:09,222 --> 00:03:11,591
device management
becomes a more responsive

68
00:03:11,591 --> 00:03:14,861
and reliable experience
with faster onboarding,

69
00:03:14,861 --> 00:03:16,430
quicker recovery times

70
00:03:16,430 --> 00:03:20,167
and better support
from their organization.

71
00:03:20,167 --> 00:03:22,135
With all these benefits in mind,

72
00:03:22,135 --> 00:03:25,205
know that the focus
of future protocol features

73
00:03:25,205 --> 00:03:28,909
will be declarative
device management,

74
00:03:28,909 --> 00:03:30,677
making it even more important

75
00:03:30,677 --> 00:03:33,013
for you to adopt
declarative device management

76
00:03:33,013 --> 00:03:36,383
in your products today.

77
00:03:36,383 --> 00:03:39,386
For an in-depth introduction
to declarative device management

78
00:03:39,386 --> 00:03:41,455
and the steps needed
to adopt it,

79
00:03:41,455 --> 00:03:46,326
make sure you watch
the WWDC21 session video.

80
00:03:46,326 --> 00:03:49,362
In this release,
we have three focus areas:

81
00:03:49,362 --> 00:03:52,632
expanding the scope of
declarative device management,

82
00:03:52,632 --> 00:03:57,304
enhancing status reports,
and enhancing predicates.

83
00:03:57,304 --> 00:03:59,439
Let's start
with expanding the scope

84
00:03:59,439 --> 00:04:02,542
of declarative device
management.

85
00:04:02,542 --> 00:04:05,078
When declarative device
management was introduced,

86
00:04:05,078 --> 00:04:08,748
it was supported on only
iOS with user enrollments.

87
00:04:08,748 --> 00:04:11,485
Now, declarative device
management is available

88
00:04:11,485 --> 00:04:15,355
for every enrollment type
MDM supports:

89
00:04:15,355 --> 00:04:17,023
automatic device enrollment,

90
00:04:17,023 --> 00:04:19,893
which includes
supervised devices;

91
00:04:19,893 --> 00:04:21,795
profile-based enrollment;

92
00:04:21,795 --> 00:04:25,465
and profile and account-based
user enrollments.

93
00:04:25,465 --> 00:04:28,401
Declarative device management
is now also available

94
00:04:28,401 --> 00:04:30,937
on Shared iPad.

95
00:04:30,937 --> 00:04:34,474
In iOS 16, users can now
find configurations

96
00:04:34,474 --> 00:04:38,545
in the MDM profile details view
in the Settings app.

97
00:04:38,545 --> 00:04:41,748
Tapping the Configurations row
reveals details

98
00:04:41,748 --> 00:04:44,851
about the active configurations.

99
00:04:44,851 --> 00:04:47,354
And I am also pleased
to announce

100
00:04:47,354 --> 00:04:49,656
that declarative device
management is available

101
00:04:49,656 --> 00:04:53,226
on every platform MDM supports.

102
00:04:53,226 --> 00:04:56,997
macOS Ventura now supports
declarative device management,

103
00:04:56,997 --> 00:05:01,434
for all MDM enrollment types
supported on macOS.

104
00:05:01,434 --> 00:05:04,938
tvOS 16 now supports declarative
device management

105
00:05:04,938 --> 00:05:08,508
for MDM device enrollment types.

106
00:05:08,508 --> 00:05:10,310
Where supported by the OS,

107
00:05:10,310 --> 00:05:12,445
the same set of declarations
and status

108
00:05:12,445 --> 00:05:14,247
that are available on iOS

109
00:05:14,247 --> 00:05:18,852
are also available
on macOS and tvOS.

110
00:05:18,852 --> 00:05:21,888
On macOS, a Configurations
section is present

111
00:05:21,888 --> 00:05:24,191
in the MDM profile details view,

112
00:05:24,191 --> 00:05:26,893
revealing the active
configurations.

113
00:05:26,893 --> 00:05:30,430
The same goes for tvOS,
where a Configurations section

114
00:05:30,430 --> 00:05:34,634
is present in the
MDM profile details view.

115
00:05:34,634 --> 00:05:36,336
One last thing to note here:

116
00:05:36,336 --> 00:05:39,005
both macOS
and Shared iPad devices

117
00:05:39,005 --> 00:05:41,374
each have two MDM channels.

118
00:05:41,374 --> 00:05:44,744
These are the device
and user channel.

119
00:05:44,744 --> 00:05:46,446
The device channel
allows management

120
00:05:46,446 --> 00:05:47,981
of device level state,

121
00:05:47,981 --> 00:05:50,217
whereas the user channel
targets management state

122
00:05:50,217 --> 00:05:52,419
for specific users.

123
00:05:52,419 --> 00:05:55,322
To use declarative device
management on any channel,

124
00:05:55,322 --> 00:05:58,391
it must be enabled separately
for that channel.

125
00:05:58,391 --> 00:06:01,228
That means sending the
DeclarativeManagement command

126
00:06:01,228 --> 00:06:03,663
on the corresponding channel.

127
00:06:03,663 --> 00:06:07,100
Also, declarative device
management status reports

128
00:06:07,100 --> 00:06:09,869
are separately generated
for each channel,

129
00:06:09,869 --> 00:06:14,374
so they need to be
separately monitored as well.

130
00:06:14,374 --> 00:06:19,846
Now on to our second focus area:
status reports.

131
00:06:19,846 --> 00:06:23,116
Let's do a quick review
of status reports.

132
00:06:23,116 --> 00:06:26,486
Devices can incrementally report
status to the server,

133
00:06:26,486 --> 00:06:29,022
for subscribed status items.

134
00:06:29,022 --> 00:06:32,092
The device tracks successful
responses from the server

135
00:06:32,092 --> 00:06:34,461
to ensure status updates
are reliable

136
00:06:34,461 --> 00:06:36,730
and not missed in the case
of networking

137
00:06:36,730 --> 00:06:39,232
or other types of problem.

138
00:06:39,232 --> 00:06:42,502
Status reporting
makes the device proactive.

139
00:06:42,502 --> 00:06:45,605
There is no need for servers
to continuously poll the device

140
00:06:45,605 --> 00:06:47,741
to watch for state changes.

141
00:06:47,741 --> 00:06:51,645
In iOS 15, we introduced
a set of status items

142
00:06:51,645 --> 00:06:54,347
for device properties,
such as model type

143
00:06:54,347 --> 00:06:56,916
and operating system version.

144
00:06:56,916 --> 00:07:01,054
For this release we are
expanding status in three areas:

145
00:07:01,054 --> 00:07:02,922
passcode state,

146
00:07:02,922 --> 00:07:05,358
accounts installed
by configurations,

147
00:07:05,358 --> 00:07:08,895
and MDM installed apps.

148
00:07:08,895 --> 00:07:12,232
Let's start
with passcode status.

149
00:07:12,232 --> 00:07:16,803
In iOS 15, we introduced
a passcode policy configuration.

150
00:07:16,803 --> 00:07:20,473
There can be some lag between
the policy being applied,

151
00:07:20,473 --> 00:07:22,642
and the passcode
becoming compliant

152
00:07:22,642 --> 00:07:24,477
when changed by the user,

153
00:07:24,477 --> 00:07:28,148
just as there is with
MDM passcode policy profiles.

154
00:07:28,148 --> 00:07:31,651
So, MDM servers have to poll
the device to determine

155
00:07:31,651 --> 00:07:34,020
when the passcode
becomes compliant.

156
00:07:34,020 --> 00:07:36,089
But with the new declarative
device management

157
00:07:36,089 --> 00:07:40,794
passcode status items,
there is no need to do that.

158
00:07:40,794 --> 00:07:43,897
We have added two status items:

159
00:07:43,897 --> 00:07:48,835
Passcode.is-compliant
and passcode.is-present.

160
00:07:48,835 --> 00:07:51,338
Compliance indicates
if the passcode is compliant

161
00:07:51,338 --> 00:07:54,741
with all passcode policies
applied via MDM profiles

162
00:07:54,741 --> 00:07:57,210
or configurations.

163
00:07:57,210 --> 00:07:59,546
These status items
have Boolean values

164
00:07:59,546 --> 00:08:01,481
that mirror
the equivalent properties

165
00:08:01,481 --> 00:08:05,452
that can be retrieved
via MDM queries.

166
00:08:05,452 --> 00:08:08,855
Let's explore
a typical server behavior.

167
00:08:08,855 --> 00:08:12,359
Often, an organization
has security sensitive state

168
00:08:12,359 --> 00:08:14,060
to apply to a device.

169
00:08:14,060 --> 00:08:17,364
For example,
VPN or Wi-Fi profiles

170
00:08:17,364 --> 00:08:21,000
to allow access
to protected networks.

171
00:08:21,000 --> 00:08:23,837
That state should only
be active on a device,

172
00:08:23,837 --> 00:08:26,906
when a strong passcode
policy is present,

173
00:08:26,906 --> 00:08:31,077
and the passcode is compliant
with that policy.

174
00:08:31,077 --> 00:08:33,780
With traditional MDM,
a server has to send

175
00:08:33,780 --> 00:08:37,183
a passcode policy profile
then poll the device,

176
00:08:37,183 --> 00:08:39,586
to wait for the passcode
to become compliant

177
00:08:39,586 --> 00:08:41,454
when the user changes it.

178
00:08:41,454 --> 00:08:44,557
Initially the passcode
is likely not compliant,

179
00:08:44,557 --> 00:08:48,194
so the Wi-Fi profile
cannot be sent.

180
00:08:48,194 --> 00:08:50,764
Eventually, the user
changes the passcode

181
00:08:50,764 --> 00:08:52,599
to bring it into compliance.

182
00:08:52,599 --> 00:08:54,134
On the server's next poll,

183
00:08:54,134 --> 00:08:57,337
it detects the changed
compliant state

184
00:08:57,337 --> 00:09:01,107
and determines it is OK
to send the Wi-Fi profile,

185
00:09:01,107 --> 00:09:04,444
which then gets installed
on the device.

186
00:09:04,444 --> 00:09:06,946
Declarative device management
removes the need

187
00:09:06,946 --> 00:09:10,350
for the server to poll by using
an activation predicate

188
00:09:10,350 --> 00:09:13,520
that is triggered by
the passcode compliance state.

189
00:09:13,520 --> 00:09:15,622
The server sends both
the passcode policy

190
00:09:15,622 --> 00:09:18,858
and the Wi-Fi profile
as configurations,

191
00:09:18,858 --> 00:09:21,961
with the Wi-Fi configuration
tied to an activation

192
00:09:21,961 --> 00:09:25,198
predicated on
the passcode compliance.

193
00:09:25,198 --> 00:09:27,834
The passcode configuration
is immediately activated

194
00:09:27,834 --> 00:09:31,204
and applies a strong
passcode policy.

195
00:09:31,204 --> 00:09:34,007
Initially, the passcode
is likely not compliant,

196
00:09:34,007 --> 00:09:36,910
so the activation predicate
evaluates to false,

197
00:09:36,910 --> 00:09:40,346
and the Wi-Fi configuration
is not activated.

198
00:09:40,346 --> 00:09:44,551
At some point, the user updates
the passcode to be compliant.

199
00:09:44,551 --> 00:09:47,821
This triggers reevaluation
of the activations

200
00:09:47,821 --> 00:09:50,590
and the predicate
now evaluates to true,

201
00:09:50,590 --> 00:09:54,627
resulting in the Wi-Fi
configuration being activated.

202
00:09:54,627 --> 00:09:58,364
All this happens without any
intervention from the server,

203
00:09:58,364 --> 00:10:01,034
and in fact can happen
without any connection

204
00:10:01,034 --> 00:10:03,670
to the server being present.

205
00:10:03,670 --> 00:10:06,272
The server does automatically
get a status report

206
00:10:06,272 --> 00:10:09,175
from the device when
the configuration activates,

207
00:10:09,175 --> 00:10:11,845
so it knows when
the change takes place.

208
00:10:11,845 --> 00:10:14,747
This illustrates how
we have successfully moved

209
00:10:14,747 --> 00:10:17,750
business logic from
the server to the device,

210
00:10:17,750 --> 00:10:19,319
to avoid the need to poll

211
00:10:19,319 --> 00:10:24,290
and get a more responsive
and reliable device behavior.

212
00:10:24,290 --> 00:10:27,894
Now, let's turn
to account status.

213
00:10:27,894 --> 00:10:31,397
In iOS 15, we introduced
account configurations

214
00:10:31,397 --> 00:10:34,968
to install accounts
of various types on a device.

215
00:10:34,968 --> 00:10:37,537
These are typically
organization accounts,

216
00:10:37,537 --> 00:10:41,007
giving the user access
to organization data.

217
00:10:41,007 --> 00:10:44,043
It is useful for the admin
to know when accounts

218
00:10:44,043 --> 00:10:45,812
have been
successfully installed,

219
00:10:45,812 --> 00:10:47,547
and what state they are in,

220
00:10:47,547 --> 00:10:51,451
to help support users
who might be having problems.

221
00:10:51,451 --> 00:10:55,722
This release adds eight
account status items for mail,

222
00:10:55,722 --> 00:10:58,324
calendar,
and other account types.

223
00:10:58,324 --> 00:11:01,261
Note, that status
is only reported for accounts

224
00:11:01,261 --> 00:11:03,062
installed by configurations

225
00:11:03,062 --> 00:11:05,665
and won't include
accounts created manually

226
00:11:05,665 --> 00:11:08,968
or installed via MDM profiles.

227
00:11:08,968 --> 00:11:11,104
Each new status item corresponds

228
00:11:11,104 --> 00:11:13,072
to an account
configuration type,

229
00:11:13,072 --> 00:11:16,042
with status for incoming
and outgoing mail accounts

230
00:11:16,042 --> 00:11:18,344
reported separately.

231
00:11:18,344 --> 00:11:22,248
The new status items each use
a different type of JSON object,

232
00:11:22,248 --> 00:11:26,252
to represent the status of
the corresponding account type.

233
00:11:26,252 --> 00:11:29,556
Here are examples
of an incoming mail status item,

234
00:11:29,556 --> 00:11:32,992
and a subscribed
calendar status item.

235
00:11:32,992 --> 00:11:36,062
The value of the identifier key
is a unique identifier

236
00:11:36,062 --> 00:11:39,599
for an object within the array
of status item objects --

237
00:11:39,599 --> 00:11:42,001
more on this in a minute.

238
00:11:42,001 --> 00:11:44,871
The value of the
declaration identifier key,

239
00:11:44,871 --> 00:11:46,773
matches the identifier
property value

240
00:11:46,773 --> 00:11:49,342
of the configuration
that installed the account,

241
00:11:49,342 --> 00:11:51,210
making it easy
to cross-reference

242
00:11:51,210 --> 00:11:55,415
the status item object and
its associated configuration.

243
00:11:55,415 --> 00:11:57,850
These two keys
are always present

244
00:11:57,850 --> 00:12:01,187
in all types of account
status item object.

245
00:12:01,187 --> 00:12:03,790
The other keys are specific
to the type of account.

246
00:12:03,790 --> 00:12:06,960
For example, hostname and port
for the mail server,

247
00:12:06,960 --> 00:12:11,164
or calendar-URL
for the subscribed calendar.

248
00:12:11,164 --> 00:12:15,468
This release introduces status
items whose value is an array,

249
00:12:15,468 --> 00:12:17,704
to support reporting
on one or more accounts

250
00:12:17,704 --> 00:12:19,472
of the same type.

251
00:12:19,472 --> 00:12:22,809
Such array values
have special behavior.

252
00:12:22,809 --> 00:12:25,712
Each item in the array
is a JSON object

253
00:12:25,712 --> 00:12:30,083
with the same schema used for
all objects in a single array.

254
00:12:30,083 --> 00:12:32,986
Each object type always
has an identifier key,

255
00:12:32,986 --> 00:12:35,822
acting as the primary key
for locating objects

256
00:12:35,822 --> 00:12:37,423
within the array.

257
00:12:37,423 --> 00:12:38,858
Other keys are present

258
00:12:38,858 --> 00:12:42,195
and tied to the underlying type
of status being reported.

259
00:12:42,195 --> 00:12:44,497
To ensure forwards compatibility

260
00:12:44,497 --> 00:12:47,467
with any keys added
in future OS releases,

261
00:12:47,467 --> 00:12:52,505
your server must accept
unknown keys in array objects.

262
00:12:52,505 --> 00:12:55,074
Changes to an array value
are always reported

263
00:12:55,074 --> 00:12:57,210
incrementally to the server

264
00:12:57,210 --> 00:13:01,180
on a per-object basis,
for performance reasons.

265
00:13:01,180 --> 00:13:02,715
Let's run through an example

266
00:13:02,715 --> 00:13:05,885
that shows how
this new feature works.

267
00:13:05,885 --> 00:13:07,186
In this example,

268
00:13:07,186 --> 00:13:09,756
the server sends
two mail account configurations

269
00:13:09,756 --> 00:13:10,990
to the device.

270
00:13:10,990 --> 00:13:14,227
These are both active
resulting in two mail accounts

271
00:13:14,227 --> 00:13:16,329
present on the device.

272
00:13:16,329 --> 00:13:18,464
The server now sends
a status subscription

273
00:13:18,464 --> 00:13:21,000
for the mail account
status item.

274
00:13:21,000 --> 00:13:23,202
When the subscription
is activated,

275
00:13:23,202 --> 00:13:25,238
status for the accounts
is collected,

276
00:13:25,238 --> 00:13:29,208
and the device sends
a status report to the server.

277
00:13:29,208 --> 00:13:32,545
The status report will include
the two account status objects

278
00:13:32,545 --> 00:13:34,213
in the status array,

279
00:13:34,213 --> 00:13:35,848
giving the server
a complete picture

280
00:13:35,848 --> 00:13:38,851
of what is currently
present on the device.

281
00:13:38,851 --> 00:13:42,088
Each array object
has a different identifier.

282
00:13:42,088 --> 00:13:44,123
After processing this report,

283
00:13:44,123 --> 00:13:46,659
the server has status
for two mail accounts,

284
00:13:46,659 --> 00:13:49,529
matching what is on the device.

285
00:13:49,529 --> 00:13:52,131
When the server adds
a mail account on the device

286
00:13:52,131 --> 00:13:55,802
by sending a new configuration,
the status item on the device

287
00:13:55,802 --> 00:13:58,905
has a new object added
to its array value,

288
00:13:58,905 --> 00:14:03,142
and another status report
is sent to the server.

289
00:14:03,142 --> 00:14:05,712
Only the new item is reported.

290
00:14:05,712 --> 00:14:08,614
The value of the identifier
key does not match

291
00:14:08,614 --> 00:14:10,349
any the server already has,

292
00:14:10,349 --> 00:14:15,154
so the server can infer this
corresponds to a new account.

293
00:14:15,154 --> 00:14:16,622
After processing this report,

294
00:14:16,622 --> 00:14:19,358
the server has status
for three mail accounts,

295
00:14:19,358 --> 00:14:21,928
the two initial ones
and the new one,

296
00:14:21,928 --> 00:14:25,932
again matching exactly
what is on the device.

297
00:14:25,932 --> 00:14:27,900
When account status changes,

298
00:14:27,900 --> 00:14:31,704
such as when a user toggles
the mail or notes enabled state,

299
00:14:31,704 --> 00:14:33,439
the status item on the device

300
00:14:33,439 --> 00:14:36,642
will have an updated object
in its array value,

301
00:14:36,642 --> 00:14:41,013
and again, a status report
is sent to the server.

302
00:14:41,013 --> 00:14:43,516
Only the changed item
is reported.

303
00:14:43,516 --> 00:14:46,319
In this case, the user
turned off the notes feature

304
00:14:46,319 --> 00:14:47,920
for the account.

305
00:14:47,920 --> 00:14:49,922
The value of the identifier key

306
00:14:49,922 --> 00:14:52,158
matches one
the server already has,

307
00:14:52,158 --> 00:14:54,961
so the server can infer
that this is an update

308
00:14:54,961 --> 00:14:56,329
to an existing account.

309
00:14:56,329 --> 00:14:57,530
Consequently,

310
00:14:57,530 --> 00:15:00,433
it replaces the existing
status item array object

311
00:15:00,433 --> 00:15:02,769
with the new one.

312
00:15:02,769 --> 00:15:04,437
After processing this report,

313
00:15:04,437 --> 00:15:07,073
the server has status
for three mail accounts,

314
00:15:07,073 --> 00:15:09,942
but one has changed.

315
00:15:09,942 --> 00:15:13,079
When an account configuration
is removed from the device,

316
00:15:13,079 --> 00:15:14,614
the status item on the device

317
00:15:14,614 --> 00:15:17,683
has the corresponding object
marked for removal,

318
00:15:17,683 --> 00:15:21,788
and another status report
is sent to the server.

319
00:15:21,788 --> 00:15:24,257
Only the removed item
is reported.

320
00:15:24,257 --> 00:15:25,858
To indicate removal,

321
00:15:25,858 --> 00:15:29,428
the array item object
contains only two keys:

322
00:15:29,428 --> 00:15:30,997
the identifier key --

323
00:15:30,997 --> 00:15:33,766
whose value matches
one the server already has --

324
00:15:33,766 --> 00:15:37,470
and the removed key,
set to the value true.

325
00:15:37,470 --> 00:15:40,373
This allows the server
to update its representation

326
00:15:40,373 --> 00:15:44,510
of the device state
by removing the existing item.

327
00:15:44,510 --> 00:15:46,379
After processing this report,

328
00:15:46,379 --> 00:15:49,215
the server has status
for only two mail accounts,

329
00:15:49,215 --> 00:15:52,952
correctly matching
the state of the device.

330
00:15:52,952 --> 00:15:55,922
One last point about
status reports.

331
00:15:55,922 --> 00:15:59,225
The device will limit the rate
at which status reports are sent

332
00:15:59,225 --> 00:16:01,527
to avoid performance issues.

333
00:16:01,527 --> 00:16:04,564
The device aggregates
changes to status items

334
00:16:04,564 --> 00:16:07,333
over a variable interval
of up to one minute

335
00:16:07,333 --> 00:16:10,570
before sending a status report
to the server.

336
00:16:10,570 --> 00:16:13,005
This means status
is reported quickly,

337
00:16:13,005 --> 00:16:15,675
but it is not immediate.

338
00:16:15,675 --> 00:16:17,543
Next, let's turn our attention

339
00:16:17,543 --> 00:16:20,513
to solving a perennial
MDM-bottleneck problem:

340
00:16:20,513 --> 00:16:24,050
monitoring
application install status.

341
00:16:24,050 --> 00:16:28,821
MDM servers often install apps
on devices to give users access

342
00:16:28,821 --> 00:16:32,658
to the tools needed
for their work or education.

343
00:16:32,658 --> 00:16:34,861
Server-side logic
is often dictated

344
00:16:34,861 --> 00:16:37,997
by whether an app is installed
successfully or not.

345
00:16:37,997 --> 00:16:42,101
So MDM servers need to monitor
app installation progress

346
00:16:42,101 --> 00:16:46,105
and watch for the possibility
of users removing managed apps

347
00:16:46,105 --> 00:16:48,875
on their device.

348
00:16:48,875 --> 00:16:53,145
Currently, MDM servers can use
the InstalledApplicationList

349
00:16:53,145 --> 00:16:56,349
or ManagedApplicationList
commands to poll the device

350
00:16:56,349 --> 00:16:59,585
to observe
app installation progress.

351
00:16:59,585 --> 00:17:02,088
We can avoid polling
by having the device

352
00:17:02,088 --> 00:17:06,058
proactively send app install
progress to the server.

353
00:17:06,058 --> 00:17:07,326
And the tool to do that

354
00:17:07,326 --> 00:17:12,198
is declarative device management
status reports.

355
00:17:12,198 --> 00:17:15,468
This release adds
an mdm.app status item.

356
00:17:15,468 --> 00:17:19,138
Its value is an array of objects
that each represent an app

357
00:17:19,138 --> 00:17:22,141
that has been installed
by the MDM server.

358
00:17:22,141 --> 00:17:25,611
Since this value is an array,
it is reported incrementally,

359
00:17:25,611 --> 00:17:28,114
using the procedure
described earlier.

360
00:17:28,114 --> 00:17:31,984
Note that only apps installed
by MDM are reported here,

361
00:17:31,984 --> 00:17:35,187
even on supervised devices.

362
00:17:35,187 --> 00:17:38,357
This status report includes
a status item for an app

363
00:17:38,357 --> 00:17:40,493
that has finished installing.

364
00:17:40,493 --> 00:17:43,162
The identifier key
is the unique identifier

365
00:17:43,162 --> 00:17:45,598
for the array item object,
and in this case,

366
00:17:45,598 --> 00:17:48,167
is the app's bundle identifier.

367
00:17:48,167 --> 00:17:51,170
The name key indicates
the name of the app.

368
00:17:51,170 --> 00:17:54,006
The three version keys
provide normal, short,

369
00:17:54,006 --> 00:17:57,043
and external
version identifiers.

370
00:17:57,043 --> 00:17:58,911
And the state key
is an enumeration

371
00:17:58,911 --> 00:18:02,848
that indicates the current
install phase for the app.

372
00:18:02,848 --> 00:18:04,850
The values of these keys
correspond

373
00:18:04,850 --> 00:18:07,053
to the equivalent items
in the MDM

374
00:18:07,053 --> 00:18:10,189
ManagedApplicationList
command response.

375
00:18:10,189 --> 00:18:13,926
With all this information, the
server can immediately identify

376
00:18:13,926 --> 00:18:18,764
which app is being reported
and what its state is.

377
00:18:18,764 --> 00:18:22,902
Let's examine an example of the
flow of data as an app installs.

378
00:18:22,902 --> 00:18:25,738
On the right side,
we have an iOS 16 device

379
00:18:25,738 --> 00:18:28,574
that is being managed
by an MDM server.

380
00:18:28,574 --> 00:18:31,978
The server has already enabled
declarative device management

381
00:18:31,978 --> 00:18:33,646
and sent a status subscription

382
00:18:33,646 --> 00:18:37,049
for the MDM-installed
app status item.

383
00:18:37,049 --> 00:18:39,719
The next step for the server
is to install an app

384
00:18:39,719 --> 00:18:43,222
using the MDM
InstallApplication command.

385
00:18:43,222 --> 00:18:46,625
Since this is a user enrollment,
user approval is needed

386
00:18:46,625 --> 00:18:49,295
to install the app,
so a prompt appears

387
00:18:49,295 --> 00:18:52,698
when the device processes
the app install command.

388
00:18:52,698 --> 00:18:55,868
At this point, the installation
progress is paused,

389
00:18:55,868 --> 00:18:58,604
waiting for user input.

390
00:18:58,604 --> 00:19:01,540
The device will send
a status report to the server,

391
00:19:01,540 --> 00:19:05,644
and that will contain a single
MDM-installed app status object,

392
00:19:05,644 --> 00:19:10,282
with the bundle ID of the app
and the state set to prompting.

393
00:19:10,282 --> 00:19:13,085
At some point, the user taps
the Install button,

394
00:19:13,085 --> 00:19:16,856
and the app install
starts on the device.

395
00:19:16,856 --> 00:19:20,693
As the install proceeds, another
status report will be sent,

396
00:19:20,693 --> 00:19:23,829
this time with the app state
set to installing;

397
00:19:23,829 --> 00:19:28,300
indicating the app is being
downloaded and installed.

398
00:19:28,300 --> 00:19:30,536
Eventually, the app
completes installation

399
00:19:30,536 --> 00:19:32,705
and is ready for use.

400
00:19:32,705 --> 00:19:35,241
At that point, another
status report will be sent

401
00:19:35,241 --> 00:19:37,443
with the app state
set to managed,

402
00:19:37,443 --> 00:19:41,380
indicating the app is properly
installed and managed.

403
00:19:41,380 --> 00:19:46,085
Now, let's say the user manually
deletes the app on the device.

404
00:19:46,085 --> 00:19:48,554
Again, a status report
will be sent,

405
00:19:48,554 --> 00:19:53,259
this time with the app state set
to managed-but-uninstalled.

406
00:19:53,259 --> 00:19:55,895
This indicates the app
is no longer installed,

407
00:19:55,895 --> 00:19:58,497
but its management state
is still being tracked

408
00:19:58,497 --> 00:20:00,699
on the device.

409
00:20:00,699 --> 00:20:02,835
Let's assume the server
wants to remove

410
00:20:02,835 --> 00:20:04,770
the app-management state.

411
00:20:04,770 --> 00:20:07,807
It does that by sending
a RemoveApplication command

412
00:20:07,807 --> 00:20:09,341
to the device.

413
00:20:09,341 --> 00:20:12,311
That removes the internally
maintained management state,

414
00:20:12,311 --> 00:20:14,647
and if the app were
still present,

415
00:20:14,647 --> 00:20:17,283
it would be removed too.

416
00:20:17,283 --> 00:20:19,752
Another status report will be
sent with the app object

417
00:20:19,752 --> 00:20:22,822
marked as removed
from the app status array.

418
00:20:22,822 --> 00:20:26,725
This illustrates the power of
the new MDM status item

419
00:20:26,725 --> 00:20:28,594
to help improve
the responsiveness

420
00:20:28,594 --> 00:20:30,963
and reliability of app installs,

421
00:20:30,963 --> 00:20:35,000
and it only takes a few steps
to implement.

422
00:20:35,000 --> 00:20:40,372
Now, let's examine our third
focus area: predicates.

423
00:20:40,372 --> 00:20:43,342
Let's quickly review
activation predicates.

424
00:20:43,342 --> 00:20:45,911
Activations can include
an optional predicate

425
00:20:45,911 --> 00:20:47,980
that determines
whether the configurations

426
00:20:47,980 --> 00:20:52,118
referenced in the activation
will be applied to the device.

427
00:20:52,118 --> 00:20:53,853
Predicates can reference
status items

428
00:20:53,853 --> 00:20:57,823
to allow the values of those
status items to be tested.

429
00:20:57,823 --> 00:21:00,593
When a status item referenced
in a predicate changes,

430
00:21:00,593 --> 00:21:03,662
the device will reprocess
all of the activations,

431
00:21:03,662 --> 00:21:06,565
reevaluating any predicates.

432
00:21:06,565 --> 00:21:08,400
Predicates are specified
as a string

433
00:21:08,400 --> 00:21:10,402
using the NSPredicate syntax

434
00:21:10,402 --> 00:21:13,572
documented on
the Apple Developer site.

435
00:21:13,572 --> 00:21:16,675
To support more complex
predicate expressions,

436
00:21:16,675 --> 00:21:19,812
we have extended the predicate
syntax to make it easier

437
00:21:19,812 --> 00:21:23,682
to detect status items
in the expression.

438
00:21:23,682 --> 00:21:26,318
The new syntax places
the status item name

439
00:21:26,318 --> 00:21:30,456
inside an @status term
in the predicate string.

440
00:21:30,456 --> 00:21:33,492
In the example,
the serial number status item

441
00:21:33,492 --> 00:21:35,327
appears in
the predicate expression,

442
00:21:35,327 --> 00:21:38,330
using the new syntax.

443
00:21:38,330 --> 00:21:40,266
The previous syntax
will continue to work

444
00:21:40,266 --> 00:21:44,537
for backwards compatibility,
however, it is now deprecated,

445
00:21:44,537 --> 00:21:47,640
so please switch
to the new one.

446
00:21:47,640 --> 00:21:49,575
Let's examine how
predicates can be used

447
00:21:49,575 --> 00:21:52,011
with status item array values.

448
00:21:52,011 --> 00:21:55,047
As we just described,
we now have status item values

449
00:21:55,047 --> 00:21:56,882
that are arrays
for the accounts

450
00:21:56,882 --> 00:21:59,785
and MDM-installed
app status items.

451
00:21:59,785 --> 00:22:02,521
It is useful to be able
to predicate an activation

452
00:22:02,521 --> 00:22:05,157
on an item in the array.

453
00:22:05,157 --> 00:22:08,561
For example, we might want
an activation to be triggered

454
00:22:08,561 --> 00:22:10,963
when an app with a particular
bundle identifier

455
00:22:10,963 --> 00:22:14,567
is installed and managed
on the device.

456
00:22:14,567 --> 00:22:16,869
NSPredicate has
a SUBQUERY term

457
00:22:16,869 --> 00:22:20,239
that can be used
to operate on arrays.

458
00:22:20,239 --> 00:22:23,142
This NSPredicate expression
uses a SUBQUERY

459
00:22:23,142 --> 00:22:26,812
targeting the MDM-installed
app status item.

460
00:22:26,812 --> 00:22:30,983
The status item is used as the
first argument to the SUBQUERY.

461
00:22:30,983 --> 00:22:33,085
The second argument
defines a variable

462
00:22:33,085 --> 00:22:35,754
that will refer to each
element of the array.

463
00:22:35,754 --> 00:22:38,023
The third argument is
a predicate expression

464
00:22:38,023 --> 00:22:42,494
that tests each element
identified by that variable.

465
00:22:42,494 --> 00:22:45,397
The SUBQUERY expression
returns an array of elements

466
00:22:45,397 --> 00:22:48,701
that match the predicate
in the third argument.

467
00:22:48,701 --> 00:22:51,637
The @count operator
then returns the length

468
00:22:51,637 --> 00:22:53,772
of that array,
and the length is checked

469
00:22:53,772 --> 00:22:57,476
to determine if there is
one resulting match.

470
00:22:57,476 --> 00:23:00,446
When the specified app
is installed and managed,

471
00:23:00,446 --> 00:23:02,748
this SUBQUERY expression
will return an array

472
00:23:02,748 --> 00:23:04,450
with a single element,

473
00:23:04,450 --> 00:23:07,453
and the predicate
will evaluate to true.

474
00:23:07,453 --> 00:23:10,356
When the app is not installed,
the SUBQUERY expression

475
00:23:10,356 --> 00:23:12,091
will return an empty array,

476
00:23:12,091 --> 00:23:15,694
and the predicate
will evaluate to false.

477
00:23:15,694 --> 00:23:18,230
Note that in order
to reference the keys

478
00:23:18,230 --> 00:23:21,800
in the status item array object,
the @key extension term

479
00:23:21,800 --> 00:23:25,838
must be used to ensure the key
paths are properly processed.

480
00:23:25,838 --> 00:23:28,540
The new predicate syntax
is extensible,

481
00:23:28,540 --> 00:23:30,976
and we will now discuss
how it can be used

482
00:23:30,976 --> 00:23:35,781
to add predicate terms
for a new type of data.

483
00:23:35,781 --> 00:23:38,417
Servers need to be able
to more directly control

484
00:23:38,417 --> 00:23:42,221
the evaluation of predicates, so
that complex server-side logic

485
00:23:42,221 --> 00:23:45,591
can translate into simple
state changes on the device,

486
00:23:45,591 --> 00:23:48,894
without the need to synchronize
large sets of configurations

487
00:23:48,894 --> 00:23:51,130
to trigger those changes.

488
00:23:51,130 --> 00:23:54,400
An example of this might be
an organization that has users

489
00:23:54,400 --> 00:23:57,236
with multiple roles
and wants efficient,

490
00:23:57,236 --> 00:23:59,071
just-in-time assignment
of devices

491
00:23:59,071 --> 00:24:03,008
as they are handed out to users,
or organizations that need

492
00:24:03,008 --> 00:24:05,644
to quickly distribute
replacement devices,

493
00:24:05,644 --> 00:24:07,813
or quickly put devices
into a safe mode

494
00:24:07,813 --> 00:24:10,516
to protect organization data.

495
00:24:10,516 --> 00:24:13,185
To support this,
I am pleased to say

496
00:24:13,185 --> 00:24:16,355
we are adding a new declaration
to allow servers

497
00:24:16,355 --> 00:24:19,058
to set arbitrary properties
on the device,

498
00:24:19,058 --> 00:24:22,328
that can be directly used
in activation predicates.

499
00:24:22,328 --> 00:24:26,865
This is the new management
properties declaration.

500
00:24:26,865 --> 00:24:29,501
The declaration consists
of a JSON object

501
00:24:29,501 --> 00:24:33,005
whose key names
are defined by the server.

502
00:24:33,005 --> 00:24:36,642
The JSON object values
can be any JSON value type,

503
00:24:36,642 --> 00:24:39,645
including arrays or objects.

504
00:24:39,645 --> 00:24:41,580
The management properties
declaration here,

505
00:24:41,580 --> 00:24:44,950
includes three properties:
the name and age properties

506
00:24:44,950 --> 00:24:47,252
that have a string
and integer value,

507
00:24:47,252 --> 00:24:51,724
and the roles property
that is an array of strings.

508
00:24:51,724 --> 00:24:54,093
This is an activation
with a predicate

509
00:24:54,093 --> 00:24:56,929
that references some
management properties.

510
00:24:56,929 --> 00:24:59,965
First, it tests the age property
to determine

511
00:24:59,965 --> 00:25:03,702
if its integer value is
greater than or equal to 18,

512
00:25:03,702 --> 00:25:06,472
then it tests the roles property
to determine

513
00:25:06,472 --> 00:25:11,577
if the string Grade12 is
in the property array value.

514
00:25:11,577 --> 00:25:12,845
Each property is referenced

515
00:25:12,845 --> 00:25:15,447
using the @property
extension term,

516
00:25:15,447 --> 00:25:19,651
with the property key name
inside the term.

517
00:25:19,651 --> 00:25:21,687
Multiple management
properties declarations

518
00:25:21,687 --> 00:25:23,288
can be sent to the device,

519
00:25:23,288 --> 00:25:26,692
but the keys should be unique
across all of them.

520
00:25:26,692 --> 00:25:29,461
If there are duplicate keys,
one of the values

521
00:25:29,461 --> 00:25:32,464
will be arbitrarily chosen
when the property is referenced

522
00:25:32,464 --> 00:25:35,834
in a predicate, leading
to unpredictable results.

523
00:25:35,834 --> 00:25:39,471
So please avoid using
duplicate key names.

524
00:25:39,471 --> 00:25:43,075
Let's explore
an example use case.

525
00:25:43,075 --> 00:25:45,411
This example involves a school.

526
00:25:45,411 --> 00:25:48,647
And of course, the school
has a set of teachers.

527
00:25:48,647 --> 00:25:52,885
The school has two divisions:
Upper and Lower.

528
00:25:52,885 --> 00:25:57,322
Each division has its own campus
with its own Wi-Fi network.

529
00:25:57,322 --> 00:25:59,858
Some teachers function
as an IT Admin

530
00:25:59,858 --> 00:26:02,895
and require access
to a shared mail account.

531
00:26:02,895 --> 00:26:05,631
Some teachers also function
as a sports coach

532
00:26:05,631 --> 00:26:07,499
and should have
a subscribed calendar

533
00:26:07,499 --> 00:26:10,369
for all the team
game schedules.

534
00:26:10,369 --> 00:26:13,839
There are thus four different
roles that a teacher may have,

535
00:26:13,839 --> 00:26:16,842
and sometimes
they have multiple roles.

536
00:26:16,842 --> 00:26:19,077
Each role has a set
of configurations

537
00:26:19,077 --> 00:26:22,014
that must be applied to devices
based on the roles

538
00:26:22,014 --> 00:26:25,417
of the teacher
assigned to the device.

539
00:26:25,417 --> 00:26:28,887
Let's consider two teachers
in our example.

540
00:26:28,887 --> 00:26:30,889
Teacher one teaches
in Lower school

541
00:26:30,889 --> 00:26:33,425
and is also a sports coach.

542
00:26:33,425 --> 00:26:39,298
Teacher two teaches in Upper
school and is also an IT admin.

543
00:26:39,298 --> 00:26:41,066
How might such a use case
be handled

544
00:26:41,066 --> 00:26:44,169
by a traditional MDM server?

545
00:26:44,169 --> 00:26:46,638
Typically, the server has
to wait for a device

546
00:26:46,638 --> 00:26:48,340
to be assigned to a teacher

547
00:26:48,340 --> 00:26:51,577
before it can fully
configure that device.

548
00:26:51,577 --> 00:26:55,247
The server has to determine
what roles the teacher has.

549
00:26:55,247 --> 00:26:59,585
It then determines what profiles
are linked to each role.

550
00:26:59,585 --> 00:27:02,488
It then has to install
each profile on the device

551
00:27:02,488 --> 00:27:05,157
one at a time.

552
00:27:05,157 --> 00:27:07,993
If a teacher changes roles,
the server has to add

553
00:27:07,993 --> 00:27:11,330
or remove profiles
to match the new roles.

554
00:27:11,330 --> 00:27:14,099
This is time-consuming
and can introduce

555
00:27:14,099 --> 00:27:17,336
significant bottlenecks
to a device-management system

556
00:27:17,336 --> 00:27:19,471
particularly at peak times,

557
00:27:19,471 --> 00:27:21,874
which in our case would be
the first day of school

558
00:27:21,874 --> 00:27:24,409
when assignments are done.

559
00:27:24,409 --> 00:27:26,745
With the new management
properties declaration,

560
00:27:26,745 --> 00:27:30,015
we have a more efficient
alternative to this.

561
00:27:30,015 --> 00:27:32,951
This involves preloading
a full set of declarations

562
00:27:32,951 --> 00:27:35,954
on the device ahead of time.

563
00:27:35,954 --> 00:27:38,323
Configurations
are assigned to activations,

564
00:27:38,323 --> 00:27:41,260
with predicates that are
triggered for different roles

565
00:27:41,260 --> 00:27:44,363
via management properties.

566
00:27:44,363 --> 00:27:47,799
When a device is assigned to
a teacher, the server sends only

567
00:27:47,799 --> 00:27:49,935
a management properties
declaration

568
00:27:49,935 --> 00:27:52,871
with the teacher's roles,
which triggers activation

569
00:27:52,871 --> 00:27:56,375
of the configurations
for those roles.

570
00:27:56,375 --> 00:27:58,844
This method minimizes
the overall server

571
00:27:58,844 --> 00:28:01,847
and network traffic
and reduces the complexity

572
00:28:01,847 --> 00:28:05,617
of making rapid changes
to device state.

573
00:28:05,617 --> 00:28:07,953
Let's go back
to our school example.

574
00:28:07,953 --> 00:28:11,590
The server will preload the
following sets of declarations:

575
00:28:11,590 --> 00:28:13,992
two activation/configuration
pairs

576
00:28:13,992 --> 00:28:17,362
that set up the Wi-Fi network
for each division.

577
00:28:17,362 --> 00:28:19,865
Then, we have an
activation/configuration pair

578
00:28:19,865 --> 00:28:23,001
for the IT admin role,
that installs a mail account.

579
00:28:23,001 --> 00:28:26,071
Finally, we have an activation
and configuration

580
00:28:26,071 --> 00:28:29,341
that installs
a subscribed calendar.

581
00:28:29,341 --> 00:28:32,444
Each activation has a predicate
that tests the division

582
00:28:32,444 --> 00:28:36,515
or function's name using
the roles management property.

583
00:28:36,515 --> 00:28:39,384
When initially loaded
on an unassigned device,

584
00:28:39,384 --> 00:28:44,189
all the predicates evaluate
to false, so nothing is applied.

585
00:28:44,189 --> 00:28:48,427
Now, let's examine what happens
on the day of assignment.

586
00:28:48,427 --> 00:28:50,696
All the server needs to do
is create

587
00:28:50,696 --> 00:28:52,598
management properties
declarations

588
00:28:52,598 --> 00:28:55,467
customized to each teacher.

589
00:28:55,467 --> 00:28:59,938
Teacher one has a roles property
that lists Lower and Sports.

590
00:28:59,938 --> 00:29:05,210
Teacher two has a roles property
that lists Upper and IT Admin.

591
00:29:05,210 --> 00:29:07,479
When these declarations
are separately sent

592
00:29:07,479 --> 00:29:09,281
to each assigned device,

593
00:29:09,281 --> 00:29:13,418
the preloaded activations
will all be reevaluated.

594
00:29:13,418 --> 00:29:16,555
So teacher one's device
has the configurations

595
00:29:16,555 --> 00:29:20,325
for Lower and Sports
roles activated.

596
00:29:20,325 --> 00:29:23,195
And teacher two's device
has the configurations

597
00:29:23,195 --> 00:29:27,199
for the Upper and IT Admin
roles activated.

598
00:29:27,199 --> 00:29:29,868
Only a single declaration
is needed to trigger

599
00:29:29,868 --> 00:29:33,438
the application
of many configurations.

600
00:29:33,438 --> 00:29:34,773
Finally, let's examine

601
00:29:34,773 --> 00:29:37,643
what happens when
a teacher changes roles.

602
00:29:37,643 --> 00:29:40,512
In this case, teacher two
has become a sports coach

603
00:29:40,512 --> 00:29:43,448
in addition
to their existing roles.

604
00:29:43,448 --> 00:29:45,283
The management
properties declaration

605
00:29:45,283 --> 00:29:47,919
for the teacher's assigned
device is now updated

606
00:29:47,919 --> 00:29:50,956
to include
the additional role name.

607
00:29:50,956 --> 00:29:53,458
When that declaration
is updated on the device,

608
00:29:53,458 --> 00:29:56,328
all the activations
are reevaluated.

609
00:29:56,328 --> 00:29:58,997
In this case, the subscribed
calendar configuration

610
00:29:58,997 --> 00:30:01,733
for the new Sports role
will be applied.

611
00:30:01,733 --> 00:30:06,838
Again, only a single declaration
change is needed as a trigger.

612
00:30:06,838 --> 00:30:07,973
This illustrates

613
00:30:07,973 --> 00:30:10,108
how the management
properties declaration

614
00:30:10,108 --> 00:30:13,512
provides a powerful way
to quickly and easily switch

615
00:30:13,512 --> 00:30:16,682
between sets of configurations
on a device,

616
00:30:16,682 --> 00:30:18,817
so that complex
server-side logic

617
00:30:18,817 --> 00:30:23,555
can translate into simple
state changes on the device.

618
00:30:23,555 --> 00:30:25,824
Now, let's wrap up.

619
00:30:25,824 --> 00:30:29,027
We have extended the scope of
declarative device management

620
00:30:29,027 --> 00:30:34,499
on iOS 16, tvOS 16,
and macOS Ventura,

621
00:30:34,499 --> 00:30:37,402
as well as making it available
for all applicable types

622
00:30:37,402 --> 00:30:41,173
of MDM enrollment,
including Shared iPad.

623
00:30:41,173 --> 00:30:45,077
This provides full support for
declarative device management

624
00:30:45,077 --> 00:30:49,948
across all Apple devices
that support MDM.

625
00:30:49,948 --> 00:30:53,919
We have added new status items
for passcode, accounts,

626
00:30:53,919 --> 00:30:56,321
and MDM-installed apps.

627
00:30:56,321 --> 00:31:00,358
The MDM-installed app status
provides a great solution

628
00:31:00,358 --> 00:31:03,895
for one of MDM's
key bottlenecks.

629
00:31:03,895 --> 00:31:06,798
Finally, we have enhanced
the predicate syntax

630
00:31:06,798 --> 00:31:10,102
to make it more extensible
and easy to use

631
00:31:10,102 --> 00:31:13,305
and added the new management
properties declaration

632
00:31:13,305 --> 00:31:16,007
that gives servers
even more opportunity

633
00:31:16,007 --> 00:31:19,811
to move complex business logic
to the device.

634
00:31:19,811 --> 00:31:22,414
Now is the time to add
declarative device management

635
00:31:22,414 --> 00:31:24,049
to your products.

636
00:31:24,049 --> 00:31:26,284
And we're excited to learn
what you'll do

637
00:31:26,284 --> 00:31:28,587
to reimagine device
management solutions

638
00:31:28,587 --> 00:31:32,357
using declarative
device management!

639
00:31:32,357 --> 00:31:35,627
As always, your feedback
is greatly appreciated.

640
00:31:35,627 --> 00:31:38,463
Thank you and enjoy
the rest of WWDC.

641
00:31:38,463 --> 00:31:43,568
♪ ♪

