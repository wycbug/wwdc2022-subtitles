1
00:00:00,000 --> 00:00:02,970
♪ instrumental hip hop music ♪

2
00:00:02,970 --> 00:00:09,409
♪

3
00:00:09,409 --> 00:00:13,247
Hi. I'm Curt, an engineer
on the SwiftUI team.

4
00:00:13,247 --> 00:00:16,950
There are some exciting new APIs
for navigation in SwiftUI.

5
00:00:16,950 --> 00:00:19,720
I've been enjoying building apps
with these new APIs

6
00:00:19,720 --> 00:00:23,290
and I'm thrilled to be able
to share them with you.

7
00:00:23,290 --> 00:00:25,893
These APIs scale
from basic stacks --

8
00:00:25,893 --> 00:00:28,929
like on Apple TV,
iPhone, and Apple Watch --

9
00:00:28,929 --> 00:00:31,565
to powerful multicolumn
presentations.

10
00:00:31,565 --> 00:00:33,901
The new APIs
bring robust support

11
00:00:33,901 --> 00:00:36,703
for programmatic navigation
and deep linking,

12
00:00:36,703 --> 00:00:40,140
letting you compose pieces
to build the perfect structure

13
00:00:40,140 --> 00:00:42,109
for your app.

14
00:00:42,109 --> 00:00:45,412
In this talk, I'll give you
some straightforward recipes

15
00:00:45,412 --> 00:00:48,782
for cooking up an app
with navigation in SwiftUI.

16
00:00:48,782 --> 00:00:51,118
And if you're already
using SwiftUI,

17
00:00:51,118 --> 00:00:54,554
we hope these new APIs will
help you kick it up a notch.

18
00:00:54,554 --> 00:00:55,889
I'll start with the ingredients

19
00:00:55,889 --> 00:00:59,559
that go into the new
data-driven navigation APIs.

20
00:00:59,559 --> 00:01:01,695
Then, we'll move
to our tasting menu:

21
00:01:01,695 --> 00:01:03,497
several quick and easy recipes

22
00:01:03,497 --> 00:01:06,533
for full programmatic
control of navigation.

23
00:01:06,533 --> 00:01:09,136
For the dessert course,
I'll share some tips

24
00:01:09,136 --> 00:01:14,374
on using the new APIs to persist
navigation state in your apps.

25
00:01:14,374 --> 00:01:17,344
If you've used navigation
in SwiftUI before,

26
00:01:17,344 --> 00:01:20,514
you might be wondering
how the new APIs are different.

27
00:01:20,514 --> 00:01:25,052
So before digging in, let's
review some of the existing API.

28
00:01:25,052 --> 00:01:28,755
The existing APIs are based
on links that send views

29
00:01:28,755 --> 00:01:31,625
that are shown in other columns
or on a stack.

30
00:01:31,625 --> 00:01:33,026
For example, I might have a list

31
00:01:33,026 --> 00:01:35,495
of navigation links
in a root view.

32
00:01:35,495 --> 00:01:37,331
When I tap one of these links,

33
00:01:37,331 --> 00:01:40,600
the link pushes
its view on the stack.

34
00:01:40,600 --> 00:01:42,869
This works great
for basic navigation,

35
00:01:42,869 --> 00:01:45,272
and you can continue
using this pattern.

36
00:01:45,272 --> 00:01:48,809
But let's pop back
to the root view.

37
00:01:48,809 --> 00:01:51,345
With the existing
navigation API,

38
00:01:51,345 --> 00:01:53,246
to present a link
programmatically,

39
00:01:53,246 --> 00:01:55,382
I add a binding to the link.

40
00:01:55,382 --> 00:01:57,985
For example,
I can present this link's view

41
00:01:57,985 --> 00:02:01,421
by setting item.showDetail
to true.

42
00:02:01,421 --> 00:02:06,693
But this means I need a separate
binding for each link.

43
00:02:06,693 --> 00:02:09,363
With the new API,
we lift the binding up

44
00:02:09,363 --> 00:02:13,066
to the entire container,
called a NavigationStack.

45
00:02:13,066 --> 00:02:14,601
The path here
is a collection

46
00:02:14,601 --> 00:02:18,672
that represents all the values
pushed on the stack.

47
00:02:18,672 --> 00:02:21,475
NavigationLinks
append values to the path.

48
00:02:21,475 --> 00:02:23,810
You can deep link
by mutating the path;

49
00:02:23,810 --> 00:02:26,513
or pop to the root view
by removing all the items

50
00:02:26,513 --> 00:02:28,248
from the path.

51
00:02:28,248 --> 00:02:31,651
In this talk, I'll show you
how the new navigation API

52
00:02:31,651 --> 00:02:34,955
enables data-driven
programmatic navigation.

53
00:02:34,955 --> 00:02:38,792
I hope you find it
powerful and easy to use.

54
00:02:38,792 --> 00:02:42,629
Before jumping into recipes for
using the new navigation APIs,

55
00:02:42,629 --> 00:02:46,066
I thought it would be helpful
to share what's on the menu.

56
00:02:46,066 --> 00:02:48,135
I've really gotten
into cooking lately

57
00:02:48,135 --> 00:02:51,304
and I've been working on an app
to keep track of my recipes.

58
00:02:51,304 --> 00:02:52,506
I have a lot of ideas

59
00:02:52,506 --> 00:02:55,075
about different ways
to present this info.

60
00:02:55,075 --> 00:02:58,178
For example,
here's a three-column approach.

61
00:02:58,178 --> 00:03:01,381
The first column lets me
select a recipe category.

62
00:03:01,381 --> 00:03:02,883
When I select a category,

63
00:03:02,883 --> 00:03:06,186
the second column lists
the recipes I've collected.

64
00:03:06,186 --> 00:03:07,554
And when I select a recipe,

65
00:03:07,554 --> 00:03:11,525
the detail area shows
the ingredients for that recipe.

66
00:03:11,525 --> 00:03:13,326
The detail area also has links

67
00:03:13,326 --> 00:03:15,829
to a selection
of related recipes.

68
00:03:15,829 --> 00:03:19,599
My grandma always said,
"The crust makes the pie."

69
00:03:19,599 --> 00:03:21,701
So that's what
we're cooking up today.

70
00:03:21,701 --> 00:03:24,638
Our ingredients are
the new navigation APIs.

71
00:03:24,638 --> 00:03:25,906
Let's dig into those,

72
00:03:25,906 --> 00:03:28,675
then we'll look at some
specific navigation recipes

73
00:03:28,675 --> 00:03:31,578
that mix them together.

74
00:03:31,578 --> 00:03:34,081
The new navigation APIs
introduce a couple

75
00:03:34,081 --> 00:03:36,416
of new container types
that you can use

76
00:03:36,416 --> 00:03:38,885
to describe
the structure of your app,

77
00:03:38,885 --> 00:03:41,521
along with a fresh new varietal
of NavigationLink

78
00:03:41,521 --> 00:03:45,492
for helping your guests
move around that structure.

79
00:03:45,492 --> 00:03:48,728
The first new container
is NavigationStack.

80
00:03:48,728 --> 00:03:51,398
NavigationStack represents
a push-pop interface

81
00:03:51,398 --> 00:03:53,867
like you see
in Find My on Apple Watch,

82
00:03:53,867 --> 00:03:55,135
Settings on iPhone,

83
00:03:55,135 --> 00:04:00,874
and the new System Settings app
on macOS Ventura.

84
00:04:00,874 --> 00:04:04,945
The second new container type
is NavigationSplitView.

85
00:04:04,945 --> 00:04:07,747
NavigationSplitView
is perfect for multicolumn apps

86
00:04:07,747 --> 00:04:11,418
like Mail or Notes
on Mac and iPad.

87
00:04:11,418 --> 00:04:13,820
And NavigationSplitView
automatically adapts

88
00:04:13,820 --> 00:04:16,323
to a single-column stack
on iPhone,

89
00:04:16,323 --> 00:04:17,891
in Slide Over on iPad,

90
00:04:17,891 --> 00:04:20,927
and even on Apple Watch
and Apple TV.

91
00:04:20,927 --> 00:04:24,097
NavigationSplitView
has two sets of initializers.

92
00:04:24,097 --> 00:04:29,970
One set, like shown here,
creates a two-column experience.

93
00:04:29,970 --> 00:04:31,338
The other set of initializers

94
00:04:31,338 --> 00:04:33,840
creates a three-column
experience.

95
00:04:33,840 --> 00:04:36,109
NavigationSplitView
comes with a cartload

96
00:04:36,109 --> 00:04:39,446
of configuration options that
let you customize column widths,

97
00:04:39,446 --> 00:04:41,281
sidebar presentation,

98
00:04:41,281 --> 00:04:45,118
and even programmatically
show and hide columns.

99
00:04:45,118 --> 00:04:46,887
I won't dive into
the configuration options

100
00:04:46,887 --> 00:04:50,223
in this talk, but please check
out my colleague Raj's talk,

101
00:04:50,223 --> 00:04:53,660
"SwiftUI on iPad:
Organize your interface"

102
00:04:53,660 --> 00:04:55,996
and the great documentation
on how to tune

103
00:04:55,996 --> 00:05:00,634
NavigationSplitView
to be just right for your app.

104
00:05:00,634 --> 00:05:03,737
Previously, NavigationLinks
always included

105
00:05:03,737 --> 00:05:06,106
a title and view to present.

106
00:05:06,106 --> 00:05:08,542
The new varieties
still include a title,

107
00:05:08,542 --> 00:05:10,510
but instead
of a view to present,

108
00:05:10,510 --> 00:05:12,379
they present a value.

109
00:05:12,379 --> 00:05:14,181
For example,
this link is presenting

110
00:05:14,181 --> 00:05:16,349
the recipe for apple pie.

111
00:05:16,349 --> 00:05:18,718
As we'll see,
NavigationLink is smart.

112
00:05:18,718 --> 00:05:21,721
A link's behavior depends on
the NavigationStack or list

113
00:05:21,721 --> 00:05:24,758
that it appears in.

114
00:05:24,758 --> 00:05:28,295
To see how these
tasty new APIs work together,

115
00:05:28,295 --> 00:05:31,097
let's look at some specific
recipes for using them

116
00:05:31,097 --> 00:05:34,601
in my cookbook app,
and in your apps.

117
00:05:34,601 --> 00:05:37,137
Our first recipe
is a basic stack of views,

118
00:05:37,137 --> 00:05:39,306
like you'd find in
Find My on Apple Watch

119
00:05:39,306 --> 00:05:41,374
or Settings on iPhone.

120
00:05:41,374 --> 00:05:43,910
I have a section
for each category.

121
00:05:43,910 --> 00:05:47,647
Within a section, I can tap
on a recipe to see the details.

122
00:05:47,647 --> 00:05:51,218
Within any recipe, I can tap
one of the related recipes

123
00:05:51,218 --> 00:05:53,753
to push it onto the stack.

124
00:05:53,753 --> 00:05:56,690
I can use the back button
to return to the original recipe

125
00:05:56,690 --> 00:06:01,728
and then to the categories list.

126
00:06:01,728 --> 00:06:04,264
This recipe combines
a NavigationStack

127
00:06:04,264 --> 00:06:06,499
with the new variety
of NavigationLink,

128
00:06:06,499 --> 00:06:09,536
and a navigation
destination modifier.

129
00:06:09,536 --> 00:06:11,805
Let's see how.

130
00:06:11,805 --> 00:06:15,175
I'll start with a basic
NavigationStack.

131
00:06:15,175 --> 00:06:19,713
Inside, I have a List that
iterates over all my categories

132
00:06:19,713 --> 00:06:22,315
and a navigationTitle.

133
00:06:22,315 --> 00:06:26,453
Inside the List, I have
a section for each category.

134
00:06:26,453 --> 00:06:30,123
Next, inside each section,
I'll add a NavigationLink

135
00:06:30,123 --> 00:06:33,560
for each recipe in the category.

136
00:06:33,560 --> 00:06:36,896
For now, I'll make the link
present my RecipeDetail view.

137
00:06:36,896 --> 00:06:38,231
This is using the existing

138
00:06:38,231 --> 00:06:41,001
view destination
NavigationLink.

139
00:06:41,001 --> 00:06:43,069
And that's enough to get
this navigation experience

140
00:06:43,069 --> 00:06:45,338
cooking along.

141
00:06:45,338 --> 00:06:48,275
But what about
programmatic navigation?

142
00:06:48,275 --> 00:06:50,210
To add programmatic navigation,

143
00:06:50,210 --> 00:06:53,680
I need to tease apart two pieces
of this navigation link:

144
00:06:53,680 --> 00:06:55,582
the value it presents

145
00:06:55,582 --> 00:06:57,951
and the view
that goes with that value.

146
00:06:57,951 --> 00:06:59,853
Let's see how.

147
00:06:59,853 --> 00:07:03,390
First, I'll pull the destination
view out of the link

148
00:07:03,390 --> 00:07:08,028
and into the new
navigationDestination modifier.

149
00:07:08,028 --> 00:07:10,997
This modifier declares
the type of the presented data

150
00:07:10,997 --> 00:07:15,268
that it's responsible for;
here, that's a Recipe.

151
00:07:15,268 --> 00:07:17,270
The modifier takes
a view builder

152
00:07:17,270 --> 00:07:20,173
that describes what view
to push onto the stack

153
00:07:20,173 --> 00:07:23,910
when a recipe value
is presented.

154
00:07:23,910 --> 00:07:26,980
Then, I'll switch to one
of the new NavigationLinks

155
00:07:26,980 --> 00:07:30,050
and just present
the recipe value.

156
00:07:30,050 --> 00:07:31,117
Let's peek under the hood

157
00:07:31,117 --> 00:07:35,555
and see how NavigationStack
makes this work.

158
00:07:35,555 --> 00:07:38,391
Every navigation stack
keeps track of a path

159
00:07:38,391 --> 00:07:41,795
that represents all the data
that the stack is showing.

160
00:07:41,795 --> 00:07:43,830
When the stack is
just showing its root view,

161
00:07:43,830 --> 00:07:47,267
like shown here,
the path is empty.

162
00:07:47,267 --> 00:07:49,436
Next, the stack also keeps track

163
00:07:49,436 --> 00:07:53,006
of all the navigation
destinations declared inside it,

164
00:07:53,006 --> 00:07:55,842
or inside any view
pushed onto the stack.

165
00:07:55,842 --> 00:07:58,378
In general, this is a set,
though for this example,

166
00:07:58,378 --> 00:08:01,448
we only have one destination.

167
00:08:01,448 --> 00:08:04,751
Let's add the pushed views
to the diagram, too.

168
00:08:04,751 --> 00:08:09,255
Now, because the path is empty,
so is the list of pushed views.

169
00:08:09,255 --> 00:08:10,690
Now, like milk and cookies,

170
00:08:10,690 --> 00:08:13,893
the magic happens
when we put these together.

171
00:08:13,893 --> 00:08:16,162
When I tap
a value-presenting link,

172
00:08:16,162 --> 00:08:19,099
it appends that value
to the path.

173
00:08:19,099 --> 00:08:23,169
Then, the navigation stack
maps its destinations over

174
00:08:23,169 --> 00:08:29,209
the path values to decide which
views to push on the stack.

175
00:08:29,209 --> 00:08:34,180
Now, from my apple pie recipe,
if I tap Pie Crust,

176
00:08:34,180 --> 00:08:37,350
the link appends
that to the path, too.

177
00:08:37,350 --> 00:08:42,021
NavigationStack does its magic

178
00:08:42,021 --> 00:08:46,025
and pushes another RecipeDetail
view onto the stack.

179
00:08:46,025 --> 00:08:48,194
For every value
I add to the path,

180
00:08:48,194 --> 00:08:51,831
NavigationStack
pushes another view.

181
00:08:51,831 --> 00:08:54,567
When I tap the back button,

182
00:08:54,567 --> 00:08:57,470
NavigationStack removes
the last item from the path

183
00:08:57,470 --> 00:08:59,672
and from the pushed views.

184
00:08:59,672 --> 00:09:02,642
And NavigationStack
has one more trick to offer.

185
00:09:02,642 --> 00:09:06,045
It lets us connect to this path
using a binding.

186
00:09:06,045 --> 00:09:08,548
Let's go back to our code.

187
00:09:08,548 --> 00:09:10,750
Here's where we were.

188
00:09:10,750 --> 00:09:13,686
To bind the path,
first I'll add some State.

189
00:09:13,686 --> 00:09:17,023
Because every value pushed
on this stack is a recipe,

190
00:09:17,023 --> 00:09:20,293
I can use an array
of recipes as my path.

191
00:09:20,293 --> 00:09:22,929
If you need to present
a variety of data on a stack,

192
00:09:22,929 --> 00:09:23,830
be sure to check out

193
00:09:23,830 --> 00:09:29,836
the new type-erasing
NavigationPath collection.

194
00:09:29,836 --> 00:09:32,505
Once I have my path state,
I add an argument

195
00:09:32,505 --> 00:09:36,209
to my NavigationStack
and pass a binding to the path.

196
00:09:36,209 --> 00:09:40,280
With that in place,
I can make my stack sizzle.

197
00:09:40,280 --> 00:09:42,182
For example,
I could add a method

198
00:09:42,182 --> 00:09:44,751
to jump to a particular recipe.

199
00:09:44,751 --> 00:09:46,152
Or from anywhere on my stack,

200
00:09:46,152 --> 00:09:51,157
I can pop back to the root
just by resetting the path.

201
00:09:51,157 --> 00:09:53,793
That's how to prepare
a pushable stack using

202
00:09:53,793 --> 00:09:55,628
the new NavigationStack,

203
00:09:55,628 --> 00:09:57,864
value-presenting
NavigationLinks,

204
00:09:57,864 --> 00:10:02,068
and navigationDestinations
in SwiftUI.

205
00:10:02,068 --> 00:10:05,338
This recipe works on all
platforms, including the Mac,

206
00:10:05,338 --> 00:10:10,076
but really shines on iPhone,
Apple TV, and Apple Watch.

207
00:10:10,076 --> 00:10:12,912
To see NavigationStack in
action, be sure to check out

208
00:10:12,912 --> 00:10:18,251
"Build a productivity app
for Apple Watch."

209
00:10:18,251 --> 00:10:21,387
Our next recipe is for
multicolumn presentation

210
00:10:21,387 --> 00:10:25,792
without any stacks, like you'd
find in Mail on Mac and iPad.

211
00:10:25,792 --> 00:10:28,661
On iPad,
the sidebar is initially hidden.

212
00:10:28,661 --> 00:10:31,164
I can reveal it
and choose a category.

213
00:10:31,164 --> 00:10:34,334
Then, in the second column,
I can choose a recipe.

214
00:10:34,334 --> 00:10:38,471
The third column
shows the recipe details.

215
00:10:38,471 --> 00:10:41,708
This recipe combines
a NavigationSplitView

216
00:10:41,708 --> 00:10:43,877
with the new variety
of NavigationLink,

217
00:10:43,877 --> 00:10:45,678
and a List selection.

218
00:10:45,678 --> 00:10:47,914
This recipe is great
on larger devices

219
00:10:47,914 --> 00:10:50,049
because it helps avoid modality.

220
00:10:50,049 --> 00:10:53,286
I can see all my information
without having to drill in.

221
00:10:53,286 --> 00:10:55,522
Let's see how.

222
00:10:55,522 --> 00:10:59,092
I'll start with a three-column
NavigationSplitView

223
00:10:59,092 --> 00:11:02,462
with placeholder views
for the content and detail.

224
00:11:02,462 --> 00:11:04,664
Then, I'll add a List
in the sidebar

225
00:11:04,664 --> 00:11:07,700
that iterates over
all my categories,

226
00:11:07,700 --> 00:11:09,869
and a navigationTitle.

227
00:11:09,869 --> 00:11:10,970
Inside the List,

228
00:11:10,970 --> 00:11:14,541
I have a NavigationLink
for each category.

229
00:11:14,541 --> 00:11:16,476
Next, I'll introduce some State

230
00:11:16,476 --> 00:11:19,479
to keep track of which category
is selected.

231
00:11:19,479 --> 00:11:21,014
I'll tweak our list
in the sidebar

232
00:11:21,014 --> 00:11:23,283
to use the selectedCategory.

233
00:11:23,283 --> 00:11:26,019
Note that we're passing
a binding to the selection.

234
00:11:26,019 --> 00:11:27,987
This lets the list
and its contents

235
00:11:27,987 --> 00:11:30,423
manipulate the selection.

236
00:11:30,423 --> 00:11:32,792
When you put a value-presenting
link inside a list

237
00:11:32,792 --> 00:11:35,028
with a matching
selection type --

238
00:11:35,028 --> 00:11:37,730
category here --
the link will automatically

239
00:11:37,730 --> 00:11:41,100
update the selection
when tapped or clicked.

240
00:11:41,100 --> 00:11:43,670
So now when I select
a category in the sidebar,

241
00:11:43,670 --> 00:11:47,140
SwiftUI updates
the selectedCategory.

242
00:11:47,140 --> 00:11:49,208
Check out Raj's
"Organize your interface" talk

243
00:11:49,208 --> 00:11:50,476
that I mentioned earlier

244
00:11:50,476 --> 00:11:56,349
for some great information
on selection and lists.

245
00:11:56,349 --> 00:11:58,484
Next,
I'll replace my placeholder

246
00:11:58,484 --> 00:12:00,987
in the content column
with a list of the recipes

247
00:12:00,987 --> 00:12:03,523
for the selected category,

248
00:12:03,523 --> 00:12:06,893
and add a navigationTitle
for this column too.

249
00:12:06,893 --> 00:12:09,028
Just like
for the selected category,

250
00:12:09,028 --> 00:12:10,463
I can use the same technique

251
00:12:10,463 --> 00:12:14,567
to keep track of the selected
recipe in the content list.

252
00:12:14,567 --> 00:12:17,337
I'll use State
for the selectedRecipe,

253
00:12:17,337 --> 00:12:20,206
have my content list
use that state,

254
00:12:20,206 --> 00:12:24,444
and use a value-presenting link
for each recipe.

255
00:12:24,444 --> 00:12:26,446
Finally,
I'll update the detail column

256
00:12:26,446 --> 00:12:30,917
to show, well, the details
for the selectedRecipe.

257
00:12:30,917 --> 00:12:32,051
With this in place,

258
00:12:32,051 --> 00:12:37,790
I again have full programmatic
control over navigation.

259
00:12:37,790 --> 00:12:40,727
For example, to navigate
to my recipe of the day,

260
00:12:40,727 --> 00:12:45,665
I just need to update
my selection state.

261
00:12:45,665 --> 00:12:47,433
That's how to prepare
a multi-column

262
00:12:47,433 --> 00:12:51,504
navigation experience using
the new NavigationSplitView,

263
00:12:51,504 --> 00:12:54,774
value-presenting
NavigationLinks,

264
00:12:54,774 --> 00:13:00,446
and Lists with selection
in SwiftUI.

265
00:13:00,446 --> 00:13:03,282
One super cool thing
about combining List selection

266
00:13:03,282 --> 00:13:05,084
and NavigationSplitView
like this,

267
00:13:05,084 --> 00:13:07,820
is that SwiftUI
can automatically adapt

268
00:13:07,820 --> 00:13:10,723
the split view
to a single stack on iPhone

269
00:13:10,723 --> 00:13:14,127
or in Slide Over on iPad.

270
00:13:14,127 --> 00:13:16,763
Changes to selection
automatically translate

271
00:13:16,763 --> 00:13:20,667
into the appropriate
pushes and pops on iPhone.

272
00:13:20,667 --> 00:13:22,535
Of course,
this multicolumn presentation

273
00:13:22,535 --> 00:13:24,671
also works great on the Mac.

274
00:13:24,671 --> 00:13:26,539
And although Apple TV
and Apple Watch

275
00:13:26,539 --> 00:13:29,842
don't show multiple columns,
those platforms also get

276
00:13:29,842 --> 00:13:33,346
the automatic translation
to a single stack.

277
00:13:33,346 --> 00:13:39,118
NavigationSplitView in SwiftUI
works on all platforms.

278
00:13:39,118 --> 00:13:42,021
Next, let's look at how we can
put all these ingredients

279
00:13:42,021 --> 00:13:45,525
together by building a
two-column navigation experience

280
00:13:45,525 --> 00:13:48,628
like that in Photos
on iPad and Mac.

281
00:13:48,628 --> 00:13:50,096
When I select a category,

282
00:13:50,096 --> 00:13:55,234
the detail area shows a grid of
all my recipes in that category.

283
00:13:55,234 --> 00:13:58,004
When I tap a recipe,
it's pushed onto a stack

284
00:13:58,004 --> 00:13:59,806
in the detail area.

285
00:13:59,806 --> 00:14:03,543
When I tap a related recipe,
it's also pushed onto the stack.

286
00:14:03,543 --> 00:14:07,013
And I can navigate back
to the grid of recipes.

287
00:14:10,016 --> 00:14:12,952
This recipe is our
pièce de résistance,

288
00:14:12,952 --> 00:14:14,887
combining navigation split view,

289
00:14:14,887 --> 00:14:17,857
stack, link, destination,
and list.

290
00:14:17,857 --> 00:14:21,661
Let's see how all these
ingredients go together.

291
00:14:21,661 --> 00:14:24,797
I'll start with a two-column
NavigationSplitView.

292
00:14:24,797 --> 00:14:27,800
The first column is exactly
like the previous recipe.

293
00:14:27,800 --> 00:14:30,770
I have some State to track
the selectedCategory

294
00:14:30,770 --> 00:14:33,539
and a List that uses
a binding to that state

295
00:14:33,539 --> 00:14:36,509
and a value-presenting
NavigationLink,

296
00:14:36,509 --> 00:14:39,045
and the requisite
navigationTitle.

297
00:14:39,045 --> 00:14:42,782
The differences in this recipe
are in the detail area.

298
00:14:42,782 --> 00:14:46,419
The new navigation APIs really
take advantage of composition.

299
00:14:46,419 --> 00:14:48,154
Just like I can put a list

300
00:14:48,154 --> 00:14:51,190
inside a column
of a NavigationSplitView,

301
00:14:51,190 --> 00:14:56,028
I can also put a NavigationStack
inside a column.

302
00:14:56,028 --> 00:14:58,264
The root view
of this Navigation Stack

303
00:14:58,264 --> 00:15:00,233
is my RecipeGrid.

304
00:15:00,233 --> 00:15:04,337
Notice that the RecipeGrid
is inside the NavigationStack.

305
00:15:04,337 --> 00:15:06,639
That means I can put
stack-related modifiers

306
00:15:06,639 --> 00:15:09,075
inside RecipeGrid.

307
00:15:09,075 --> 00:15:11,077
Let's zoom in to
the body of RecipeGrid

308
00:15:11,077 --> 00:15:14,847
to see what that means.

309
00:15:14,847 --> 00:15:18,584
RecipeGrid is a view and takes
a category as a parameter.

310
00:15:18,584 --> 00:15:22,622
Because category is optional
here, I'll start with an if-let.

311
00:15:22,622 --> 00:15:25,825
The else case handles
an empty selection.

312
00:15:25,825 --> 00:15:30,263
Inside my if, I'll add
a scroll view and a lazy grid.

313
00:15:30,263 --> 00:15:33,166
Lazy grid layout
takes a sequence of views.

314
00:15:33,166 --> 00:15:36,569
Here, I'm using ForEach
to iterate over my recipes.

315
00:15:36,569 --> 00:15:37,770
For each recipe,

316
00:15:37,770 --> 00:15:41,107
I have a value-presenting
NavigationLink.

317
00:15:41,107 --> 00:15:43,576
The link presents
a recipe value.

318
00:15:43,576 --> 00:15:45,878
The link's label,
in this trailing closure,

319
00:15:45,878 --> 00:15:50,449
is my RecipeTile
with the thumbnail and title.

320
00:15:50,449 --> 00:15:52,852
So what's left
to finish this grid?

321
00:15:52,852 --> 00:15:54,453
Well, I haven't told
the NavigationStack

322
00:15:54,453 --> 00:15:57,723
how to map
from recipes to detail views.

323
00:15:57,723 --> 00:15:59,659
Like I mentioned
with the first recipe,

324
00:15:59,659 --> 00:16:01,127
the new NavigationStack

325
00:16:01,127 --> 00:16:04,030
uses the navigationDestination
modifier

326
00:16:04,030 --> 00:16:08,034
to map from values on its path
to views shown on the stack.

327
00:16:08,034 --> 00:16:11,737
So let's add a
navigationDestination modifier.

328
00:16:11,737 --> 00:16:14,440
But where should I attach it?

329
00:16:14,440 --> 00:16:17,276
I'm tempted to attach it
directly to the link,

330
00:16:17,276 --> 00:16:19,779
but this is wrong
for two reasons.

331
00:16:19,779 --> 00:16:23,683
Lazy containers, like List,
Table, or, here, LazyVGrid,

332
00:16:23,683 --> 00:16:26,485
don't load all of their views
immediately.

333
00:16:26,485 --> 00:16:28,087
If I put the modifier here,

334
00:16:28,087 --> 00:16:30,122
the destination
might not be loaded,

335
00:16:30,122 --> 00:16:31,858
so the surrounding
NavigationStack

336
00:16:31,858 --> 00:16:33,793
might not see it.

337
00:16:33,793 --> 00:16:36,062
Second, if I put
the modifier here,

338
00:16:36,062 --> 00:16:39,465
it will be repeated
for every item in my grid.

339
00:16:39,465 --> 00:16:43,870
Instead, I'll attach
the modifier to my ScrollView.

340
00:16:43,870 --> 00:16:47,039
By attaching the modifier
outside the ScrollView,

341
00:16:47,039 --> 00:16:49,008
I ensure that
the NavigationStack

342
00:16:49,008 --> 00:16:51,377
can see
this navigationDestination

343
00:16:51,377 --> 00:16:54,280
regardless
of the scroll position.

344
00:16:54,280 --> 00:16:57,083
Another thing I like about
putting the modifier here

345
00:16:57,083 --> 00:17:00,152
is that it's still close
to the links that target it.

346
00:17:00,152 --> 00:17:04,290
Navigation destination gives me
flexibility to organize my code

347
00:17:04,290 --> 00:17:07,827
the way that makes sense
to me or my team.

348
00:17:07,827 --> 00:17:10,363
Popping back
to my NavigationSplitView,

349
00:17:10,363 --> 00:17:11,964
there's just one more thing

350
00:17:11,964 --> 00:17:14,867
to enable full programmatic
navigation here.

351
00:17:14,867 --> 00:17:17,937
I need to add a navigation path.

352
00:17:17,937 --> 00:17:20,506
I'll add State to hold the path

353
00:17:20,506 --> 00:17:24,043
and bind the state
to my NavigationStack.

354
00:17:24,043 --> 00:17:27,380
With full programmatic
navigation in place,

355
00:17:27,380 --> 00:17:29,849
I can write a method
to show my recipe of the day

356
00:17:29,849 --> 00:17:33,052
in this navigation experience.

357
00:17:33,052 --> 00:17:33,986
That's how to prepare

358
00:17:33,986 --> 00:17:37,189
a multicolumn navigation
experience with stacks

359
00:17:37,189 --> 00:17:40,459
using the new
NavigationSplitView,

360
00:17:40,459 --> 00:17:42,061
NavigationStack,

361
00:17:42,061 --> 00:17:44,096
value-presenting
NavigationLinks,

362
00:17:44,096 --> 00:17:48,801
and Lists with selection
in SwiftUI.

363
00:17:48,801 --> 00:17:51,904
As with the previous recipe,
this one also automatically

364
00:17:51,904 --> 00:17:57,243
adapts to narrow presentations
and works on all platforms.

365
00:17:57,243 --> 00:17:59,545
It was fun exploring
these recipes for structuring

366
00:17:59,545 --> 00:18:04,417
the navigation in my app,
but our navigation feast

367
00:18:04,417 --> 00:18:06,986
wouldn't be complete
without dessert.

368
00:18:06,986 --> 00:18:11,457
For that, let's look at how
to persist the navigation state.

369
00:18:11,457 --> 00:18:13,726
To persist navigation state
in my app,

370
00:18:13,726 --> 00:18:15,661
I just need
two more ingredients:

371
00:18:15,661 --> 00:18:18,764
Codable and SceneStorage.

372
00:18:18,764 --> 00:18:21,367
This recipe
has three basic steps.

373
00:18:21,367 --> 00:18:23,736
First, I'll encapsulate
my navigation state

374
00:18:23,736 --> 00:18:26,238
in a NavigationModel type.

375
00:18:26,238 --> 00:18:28,507
That lets me save
and restore it as a unit

376
00:18:28,507 --> 00:18:30,843
so it's always consistent.

377
00:18:30,843 --> 00:18:34,580
Then, I'll make my
navigation model Codable.

378
00:18:34,580 --> 00:18:38,784
Finally, I'll use SceneStorage
to save and restore my model.

379
00:18:38,784 --> 00:18:40,386
I'll have to take care
along the way --

380
00:18:40,386 --> 00:18:43,122
I don't want my app to crash
like a fallen soufflé --

381
00:18:43,122 --> 00:18:45,858
but the steps
are straightforward.

382
00:18:45,858 --> 00:18:48,127
Let's look at step one.

383
00:18:48,127 --> 00:18:51,030
Here's the code
from the end of our last recipe.

384
00:18:51,030 --> 00:18:54,233
My navigation state is stored
in the selectedCategory

385
00:18:54,233 --> 00:18:55,935
and path properties.

386
00:18:55,935 --> 00:18:59,472
The selectedCategory tracks
the selection in the sidebar.

387
00:18:59,472 --> 00:19:02,141
The path tracks the views
pushed onto the stack

388
00:19:02,141 --> 00:19:04,310
in the detail area.

389
00:19:04,310 --> 00:19:06,979
I'll introduce
a new NavigationModel class

390
00:19:06,979 --> 00:19:12,718
and make it conform
to ObservableObject.

391
00:19:12,718 --> 00:19:17,490
Next, I'll move my navigation
state into my model object,

392
00:19:17,490 --> 00:19:22,161
changing the property wrappers
from State to Published.

393
00:19:22,161 --> 00:19:24,497
Then,
I'll introduce a StateObject

394
00:19:24,497 --> 00:19:27,900
to hold an instance
of my NavigationModel

395
00:19:27,900 --> 00:19:33,072
and change the parameters
to use the new model object.

396
00:19:33,072 --> 00:19:37,043
Next, I'll make my
navigation model Codable.

397
00:19:37,043 --> 00:19:38,811
I'll start by adding
the Codable conformance

398
00:19:38,811 --> 00:19:39,612
to the class.

399
00:19:39,612 --> 00:19:41,113
In many cases,

400
00:19:41,113 --> 00:19:43,816
Swift can automatically generate
Codable conformance,

401
00:19:43,816 --> 00:19:46,919
but I want to implement
my own conformance here.

402
00:19:46,919 --> 00:19:50,256
The main reason is that
Recipe is a model value.

403
00:19:50,256 --> 00:19:52,425
I don't want to store
the entire model value

404
00:19:52,425 --> 00:19:54,093
for state restoration.

405
00:19:54,093 --> 00:19:55,928
There are two reasons for this.

406
00:19:55,928 --> 00:19:57,897
First, my recipe database

407
00:19:57,897 --> 00:20:00,766
already contains all the details
for the recipe.

408
00:20:00,766 --> 00:20:03,369
It's not a good use of storage
to repeat that information

409
00:20:03,369 --> 00:20:06,038
in my saved navigation state.

410
00:20:06,038 --> 00:20:09,241
Second, if my recipe database
can change independently

411
00:20:09,241 --> 00:20:11,410
of my local navigation state --

412
00:20:11,410 --> 00:20:14,747
say, because I finally get
around to adding syncing --

413
00:20:14,747 --> 00:20:19,819
I don't want my local navigation
state to contain stale data.

414
00:20:19,819 --> 00:20:23,155
For custom codability,
next I'll add CodingKeys.

415
00:20:23,155 --> 00:20:25,458
One of the keys
is just selectedCategory.

416
00:20:25,458 --> 00:20:29,728
But notice that I named
the other "recipePathIds”

417
00:20:29,728 --> 00:20:30,729
I'm planning to just store

418
00:20:30,729 --> 00:20:34,233
the identifiers of the recipes
on the path.

419
00:20:34,233 --> 00:20:37,002
In my encode method,
I'll create a keyed container

420
00:20:37,002 --> 00:20:40,106
using my coding keys
and add the selected category

421
00:20:40,106 --> 00:20:42,808
to the container.

422
00:20:42,808 --> 00:20:44,677
I'm using encodeIfPresent,

423
00:20:44,677 --> 00:20:48,881
so I only write the value
if it's non-nil.

424
00:20:48,881 --> 00:20:52,418
Then, I'll add
the recipe path identifiers.

425
00:20:52,418 --> 00:20:54,220
Note that I'm
mapping over the path

426
00:20:54,220 --> 00:20:57,056
to get the identifiers
to encode.

427
00:20:57,056 --> 00:20:59,458
For example,
suppose my navigation state

428
00:20:59,458 --> 00:21:02,495
included Dessert
as a selected category,

429
00:21:02,495 --> 00:21:05,331
with Apple Pie
and Pie Crust on the path,

430
00:21:05,331 --> 00:21:07,933
like shown
in the green box on top.

431
00:21:07,933 --> 00:21:14,273
This might be encoded to JSON,
like shown in this other box.

432
00:21:14,273 --> 00:21:15,941
To finish up Codability,

433
00:21:15,941 --> 00:21:18,277
I'll add the required
initializer.

434
00:21:18,277 --> 00:21:22,381
The interesting bit is here
where I decode the recipe IDs,

435
00:21:22,381 --> 00:21:23,983
then use my shared data model

436
00:21:23,983 --> 00:21:28,354
to convert the IDs
back into recipes.

437
00:21:28,354 --> 00:21:30,856
I'm using compactMap
to discard any recipes

438
00:21:30,856 --> 00:21:32,324
that couldn't be found.

439
00:21:32,324 --> 00:21:34,827
For example, this might happen
if I delete a recipe

440
00:21:34,827 --> 00:21:37,830
on another device
after I have sync working --

441
00:21:37,830 --> 00:21:40,666
something I'm definitely
going to do someday.

442
00:21:40,666 --> 00:21:42,868
This is a place you'll need
to use discretion

443
00:21:42,868 --> 00:21:46,105
in your own apps to make sure
any restored navigation state

444
00:21:46,105 --> 00:21:50,142
still makes sense.

445
00:21:50,142 --> 00:21:52,111
Finally,
I'll add a computed property

446
00:21:52,111 --> 00:21:56,749
for reading and writing
my model as JSON data.

447
00:21:56,749 --> 00:21:58,284
Now that I have
a navigation model

448
00:21:58,284 --> 00:22:00,586
and it knows how to encode
and decode itself,

449
00:22:00,586 --> 00:22:03,856
all that's left is to actually
save and restore it.

450
00:22:03,856 --> 00:22:07,092
For that I'll use SceneStorage.

451
00:22:07,092 --> 00:22:09,161
Here's where we left
our main view.

452
00:22:09,161 --> 00:22:12,231
I was using a StateObject
to hold my NavigationModel.

453
00:22:12,231 --> 00:22:14,667
Now, I'll introduce
some SceneStorage

454
00:22:14,667 --> 00:22:18,204
to persist my NavigationModel.

455
00:22:18,204 --> 00:22:21,040
SceneStorage properties
automatically save and restore

456
00:22:21,040 --> 00:22:22,942
their associated values.

457
00:22:22,942 --> 00:22:26,312
When the type of the storage
is optional, like my data here,

458
00:22:26,312 --> 00:22:30,049
the value is nil when
a new scene is created.

459
00:22:30,049 --> 00:22:31,784
When the system
restores a scene,

460
00:22:31,784 --> 00:22:35,187
SwiftUI ensures that the value
of the SceneStorage property

461
00:22:35,187 --> 00:22:36,922
is also restored.

462
00:22:36,922 --> 00:22:40,926
I'll take advantage of this
to persist my NavigationModel.

463
00:22:40,926 --> 00:22:45,431
To do that, I'll add
a task modifier to my view.

464
00:22:45,431 --> 00:22:48,534
The task modifier
runs its closure asynchronously.

465
00:22:48,534 --> 00:22:50,202
It starts when the view appears

466
00:22:50,202 --> 00:22:53,772
and is cancelled
when the view goes away.

467
00:22:53,772 --> 00:22:56,508
Whenever my view appears,
I'll first check whether I have

468
00:22:56,508 --> 00:23:00,913
any existing data
from a previous run of the app.

469
00:23:00,913 --> 00:23:05,451
If so, I'll update my
navigation model with that data.

470
00:23:05,451 --> 00:23:09,121
Then, I'll start an asynchronous
for loop that will iterate

471
00:23:09,121 --> 00:23:11,657
whenever my
navigation model changes.

472
00:23:11,657 --> 00:23:15,194
The body of this loop
will run on each change,

473
00:23:15,194 --> 00:23:17,596
so I can use that
to save my navigation state

474
00:23:17,596 --> 00:23:21,634
back to my scene storage data.

475
00:23:21,634 --> 00:23:23,369
And that's it!

476
00:23:23,369 --> 00:23:24,670
When I leave my app
to go check out

477
00:23:24,670 --> 00:23:27,539
some vintage Julia Child
cooking shows on the web,

478
00:23:27,539 --> 00:23:29,308
it remembers where I was.

479
00:23:29,308 --> 00:23:30,643
When I return to the app,

480
00:23:30,643 --> 00:23:34,146
it takes me back
to where I left off.

481
00:23:34,146 --> 00:23:35,814
Now, no cookbook
would be complete

482
00:23:35,814 --> 00:23:39,418
without a weird section at
the end with handy kitchen tips.

483
00:23:39,418 --> 00:23:41,987
I don't have three great
substitutes for cilantro,

484
00:23:41,987 --> 00:23:45,791
but I do have some
navigation tips to share.

485
00:23:45,791 --> 00:23:47,860
Switch to the new
NavigationStack

486
00:23:47,860 --> 00:23:50,929
and NavigationSplitView
as soon as you can.

487
00:23:50,929 --> 00:23:53,932
If you're using NavigationView
with the stack style,

488
00:23:53,932 --> 00:23:55,901
switch to NavigationStack.

489
00:23:55,901 --> 00:23:59,438
NavigationStack is also
a good first choice on Apple TV,

490
00:23:59,438 --> 00:24:03,008
Apple Watch,
or in sheets on iPad and iPhone,

491
00:24:03,008 --> 00:24:06,211
where the stack style
has always been the default.

492
00:24:06,211 --> 00:24:08,781
If you're using
a multicolumn NavigationView,

493
00:24:08,781 --> 00:24:11,450
switch to NavigationSplitView.

494
00:24:11,450 --> 00:24:14,520
And if you've already adopted
programmatic navigation

495
00:24:14,520 --> 00:24:16,422
using the links
that take bindings,

496
00:24:16,422 --> 00:24:18,190
I strongly encourage you to move

497
00:24:18,190 --> 00:24:20,893
to the new value-presenting
NavigationLink

498
00:24:20,893 --> 00:24:24,663
along with navigation paths
and list selection.

499
00:24:24,663 --> 00:24:27,633
The old-style programmatic links
are deprecated

500
00:24:27,633 --> 00:24:31,937
beginning in iOS 16
and aligned releases.

501
00:24:31,937 --> 00:24:35,240
For details and examples
on migrating to the new APIs,

502
00:24:35,240 --> 00:24:36,542
check out the article,

503
00:24:36,542 --> 00:24:38,644
"Migrating to new
navigation types"

504
00:24:38,644 --> 00:24:41,814
in the developer documentation.

505
00:24:41,814 --> 00:24:45,184
Next, keep in mind that List
and the new NavigationSplitView

506
00:24:45,184 --> 00:24:48,520
and NavigationStack
were made to mix together.

507
00:24:48,520 --> 00:24:51,357
Compose them to create
navigation experiences

508
00:24:51,357 --> 00:24:54,059
your guests will love.

509
00:24:54,059 --> 00:24:56,962
When using navigation stacks,
navigation destinations

510
00:24:56,962 --> 00:25:00,632
can be anywhere inside
the stack or its subviews.

511
00:25:00,632 --> 00:25:03,369
Consider putting destinations
near the corresponding links

512
00:25:03,369 --> 00:25:05,104
to make maintenance easier,

513
00:25:05,104 --> 00:25:08,907
but remember not to put them
inside of lazy containers.

514
00:25:08,907 --> 00:25:11,176
Finally, I'd encourage you
to start building

515
00:25:11,176 --> 00:25:14,213
your navigation experiences
with NavigationSplitView

516
00:25:14,213 --> 00:25:15,681
when it makes sense.

517
00:25:15,681 --> 00:25:17,783
Even if you're initially
developing for iPhone,

518
00:25:17,783 --> 00:25:20,185
NavigationSplitView
will automatically adapt

519
00:25:20,185 --> 00:25:22,087
to the narrower device.

520
00:25:22,087 --> 00:25:25,424
And when you're ready to support
iPhone Pro Max in landscape,

521
00:25:25,424 --> 00:25:27,793
or to bring your app
to iPad or Mac,

522
00:25:27,793 --> 00:25:29,061
NavigationSplitView

523
00:25:29,061 --> 00:25:32,498
will take advantage
of all that additional space.

524
00:25:32,498 --> 00:25:33,532
Thanks for the chance

525
00:25:33,532 --> 00:25:36,935
to share the new SwiftUI
Navigation APIs with you!

526
00:25:36,935 --> 00:25:39,037
Besides the talks
I mentioned earlier,

527
00:25:39,037 --> 00:25:40,139
I invite you to check out

528
00:25:40,139 --> 00:25:42,975
"Bring multiple windows
to your SwiftUI app"

529
00:25:42,975 --> 00:25:45,978
for some great info on opening
new windows and scenes

530
00:25:45,978 --> 00:25:47,579
in your apps.

531
00:25:47,579 --> 00:25:50,382
I hope that these recipes for
navigation in our cookbook app

532
00:25:50,382 --> 00:25:51,717
were palate-pleasing.

533
00:25:51,717 --> 00:25:54,119
I'm looking forward to seeing
the great experiences

534
00:25:54,119 --> 00:25:55,954
you cook up in your own apps.

535
00:25:55,954 --> 00:25:58,190
Bon appétit!
[LIPS SMACK]

536
00:25:58,190 --> 00:26:03,796
♪

