1
00:00:00,033 --> 00:00:03,003
♪ Mellow instrumental
hip-hop music ♪

2
00:00:03,003 --> 00:00:09,576
♪

3
00:00:09,576 --> 00:00:10,978
Dani Chootong: Hello,
and welcome to

4
00:00:10,978 --> 00:00:13,213
"What's new
with in-app purchase."

5
00:00:13,213 --> 00:00:16,550
I'm Dani, and I'm an engineer
on the StoreKit team.

6
00:00:16,550 --> 00:00:19,186
Today I'll be presenting
with my colleague Ian,

7
00:00:19,186 --> 00:00:20,854
and we'll be going over
the new improvements

8
00:00:20,854 --> 00:00:23,657
we're bringing
to in-app purchase this year.

9
00:00:23,657 --> 00:00:26,126
Last year,
we introduced StoreKit 2,

10
00:00:26,126 --> 00:00:29,096
a set of new APIs
designed from the ground up

11
00:00:29,096 --> 00:00:32,032
to make it simple
to integrate in-app purchases.

12
00:00:32,032 --> 00:00:34,902
StoreKit 2 uses
modern language features,

13
00:00:34,902 --> 00:00:38,538
including Swift concurrency
using the async/await pattern.

14
00:00:38,538 --> 00:00:39,573
On the server side,

15
00:00:39,573 --> 00:00:41,608
we complemented these
new StoreKit features

16
00:00:41,608 --> 00:00:45,078
with an entirely new set
of App Store Server endpoints.

17
00:00:45,078 --> 00:00:47,214
These server endpoints
make it easy to retrieve

18
00:00:47,214 --> 00:00:49,917
transaction information
and check subscription status

19
00:00:49,917 --> 00:00:52,219
on your server.

20
00:00:52,219 --> 00:00:55,822
We also released Version 2 of
App Store Server Notifications,

21
00:00:55,822 --> 00:00:57,691
to make tracking
the subscription lifecycle

22
00:00:57,691 --> 00:01:00,227
on your server easier than ever.

23
00:01:00,227 --> 00:01:02,996
Today I'll be going over
these new APIs,

24
00:01:02,996 --> 00:01:04,598
as well as
enhancements we're bringing

25
00:01:04,598 --> 00:01:07,467
to the new StoreKit models.

26
00:01:07,467 --> 00:01:09,303
Then, Ian will walk you through

27
00:01:09,303 --> 00:01:11,204
some exciting new
server updates,

28
00:01:11,204 --> 00:01:13,707
including App Store Server
API enhancements

29
00:01:13,707 --> 00:01:17,611
and brand-new APIs for
App Store Server Notifications.

30
00:01:17,611 --> 00:01:20,514
First, I'll go over
the new App Transaction API

31
00:01:20,514 --> 00:01:23,583
for verifying
the purchase of your app.

32
00:01:23,583 --> 00:01:26,420
Next, I'll dig into some
new properties we've added

33
00:01:26,420 --> 00:01:28,989
to our StoreKit models.

34
00:01:28,989 --> 00:01:32,225
I'll introduce you
to the new SwiftUI friendly APIs

35
00:01:32,225 --> 00:01:34,127
for redeeming
subscription offer codes

36
00:01:34,127 --> 00:01:37,230
and asking a customer
to review your app.

37
00:01:37,230 --> 00:01:39,967
Then, I'll introduce you
to StoreKit Messages,

38
00:01:39,967 --> 00:01:41,735
an API used to display

39
00:01:41,735 --> 00:01:44,171
App Store messages
to your customers.

40
00:01:44,171 --> 00:01:46,740
And finally, I'll go over
an enhancement we're adding

41
00:01:46,740 --> 00:01:49,343
to preserve Application Username
when you're migrating

42
00:01:49,343 --> 00:01:52,879
from the original
to the modern StoreKit APIs.

43
00:01:52,879 --> 00:01:55,949
Throughout this presentation,
I'll be using my favorite app,

44
00:01:55,949 --> 00:01:57,017
Food Truck.

45
00:01:57,017 --> 00:01:59,987
In the Food Truck app, I manage
a pop-up donut food truck

46
00:01:59,987 --> 00:02:02,789
that visits various cities
to make donut deliveries.

47
00:02:02,789 --> 00:02:05,392
So, let's get started!

48
00:02:05,392 --> 00:02:06,960
Meet App Transaction.

49
00:02:06,960 --> 00:02:09,196
The App Transaction
is our new API

50
00:02:09,196 --> 00:02:12,432
for verifying the purchase
of your app.

51
00:02:12,432 --> 00:02:14,968
The App Transaction represents
the signed information

52
00:02:14,968 --> 00:02:18,939
for the purchase of your app
for the device it's running on.

53
00:02:18,939 --> 00:02:21,508
It's signed using JWS,

54
00:02:21,508 --> 00:02:24,444
and it replaces the app detail
portion of the app receipt

55
00:02:24,444 --> 00:02:27,247
from the original StoreKit API.

56
00:02:27,247 --> 00:02:29,416
Just like
transaction verification,

57
00:02:29,416 --> 00:02:31,585
StoreKit performs
automatic verification

58
00:02:31,585 --> 00:02:34,888
of the app transaction for you.

59
00:02:34,888 --> 00:02:37,457
However, if you wish, you can also perform

60
00:02:37,457 --> 00:02:39,326
your own validation.

61
00:02:39,326 --> 00:02:43,230
Validating a JWS signature
is a well-documented standard.

62
00:02:43,230 --> 00:02:45,065
You can refer
to the public documentation

63
00:02:45,065 --> 00:02:48,335
to implement
your own validation.

64
00:02:48,335 --> 00:02:50,370
StoreKit takes care
of automatically updating

65
00:02:50,370 --> 00:02:52,672
the App Transaction
when necessary.

66
00:02:52,672 --> 00:02:54,775
However, in the rare case
that the user

67
00:02:54,775 --> 00:02:57,978
thinks there's something wrong,
it can be refreshed.

68
00:02:57,978 --> 00:02:59,613
You should provide
UI in your app

69
00:02:59,613 --> 00:03:03,417
to allow your customers
to refresh the app transaction.

70
00:03:03,417 --> 00:03:06,186
This should only be used
in response to user action,

71
00:03:06,186 --> 00:03:07,988
as refreshing
the App Transaction

72
00:03:07,988 --> 00:03:11,091
prompts the user
to authenticate.

73
00:03:11,091 --> 00:03:15,362
Preventing fraud isn't the only
reason to love App Transaction.

74
00:03:15,362 --> 00:03:18,598
If you're looking to switch
business models from a paid app

75
00:03:18,598 --> 00:03:21,368
to a free app that offers
in-app purchases,

76
00:03:21,368 --> 00:03:23,170
if you're curious about
which of your customers

77
00:03:23,170 --> 00:03:25,172
preordered your app,

78
00:03:25,172 --> 00:03:27,874
or even if you just want to know
when your app was purchased,

79
00:03:27,874 --> 00:03:31,878
these are all situations you can
handle with App Transaction.

80
00:03:31,878 --> 00:03:33,747
In the app receipt,
the receipt payload

81
00:03:33,747 --> 00:03:36,383
combine the purchase data
about your application

82
00:03:36,383 --> 00:03:39,786
along with all the in-app
purchases that have occurred.

83
00:03:39,786 --> 00:03:41,988
These are now broken up
into two separate components

84
00:03:41,988 --> 00:03:43,290
in StoreKit.

85
00:03:43,290 --> 00:03:46,393
The first of these
is the Transaction History.

86
00:03:46,393 --> 00:03:48,495
StoreKit's transaction APIs
give you insight

87
00:03:48,495 --> 00:03:51,064
into the user's entire
in-app purchase history,

88
00:03:51,064 --> 00:03:52,933
right on the device.

89
00:03:52,933 --> 00:03:56,269
These APIs allow you to find
the exact information you need,

90
00:03:56,269 --> 00:03:58,672
including the user's
latest transactions,

91
00:03:58,672 --> 00:04:02,476
unfinished transactions,
and current entitlements.

92
00:04:02,476 --> 00:04:05,278
If you prefer to perform these
calculations on your server,

93
00:04:05,278 --> 00:04:07,347
you can also get
the user's purchase history

94
00:04:07,347 --> 00:04:09,516
from the App Store Server API.

95
00:04:09,516 --> 00:04:11,651
Ian will have some
exciting updates on this

96
00:04:11,651 --> 00:04:13,687
later this session.

97
00:04:13,687 --> 00:04:16,089
And the second component
is the App Transaction,

98
00:04:16,089 --> 00:04:18,058
which contains the data
you need to make sure

99
00:04:18,058 --> 00:04:20,861
that your app is valid
for the device it's running on.

100
00:04:20,861 --> 00:04:23,063
It's easy to verify
the purchase of your app

101
00:04:23,063 --> 00:04:25,599
using App Transaction,
and in just a moment,

102
00:04:25,599 --> 00:04:28,869
I'll be going over an example
of how you can use it.

103
00:04:28,869 --> 00:04:30,537
But first,
let me give you some background

104
00:04:30,537 --> 00:04:32,239
about my favorite app.

105
00:04:32,239 --> 00:04:34,508
With Food Truck, I'm able
to make donut deliveries,

106
00:04:34,508 --> 00:04:36,776
check in on a basic social feed,

107
00:04:36,776 --> 00:04:39,045
and visualize my sales history.

108
00:04:39,045 --> 00:04:41,047
Keeping all this information
in a database

109
00:04:41,047 --> 00:04:45,218
is an ongoing cost for my app,
so to help me cover the costs,

110
00:04:45,218 --> 00:04:47,487
I'm going to turn
the yearly sales history chart

111
00:04:47,487 --> 00:04:49,523
into a onetime purchase.

112
00:04:49,523 --> 00:04:52,792
Additionally, I want to enhance
the social feed.

113
00:04:52,792 --> 00:04:54,628
So instead of just seeing
what others are saying

114
00:04:54,628 --> 00:04:56,630
about my food truck,
I want to provide the tools

115
00:04:56,630 --> 00:04:59,299
so I can engage
with my customers as well.

116
00:04:59,299 --> 00:05:00,967
This will be
a subscription service,

117
00:05:00,967 --> 00:05:04,504
and I'll have a monthly
and a yearly plan.

118
00:05:04,504 --> 00:05:07,507
Food Truck began as a paid app,
but I'm going to make the switch

119
00:05:07,507 --> 00:05:10,310
to a free app that offers
in-app purchases.

120
00:05:10,310 --> 00:05:11,912
But I don't want
my existing customers

121
00:05:11,912 --> 00:05:15,782
who already purchased Food Truck
to feel left out.

122
00:05:15,782 --> 00:05:17,751
So, I'll be using
the App Transaction

123
00:05:17,751 --> 00:05:20,220
to make sure that the customers
who purchased Food Truck

124
00:05:20,220 --> 00:05:24,157
continue to have access to the
premium content they paid for.

125
00:05:24,157 --> 00:05:26,993
Here's the timeline
for Food Truck.

126
00:05:26,993 --> 00:05:29,262
At the initial release,
Food Truck started out

127
00:05:29,262 --> 00:05:31,965
as a paid app that cost $4.99.

128
00:05:31,965 --> 00:05:34,401
Version 1.0 offered
donut deliveries,

129
00:05:34,401 --> 00:05:37,938
a basic social feed,
and sales history charts.

130
00:05:37,938 --> 00:05:39,906
Later, at the release
of version 8.0,

131
00:05:39,906 --> 00:05:42,008
my business model changed.

132
00:05:42,008 --> 00:05:43,810
Food Truck is now free,
but includes

133
00:05:43,810 --> 00:05:47,347
a variety of in-app purchases
which unlock premium features.

134
00:05:47,347 --> 00:05:50,283
The yearly sales history chart
is now a nonconsumable

135
00:05:50,283 --> 00:05:52,485
onetime purchase,
and now there's

136
00:05:52,485 --> 00:05:55,255
a new subscription service
for a premium social feed

137
00:05:55,255 --> 00:05:58,124
that gives you
advanced engagement tools.

138
00:05:58,124 --> 00:06:00,760
Now let's take a look at
two different types of customers

139
00:06:00,760 --> 00:06:03,263
who might be affected by this.

140
00:06:03,263 --> 00:06:06,633
Alice found out about my
Food Truck app in version 2.5,

141
00:06:06,633 --> 00:06:09,069
and she decided she wants
to share her passion for donuts

142
00:06:09,069 --> 00:06:11,137
in the digital world.

143
00:06:11,137 --> 00:06:13,506
So, she purchased
my app for $4.99

144
00:06:13,506 --> 00:06:16,476
and began her
donut delivery journey.

145
00:06:16,476 --> 00:06:19,512
A second customer, Bob, finds
out about my Food Truck app

146
00:06:19,512 --> 00:06:21,014
though a friend
and downloads it for free

147
00:06:21,014 --> 00:06:23,683
in the App Store in version 8.2.

148
00:06:23,683 --> 00:06:26,219
In this scenario, Alice,
who purchased my app

149
00:06:26,219 --> 00:06:28,521
before it became free,
should still have access

150
00:06:28,521 --> 00:06:33,093
to all the premium content
she already paid for.

151
00:06:33,093 --> 00:06:35,095
She still has the option
to purchase the premium

152
00:06:35,095 --> 00:06:37,764
social feed subscription,
but I don't want to deny her

153
00:06:37,764 --> 00:06:42,569
the yearly sales history chart
that was initially included.

154
00:06:42,569 --> 00:06:44,871
Bob, however,
got my app for free.

155
00:06:44,871 --> 00:06:47,307
I know then not to unlock
features and content

156
00:06:47,307 --> 00:06:49,509
until they complete
the in-app purchase.

157
00:06:49,509 --> 00:06:51,344
So, let's see how
we can achieve this

158
00:06:51,344 --> 00:06:53,880
with App Transaction in code.

159
00:06:53,880 --> 00:06:55,815
I'll start off
by fetching the app transaction

160
00:06:55,815 --> 00:06:59,352
by calling
AppTransaction.shared.

161
00:06:59,352 --> 00:07:01,721
This call gets me
a VerificationResult

162
00:07:01,721 --> 00:07:03,990
containing my app transaction.

163
00:07:03,990 --> 00:07:05,992
Within the result,
the AppTransaction type

164
00:07:05,992 --> 00:07:09,296
contains the JWS payload.

165
00:07:09,296 --> 00:07:11,865
Next, I'll switch on the result.

166
00:07:11,865 --> 00:07:14,134
If the result is unverified,
this would be a good time

167
00:07:14,134 --> 00:07:16,136
to alert the user
that their app purchase

168
00:07:16,136 --> 00:07:18,104
could not be verified
by the App Store,

169
00:07:18,104 --> 00:07:22,142
and then, I can prompt them
to refresh the app transaction.

170
00:07:22,142 --> 00:07:26,046
At this time, I'll offer
a minimal experience for my app.

171
00:07:26,046 --> 00:07:28,281
If the result is verified,
I'm going to use this as

172
00:07:28,281 --> 00:07:31,885
an opportunity to check whether
the user has purchased my app.

173
00:07:31,885 --> 00:07:33,153
Customers
that purchased my app

174
00:07:33,153 --> 00:07:36,289
should be granted
the services they paid for.

175
00:07:36,289 --> 00:07:39,492
For this, I'll use the original
app version property.

176
00:07:39,492 --> 00:07:41,761
This property lets me know
the app version in which

177
00:07:41,761 --> 00:07:46,099
the customer had downloaded
my app for the very first time.

178
00:07:46,099 --> 00:07:49,069
Version 8.0 is the version
in which my app became free

179
00:07:49,069 --> 00:07:51,571
with in-app purchases.

180
00:07:51,571 --> 00:07:53,940
I'm going to pass the customer's
original app version

181
00:07:53,940 --> 00:07:57,010
to my function which checks
if the user purchased my app

182
00:07:57,010 --> 00:07:58,812
before version 8.0.

183
00:07:58,812 --> 00:08:01,081
And with that, I can make
an informed decision about

184
00:08:01,081 --> 00:08:05,919
how I should go about providing
premium content to my users.

185
00:08:05,919 --> 00:08:08,154
For customers like Alice,
who purchased my app,

186
00:08:08,154 --> 00:08:10,490
I'm going to provide the content
the user is entitled to

187
00:08:10,490 --> 00:08:13,093
that they had
at the time of purchase.

188
00:08:13,093 --> 00:08:15,995
In my case, I'm going to unlock
the yearly sales history chart

189
00:08:15,995 --> 00:08:18,331
for her deliveries.

190
00:08:18,331 --> 00:08:20,900
Also, I want to check
any additional in-app purchases

191
00:08:20,900 --> 00:08:25,171
they may have made
so I can provide that as well.

192
00:08:25,171 --> 00:08:27,907
Otherwise, I can be confident
that the user downloaded my app

193
00:08:27,907 --> 00:08:31,044
after I switched
my business model, like Bob.

194
00:08:31,044 --> 00:08:32,078
This can be a good time

195
00:08:32,078 --> 00:08:33,780
to check the user's
current entitlements

196
00:08:33,780 --> 00:08:37,650
so I can unlock the features
and content they paid for.

197
00:08:37,650 --> 00:08:39,152
And with just
a few lines of code,

198
00:08:39,152 --> 00:08:41,755
I was able to verify
the purchase of my app,

199
00:08:41,755 --> 00:08:43,323
check whether
the user downloaded

200
00:08:43,323 --> 00:08:44,924
the paid version of my app,

201
00:08:44,924 --> 00:08:47,494
and I can immediately start
providing my premium content,

202
00:08:47,494 --> 00:08:52,031
whether the customer
purchased my app or not.

203
00:08:52,031 --> 00:08:54,200
With App Transaction,
you can easily support

204
00:08:54,200 --> 00:08:56,403
your customers
whether they're early supporters

205
00:08:56,403 --> 00:08:59,472
or if they've just recently
downloaded your app.

206
00:08:59,472 --> 00:09:01,441
Now I'd like to move on
to the new properties

207
00:09:01,441 --> 00:09:04,344
we're adding
to our StoreKit models.

208
00:09:04,344 --> 00:09:07,414
The first of these properties
is the price locale.

209
00:09:07,414 --> 00:09:10,683
The price locale is now
included in StoreKit products.

210
00:09:10,683 --> 00:09:12,585
You may already be familiar
with price locale

211
00:09:12,585 --> 00:09:16,423
from interfacing with
our original purchase APIs.

212
00:09:16,423 --> 00:09:19,592
Next, I'll dig into
the server environment property.

213
00:09:19,592 --> 00:09:21,661
Now, you can tell
the server environment

214
00:09:21,661 --> 00:09:25,131
a transaction
or renewal info occurred in.

215
00:09:25,131 --> 00:09:27,333
Then, I'll move onto
the recent subscription

216
00:09:27,333 --> 00:09:28,902
start date property.

217
00:09:28,902 --> 00:09:31,471
You can use this as a tool
to make informed decisions

218
00:09:31,471 --> 00:09:35,241
for your customers based
on their subscription patterns.

219
00:09:35,241 --> 00:09:37,844
And lastly, I'll go over
some special considerations

220
00:09:37,844 --> 00:09:39,546
for these properties
when you're using them

221
00:09:39,546 --> 00:09:41,881
with StoreKit Testing in Xcode.

222
00:09:41,881 --> 00:09:43,650
These properties return
sentinel values

223
00:09:43,650 --> 00:09:46,519
in older operating systems,
and I'll explain what this means

224
00:09:46,519 --> 00:09:48,521
in just a bit.

225
00:09:48,521 --> 00:09:51,691
The StoreKit APIs were designed
with flexibility in mind,

226
00:09:51,691 --> 00:09:53,026
so I'm proud to announce

227
00:09:53,026 --> 00:09:55,295
that you can take advantage
of these new properties

228
00:09:55,295 --> 00:09:58,431
on devices as far back as
last year's operating systems,

229
00:09:58,431 --> 00:10:01,901
even though they did not
originally ship with them.

230
00:10:01,901 --> 00:10:04,304
All you'll need to make
this happen is to use

231
00:10:04,304 --> 00:10:07,073
Xcode 14 to build your app,
and you'll have access

232
00:10:07,073 --> 00:10:10,176
to these properties in
the previous operating systems.

233
00:10:10,176 --> 00:10:12,178
This is possible
because the implementation

234
00:10:12,178 --> 00:10:14,514
for these properties
are compiled into your app,

235
00:10:14,514 --> 00:10:16,983
so when your customers
update to the new version,

236
00:10:16,983 --> 00:10:19,185
they'll be able to get the
benefits of these enhancements

237
00:10:19,185 --> 00:10:21,955
without needing to update
their operating system.

238
00:10:21,955 --> 00:10:23,790
There is one thing
to keep in mind

239
00:10:23,790 --> 00:10:26,359
when using these properties,
though.

240
00:10:26,359 --> 00:10:28,328
These properties
will return sentinel values

241
00:10:28,328 --> 00:10:30,396
when you're using
StoreKit testing in Xcode

242
00:10:30,396 --> 00:10:32,532
in these older
operating systems.

243
00:10:32,532 --> 00:10:33,967
When I say sentinel values,

244
00:10:33,967 --> 00:10:36,069
I'm referring to
placeholder values that signal

245
00:10:36,069 --> 00:10:38,538
that these are not real values
you should work with,

246
00:10:38,538 --> 00:10:41,307
and I'll explain
why this occurs.

247
00:10:41,307 --> 00:10:43,543
The sandbox and production
environments

248
00:10:43,543 --> 00:10:45,812
make use of these properties
by extracting the values

249
00:10:45,812 --> 00:10:48,081
from the App Store
server response.

250
00:10:48,081 --> 00:10:50,083
StoreKit testing
in Xcode, however,

251
00:10:50,083 --> 00:10:52,785
is a local testing environment
that operates independently

252
00:10:52,785 --> 00:10:54,821
from the App Store server.

253
00:10:54,821 --> 00:10:57,156
This means we're not able
to backport the value of these

254
00:10:57,156 --> 00:11:00,527
properties to the previous
operating systems there.

255
00:11:00,527 --> 00:11:02,395
You can easily
get around this limitation

256
00:11:02,395 --> 00:11:05,231
by updating your test device
to a new operating system,

257
00:11:05,231 --> 00:11:07,100
and you'll be all set
to test these values

258
00:11:07,100 --> 00:11:08,735
in the local environment.

259
00:11:08,735 --> 00:11:10,970
Let's discuss some situations
that demonstrate

260
00:11:10,970 --> 00:11:13,339
how you can start using
these new properties,

261
00:11:13,339 --> 00:11:15,775
the first of which
is price locale.

262
00:11:15,775 --> 00:11:18,478
StoreKit products already have
a display price property

263
00:11:18,478 --> 00:11:21,281
to label the purchase price,
but with price locale,

264
00:11:21,281 --> 00:11:22,715
you can format numbers

265
00:11:22,715 --> 00:11:25,985
deriving from
the product's decimal price.

266
00:11:25,985 --> 00:11:27,720
If you have
a yearly subscription,

267
00:11:27,720 --> 00:11:29,756
you might
use this as an opportunity

268
00:11:29,756 --> 00:11:32,725
to show your customers how much
it would cost them per month.

269
00:11:32,725 --> 00:11:35,328
In this example, you can see
that the yearly subscription

270
00:11:35,328 --> 00:11:38,598
amounts to $4.17 per month.

271
00:11:38,598 --> 00:11:40,199
Or perhaps
you'd want to show them

272
00:11:40,199 --> 00:11:42,468
how much they would save if they
purchased your yearly service

273
00:11:42,468 --> 00:11:44,404
over your monthly service.

274
00:11:44,404 --> 00:11:46,606
With this information,
your customers can make

275
00:11:46,606 --> 00:11:48,474
informed decisions
when they're considering

276
00:11:48,474 --> 00:11:51,144
your purchase options.

277
00:11:51,144 --> 00:11:54,013
Now, let's move on
to the environment property.

278
00:11:54,013 --> 00:11:55,515
The environment property
is available

279
00:11:55,515 --> 00:11:57,917
in the Transaction
and renewal Info.

280
00:11:57,917 --> 00:11:59,919
This property tells you
the server environment

281
00:11:59,919 --> 00:12:02,989
in which the transaction
or renewal info originated in,

282
00:12:02,989 --> 00:12:06,092
which could be Xcode,
sandbox, or production.

283
00:12:06,092 --> 00:12:07,327
Your app may communicate

284
00:12:07,327 --> 00:12:09,729
transaction information
to your server after a customer

285
00:12:09,729 --> 00:12:13,132
makes a purchase
for bookkeeping and analytics.

286
00:12:13,132 --> 00:12:15,301
When your app generates
these transactions,

287
00:12:15,301 --> 00:12:18,171
it could be from any one
of these server environments.

288
00:12:18,171 --> 00:12:19,672
Like most of you,
I don't want to add noise

289
00:12:19,672 --> 00:12:22,842
to my analytics
with irrelevant test data.

290
00:12:22,842 --> 00:12:25,044
So, knowing the environment
can help you

291
00:12:25,044 --> 00:12:27,614
filter out unnecessary
information from being sent up

292
00:12:27,614 --> 00:12:29,148
to your server.

293
00:12:29,148 --> 00:12:30,350
Finally, let's take a look at

294
00:12:30,350 --> 00:12:32,785
the recent subscription
start date.

295
00:12:32,785 --> 00:12:34,954
The recent subscription
start date is available

296
00:12:34,954 --> 00:12:37,624
within a product's
subscription information,

297
00:12:37,624 --> 00:12:39,325
and it represents
the most recent period

298
00:12:39,325 --> 00:12:41,594
of continuous subscription.

299
00:12:41,594 --> 00:12:44,230
A subscription is considered
continuous if there is no more

300
00:12:44,230 --> 00:12:48,234
than a 60-day gap between
any two subscribed periods.

301
00:12:48,234 --> 00:12:50,269
Keep in mind that this period
can contain gaps

302
00:12:50,269 --> 00:12:53,239
where the customer was not
subscribed to your product,

303
00:12:53,239 --> 00:12:54,874
so don't use this
as an indicator

304
00:12:54,874 --> 00:12:59,212
for the number of days
a customer has been subscribed.

305
00:12:59,212 --> 00:13:01,514
The recent subscription
start date can help you

306
00:13:01,514 --> 00:13:05,485
determine a pattern of loyalty
between you and your customers.

307
00:13:05,485 --> 00:13:07,954
For your loyal customers,
you might offer them a reward

308
00:13:07,954 --> 00:13:10,890
as a way to keep them
engaged with your product.

309
00:13:10,890 --> 00:13:12,291
Or if you notice that a customer

310
00:13:12,291 --> 00:13:14,193
has unsubscribed
from your service,

311
00:13:14,193 --> 00:13:16,996
you can use it as a chance
to win back a lapsed customer

312
00:13:16,996 --> 00:13:21,634
by offering them an incentive to
start using your product again.

313
00:13:21,634 --> 00:13:23,703
I mentioned earlier
that we'd take a closer look

314
00:13:23,703 --> 00:13:26,572
at the sentinel values
for these properties.

315
00:13:26,572 --> 00:13:28,841
As a reminder,
when I say sentinel values,

316
00:13:28,841 --> 00:13:30,510
I'm referring
to placeholder values

317
00:13:30,510 --> 00:13:34,781
that serve as an indicator
of the absence of a real value.

318
00:13:34,781 --> 00:13:38,251
The sentinel values for these
properties are easy to identify.

319
00:13:38,251 --> 00:13:39,986
When you're dealing
with price locale,

320
00:13:39,986 --> 00:13:45,525
the sentinel value is a locale
with the identifier xx_XX.

321
00:13:45,525 --> 00:13:49,062
For the environment property,
it'll be an empty string.

322
00:13:49,062 --> 00:13:51,698
And finally, for the recent
subscription start date,

323
00:13:51,698 --> 00:13:54,300
this value is Date.distantPast.

324
00:13:54,300 --> 00:13:56,502
Luckily, the occurrence
of these sentinel values

325
00:13:56,502 --> 00:13:58,738
are predictable --
you'll only encounter them

326
00:13:58,738 --> 00:14:00,707
if you're using
StoreKit testing in Xcode

327
00:14:00,707 --> 00:14:02,442
in older operating systems,

328
00:14:02,442 --> 00:14:05,878
and you can get around this
by updating your test device.

329
00:14:05,878 --> 00:14:07,513
So now you've seen
the enhancements

330
00:14:07,513 --> 00:14:09,649
we've made
to our StoreKit models.

331
00:14:09,649 --> 00:14:11,684
And my favorite part is,
they're backward compatible

332
00:14:11,684 --> 00:14:13,720
all the way back
to the operating system

333
00:14:13,720 --> 00:14:15,822
in which the models
were introduced,

334
00:14:15,822 --> 00:14:17,824
so your customers can see
the benefits right away

335
00:14:17,824 --> 00:14:19,559
just by updating your app.

336
00:14:19,559 --> 00:14:22,195
When you perform arithmetic
with price values,

337
00:14:22,195 --> 00:14:24,430
the price locale
helps you correctly format it

338
00:14:24,430 --> 00:14:26,799
so that it matches
the App Store's locale.

339
00:14:26,799 --> 00:14:29,268
For transactions
and subscription information,

340
00:14:29,268 --> 00:14:30,503
the environment
tells you exactly

341
00:14:30,503 --> 00:14:32,271
where they originated from,

342
00:14:32,271 --> 00:14:33,973
so if you store this data
on your server,

343
00:14:33,973 --> 00:14:37,376
you can act on it accordingly
depending on the environment.

344
00:14:37,376 --> 00:14:40,012
The recent subscription
start date helps you understand

345
00:14:40,012 --> 00:14:42,482
customer loyalty, so you can
tailor specific offers

346
00:14:42,482 --> 00:14:45,084
to long-time customers,
or maybe you can provide

347
00:14:45,084 --> 00:14:49,422
an incentive for customers
who have unsubscribed.

348
00:14:49,422 --> 00:14:52,692
And in case you were wondering,
yes, the environment

349
00:14:52,692 --> 00:14:55,528
and recent subscription
start date are also available

350
00:14:55,528 --> 00:14:59,031
via App Store Server API and
App Store Server Notifications,

351
00:14:59,031 --> 00:15:01,100
which Ian will discuss.

352
00:15:01,100 --> 00:15:04,470
Now I'd like talk about the
new SwiftUI APIs we're providing

353
00:15:04,470 --> 00:15:08,107
for redeeming offer codes
and requesting a review.

354
00:15:08,107 --> 00:15:11,244
Offer codes can help
you acquire, retain,

355
00:15:11,244 --> 00:15:14,080
and win back subscribers
by providing subscriptions

356
00:15:14,080 --> 00:15:16,983
at a discount
or free for a limited time.

357
00:15:16,983 --> 00:15:19,452
Now in App Store Connect,
you can create uniquely named

358
00:15:19,452 --> 00:15:20,820
custom codes.

359
00:15:20,820 --> 00:15:23,489
There, you can set
a maximum redemption limit

360
00:15:23,489 --> 00:15:26,526
and you can choose whether
or not to set an expiration.

361
00:15:26,526 --> 00:15:28,995
Let's look at the SwiftUI
implementation to present

362
00:15:28,995 --> 00:15:32,365
an offer code redemption sheet
straight from your app.

363
00:15:32,365 --> 00:15:34,033
Here, I've got a SwiftUI view

364
00:15:34,033 --> 00:15:36,836
with a button to trigger
the offer code redeem sheet.

365
00:15:36,836 --> 00:15:38,671
The offer code redemption sheet

366
00:15:38,671 --> 00:15:42,842
now has its own
view modifier in SwiftUI.

367
00:15:42,842 --> 00:15:44,644
The view modifier
is easy to use,

368
00:15:44,644 --> 00:15:47,914
it just needs a binding Boolean
to start the process.

369
00:15:47,914 --> 00:15:49,882
And once the offer code sheet
is dismissed,

370
00:15:49,882 --> 00:15:51,050
you'll get a result
representing

371
00:15:51,050 --> 00:15:54,954
whether or not the sheet
presented successfully.

372
00:15:54,954 --> 00:15:57,557
When a customer redeems
an offer code for your app,

373
00:15:57,557 --> 00:15:58,591
the resulting transaction

374
00:15:58,591 --> 00:16:02,061
is sent
to the transaction listener.

375
00:16:02,061 --> 00:16:04,230
So, be sure to set up
a transaction listener

376
00:16:04,230 --> 00:16:06,232
as soon as your app launches
to receive new

377
00:16:06,232 --> 00:16:09,969
and updated transactions
while your app is running.

378
00:16:09,969 --> 00:16:14,841
The offer code view modifier
is available starting on iOS 16.

379
00:16:14,841 --> 00:16:18,477
Next, I'd like to talk about
updates to request review.

380
00:16:18,477 --> 00:16:21,280
Getting customer feedback
is important.

381
00:16:21,280 --> 00:16:23,549
Potential new customers
might use reviews

382
00:16:23,549 --> 00:16:27,153
as a deciding factor in their
decision to download your app.

383
00:16:27,153 --> 00:16:29,355
Others might want to leave
a review as a way to provide

384
00:16:29,355 --> 00:16:32,158
feedback or suggestions.

385
00:16:32,158 --> 00:16:34,760
Either way, we want to give you
the tools to make it easy

386
00:16:34,760 --> 00:16:37,296
for you to request
a rating from your customers,

387
00:16:37,296 --> 00:16:39,065
so you can let them know
you're listening

388
00:16:39,065 --> 00:16:41,467
and you can continue
engaging with them.

389
00:16:41,467 --> 00:16:44,070
Let's review the code.

390
00:16:44,070 --> 00:16:45,271
Here I have a very simple view

391
00:16:45,271 --> 00:16:48,274
to demonstrate
the Request Review APIs.

392
00:16:48,274 --> 00:16:50,743
In SwiftUI,
there's now an environment value

393
00:16:50,743 --> 00:16:52,511
called requestReview.

394
00:16:52,511 --> 00:16:54,313
You can use this value
to get an instance

395
00:16:54,313 --> 00:16:56,549
of the RequestReviewAction,

396
00:16:56,549 --> 00:16:58,417
and when you're ready
to request a rating,

397
00:16:58,417 --> 00:17:00,419
simply call the instance
as a function

398
00:17:00,419 --> 00:17:03,522
to request to display
the review prompt.

399
00:17:03,522 --> 00:17:05,191
You can decide
the right time to request

400
00:17:05,191 --> 00:17:06,826
a review for your app.

401
00:17:06,826 --> 00:17:09,428
However, you should be aware
that the prompt will only be

402
00:17:09,428 --> 00:17:12,031
displayed to customers
a maximum of three times

403
00:17:12,031 --> 00:17:14,901
within a 365-day period.

404
00:17:14,901 --> 00:17:16,502
And you shouldn't ask customers

405
00:17:16,502 --> 00:17:19,739
to review the same version
of your app multiple times.

406
00:17:19,739 --> 00:17:22,541
Avoid interrupting customers
with a review prompt.

407
00:17:22,541 --> 00:17:24,810
A good time to ask for a review
could be after they've

408
00:17:24,810 --> 00:17:27,813
had a positive interaction,
such as completing a purchase

409
00:17:27,813 --> 00:17:31,117
on an e-commerce app,
or completing a level in a game.

410
00:17:31,117 --> 00:17:33,853
Finally, customers can disable
requests from ever appearing

411
00:17:33,853 --> 00:17:35,922
on their device,
so you shouldn't request

412
00:17:35,922 --> 00:17:39,926
a review as a result
of a user action.

413
00:17:39,926 --> 00:17:42,194
These APIs are really
going to come in handy

414
00:17:42,194 --> 00:17:43,663
for your SwiftUI apps.

415
00:17:43,663 --> 00:17:45,564
Next,
I'd like to introduce you

416
00:17:45,564 --> 00:17:48,467
to our new API
for StoreKit messages.

417
00:17:48,467 --> 00:17:51,070
A StoreKit message represents
a sheet that appears over

418
00:17:51,070 --> 00:17:54,807
your app to display important
information to the user.

419
00:17:54,807 --> 00:17:57,243
Messages are vended
by the App Store.

420
00:17:57,243 --> 00:17:58,744
Each message has a reason,

421
00:17:58,744 --> 00:18:01,881
which is included
in the message metadata.

422
00:18:01,881 --> 00:18:03,716
StoreKit messages are retrieved

423
00:18:03,716 --> 00:18:05,584
when your app
comes to the foreground.

424
00:18:05,584 --> 00:18:07,320
As an example,
let's take a look at

425
00:18:07,320 --> 00:18:10,856
one of the message reasons --
price increase consent.

426
00:18:10,856 --> 00:18:13,225
When you increase
the price of a subscription

427
00:18:13,225 --> 00:18:15,962
and it requires user consent,
the App Store will inform

428
00:18:15,962 --> 00:18:19,832
affected subscribers through
email, push notification,

429
00:18:19,832 --> 00:18:21,867
and an in-app
price consent sheet.

430
00:18:21,867 --> 00:18:23,970
In this case, the App Store
requires that the user

431
00:18:23,970 --> 00:18:25,905
agrees to the new price
of your subscription

432
00:18:25,905 --> 00:18:28,441
before it renews
at the higher price.

433
00:18:28,441 --> 00:18:30,977
So, if you decide to charge
more for your subscription,

434
00:18:30,977 --> 00:18:32,979
a price increase consent sheet
may appear

435
00:18:32,979 --> 00:18:36,315
when a user opens your app if
they haven't already responded

436
00:18:36,315 --> 00:18:38,284
to your price increase.

437
00:18:38,284 --> 00:18:40,653
By default, StoreKit messages
appear over your app

438
00:18:40,653 --> 00:18:42,989
when the user brings
your app to the foreground,

439
00:18:42,989 --> 00:18:44,890
and it may ask the user
to take some action

440
00:18:44,890 --> 00:18:46,692
relating to your app.

441
00:18:46,692 --> 00:18:48,494
Let's review this.

442
00:18:48,494 --> 00:18:51,297
The entire process
starts with your app.

443
00:18:51,297 --> 00:18:53,466
When your app
enters the foreground,

444
00:18:53,466 --> 00:18:54,633
StoreKit knows to check

445
00:18:54,633 --> 00:18:56,902
if there's pending messages
to display.

446
00:18:56,902 --> 00:19:00,006
And if there are, StoreKit
checks in with the App Store.

447
00:19:00,006 --> 00:19:01,907
The App Store returns
information about the message

448
00:19:01,907 --> 00:19:03,676
to StoreKit.

449
00:19:03,676 --> 00:19:05,578
At this time,
StoreKit checks whether your app

450
00:19:05,578 --> 00:19:07,613
is set up to receive messages.

451
00:19:07,613 --> 00:19:10,649
You can do this by setting up
a message listener in your app,

452
00:19:10,649 --> 00:19:12,485
which I'll get into shortly.

453
00:19:12,485 --> 00:19:14,720
If your app has set up
a message listener,

454
00:19:14,720 --> 00:19:17,923
StoreKit sends information
about the message to your app.

455
00:19:17,923 --> 00:19:20,760
Now's your chance to decide
whether or not it's a good time

456
00:19:20,760 --> 00:19:22,795
for your app
to display the message,

457
00:19:22,795 --> 00:19:25,498
or if you want to defer
the presentation for later.

458
00:19:25,498 --> 00:19:28,134
If you don't set up
a message listener,

459
00:19:28,134 --> 00:19:29,835
StoreKit displays
the message right away

460
00:19:29,835 --> 00:19:32,338
by presenting the message sheet
over your app.

461
00:19:32,338 --> 00:19:34,407
I'll go over
how to do this in code.

462
00:19:34,407 --> 00:19:36,409
But before I do that,
I'll explain a situation

463
00:19:36,409 --> 00:19:38,778
in which it would be useful
to control the presentation

464
00:19:38,778 --> 00:19:41,147
of an App Store message.

465
00:19:41,147 --> 00:19:43,449
In the Food Truck app,
I'm able to customize the donuts

466
00:19:43,449 --> 00:19:45,484
I'm delivering
to different cities.

467
00:19:45,484 --> 00:19:48,087
If a message gets delivered
to my app during this time,

468
00:19:48,087 --> 00:19:50,289
it would be confusing
to the user if they're suddenly

469
00:19:50,289 --> 00:19:53,459
interrupted by a message sheet,
so I'm going to be implementing

470
00:19:53,459 --> 00:19:56,128
the messages API
to make sure this doesn't happen

471
00:19:56,128 --> 00:19:59,331
by controlling when incoming
messages are presented.

472
00:19:59,331 --> 00:20:01,534
Now let's get into the code.

473
00:20:01,534 --> 00:20:04,303
Here, I have a simple view
for the donut editor.

474
00:20:04,303 --> 00:20:06,605
As I mentioned earlier,
pending messages are sent

475
00:20:06,605 --> 00:20:09,141
each time your app
comes to the foreground.

476
00:20:09,141 --> 00:20:12,011
So, I want to set up
a message listener in each view

477
00:20:12,011 --> 00:20:15,781
in which I want to defer
the presentation of a message.

478
00:20:15,781 --> 00:20:17,983
I'll add a binding array
to collect all the messages

479
00:20:17,983 --> 00:20:20,920
that are delivered to my app
while I'm in the editing view.

480
00:20:20,920 --> 00:20:24,090
This is important, because if I
don't set up a message listener,

481
00:20:24,090 --> 00:20:26,759
StoreKit is going to display
the message sheet right away

482
00:20:26,759 --> 00:20:28,961
when my app
comes to the foreground.

483
00:20:28,961 --> 00:20:32,531
As soon as the view appears,
I set up my message listener.

484
00:20:32,531 --> 00:20:34,667
I'll do this by setting up
a task that iterates

485
00:20:34,667 --> 00:20:37,503
over a static property
on the message type.

486
00:20:37,503 --> 00:20:39,538
This property
is an async sequence,

487
00:20:39,538 --> 00:20:42,675
and I'm able to receive messages
as they come in.

488
00:20:42,675 --> 00:20:44,443
For my use case,
I'm going to save the message

489
00:20:44,443 --> 00:20:46,745
in the pendingMessages array.

490
00:20:46,745 --> 00:20:48,647
Since pending messages
get delivered each time

491
00:20:48,647 --> 00:20:50,749
your app enters the foreground,
your app could receive

492
00:20:50,749 --> 00:20:53,486
the same message more than once,
so I have this condition

493
00:20:53,486 --> 00:20:56,755
to avoid adding
duplicate messages to my array.

494
00:20:56,755 --> 00:20:58,757
Then, once the view dismisses,

495
00:20:58,757 --> 00:21:01,760
I'll display the messages
in the parent view.

496
00:21:01,760 --> 00:21:03,729
This is the parent view
which holds a navigation link

497
00:21:03,729 --> 00:21:05,498
to the donut editor.

498
00:21:05,498 --> 00:21:07,433
Here, I've collected
all the pending messages

499
00:21:07,433 --> 00:21:10,669
I need to display
in this pendingMessages array.

500
00:21:10,669 --> 00:21:13,506
So how do I display
these pending messages?

501
00:21:13,506 --> 00:21:15,174
Well, now there's
an environment value

502
00:21:15,174 --> 00:21:17,243
displayStoreKitMessage.

503
00:21:17,243 --> 00:21:19,879
This gets you an instance
of a DisplayMessageAction,

504
00:21:19,879 --> 00:21:23,382
which you can then use
to display a given message.

505
00:21:23,382 --> 00:21:24,416
When the view appears,

506
00:21:24,416 --> 00:21:25,985
I'll iterate through
the pending messages

507
00:21:25,985 --> 00:21:27,853
and call displayStoreKitMessage

508
00:21:27,853 --> 00:21:30,389
passing in the message
I want to display.

509
00:21:30,389 --> 00:21:34,693
StoreKit takes care
of presenting the message sheet.

510
00:21:34,693 --> 00:21:36,195
Earlier, I mentioned
that the same message

511
00:21:36,195 --> 00:21:38,797
may get delivered to your app
more than once.

512
00:21:38,797 --> 00:21:40,866
That's because a message
doesn't get marked as read

513
00:21:40,866 --> 00:21:42,935
until it's presented
to the user.

514
00:21:42,935 --> 00:21:45,638
So, StoreKit makes sure
that each unique message

515
00:21:45,638 --> 00:21:48,440
is only presented once.

516
00:21:48,440 --> 00:21:50,476
And that was
a quick implementation

517
00:21:50,476 --> 00:21:52,611
of the Messages API.

518
00:21:52,611 --> 00:21:55,848
Remember, StoreKit messages
are sent to your app each time

519
00:21:55,848 --> 00:21:58,350
it comes to the foreground,
so you'll want to set up

520
00:21:58,350 --> 00:22:01,187
a message listener in each view
in which you want to control

521
00:22:01,187 --> 00:22:04,256
the timing of when
the messages are presented.

522
00:22:04,256 --> 00:22:07,293
You can ensure customers have a
great experience by making sure

523
00:22:07,293 --> 00:22:10,796
message sheets don't appear
at unexpected moments.

524
00:22:10,796 --> 00:22:12,565
Or perhaps you want
to tailor your logic

525
00:22:12,565 --> 00:22:14,366
for certain messages types.

526
00:22:14,366 --> 00:22:16,368
With a price increase
consent message,

527
00:22:16,368 --> 00:22:17,803
you may want to educate
your customer

528
00:22:17,803 --> 00:22:19,672
about the additional value
you're providing

529
00:22:19,672 --> 00:22:23,075
before the price increase
consent sheet appears.

530
00:22:23,075 --> 00:22:25,711
Finally, let's review
how StoreKit preserves

531
00:22:25,711 --> 00:22:28,280
the applicationUsername
as an appAccountToken

532
00:22:28,280 --> 00:22:31,183
after a user makes a purchase.

533
00:22:31,183 --> 00:22:34,086
If you have a user account
system on your server,

534
00:22:34,086 --> 00:22:35,888
chances are
you're already making use

535
00:22:35,888 --> 00:22:38,424
of the applicationUsername
property.

536
00:22:38,424 --> 00:22:41,360
The applicationUsername
is a string that you create

537
00:22:41,360 --> 00:22:45,831
to associate a transaction with
a user account on your service.

538
00:22:45,831 --> 00:22:48,234
In the original API
for in-app purchase,

539
00:22:48,234 --> 00:22:50,936
you set the applicationUsername
value when you add a payment

540
00:22:50,936 --> 00:22:53,339
to the payment queue.

541
00:22:53,339 --> 00:22:56,809
Although the applicationUsername
accepts any string,

542
00:22:56,809 --> 00:22:59,211
we recommend that you provide
the string representation

543
00:22:59,211 --> 00:23:01,814
of a UUID.

544
00:23:01,814 --> 00:23:04,183
When you provide it
a UUID string,

545
00:23:04,183 --> 00:23:06,085
StoreKit persists
the value and you'll see it

546
00:23:06,085 --> 00:23:08,520
in the transaction
that the queue updates.

547
00:23:08,520 --> 00:23:10,456
If you don't provide
a UUID string

548
00:23:10,456 --> 00:23:13,792
for the applicationUsername,
StoreKit may not persist it.

549
00:23:13,792 --> 00:23:15,894
There's no guarantee
the value will persist

550
00:23:15,894 --> 00:23:18,697
between the time you add the
payment transaction to the queue

551
00:23:18,697 --> 00:23:21,934
and when the queue updates
the transaction.

552
00:23:21,934 --> 00:23:25,070
When you provide the string
representation of a UUID,

553
00:23:25,070 --> 00:23:27,306
you can identify which of your
app's user accounts

554
00:23:27,306 --> 00:23:30,409
began and completed
a transaction.

555
00:23:30,409 --> 00:23:33,312
In the modern StoreKit APIs,
we implement this concept

556
00:23:33,312 --> 00:23:35,881
as a purchase option
called appAccountToken

557
00:23:35,881 --> 00:23:39,385
and it requires a UUID format.

558
00:23:39,385 --> 00:23:41,620
Now, when you set
the applicationUsername

559
00:23:41,620 --> 00:23:44,523
to a UUID string during payment,

560
00:23:44,523 --> 00:23:47,760
the App Store server stores it
as an appAccountToken.

561
00:23:47,760 --> 00:23:51,030
So you'll see its UUID appear
in the signed transaction info

562
00:23:51,030 --> 00:23:53,265
returned by
the App Store Server API

563
00:23:53,265 --> 00:23:57,336
and in V2 App Store
Server Notifications.

564
00:23:57,336 --> 00:24:00,539
And as a UUID, it's compatible
with the appAccountToken

565
00:24:00,539 --> 00:24:03,909
in the modern
StoreKit transaction APIs.

566
00:24:03,909 --> 00:24:06,445
So, now you can be sure that
when you update your codebase

567
00:24:06,445 --> 00:24:08,247
to the modern StoreKit APIs,

568
00:24:08,247 --> 00:24:11,083
the UUID you used
for the applicationUsername

569
00:24:11,083 --> 00:24:12,985
is preserved
as an appAccountToken

570
00:24:12,985 --> 00:24:15,788
in the StoreKit transactions.

571
00:24:15,788 --> 00:24:18,123
We touched on
a lot of things today.

572
00:24:18,123 --> 00:24:20,426
Before moving on
to the server updates,

573
00:24:20,426 --> 00:24:24,263
let's review this year's
StoreKit updates.

574
00:24:24,263 --> 00:24:26,398
We discussed validating
your app's purchase

575
00:24:26,398 --> 00:24:28,033
with App Transaction,

576
00:24:28,033 --> 00:24:31,603
redeeming an offer code and
requesting a review in SwiftUI,

577
00:24:31,603 --> 00:24:35,407
and controlling the presentation
of StoreKit messages.

578
00:24:35,407 --> 00:24:38,577
We talked about
new price locale, environment,

579
00:24:38,577 --> 00:24:41,714
and recent subscription
start date properties.

580
00:24:41,714 --> 00:24:43,782
And, we went over
the importance of using

581
00:24:43,782 --> 00:24:48,087
a string representation of a
UUID for the applicationUsername

582
00:24:48,087 --> 00:24:50,923
to persist it
as an app account token.

583
00:24:50,923 --> 00:24:53,659
I highly recommend
you check out our other session

584
00:24:53,659 --> 00:24:56,061
"What's new
in StoreKit testing."

585
00:24:56,061 --> 00:24:58,897
And if you need a refresher
on the StoreKit 2 APIs,

586
00:24:58,897 --> 00:25:01,934
check out last year's session
"Meet StoreKit 2."

587
00:25:01,934 --> 00:25:03,635
Now I'd like
to hand it over to Ian

588
00:25:03,635 --> 00:25:06,672
to walk you through the updates
to the App Store server.

589
00:25:06,672 --> 00:25:07,973
Ian Zanger: Thanks, Dani.

590
00:25:07,973 --> 00:25:09,775
Hi, everyone.
My name is Ian,

591
00:25:09,775 --> 00:25:12,911
and I'm an engineer
on the App Store Server team.

592
00:25:12,911 --> 00:25:14,179
Now that you've heard the latest

593
00:25:14,179 --> 00:25:16,415
about in-app purchase
with StoreKit,

594
00:25:16,415 --> 00:25:19,251
I'm going to switch gears
and talk about the server.

595
00:25:19,251 --> 00:25:23,222
First, I'll review some recent
developments from the past year

596
00:25:23,222 --> 00:25:25,557
before moving on
to some exciting new updates

597
00:25:25,557 --> 00:25:27,860
coming to
the App Store Server API

598
00:25:27,860 --> 00:25:32,297
and App Store Server
Notifications Version 2.

599
00:25:32,297 --> 00:25:34,533
Let's get started.

600
00:25:34,533 --> 00:25:36,068
Last year was big.

601
00:25:36,068 --> 00:25:39,037
We brought you an entirely new
suite of endpoints

602
00:25:39,037 --> 00:25:41,006
with the App Store Server API

603
00:25:41,006 --> 00:25:44,343
and App Store Server
Notifications V2,

604
00:25:44,343 --> 00:25:46,578
including full
sandbox testing support

605
00:25:46,578 --> 00:25:48,814
for all these new features.

606
00:25:48,814 --> 00:25:52,651
We shared how you can use the
Get Transaction History endpoint

607
00:25:52,651 --> 00:25:55,888
to get the full history
of a user's in-app purchases,

608
00:25:55,888 --> 00:25:59,091
or the Get All Subscription
Statuses endpoint

609
00:25:59,091 --> 00:26:01,059
to stay up to date
with the current state

610
00:26:01,059 --> 00:26:03,495
of a user's subscriptions.

611
00:26:03,495 --> 00:26:05,898
Both of these endpoints
conveniently key

612
00:26:05,898 --> 00:26:09,168
off of a user's
originalTransactionId,

613
00:26:09,168 --> 00:26:11,603
so you can access
this trove of data

614
00:26:11,603 --> 00:26:14,807
by storing just
this one simple value.

615
00:26:14,807 --> 00:26:16,775
We also covered how version 2

616
00:26:16,775 --> 00:26:19,011
of App Store Server
Notifications

617
00:26:19,011 --> 00:26:22,080
can simplify event processing
on your server

618
00:26:22,080 --> 00:26:25,384
and complement
the App Store Server API.

619
00:26:25,384 --> 00:26:27,386
With V2 notifications,

620
00:26:27,386 --> 00:26:30,522
the App Store server
calls your server directly,

621
00:26:30,522 --> 00:26:33,892
providing in-app purchase
updates as they happen.

622
00:26:33,892 --> 00:26:37,262
The streamlined notification
type and subtype

623
00:26:37,262 --> 00:26:40,265
make it easy to understand
what's happening.

624
00:26:40,265 --> 00:26:42,134
You can use these
to track changes

625
00:26:42,134 --> 00:26:45,938
related to in-app subscriptions
and other events.

626
00:26:45,938 --> 00:26:47,573
With all of these data sources,

627
00:26:47,573 --> 00:26:51,410
we wanted to make that data
as easy as possible to parse.

628
00:26:51,410 --> 00:26:53,679
Receipts are now a thing
of the past,

629
00:26:53,679 --> 00:26:56,582
as these new services
provide in-app data

630
00:26:56,582 --> 00:27:00,486
in signed JSON format,
so you can easily parse it

631
00:27:00,486 --> 00:27:04,089
and trust that it came
from the App Store server.

632
00:27:04,089 --> 00:27:07,626
Last year was a big year
for the App Store server.

633
00:27:07,626 --> 00:27:10,062
It may have been big
for you as well

634
00:27:10,062 --> 00:27:12,431
if you worked to update
your server code

635
00:27:12,431 --> 00:27:15,067
to leverage all
these new features.

636
00:27:15,067 --> 00:27:18,237
Rest assured that effort
will continue to pay off

637
00:27:18,237 --> 00:27:21,340
as we bring powerful new
enhancements and features

638
00:27:21,340 --> 00:27:27,179
to App Store Server API and App
Store Server Notifications V2.

639
00:27:27,179 --> 00:27:28,747
That's our year in review,

640
00:27:28,747 --> 00:27:30,482
but if you'd like
more of a refresher

641
00:27:30,482 --> 00:27:32,518
after hearing
this year's updates,

642
00:27:32,518 --> 00:27:36,989
be sure to check out
the WWDC21 sessions titled

643
00:27:36,989 --> 00:27:40,125
"Manage in-app purchases
on your server,"

644
00:27:40,125 --> 00:27:42,261
"Meet StoreKit 2,"

645
00:27:42,261 --> 00:27:45,831
and "Support customers
and handle refunds."

646
00:27:45,831 --> 00:27:48,467
Now let's move on
to brand-new updates

647
00:27:48,467 --> 00:27:53,205
coming to the App Store server
for WWDC22.

648
00:27:53,205 --> 00:27:56,141
First I'll share
some updates to transaction

649
00:27:56,141 --> 00:27:58,377
and renewal info fields.

650
00:27:58,377 --> 00:28:01,146
Next I'll tell you about
new enhancements

651
00:28:01,146 --> 00:28:03,916
to the App Store Server API.

652
00:28:03,916 --> 00:28:06,585
And finally, I'll share
exciting new features

653
00:28:06,585 --> 00:28:11,189
coming to App Store Server
Notifications V2.

654
00:28:11,189 --> 00:28:14,459
Now let's dive in with
the first of our new topics:

655
00:28:14,459 --> 00:28:18,497
new fields found in
transaction and renewal info.

656
00:28:18,497 --> 00:28:21,733
Earlier, you heard from Dani
about a couple new fields

657
00:28:21,733 --> 00:28:24,136
coming to the transaction
and renewal info

658
00:28:24,136 --> 00:28:26,038
of in-app purchases.

659
00:28:26,038 --> 00:28:30,075
These fields, environment
and recentSubscriptionStartDate,

660
00:28:30,075 --> 00:28:32,077
are also coming
to the transaction

661
00:28:32,077 --> 00:28:33,512
and renewal info payloads

662
00:28:33,512 --> 00:28:36,315
you receive from
the App Store Server API

663
00:28:36,315 --> 00:28:40,686
and in V2 App Store Server
Notifications.

664
00:28:40,686 --> 00:28:44,389
Let's take a fresh look at the
data you can expect to receive

665
00:28:44,389 --> 00:28:48,393
from the App Store server
with these new fields included.

666
00:28:48,393 --> 00:28:50,929
First is the transaction
info payload,

667
00:28:50,929 --> 00:28:53,732
which we can see here
after decoding.

668
00:28:53,732 --> 00:28:57,803
Down at the bottom, you can see
our new field: environment.

669
00:28:57,803 --> 00:28:59,771
You can use it to tell,
at a glance,

670
00:28:59,771 --> 00:29:01,573
whether the transaction
took place

671
00:29:01,573 --> 00:29:04,876
in the production
or sandbox environment.

672
00:29:04,876 --> 00:29:07,245
Next is the renewal info
payload,

673
00:29:07,245 --> 00:29:10,015
also seen here after decoding.

674
00:29:10,015 --> 00:29:13,619
As you can see, the environment
field is also available here

675
00:29:13,619 --> 00:29:15,654
for your reference.

676
00:29:15,654 --> 00:29:18,190
Additionally,
recentSubscriptionStartDate

677
00:29:18,190 --> 00:29:21,426
will now appear
in every renewal info payload.

678
00:29:21,426 --> 00:29:23,795
This is the start date
of the user's first

679
00:29:23,795 --> 00:29:27,799
subscription purchase in their
most recent string of renewals,

680
00:29:27,799 --> 00:29:32,104
ignoring any gaps
of 60 days or fewer.

681
00:29:32,104 --> 00:29:35,540
recentSubscriptionStartDate
is an easy way to get an idea

682
00:29:35,540 --> 00:29:38,510
of a customer's loyalty
at a glance.

683
00:29:38,510 --> 00:29:40,045
But if you'd like more detail,

684
00:29:40,045 --> 00:29:43,749
including the timing and length
of any gaps in service,

685
00:29:43,749 --> 00:29:47,019
you can call the
Get Transaction History endpoint

686
00:29:47,019 --> 00:29:48,620
and examine the full history

687
00:29:48,620 --> 00:29:51,923
of a user's subscription
renewal purchases.

688
00:29:51,923 --> 00:29:54,092
Or for even more detail,

689
00:29:54,092 --> 00:29:56,962
with App Store Server
Notifications V2,

690
00:29:56,962 --> 00:29:59,865
the App Store server
automatically sends updates

691
00:29:59,865 --> 00:30:03,068
about user subscriptions
to your server.

692
00:30:03,068 --> 00:30:05,937
These notifications give you
maximum insight

693
00:30:05,937 --> 00:30:09,708
into the timing of events like
renewal preference changes,

694
00:30:09,708 --> 00:30:14,546
offer redemptions,
billing failures, and more.

695
00:30:14,546 --> 00:30:17,349
As you can see,
recentSubscriptionStartDate

696
00:30:17,349 --> 00:30:19,151
rounds out a suite of options

697
00:30:19,151 --> 00:30:21,586
for determining
customer loyalty.

698
00:30:21,586 --> 00:30:23,755
Use these tools to target offers

699
00:30:23,755 --> 00:30:27,059
and reward your most
loyal customers.

700
00:30:27,059 --> 00:30:30,495
Now let's move on to some
convenient new enhancements

701
00:30:30,495 --> 00:30:33,732
to the Get Transaction History
endpoint.

702
00:30:33,732 --> 00:30:36,001
With the Get Transaction History
endpoint,

703
00:30:36,001 --> 00:30:39,204
you can fetch the full history
of a user's purchases

704
00:30:39,204 --> 00:30:41,006
in your app.

705
00:30:41,006 --> 00:30:43,375
The endpoint response
is paginated

706
00:30:43,375 --> 00:30:46,945
so you can process this data
in reasonable chunks.

707
00:30:46,945 --> 00:30:49,981
Each response contains a
revision token that you provide

708
00:30:49,981 --> 00:30:53,919
in the next request in order
to get the next page.

709
00:30:53,919 --> 00:30:56,621
And the pages are sorted
by modified date,

710
00:30:56,621 --> 00:30:59,691
meaning each subsequent page
contains transactions

711
00:30:59,691 --> 00:31:02,928
that are more recently modified.

712
00:31:02,928 --> 00:31:05,297
Let's take a look
at how this works.

713
00:31:05,297 --> 00:31:08,266
You call the Get Transaction
History endpoint,

714
00:31:08,266 --> 00:31:12,104
and provide
an originalTransactionId.

715
00:31:12,104 --> 00:31:16,408
The App Store server will return
up to 20 signed transactions

716
00:31:16,408 --> 00:31:18,043
for that user.

717
00:31:18,043 --> 00:31:21,179
It will also return
an updated revision value

718
00:31:21,179 --> 00:31:25,517
that you will provide in your
next page request for this user.

719
00:31:25,517 --> 00:31:27,686
You'll know there's
more data available

720
00:31:27,686 --> 00:31:31,723
when the hasMore field
in the response is true.

721
00:31:31,723 --> 00:31:32,924
Let's say in this case

722
00:31:32,924 --> 00:31:35,861
that there's another page
of data available.

723
00:31:35,861 --> 00:31:37,996
You make another request
to the endpoint,

724
00:31:37,996 --> 00:31:41,633
and you include that revision
value from the first response.

725
00:31:41,633 --> 00:31:43,535
You receive
the next page of data,

726
00:31:43,535 --> 00:31:46,404
including an updated
revision value.

727
00:31:46,404 --> 00:31:49,741
hasMore is now false,
so you know you're up to date

728
00:31:49,741 --> 00:31:52,511
with the latest
transaction data.

729
00:31:52,511 --> 00:31:54,179
Except this time,
you notice something

730
00:31:54,179 --> 00:31:56,681
about the final transaction
in the response;

731
00:31:56,681 --> 00:31:58,483
you've seen it before!

732
00:31:58,483 --> 00:32:01,286
It was one of
the original 20 you received

733
00:32:01,286 --> 00:32:03,889
in response to your first
request.

734
00:32:03,889 --> 00:32:06,591
This means the transaction
must have been modified,

735
00:32:06,591 --> 00:32:10,495
so it was put back at the top
of the sort order.

736
00:32:10,495 --> 00:32:13,465
Now, you can examine
the data of that transaction

737
00:32:13,465 --> 00:32:15,700
and take note of what's changed.

738
00:32:15,700 --> 00:32:18,637
In this instance,
you notice the revocationDate

739
00:32:18,637 --> 00:32:21,807
and revocationReason fields
are now populated,

740
00:32:21,807 --> 00:32:24,209
meaning the transaction
was revoked.

741
00:32:24,209 --> 00:32:26,845
You can take action
by revoking any content

742
00:32:26,845 --> 00:32:29,614
associated with the purchase.

743
00:32:29,614 --> 00:32:32,150
It's a good idea to store
the revision value

744
00:32:32,150 --> 00:32:34,519
from this final response
alongside

745
00:32:34,519 --> 00:32:39,324
the originalTransactionId
you used to identify the user.

746
00:32:39,324 --> 00:32:41,860
The next time you call
the endpoint for this user,

747
00:32:41,860 --> 00:32:44,062
you can provide
that revision and know

748
00:32:44,062 --> 00:32:47,199
that you're getting back
only fresh transaction data

749
00:32:47,199 --> 00:32:50,969
that has been modified
since your last request.

750
00:32:50,969 --> 00:32:54,072
As you've seen, the
Get Transaction History endpoint

751
00:32:54,072 --> 00:32:57,809
provides you a simple way
to retrieve a comprehensive set

752
00:32:57,809 --> 00:33:00,011
of in-app purchase data.

753
00:33:00,011 --> 00:33:03,849
But maybe sometimes it can be
a bit too comprehensive.

754
00:33:03,849 --> 00:33:06,284
Some users have
lengthy purchase histories

755
00:33:06,284 --> 00:33:09,054
dating back several years.

756
00:33:09,054 --> 00:33:12,090
For these users,
this endpoint could return

757
00:33:12,090 --> 00:33:16,895
hundreds of purchases
of a variety of types.

758
00:33:16,895 --> 00:33:20,232
Even with pages,
this can be a lot to handle.

759
00:33:20,232 --> 00:33:22,801
That's why this year,
we're enhancing this endpoint

760
00:33:22,801 --> 00:33:27,305
with a variety of new sort
and filter options.

761
00:33:27,305 --> 00:33:31,109
Now, you can tell us exactly the
data you want from the start,

762
00:33:31,109 --> 00:33:33,511
saving processing time
on your server

763
00:33:33,511 --> 00:33:35,447
and reducing the number
of network calls

764
00:33:35,447 --> 00:33:39,317
needed to retrieve
all available pages.

765
00:33:39,317 --> 00:33:41,887
You can sort
by descending modified date

766
00:33:41,887 --> 00:33:43,889
if you're interested
in seeing the most recently

767
00:33:43,889 --> 00:33:47,792
modified purchases
on the first page of results.

768
00:33:47,792 --> 00:33:50,595
You can also filter
by several useful fields

769
00:33:50,595 --> 00:33:54,199
such as product type,
product ID,

770
00:33:54,199 --> 00:33:56,968
Family sharing status,
and more.

771
00:33:56,968 --> 00:33:59,704
To apply these new
sort and filter options,

772
00:33:59,704 --> 00:34:03,141
just append them as query
parameters to your request

773
00:34:03,141 --> 00:34:06,344
to the Get Transaction History
endpoint.

774
00:34:06,344 --> 00:34:09,180
Let's take a closer look
at how that works.

775
00:34:09,180 --> 00:34:12,684
Here you can see all
the new parameter options.

776
00:34:12,684 --> 00:34:15,453
These may look familiar,
since most are taken directly

777
00:34:15,453 --> 00:34:18,623
from the transaction info
payload.

778
00:34:18,623 --> 00:34:20,392
You can mix and match
these parameters

779
00:34:20,392 --> 00:34:22,594
to get very specific results.

780
00:34:22,594 --> 00:34:24,863
For example,
maybe we want to fetch

781
00:34:24,863 --> 00:34:28,333
only the nonconsumable purchases
a user has made

782
00:34:28,333 --> 00:34:31,002
since the beginning
of this year.

783
00:34:31,002 --> 00:34:34,739
We also want to exclude
any revoked purchases.

784
00:34:34,739 --> 00:34:36,508
We will build our custom request

785
00:34:36,508 --> 00:34:39,444
by setting the productType
to NON_CONSUMABLE

786
00:34:39,444 --> 00:34:43,114
and specifying the startDate
as the beginning of this year

787
00:34:43,114 --> 00:34:45,183
represented in milliseconds.

788
00:34:45,183 --> 00:34:49,187
Finally, we'll set
excludeRevoked to true.

789
00:34:49,187 --> 00:34:50,889
And that's our request!

790
00:34:50,889 --> 00:34:53,091
Since we did not specify
a sort order,

791
00:34:53,091 --> 00:34:55,093
the response will default
to sorting

792
00:34:55,093 --> 00:34:58,129
by ascending modified date.

793
00:34:58,129 --> 00:35:00,932
Now even with a request
as specific as this,

794
00:35:00,932 --> 00:35:04,336
there could be multiple pages
of purchases to retrieve.

795
00:35:04,336 --> 00:35:06,671
For follow-up requests,
we should make sure

796
00:35:06,671 --> 00:35:09,341
to include the exact same
query parameters,

797
00:35:09,341 --> 00:35:12,978
in addition to the revision
from the previous response.

798
00:35:12,978 --> 00:35:14,779
For even more flexibility,

799
00:35:14,779 --> 00:35:18,183
three of the filter fields
support multiple values,

800
00:35:18,183 --> 00:35:20,585
so you can filter
to only those purchases

801
00:35:20,585 --> 00:35:24,689
that match at least
one of the provided values.

802
00:35:24,689 --> 00:35:28,960
These fields are productType,
productId,

803
00:35:28,960 --> 00:35:32,197
and subscriptionGroupIdentifier.

804
00:35:32,197 --> 00:35:35,367
To provide multiple values
for these parameters,

805
00:35:35,367 --> 00:35:39,170
simply define them
multiple times.

806
00:35:39,170 --> 00:35:44,376
Next let's move on to App Store
Server Notification updates.

807
00:35:44,376 --> 00:35:47,312
With App Store Server
Notifications V2,

808
00:35:47,312 --> 00:35:50,415
you can take your server
to the next level.

809
00:35:50,415 --> 00:35:53,485
V2 notifications
give detailed insights

810
00:35:53,485 --> 00:35:55,086
about in-app purchase events

811
00:35:55,086 --> 00:35:57,822
that you can't get
anywhere else.

812
00:35:57,822 --> 00:36:01,159
These are especially useful
for tracking the lifecycle

813
00:36:01,159 --> 00:36:05,030
of autorenewable subscriptions
offered in your app.

814
00:36:05,030 --> 00:36:08,566
You can use these insights
to retain customers,

815
00:36:08,566 --> 00:36:10,802
win back those
that have churned,

816
00:36:10,802 --> 00:36:15,106
resolve customer support
requests, and more.

817
00:36:15,106 --> 00:36:19,444
With all of these benefits, you
might wonder how to get started.

818
00:36:19,444 --> 00:36:21,179
As with any new feature,

819
00:36:21,179 --> 00:36:24,849
the sandbox testing environment
is the best place to start.

820
00:36:24,849 --> 00:36:26,084
That's why last year,

821
00:36:26,084 --> 00:36:29,421
we added the ability to set
a separate server URL

822
00:36:29,421 --> 00:36:31,790
in App Store Connect
for receiving

823
00:36:31,790 --> 00:36:35,260
App Store Server Notifications
in sandbox.

824
00:36:35,260 --> 00:36:37,862
After registering
your server URL,

825
00:36:37,862 --> 00:36:39,597
you'll want to confirm
your server

826
00:36:39,597 --> 00:36:43,401
is receiving notifications
from the App Store server.

827
00:36:43,401 --> 00:36:45,270
You might set up
a sandbox account

828
00:36:45,270 --> 00:36:49,274
just to trigger a notification
through a user action.

829
00:36:49,274 --> 00:36:52,777
For example, let's say you
perform a first time buy

830
00:36:52,777 --> 00:36:56,214
of a subscription
using that sandbox account.

831
00:36:56,214 --> 00:37:00,685
You should receive a V2
notification of type SUBSCRIBED

832
00:37:00,685 --> 00:37:03,254
and subtype INITIAL_BUY.

833
00:37:03,254 --> 00:37:05,623
But what if that notification
doesn't come?

834
00:37:05,623 --> 00:37:08,259
You might wonder if there
was an issue with your server

835
00:37:08,259 --> 00:37:12,097
or the steps you took
to trigger a notification.

836
00:37:12,097 --> 00:37:15,166
This situation can generate
a lot of uncertainty

837
00:37:15,166 --> 00:37:16,801
right as you're getting started.

838
00:37:16,801 --> 00:37:19,571
We want to simplify this
experience and give you a way

839
00:37:19,571 --> 00:37:23,041
to easily verify that App Store
Server Notifications

840
00:37:23,041 --> 00:37:25,343
can reach your server.

841
00:37:25,343 --> 00:37:27,979
That's why this year,
we're introducing the new

842
00:37:27,979 --> 00:37:31,149
Request a Test Notification
endpoint.

843
00:37:31,149 --> 00:37:32,884
By calling this simple
endpoint,

844
00:37:32,884 --> 00:37:37,689
you can ask us to send
a V2 Notification of type TEST

845
00:37:37,689 --> 00:37:42,427
to the server URL registered for
your app in App Store Connect.

846
00:37:42,427 --> 00:37:45,897
The new TEST notification type
is used exclusively

847
00:37:45,897 --> 00:37:47,932
for this endpoint.

848
00:37:47,932 --> 00:37:51,035
You can call the endpoint
in sandbox or production

849
00:37:51,035 --> 00:37:55,340
to test your saved URL
for either environment.

850
00:37:55,340 --> 00:37:59,344
Use this new endpoint
to quickly test new server URLs

851
00:37:59,344 --> 00:38:01,746
and configurations.

852
00:38:01,746 --> 00:38:04,916
Let's see how this simplifies
first-time setup.

853
00:38:04,916 --> 00:38:08,553
Now, if you're just looking to
trigger your first notification,

854
00:38:08,553 --> 00:38:10,922
there's no need to set up
a sandbox account

855
00:38:10,922 --> 00:38:12,957
or perform a purchase.

856
00:38:12,957 --> 00:38:14,325
Just call the new endpoint

857
00:38:14,325 --> 00:38:16,961
in whichever environment
you want to test

858
00:38:16,961 --> 00:38:20,632
and you'll receive
an HTTP 200 response

859
00:38:20,632 --> 00:38:22,734
confirming your request.

860
00:38:22,734 --> 00:38:25,136
The response
will contain a new field,

861
00:38:25,136 --> 00:38:29,607
testNotificationToken, which
identifies the test notification

862
00:38:29,607 --> 00:38:31,709
your server will receive.

863
00:38:31,709 --> 00:38:34,379
We will come back
to this field later.

864
00:38:34,379 --> 00:38:38,816
Shortly afterward, your server
should receive a V2 notification

865
00:38:38,816 --> 00:38:43,621
of type TEST at the URL
saved in App Store Connect.

866
00:38:43,621 --> 00:38:46,491
Now let's see
how to call this endpoint.

867
00:38:46,491 --> 00:38:49,527
Just send a simple POST request
to this new path

868
00:38:49,527 --> 00:38:52,030
on the App Store server.

869
00:38:52,030 --> 00:38:55,233
You'll receive
an HTTP 200 response

870
00:38:55,233 --> 00:38:58,570
and know that your request
has been submitted.

871
00:38:58,570 --> 00:39:01,439
The response will contain
that new field I mentioned,

872
00:39:01,439 --> 00:39:03,808
testNotificationToken.

873
00:39:03,808 --> 00:39:06,144
Take note of this for later.

874
00:39:06,144 --> 00:39:10,315
Soon you'll receive
a signed TEST Notification.

875
00:39:10,315 --> 00:39:12,517
Here's what that notification
will look like

876
00:39:12,517 --> 00:39:14,485
once it's decoded.

877
00:39:14,485 --> 00:39:17,488
You'll notice it contains
all the usual top-level fields

878
00:39:17,488 --> 00:39:19,524
of a V2 notification,

879
00:39:19,524 --> 00:39:23,228
including the new
notificationType, TEST.

880
00:39:23,228 --> 00:39:26,097
The contents of the data object
are a bit shorter

881
00:39:26,097 --> 00:39:27,899
than a normal notification.

882
00:39:27,899 --> 00:39:29,634
Since this is just a test,

883
00:39:29,634 --> 00:39:32,837
there are no transaction-related
data to include,

884
00:39:32,837 --> 00:39:35,640
so we omit
transaction-specific fields,

885
00:39:35,640 --> 00:39:40,078
most notably
the signedTransactionInfo.

886
00:39:40,078 --> 00:39:43,681
When calling the new Request
a Test Notification endpoint,

887
00:39:43,681 --> 00:39:46,184
keep in mind that App Store
Server Notifications

888
00:39:46,184 --> 00:39:48,653
are sent asynchronously.

889
00:39:48,653 --> 00:39:50,822
Your successful call
to the endpoint

890
00:39:50,822 --> 00:39:55,460
will return an HTTP 200
but the actual test notification

891
00:39:55,460 --> 00:39:59,464
will arrive separately,
a short while later.

892
00:39:59,464 --> 00:40:01,366
Given that this endpoint
is all about

893
00:40:01,366 --> 00:40:03,701
testing your server
configuration,

894
00:40:03,701 --> 00:40:07,105
you might be wondering
what to do when that test fails.

895
00:40:07,105 --> 00:40:12,110
In other words, what if the test
notification doesn't arrive?

896
00:40:12,110 --> 00:40:14,979
To further enhance
your testing capabilities,

897
00:40:14,979 --> 00:40:18,750
we're releasing the Get Test
Notification Status endpoint,

898
00:40:18,750 --> 00:40:20,518
which you will use
in conjunction

899
00:40:20,518 --> 00:40:24,088
with the Request a Test
Notification endpoint.

900
00:40:24,088 --> 00:40:26,791
With this new endpoint,
you can check on the status

901
00:40:26,791 --> 00:40:30,628
of a previously requested
TEST notification.

902
00:40:30,628 --> 00:40:33,531
The endpoint response will tell
you if the App Store server

903
00:40:33,531 --> 00:40:35,366
was able to reach your server

904
00:40:35,366 --> 00:40:39,170
and successfully send
the TEST notification.

905
00:40:39,170 --> 00:40:42,340
If the send failed,
it will give you an idea of why,

906
00:40:42,340 --> 00:40:46,477
so you can better troubleshoot
your server configuration.

907
00:40:46,477 --> 00:40:50,281
Let's check out how you'll use
this endpoint.

908
00:40:50,281 --> 00:40:54,886
Send a GET request to this path
on the App Store server.

909
00:40:54,886 --> 00:40:58,089
In the path, include
the testNotificationToken

910
00:40:58,089 --> 00:41:02,460
you received from the Request
a Test Notification endpoint.

911
00:41:02,460 --> 00:41:04,862
This will tell us
which test notification

912
00:41:04,862 --> 00:41:07,231
you want to check the status of.

913
00:41:07,231 --> 00:41:09,167
Now for the response.

914
00:41:09,167 --> 00:41:13,071
The signedPayload field contains
the TEST notification payload

915
00:41:13,071 --> 00:41:15,540
that the App Store server
attempted to send

916
00:41:15,540 --> 00:41:17,375
to your server.

917
00:41:17,375 --> 00:41:21,279
And the firstSendAttemptResult
field indicates the result

918
00:41:21,279 --> 00:41:23,848
of that send attempt.

919
00:41:23,848 --> 00:41:27,652
Here, SUCCESS indicates
that the send was successful,

920
00:41:27,652 --> 00:41:31,723
meaning the App Store server
received an HTTP 200 response

921
00:41:31,723 --> 00:41:34,125
from your server.

922
00:41:34,125 --> 00:41:36,527
If the send was unsuccessful,

923
00:41:36,527 --> 00:41:40,665
you'll instead see one of
several different error values.

924
00:41:40,665 --> 00:41:44,502
These values indicate the error
the App Store server experienced

925
00:41:44,502 --> 00:41:48,005
trying to reach your server
with the test notification.

926
00:41:48,005 --> 00:41:51,809
With this information, you can
troubleshoot your server issue,

927
00:41:51,809 --> 00:41:54,746
request new test notifications
as needed,

928
00:41:54,746 --> 00:41:58,116
and get your server
running reliably.

929
00:41:58,116 --> 00:42:00,918
Collectively, these test
notification endpoints

930
00:42:00,918 --> 00:42:03,721
are simple to use and can
save you a lot of trouble

931
00:42:03,721 --> 00:42:06,591
when setting up
or reconfiguring your server

932
00:42:06,591 --> 00:42:11,696
to receive V2 App Store Server
Notifications.

933
00:42:11,696 --> 00:42:13,131
Now with the help
of these endpoints,

934
00:42:13,131 --> 00:42:17,001
you can set up your server and
confirm it's running smoothly.

935
00:42:17,001 --> 00:42:20,204
But servers aren't perfect
and outages happen.

936
00:42:20,204 --> 00:42:23,040
How do you recover
when your server goes down,

937
00:42:23,040 --> 00:42:26,911
leading you to miss
App Store Server Notifications?

938
00:42:26,911 --> 00:42:30,481
The current solution to this
is a retry system.

939
00:42:30,481 --> 00:42:33,451
When the App Store server
fails to reach your server,

940
00:42:33,451 --> 00:42:36,087
it initiates a retry process.

941
00:42:36,087 --> 00:42:40,358
It will retry sending the same
notification up to five times,

942
00:42:40,358 --> 00:42:43,361
with a longer wait
between each attempt.

943
00:42:43,361 --> 00:42:47,698
These retries take place only
in the production environment.

944
00:42:47,698 --> 00:42:50,635
Retries help you eventually
recover from an outage,

945
00:42:50,635 --> 00:42:53,738
but they're not perfect
for every situation.

946
00:42:53,738 --> 00:42:57,108
For example, some outages
can be extensive.

947
00:42:57,108 --> 00:42:58,976
If your server
is down long enough

948
00:42:58,976 --> 00:43:02,480
to miss the final retry attempt
from the App Store server,

949
00:43:02,480 --> 00:43:05,316
that notification is lost.

950
00:43:05,316 --> 00:43:06,584
Or more commonly,

951
00:43:06,584 --> 00:43:09,587
your server could experience
a very brief issue,

952
00:43:09,587 --> 00:43:13,558
during which it misses
only a handful of notifications.

953
00:43:13,558 --> 00:43:16,194
But missing even
a single notification

954
00:43:16,194 --> 00:43:18,830
means some of your customer
records are out of date

955
00:43:18,830 --> 00:43:20,565
for at least an hour.

956
00:43:20,565 --> 00:43:23,434
Yet you don't know which ones!

957
00:43:23,434 --> 00:43:26,237
Clearly, server outages
are stressful,

958
00:43:26,237 --> 00:43:29,307
and recovering from them
can be a complex task.

959
00:43:29,307 --> 00:43:31,843
That's why we want to make it
as easy as possible

960
00:43:31,843 --> 00:43:35,179
to recover missed
App Store Server Notifications,

961
00:43:35,179 --> 00:43:39,884
so you can get your server back
on track as soon as possible.

962
00:43:39,884 --> 00:43:42,687
That's why this year,
we are introducing the new

963
00:43:42,687 --> 00:43:45,323
Get Notification History
endpoint.

964
00:43:45,323 --> 00:43:46,991
With this endpoint,

965
00:43:46,991 --> 00:43:51,329
you can fetch the history of V2
App Store Server Notifications

966
00:43:51,329 --> 00:43:53,764
generated for your app.

967
00:43:53,764 --> 00:43:58,236
Whether your server successfully
received a notification or not,

968
00:43:58,236 --> 00:44:02,740
that notification will appear in
the response of this endpoint.

969
00:44:02,740 --> 00:44:04,108
When calling this endpoint,

970
00:44:04,108 --> 00:44:08,513
you'll specify a date range
of notifications to fetch.

971
00:44:08,513 --> 00:44:11,916
With WWDC, we have started
recording this data,

972
00:44:11,916 --> 00:44:15,419
and we will build up to the cap
of the latest six months

973
00:44:15,419 --> 00:44:18,189
of rolling history
being available.

974
00:44:18,189 --> 00:44:22,293
You can optionally filter your
request by type and subtype,

975
00:44:22,293 --> 00:44:25,696
or fetch just
a single user's notifications

976
00:44:25,696 --> 00:44:29,033
by providing
an originalTransactionId.

977
00:44:29,033 --> 00:44:31,903
And the existing retry system
is still available,

978
00:44:31,903 --> 00:44:35,840
so you can use it in tandem
with this new endpoint.

979
00:44:35,840 --> 00:44:39,043
Let's take a look at how
you'll call this endpoint.

980
00:44:39,043 --> 00:44:41,846
You'll send a POST request
to this new path

981
00:44:41,846 --> 00:44:43,681
on the App Store server.

982
00:44:43,681 --> 00:44:48,819
In the request body, you'll
include a startDate and endDate.

983
00:44:48,819 --> 00:44:51,422
The response will contain
only notifications

984
00:44:51,422 --> 00:44:54,792
we first attempted to send
in this window.

985
00:44:54,792 --> 00:44:58,062
Keep in mind that the earliest
notifications available

986
00:44:58,062 --> 00:45:02,967
will be those sent six months
before the date of your request.

987
00:45:02,967 --> 00:45:06,470
Optionally, you can specify
a notificationType

988
00:45:06,470 --> 00:45:08,606
and notificationSubtype.

989
00:45:08,606 --> 00:45:12,510
If you do, the history will be
filtered to only notifications

990
00:45:12,510 --> 00:45:15,146
that match both of these values.

991
00:45:15,146 --> 00:45:19,483
Keep in mind that some
notifications have no subtype.

992
00:45:19,483 --> 00:45:21,319
Alternatively,
you can provide

993
00:45:21,319 --> 00:45:23,988
an originalTransactionId
of a user,

994
00:45:23,988 --> 00:45:28,659
to fetch the notification
history of only that user.

995
00:45:28,659 --> 00:45:31,629
Finally, you should provide
a paginationToken

996
00:45:31,629 --> 00:45:34,765
as a query parameter
for every follow-up request

997
00:45:34,765 --> 00:45:37,168
in order to get the next page.

998
00:45:37,168 --> 00:45:39,737
Make sure you use
the same request body

999
00:45:39,737 --> 00:45:41,339
for follow-up requests,

1000
00:45:41,339 --> 00:45:44,508
changing only
this paginationToken.

1001
00:45:44,508 --> 00:45:47,445
Now let's take a look
at the response.

1002
00:45:47,445 --> 00:45:51,749
The notificationHistory array
contains up to 20 notifications,

1003
00:45:51,749 --> 00:45:55,620
with the oldest
notifications first.

1004
00:45:55,620 --> 00:45:59,857
Each entry in this array
represents a notification

1005
00:45:59,857 --> 00:46:02,927
and inside you'll find
the signedPayload,

1006
00:46:02,927 --> 00:46:07,431
which you can decode as usual
to view the transaction data.

1007
00:46:07,431 --> 00:46:10,334
The data within
is identical to the payload

1008
00:46:10,334 --> 00:46:14,572
the App Store server sent
in the original notification.

1009
00:46:14,572 --> 00:46:16,607
You'll see that we've also
brought the new

1010
00:46:16,607 --> 00:46:20,845
firstSendAttemptResult field
to this endpoint response.

1011
00:46:20,845 --> 00:46:24,148
You can use this field to look
for sequences of timeouts

1012
00:46:24,148 --> 00:46:27,485
and other errors to better
understand why your server

1013
00:46:27,485 --> 00:46:30,855
missed notifications
in the past.

1014
00:46:30,855 --> 00:46:33,624
The response also contains
a paginationToken

1015
00:46:33,624 --> 00:46:36,193
if there are more pages
to retrieve.

1016
00:46:36,193 --> 00:46:38,262
You should provide this
in your next request

1017
00:46:38,262 --> 00:46:41,799
in order to get the next page
of notifications.

1018
00:46:41,799 --> 00:46:43,934
You'll know there are
more pages to retrieve

1019
00:46:43,934 --> 00:46:47,705
as long as
the hasMore field is true.

1020
00:46:47,705 --> 00:46:49,240
And that's everything
you need to know

1021
00:46:49,240 --> 00:46:52,543
about this useful new endpoint.

1022
00:46:52,543 --> 00:46:56,113
That concludes our App Store
server updates for today.

1023
00:46:56,113 --> 00:46:59,150
Every server feature
announced today is available now

1024
00:46:59,150 --> 00:47:02,386
in both sandbox and production.

1025
00:47:02,386 --> 00:47:04,755
We hope you'll take advantage
of these new features

1026
00:47:04,755 --> 00:47:07,758
to make your server
the best it can be.

1027
00:47:07,758 --> 00:47:11,462
For more great content on using
a server with in-app purchase,

1028
00:47:11,462 --> 00:47:13,698
including how to use
the latest features

1029
00:47:13,698 --> 00:47:15,800
while supporting legacy clients,

1030
00:47:15,800 --> 00:47:20,371
I encourage you to check out
another session at WWDC22,

1031
00:47:20,371 --> 00:47:24,208
"Explore in-app purchase
integration and migration."

1032
00:47:24,208 --> 00:47:27,545
Both: Thanks for joining us
at WWDC22!

1033
00:47:27,545 --> 00:47:31,582
♪

