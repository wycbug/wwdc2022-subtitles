1
00:00:00,334 --> 00:00:07,341
♪ ♪

2
00:00:10,177 --> 00:00:13,180
Hi, and welcome to WWDC.

3
00:00:13,213 --> 00:00:15,415
My name is David,
and I'd like to tell you about

4
00:00:15,449 --> 00:00:18,685
how you can explore
more content with MusicKit.

5
00:00:18,719 --> 00:00:21,288
The MusicKit framework
was launched in 2021,

6
00:00:21,321 --> 00:00:25,659
providing a set of APIs to access
and play music natively in Swift.

7
00:00:25,692 --> 00:00:28,996
This framework makes it easy for
your app to integrate with Apple Music,

8
00:00:29,029 --> 00:00:32,299
providing access
to the entire Apple Music catalog.

9
00:00:32,332 --> 00:00:34,968
Today, I'd like to talk about
some of the major enhancements

10
00:00:35,002 --> 00:00:36,937
we've made to MusicKit.

11
00:00:36,970 --> 00:00:40,641
I'll start off with some additions to get
even more out of the Apple Music catalog,

12
00:00:40,674 --> 00:00:45,012
with new music item types,
new requests, and new metadata.

13
00:00:46,046 --> 00:00:49,283
After that, I'll discuss how
you can fetch personalized content

14
00:00:49,316 --> 00:00:53,187
to provide a tailored experience
for each of your users.

15
00:00:53,220 --> 00:00:56,223
Next up, I'll go
beyond the Apple Music catalog.

16
00:00:56,256 --> 00:00:59,092
This year, you can take your app
to a whole new level

17
00:00:59,126 --> 00:01:02,596
by including music
from your user's library.

18
00:01:02,629 --> 00:01:06,133
Finally, I'll discuss
how to actively interact with the library,

19
00:01:06,166 --> 00:01:09,036
such as adding items to the library
or a playlist,

20
00:01:09,069 --> 00:01:12,072
as well as creating and editing playlists.

21
00:01:12,105 --> 00:01:14,842
Let's dive into
the catalog content additions.

22
00:01:14,875 --> 00:01:18,579
The initial release of MusicKit
introduced a new model layer for music,

23
00:01:18,612 --> 00:01:22,616
including core types like Songs,
Albums, and Playlists.

24
00:01:22,649 --> 00:01:25,252
This year, we're making it easier
to discover new music

25
00:01:25,285 --> 00:01:28,722
with MusicKit
with the addition of two new types:

26
00:01:28,755 --> 00:01:30,824
Curator and Radio Show.

27
00:01:32,092 --> 00:01:34,561
Beyond that, MusicKit now also allows you

28
00:01:34,595 --> 00:01:37,831
to build great UI
for searching through the catalog,

29
00:01:37,865 --> 00:01:41,134
access top charts to get
the most popular songs, albums,

30
00:01:41,168 --> 00:01:44,204
and more, and fetch new attributes

31
00:01:44,238 --> 00:01:48,809
such as higher quality audio metadata
like Spatial Audio with Dolby Atmos.

32
00:01:49,610 --> 00:01:53,213
Let's start with curators and radio shows,
which are fantastic resources

33
00:01:53,247 --> 00:01:54,882
for music discovery.

34
00:01:54,915 --> 00:01:58,385
Here, we're taking a look
at an example Curator, Nike.

35
00:01:58,418 --> 00:02:02,756
Other examples of curators
are Shazam and Beats by Dr. Dre.

36
00:02:02,789 --> 00:02:07,127
Here, we can easily find all of
the playlists generated by this curator.

37
00:02:07,160 --> 00:02:11,231
This functionality allows people to get
quick access to playlists they may love,

38
00:02:11,265 --> 00:02:14,434
finding new songs
or revisiting old favorites.

39
00:02:14,468 --> 00:02:17,304
Now let's dive
into the more technical details.

40
00:02:18,238 --> 00:02:20,641
Curators host a variety of attributes.

41
00:02:20,674 --> 00:02:24,244
Some of the primary attributes
of this new Curator type are name,

42
00:02:24,278 --> 00:02:28,348
url, artwork, and kind.

43
00:02:28,382 --> 00:02:32,719
The kind property is an enum that can
either be "editorial" or "external"

44
00:02:32,753 --> 00:02:37,291
indicating whether a given curator is
an Apple curator or a third party curator.

45
00:02:38,258 --> 00:02:40,761
Curators also have
a playlists relationship

46
00:02:40,794 --> 00:02:42,896
showing playlists made by that curator,

47
00:02:42,930 --> 00:02:46,133
truly servicing
the music discovery notion we just saw.

48
00:02:47,835 --> 00:02:50,304
Next, we have the Radio Show type.

49
00:02:50,337 --> 00:02:52,940
Radio Shows like
"New Music Daily by Zane Lowe"

50
00:02:52,973 --> 00:02:56,343
and "Pop Hits Radio by Brooke Reese"
are another way to discover

51
00:02:56,376 --> 00:02:59,046
new music through seasoned professionals.

52
00:02:59,079 --> 00:03:00,647
Much like the Curator type,

53
00:03:00,681 --> 00:03:03,317
radio shows also have
a playlists relationship

54
00:03:03,350 --> 00:03:06,320
to find the music a radio show features.

55
00:03:06,353 --> 00:03:09,623
Just as these two new types
hold relationships to playlists,

56
00:03:09,656 --> 00:03:13,260
we are also exposing two new
relationships on the Playlist type,

57
00:03:13,293 --> 00:03:17,698
"Curator" and "RadioShow" for
the reversed logic: that given a playlist,

58
00:03:17,731 --> 00:03:21,702
we can easily get the structure
of which entity generated said playlist.

59
00:03:23,203 --> 00:03:26,840
MusicKit allows searching the catalog
for content from a plethora of types,

60
00:03:26,874 --> 00:03:31,645
and now we're adding support for our new
item types, like curators and radio shows.

61
00:03:31,678 --> 00:03:34,481
The list just continues to grow,
and as a result,

62
00:03:34,515 --> 00:03:37,651
building good UI becomes
more and more challenging.

63
00:03:37,684 --> 00:03:40,621
That's why this year,
we're making it much easier for you

64
00:03:40,654 --> 00:03:43,857
through top results and suggestions.

65
00:03:43,891 --> 00:03:47,694
Let's take a look at the utility
these enhancements bring to a UI.

66
00:03:47,728 --> 00:03:51,164
When typing to search for content,
you may want to provide strong,

67
00:03:51,198 --> 00:03:53,834
music-related auto-complete support.

68
00:03:53,867 --> 00:03:56,170
That's where suggestions come into play,

69
00:03:56,203 --> 00:03:59,239
providing terms
that people may be trying to reach.

70
00:03:59,273 --> 00:04:02,309
You can even take it a step further
and display top results

71
00:04:02,342 --> 00:04:06,380
for quick access
to what people may be searching for.

72
00:04:06,413 --> 00:04:09,650
For the best results, you may not care
about the type of the item,

73
00:04:09,683 --> 00:04:12,653
but instead want to focus on relevancy.

74
00:04:12,686 --> 00:04:15,355
This is the power of top results.

75
00:04:15,389 --> 00:04:18,659
Now, let's take a look at what
implementing this would look like,

76
00:04:18,692 --> 00:04:20,227
starting with Top Results.

77
00:04:20,260 --> 00:04:23,864
Here we have the existing way to create
a catalog search request,

78
00:04:23,897 --> 00:04:25,499
requiring a search term

79
00:04:25,532 --> 00:04:28,001
and the types of items
that you want represented.

80
00:04:28,035 --> 00:04:31,805
The response includes collections
categorized by the requested types,

81
00:04:31,839 --> 00:04:35,175
meaning multiple lists
of type specific results.

82
00:04:35,209 --> 00:04:38,078
Although this is great,
we want to expose a single list

83
00:04:38,111 --> 00:04:41,081
of the most relevant results
that is type agnostic.

84
00:04:41,114 --> 00:04:45,652
And requesting this information
is as simple as adding one line.

85
00:04:45,686 --> 00:04:49,790
Here we're setting the includeTopResults
property on the request to true,

86
00:04:49,823 --> 00:04:53,060
and a new property
is filled in the response.

87
00:04:53,093 --> 00:04:55,796
This new property is named topResults

88
00:04:55,829 --> 00:04:58,866
which contains items
of any of the requested types.

89
00:04:58,899 --> 00:05:02,202
Here's what the output
of the print statement looks like.

90
00:05:02,236 --> 00:05:06,073
We can see that the top results
returned are a mix of songs, artists,

91
00:05:06,106 --> 00:05:11,011
and albums in a single collection
and is ordered by relevancy.

92
00:05:11,044 --> 00:05:14,047
Now I'll show you how to help
people get to their search destination

93
00:05:14,081 --> 00:05:16,683
faster with Suggestions.

94
00:05:16,717 --> 00:05:20,687
Simply create a suggestions request
with a string term.

95
00:05:20,721 --> 00:05:25,192
Upon calling response,
you'll get back a suggestions response.

96
00:05:25,225 --> 00:05:27,961
The response contains
an array of Suggestions.

97
00:05:27,995 --> 00:05:32,232
And each suggestion includes a display
term which is suitable for your UI,

98
00:05:32,266 --> 00:05:34,067
as well as a search term.

99
00:05:34,101 --> 00:05:37,538
When people select a suggestion,
you can fetch the corresponding results

100
00:05:37,571 --> 00:05:40,240
by performing a search request
with the search term.

101
00:05:41,508 --> 00:05:46,280
Catalog charts are a great way to stay
up-to-date with the most popular songs.

102
00:05:46,313 --> 00:05:50,584
MusicKit offers various types of charts
to see what's trending.

103
00:05:50,617 --> 00:05:53,053
The types of charts
being offered are top charts,

104
00:05:53,086 --> 00:05:57,824
such as Top Songs or Top Albums,
which correspond to the most played music,

105
00:05:57,858 --> 00:06:01,528
city charts, and daily top 100.

106
00:06:01,562 --> 00:06:06,633
You may also specify the requested charts
to be filtered by a specific genre.

107
00:06:06,667 --> 00:06:09,870
Retrieving these charts
through code is extremely simple.

108
00:06:09,903 --> 00:06:12,539
The catalog charts request
follows established patterns

109
00:06:12,573 --> 00:06:15,709
already used
in the catalog search request.

110
00:06:15,742 --> 00:06:18,879
First, initialize a charts request.

111
00:06:18,912 --> 00:06:22,182
You can then specify
the kinds of charts you'd like.

112
00:06:22,216 --> 00:06:25,252
By default,
this will fetch the most played content,

113
00:06:25,285 --> 00:06:30,157
but you can also include daily
global top charts and city top charts.

114
00:06:30,190 --> 00:06:33,560
Lastly, just specify the types
you want your charts to contain.

115
00:06:33,594 --> 00:06:35,896
And that's it.

116
00:06:35,929 --> 00:06:38,699
When we access the first playlist chart
in the response,

117
00:06:38,732 --> 00:06:43,270
we get a MusicCatalogChart
representing the daily global top charts.

118
00:06:43,303 --> 00:06:48,775
Its items are playlists like "Top 100:
Global" and "Top 100: USA".

119
00:06:48,809 --> 00:06:52,279
If you've been fetching catalog charts
using MusicDataRequest in the past,

120
00:06:52,312 --> 00:06:55,482
you no longer need to,
as MusicKit will do the work for you,

121
00:06:55,516 --> 00:06:58,752
with pagination support
built into the collection of items.

122
00:06:58,785 --> 00:07:00,320
In 2021,

123
00:07:00,354 --> 00:07:02,789
we introduced
groundbreaking audio experiences

124
00:07:02,823 --> 00:07:05,959
with true multidimensional sound
and clarity:

125
00:07:05,993 --> 00:07:09,396
Spatial Audio with support
for Dolby Atmos.

126
00:07:09,429 --> 00:07:13,166
This immersive experience is
already available for thousands of songs,

127
00:07:13,200 --> 00:07:15,702
and now you can access this data.

128
00:07:15,736 --> 00:07:20,674
MusicKit exposes which audio resources are
available for any song or album

129
00:07:20,707 --> 00:07:25,646
through Audio Variants, so now,
you can relay this information to others.

130
00:07:25,679 --> 00:07:28,315
Examples of audio variants
are the previously mentioned

131
00:07:28,348 --> 00:07:33,387
Spatial Audio with Dolby Atmos,
Lossless Audio, and much more.

132
00:07:34,755 --> 00:07:38,492
We are also exposing a new
boolean property alongside audio variants,

133
00:07:38,525 --> 00:07:43,297
is Apple Digital Master, which is
the highest quality master supported.

134
00:07:43,330 --> 00:07:46,099
Since this metadata is
exposed at the item level,

135
00:07:46,133 --> 00:07:48,368
audio variants
are perfect for a detail view,

136
00:07:48,402 --> 00:07:51,471
allowing you to achieve UI like this.

137
00:07:51,505 --> 00:07:54,341
Here we have a detail view of an album.

138
00:07:54,374 --> 00:07:56,743
And here,
we can see the appropriate badges

139
00:07:56,777 --> 00:07:59,580
based on the audio variants
property mentioned earlier,

140
00:07:59,613 --> 00:08:02,950
letting users know
what audio quality they can expect.

141
00:08:02,983 --> 00:08:05,819
In this case,
spatial audio and lossless audio

142
00:08:05,853 --> 00:08:08,088
are available for this specific album.

143
00:08:08,121 --> 00:08:11,325
Now let's see how we can write
code to achieve this.

144
00:08:11,358 --> 00:08:14,928
Loading audio variants are like loading
any other extended attribute.

145
00:08:14,962 --> 00:08:18,732
Take an existing album or song,
in this case an album,

146
00:08:18,765 --> 00:08:22,803
and use the with method to load
the audioVariants extended attribute.

147
00:08:22,836 --> 00:08:27,441
Now your detailedAlbum has
the audioVariants property populated.

148
00:08:27,474 --> 00:08:29,510
Here we can see
the audio variants property,

149
00:08:29,543 --> 00:08:32,913
which is an array
whose element is an AudioVariant.

150
00:08:32,946 --> 00:08:36,884
With these values, you can indicate
in your UI the available audio resources

151
00:08:36,917 --> 00:08:40,153
for that particular element,
just like we saw earlier.

152
00:08:40,187 --> 00:08:42,256
Now, this is great,
but you may want to show these

153
00:08:42,289 --> 00:08:45,959
audio badges on more than
just top level or detail views.

154
00:08:45,993 --> 00:08:48,562
That's why
we're also taking it one step further

155
00:08:48,595 --> 00:08:52,099
and exposing the active audio variant
for the music player.

156
00:08:52,132 --> 00:08:55,469
Accessing the active audio variant allows
for a visual indication

157
00:08:55,502 --> 00:08:58,772
of the quality of audio
for the currently playing item,

158
00:08:58,805 --> 00:09:01,542
such as Dolby Atmos in this view.

159
00:09:01,575 --> 00:09:04,511
And the MusicKit player API
automatically chooses

160
00:09:04,545 --> 00:09:08,382
the correct audio quality based on
user settings and network conditions.

161
00:09:09,216 --> 00:09:11,518
To access the active
trait from the player,

162
00:09:11,552 --> 00:09:15,122
first, we access the
ApplicationMusicPlayer's playback state

163
00:09:15,155 --> 00:09:17,157
in an observed object.

164
00:09:17,191 --> 00:09:21,728
We can then access the active audioVariant
directly from the playback state

165
00:09:21,762 --> 00:09:24,031
Now,
we simply check the audioVariant property

166
00:09:24,064 --> 00:09:27,734
to see if it's dolbyAtmos,
and add additional UI if it is.

167
00:09:27,768 --> 00:09:30,204
Because the playback state
is an observed object,

168
00:09:30,237 --> 00:09:32,272
this view will automatically update

169
00:09:32,306 --> 00:09:34,274
whenever the currently
playing item changes,

170
00:09:34,308 --> 00:09:37,311
making sure your view is
always up-to-date.

171
00:09:37,344 --> 00:09:39,680
Now that we've gone over
some catalog additions,

172
00:09:39,713 --> 00:09:42,282
let's dive into
fetching personalized content.

173
00:09:42,316 --> 00:09:45,285
Personalized content is data
specific to a subscriber,

174
00:09:45,319 --> 00:09:49,423
providing a unique and tailored
experience for every user in your app.

175
00:09:49,456 --> 00:09:52,526
Normally, personalized content
requires special authentications

176
00:09:52,559 --> 00:09:55,395
and user tokens,
but in the MusicKit framework,

177
00:09:55,429 --> 00:09:59,132
we've made this all automatic so you don't
have to deal with any of the hassle.

178
00:09:59,166 --> 00:10:01,502
The personalized content
we're bringing to developers

179
00:10:01,535 --> 00:10:03,770
is access to recently played items

180
00:10:03,804 --> 00:10:06,907
and personal recommendations.

181
00:10:06,940 --> 00:10:09,443
Recently played content is
a valuable piece of data

182
00:10:09,476 --> 00:10:12,279
for a person's
music consumption experience.

183
00:10:12,312 --> 00:10:16,917
It allows for quick and easy access
to music items you know they enjoy.

184
00:10:16,950 --> 00:10:20,354
And when listening to new music,
it allows people to later go back

185
00:10:20,387 --> 00:10:22,489
and refer to their history.

186
00:10:22,523 --> 00:10:25,526
To fetch recently played
containers like albums, playlists,

187
00:10:25,559 --> 00:10:29,730
and stations, you can create
a recently played container request.

188
00:10:29,763 --> 00:10:32,432
Note that if you play a song
from a playlist or album,

189
00:10:32,466 --> 00:10:34,635
the container type will be retrieved.

190
00:10:34,668 --> 00:10:38,138
In the response,
you will find recently played music items,

191
00:10:38,172 --> 00:10:43,443
which offer convenience accessors
for the title, subtitle, and artwork.

192
00:10:43,477 --> 00:10:46,947
You can also fetch recently played items
of more specific types,

193
00:10:46,980 --> 00:10:48,882
like songs or stations.

194
00:10:48,916 --> 00:10:52,653
Here, we create a recently played request,
specifying the Song type

195
00:10:52,686 --> 00:10:56,490
through the generic parameter,
indicated by the angle brackets.

196
00:10:56,523 --> 00:10:59,693
Our response now only contains
the songs that we have played.

197
00:10:59,726 --> 00:11:02,596
Now, onto personal recommendations.

198
00:11:02,629 --> 00:11:07,067
Personal recommendations let your app
experience feel more intimate and engaging

199
00:11:07,100 --> 00:11:11,905
as they are generated based off
the user's library and listening history.

200
00:11:11,939 --> 00:11:14,575
Recommendations are
nicely organized by themes,

201
00:11:14,608 --> 00:11:20,147
resulting in groupings by genres, artists,
collections like "Made for You," and more.

202
00:11:20,180 --> 00:11:22,683
To fetch personal recommendations,

203
00:11:22,716 --> 00:11:25,552
simply create
a personal recommendations request.

204
00:11:25,586 --> 00:11:28,388
The response is
a collection of recommendations.

205
00:11:28,422 --> 00:11:32,092
When we log the first recommendation,
we can see that this particular element

206
00:11:32,125 --> 00:11:34,595
represents the "Made for You"
recommendation.

207
00:11:34,628 --> 00:11:38,632
Recommendations have an ID,
title, and nextRefreshDate.

208
00:11:38,665 --> 00:11:42,135
The nextRefreshDate represents
the date time for when this recommendation

209
00:11:42,169 --> 00:11:45,372
should be refreshed
for the most up-to-date suggestions.

210
00:11:45,405 --> 00:11:49,109
The playlists property contains all
of the playlists that are made for me.

211
00:11:49,142 --> 00:11:52,446
Let's take a look at another
example of a recommendation.

212
00:11:52,479 --> 00:11:56,250
Here we'll print out the second element
of the recommendations response.

213
00:11:56,283 --> 00:11:59,820
I listen to a ton of alternative music,
and this recommendation contains

214
00:11:59,853 --> 00:12:04,391
a mix of different types,
in this case, Albums and Playlists.

215
00:12:04,424 --> 00:12:06,994
Those are grouped
in a single collection of items,

216
00:12:07,027 --> 00:12:11,131
which are ordered by relevancy,
much like top results for catalog search.

217
00:12:11,164 --> 00:12:14,868
Now, let's take it a step further
and talk about how you can create

218
00:12:14,902 --> 00:12:17,371
even more relevant experiences
around music

219
00:12:17,404 --> 00:12:21,175
by incorporating content
from your user's library into your app.

220
00:12:21,208 --> 00:12:25,312
This year, MusicKit allows your app
to fetch items from the library

221
00:12:25,345 --> 00:12:28,749
with two types of requests:
the library request

222
00:12:28,782 --> 00:12:31,485
and the library sectioned request,

223
00:12:31,518 --> 00:12:34,588
search for content in the user's library,

224
00:12:34,621 --> 00:12:37,524
and load extended attributes
and relationships

225
00:12:37,558 --> 00:12:39,927
specifically from the library.

226
00:12:39,960 --> 00:12:42,296
Before we see the technical details,

227
00:12:42,329 --> 00:12:45,566
let's see how we can use library content
to enhance your app.

228
00:12:45,599 --> 00:12:48,435
I've been working on a fitness app
called Music Marathon

229
00:12:48,468 --> 00:12:50,704
that will track your outdoor runs.

230
00:12:50,737 --> 00:12:52,906
By incorporating MusicKit in the project,

231
00:12:52,940 --> 00:12:55,509
we allow people to play music
directly through the app

232
00:12:55,542 --> 00:12:59,546
instead of context switching between
the Apple Music app and this one.

233
00:12:59,580 --> 00:13:03,016
Let's start a new workout
and look for music content.

234
00:13:04,818 --> 00:13:07,154
Here we see some
recommended playlists retrieved

235
00:13:07,187 --> 00:13:09,122
from the personal recommendations request,

236
00:13:09,156 --> 00:13:12,860
to give people quick access
to playlists we think they'll love.

237
00:13:12,893 --> 00:13:17,531
Going to the library tab,
we can see it's an empty view.

238
00:13:17,564 --> 00:13:20,267
It would be great to be able to see
all of my personal playlists,

239
00:13:20,300 --> 00:13:21,835
so let's write that feature.

240
00:13:21,869 --> 00:13:25,439
I already have some UI set up
to handle the basics of this view,

241
00:13:25,472 --> 00:13:29,109
and now I want to load
the playlists from my library.

242
00:13:29,142 --> 00:13:30,777
First, I'll make library request...

243
00:13:33,647 --> 00:13:35,749
Specifying playlist
in the generic parameter

244
00:13:35,782 --> 00:13:38,785
to indicate that we want the playlists
from the user's library.

245
00:13:42,256 --> 00:13:44,958
And I'll store it in a local variable
I'll name "request."

246
00:13:47,928 --> 00:13:51,098
Next I'll take this request
and call the response function.

247
00:13:53,867 --> 00:13:56,403
This method is an async throwing method,

248
00:13:56,436 --> 00:13:58,572
so let's add the try and await keywords.

249
00:13:58,605 --> 00:14:01,441
and once again store it
in a response variable.

250
00:14:04,311 --> 00:14:07,614
Then, I'll update the state object
to receive this response.

251
00:14:11,752 --> 00:14:14,555
Now all that's left to do
is update the list

252
00:14:14,588 --> 00:14:17,457
so we can see the playlists in my UI.

253
00:14:17,491 --> 00:14:21,228
I'll iterate through the items
in the response using a ForEach...

254
00:14:25,432 --> 00:14:28,669
And retrieve each playlist
in the MusicItemCollection.

255
00:14:30,404 --> 00:14:31,638
Now that we have the playlists,

256
00:14:31,672 --> 00:14:33,941
I'll pass them into a PlaylistCell
I've already made.

257
00:14:35,642 --> 00:14:37,644
Now if we re-run...

258
00:14:44,017 --> 00:14:46,753
And navigate back to the app,

259
00:14:46,787 --> 00:14:50,057
we can see all of my personal
playlists in the library.

260
00:14:50,090 --> 00:14:52,826
Now, I can choose to listen
to personal recommendations,

261
00:14:52,860 --> 00:14:57,097
anything from the Apple Music catalog,
and my own personal library.

262
00:14:57,130 --> 00:15:00,467
Now that we've seen how easy
it is to access library content,

263
00:15:00,501 --> 00:15:02,569
let's look at what else
the library request can do.

264
00:15:02,603 --> 00:15:05,239
The music library request
is a powerful API

265
00:15:05,272 --> 00:15:07,741
to fetch items from the user's library.

266
00:15:07,774 --> 00:15:11,845
On iOS, unlike other requests
to fetch content from the music catalog,

267
00:15:11,879 --> 00:15:15,682
MusicLibraryRequest will not
actually load data from the network.

268
00:15:15,716 --> 00:15:19,152
Instead, it will load items
from the copy of the user's library

269
00:15:19,186 --> 00:15:21,622
that is stored on device.

270
00:15:21,655 --> 00:15:24,591
The basics of this request
only require you to specify

271
00:15:24,625 --> 00:15:27,027
which music item type is desired.

272
00:15:27,060 --> 00:15:29,429
This item type is passed
through the generic parameter

273
00:15:29,463 --> 00:15:32,332
of the MusicLibraryRequest.

274
00:15:32,366 --> 00:15:36,003
You can apply a variety of filters
and sort options on the request

275
00:15:36,036 --> 00:15:39,873
in order to finely tune your call
to match your requirements.

276
00:15:39,907 --> 00:15:43,710
This request is also capable
of fetching already downloaded content,

277
00:15:43,744 --> 00:15:46,947
supporting a fully offline experience.

278
00:15:46,980 --> 00:15:50,450
Let's start with the simple, base request,
the same request we wrote

279
00:15:50,484 --> 00:15:55,322
in the Music Marathon app, but this time,
ask for the Albums in the library.

280
00:15:55,355 --> 00:15:58,625
The album type is specified
through the generic parameter.

281
00:15:58,659 --> 00:16:01,695
To perform the request,
call the response function.

282
00:16:01,728 --> 00:16:04,898
Looking at the output,
we have a MusicLibraryResponse,

283
00:16:04,932 --> 00:16:07,334
where its items are a MusicItemCollection

284
00:16:07,367 --> 00:16:11,104
of all the albums found
within the user's music library.

285
00:16:11,138 --> 00:16:14,541
Here we notice that these Albums are
the same Album structure that you would

286
00:16:14,575 --> 00:16:19,346
get from one of our various catalog
requests and have the same capabilities.

287
00:16:19,379 --> 00:16:22,649
Whereas in this example we are
fetching every album in the library,

288
00:16:22,683 --> 00:16:27,221
we know there are scenarios where
you only want a specific subset of albums.

289
00:16:27,254 --> 00:16:31,458
That's why MusicLibraryRequest
also enables you to be more specific

290
00:16:31,491 --> 00:16:34,595
about what items
you want to fetch from the library.

291
00:16:34,628 --> 00:16:38,665
Let's take the same request
we wrote before and add a filter.

292
00:16:38,699 --> 00:16:42,369
Here, we want to load all albums
where the isCompilation property

293
00:16:42,402 --> 00:16:43,971
is equal to true.

294
00:16:44,004 --> 00:16:47,941
When you call filter method,
Xcode's autocompletion will only offer

295
00:16:47,975 --> 00:16:52,212
specific key paths that are supported
for the type of item you are requesting.

296
00:16:52,246 --> 00:16:56,283
Now, the response only has
albums which are compilations.

297
00:16:56,316 --> 00:16:59,653
But that's not all the power
the MusicLibraryRequest has to offer.

298
00:16:59,686 --> 00:17:01,655
You can chain multiple filters,

299
00:17:01,688 --> 00:17:04,958
giving you a more refined request
with each addition.

300
00:17:04,992 --> 00:17:08,862
What if we wanted all of
the compilations of a particular genre?

301
00:17:08,896 --> 00:17:11,331
We can add another filter to the request.

302
00:17:11,365 --> 00:17:15,002
For example, here we have
an instance of Genre named "Dance."

303
00:17:15,035 --> 00:17:18,305
You can filter by the genre's relationship
to restrict the results

304
00:17:18,338 --> 00:17:22,309
to only include compilations
that contain this specific genre.

305
00:17:22,342 --> 00:17:25,746
Now our response
only contains dance compilations.

306
00:17:25,779 --> 00:17:29,283
How about only including dance
compilations that are already downloaded?

307
00:17:29,316 --> 00:17:32,252
To do that,
just set the includeOnlyDownloadedContent

308
00:17:32,286 --> 00:17:33,787
to true on the request.

309
00:17:33,820 --> 00:17:34,955
And that's it.

310
00:17:34,988 --> 00:17:37,891
The response is
the same MusicLibraryResponse,

311
00:17:37,925 --> 00:17:41,662
but the items now only contain
elements that are downloaded.

312
00:17:41,695 --> 00:17:45,165
As you can see,
the music library request is very powerful

313
00:17:45,199 --> 00:17:50,204
and unlocks new capabilities that weren't
possible with a custom MusicDataRequest.

314
00:17:50,237 --> 00:17:54,842
But MusicKit offers even more options
to fetch data from the user's library.

315
00:17:54,875 --> 00:17:57,611
Meet the Library Sectioned Request.

316
00:17:57,644 --> 00:18:02,082
The sectioned request is able
to fetch items grouped by sections.

317
00:18:02,115 --> 00:18:06,987
As a result, the sectioned request
takes in two distinct generic parameters.

318
00:18:07,020 --> 00:18:11,758
The first representing the section type,
and the second, the item type.

319
00:18:11,792 --> 00:18:14,661
The library sectioned request
supports the same capabilities

320
00:18:14,695 --> 00:18:18,098
as the regular library request,
such as a variety of filter

321
00:18:18,131 --> 00:18:23,470
and sort methods which you can apply
to either the sections or the items.

322
00:18:23,504 --> 00:18:26,874
Here's how you can fetch
all albums sectioned by their genres

323
00:18:26,907 --> 00:18:29,743
using the library sectioned request.

324
00:18:29,776 --> 00:18:33,647
The sectioned Response holds a property
named "sections" where each element

325
00:18:33,680 --> 00:18:38,318
corresponds to the first generic parameter
of the request, Genre in this case.

326
00:18:38,352 --> 00:18:42,456
Each genre not only exposes
its own attributes, but it also contains

327
00:18:42,489 --> 00:18:46,660
a collection of albums,
accessible via the items property.

328
00:18:46,693 --> 00:18:50,030
Those items correspond
to the second generic argument.

329
00:18:50,063 --> 00:18:53,367
Here, the highlight shows albums
whose genre is Alternative.

330
00:18:53,400 --> 00:18:56,937
And as mentioned before,
the capabilities of filtering and sorting

331
00:18:56,970 --> 00:18:59,706
are also available
for this sectioned request.

332
00:18:59,740 --> 00:19:02,643
Let's say we want the same albums,
sectioned by genres,

333
00:19:02,676 --> 00:19:05,979
but the albums sorted
by their artist's name.

334
00:19:06,013 --> 00:19:07,681
We add a sort filter.

335
00:19:07,714 --> 00:19:11,585
By specifying the artistName keyPath
on Albums and saying that we want

336
00:19:11,618 --> 00:19:15,055
these to be ascending,
we're sorting the response.

337
00:19:15,088 --> 00:19:18,592
Notice that the method is sortItems
as we are specifying the sorting

338
00:19:18,625 --> 00:19:21,662
to be applied to the items
and not the sections.

339
00:19:21,695 --> 00:19:23,564
Had we wanted to specify the sections,

340
00:19:23,597 --> 00:19:27,668
a set of filterSections
and sortSection methods are available.

341
00:19:27,701 --> 00:19:29,670
Let's take a look at the new response.

342
00:19:32,139 --> 00:19:35,776
We can now see that our albums
are ordered alphabetically by artist name

343
00:19:35,809 --> 00:19:37,811
instead of by their titles.

344
00:19:37,845 --> 00:19:42,516
Both the library request and library
sectioned request are extremely powerful,

345
00:19:42,549 --> 00:19:45,485
but you might also want to complement
your music search UI

346
00:19:45,519 --> 00:19:48,655
by adding search results
from the user's library.

347
00:19:48,689 --> 00:19:52,593
So we've added a new structured request
which operates almost identically

348
00:19:52,626 --> 00:19:54,962
to catalog search,
but instead of loading results

349
00:19:54,995 --> 00:19:59,666
from the catalog, it finds
relevant items in the user's library.

350
00:19:59,700 --> 00:20:02,669
Just like its catalog counterpart,
the library search request

351
00:20:02,703 --> 00:20:06,773
only requires a search term
and an array of types.

352
00:20:06,807 --> 00:20:10,244
Now that we've seen the different ways
to retrieve items from the user's library,

353
00:20:10,277 --> 00:20:13,814
what about loading extended
attributes and relationships?

354
00:20:13,847 --> 00:20:17,784
As you may know, the initial release
of MusicKit introduced the with method,

355
00:20:17,818 --> 00:20:22,189
loading these properties from
Apple Music API in a straightforward way.

356
00:20:22,222 --> 00:20:24,658
This year,
we're augmenting the current with method

357
00:20:24,691 --> 00:20:28,195
to also take in
a preferred source parameter.

358
00:20:28,228 --> 00:20:32,299
This preferred source indicates where
to load data from, for extended attributes

359
00:20:32,332 --> 00:20:36,170
and relationships that are available
in both the Apple Music catalog

360
00:20:36,203 --> 00:20:38,438
and the user's library.

361
00:20:38,472 --> 00:20:41,942
And for the properties that only live
in either the catalog or the library,

362
00:20:41,975 --> 00:20:44,711
they will still fetched
regardless of the preferred source

363
00:20:44,745 --> 00:20:47,581
to make sure nothing is ignored.

364
00:20:47,614 --> 00:20:49,950
In addition,
you can use this functionality

365
00:20:49,983 --> 00:20:52,419
no matter where
the initial item came from,

366
00:20:52,452 --> 00:20:56,390
whether it be a catalog request,
a library request, or elsewhere.

367
00:20:56,423 --> 00:20:57,958
It all just works.

368
00:20:58,959 --> 00:21:02,963
Here we have the known way of
receiving a relationship of a music item.

369
00:21:02,996 --> 00:21:06,700
We're loading the tracks of an album,
and when we display the output,

370
00:21:06,733 --> 00:21:09,269
we can see
all of the tracks for that album.

371
00:21:09,303 --> 00:21:13,574
However, with the new addition
of the preferredSource property,

372
00:21:13,607 --> 00:21:15,242
we can specify that we would like to fetch

373
00:21:15,275 --> 00:21:17,578
this relationship from the library.

374
00:21:17,611 --> 00:21:22,349
Now our output only contains the tracks
of the album found in the library.

375
00:21:22,382 --> 00:21:25,886
With the various ways you can
now fetch items from the user's library,

376
00:21:25,919 --> 00:21:28,655
it only makes sense to allow users
to be able to interact

377
00:21:28,689 --> 00:21:31,358
with their library
directly through MusicKit.

378
00:21:31,391 --> 00:21:34,228
Let's jump back into my sample app,
Music Marathon,

379
00:21:34,261 --> 00:21:37,164
to see some of the capabilities
the library offers.

380
00:21:37,197 --> 00:21:39,333
As I'm working out,
I want to browse through some

381
00:21:39,366 --> 00:21:40,834
of my personal recommendations.

382
00:21:43,270 --> 00:21:45,839
As I look through the tracks,
I realize that one of these songs

383
00:21:45,873 --> 00:21:47,975
would be perfect for my workout playlist.

384
00:21:48,008 --> 00:21:51,311
If hold down one of these cells,
a contextual menu pops up,

385
00:21:51,345 --> 00:21:53,881
allowing me
to add this song to a playlist.

386
00:21:53,914 --> 00:21:57,851
When we press it, a pop-up
of all of my playlists appear again.

387
00:21:57,885 --> 00:22:01,555
Let's write code to add the selected track
to whichever playlist I pick.

388
00:22:01,588 --> 00:22:05,025
I've already piped the selected item
to our AddToPlaylistCell cell,

389
00:22:05,058 --> 00:22:09,229
so all we have to do is access the
MusicLibrary through the shared instance.

390
00:22:13,534 --> 00:22:16,703
We'll call the "add" method,

391
00:22:16,737 --> 00:22:18,972
specifying our selected track

392
00:22:19,006 --> 00:22:21,275
and which playlist we want to add to.

393
00:22:23,343 --> 00:22:25,812
This method is also
an async throwing function,

394
00:22:25,846 --> 00:22:28,815
so we add once again
the try and await keywords.

395
00:22:31,084 --> 00:22:33,053
Lastly, we'll dismiss the picker

396
00:22:33,086 --> 00:22:36,490
by setting the isShowingPlaylistPicker
binding variable to false.

397
00:22:38,225 --> 00:22:40,827
Now if we re-run

398
00:22:40,861 --> 00:22:44,598
and add a track to a playlist
and select one of our playlists,

399
00:22:44,631 --> 00:22:47,901
we should expect to see this item added.

400
00:22:47,935 --> 00:22:50,704
Navigating back to the library tab
within the app,

401
00:22:50,737 --> 00:22:53,607
we can see the song is
now added to our workout playlist.

402
00:22:53,640 --> 00:22:56,443
And that's how simple it is
to add an item to a playlist.

403
00:22:56,476 --> 00:22:59,913
Let's look at some of the other
functionality the library offers.

404
00:22:59,947 --> 00:23:03,317
The various other ways to interact
with the library are adding content

405
00:23:03,350 --> 00:23:06,420
to the library, creating playlists,

406
00:23:06,453 --> 00:23:10,524
and editing playlists' metadata
and track list.

407
00:23:10,557 --> 00:23:14,728
Adding content to the user's music library
allows people to find specific songs

408
00:23:14,761 --> 00:23:18,532
or albums in the library tab
of the Apple Music app,

409
00:23:18,565 --> 00:23:21,134
as well as synchronizes across all devices

410
00:23:21,168 --> 00:23:24,338
when "Sync Library" is turned on
in Settings.

411
00:23:24,371 --> 00:23:27,474
Providing this functionality
directly in your app saves people

412
00:23:27,508 --> 00:23:30,878
from context switching between
the Apple Music app and yours,

413
00:23:30,911 --> 00:23:34,515
so they can stay engaged
in the content you're providing.

414
00:23:34,548 --> 00:23:36,917
Also, by integrating adding to the library

415
00:23:36,950 --> 00:23:39,586
along with the newly introduced
library requests,

416
00:23:39,620 --> 00:23:42,322
your app can immediately benefit
from these results,

417
00:23:42,356 --> 00:23:46,026
giving users easy access
to content they love.

418
00:23:46,059 --> 00:23:47,928
Even with this powerful service,

419
00:23:47,961 --> 00:23:51,331
you may still want to craft
specific musical experiences.

420
00:23:51,365 --> 00:23:56,236
So this year, we're bringing
playlist creation and editing to MusicKit.

421
00:23:56,270 --> 00:23:59,806
You can now create playlists
on behalf of your users.

422
00:23:59,840 --> 00:24:03,277
We're also allowing items,
such as songs or even whole albums,

423
00:24:03,310 --> 00:24:07,447
to be added to any eligible playlist
in the user's library.

424
00:24:07,481 --> 00:24:11,151
Creating playlists are fantastic
for grouping content that people love

425
00:24:11,185 --> 00:24:14,188
or fitting any mood your app wants to set.

426
00:24:14,221 --> 00:24:16,557
And by adding content
to existing playlists,

427
00:24:16,590 --> 00:24:19,860
you allow for the various
music discovery tools MusicKit offers

428
00:24:19,893 --> 00:24:22,629
to directly affect people.

429
00:24:22,663 --> 00:24:24,898
You can now also edit playlists
that you've created,

430
00:24:24,932 --> 00:24:28,402
being able to edit the track list
and metadata to make sure

431
00:24:28,435 --> 00:24:30,504
everything is just as you want it.

432
00:24:30,537 --> 00:24:33,507
And those are the ways you can
interact with users' libraries

433
00:24:33,540 --> 00:24:35,776
from within your app.

434
00:24:35,809 --> 00:24:39,713
To wrap up, MusicKit received
some major upgrades this year.

435
00:24:39,746 --> 00:24:43,750
Easily incorporate our catalog
enhancements for new types, properties,

436
00:24:43,784 --> 00:24:47,988
and search augmentations to your existing
apps for an even better experience.

437
00:24:49,256 --> 00:24:51,458
Integrate library content
and functionality

438
00:24:51,491 --> 00:24:53,260
to unlock brand-new capabilities

439
00:24:53,293 --> 00:24:55,596
and let users be in control
of their experience.

440
00:24:57,130 --> 00:25:00,367
And using MusicKit can enhance
multiple different types of apps.

441
00:25:00,400 --> 00:25:03,637
Fitness apps, games,
social media apps, mapping apps,

442
00:25:03,670 --> 00:25:07,975
and more can all benefit
from playing or sharing music.

443
00:25:08,008 --> 00:25:12,012
To go even further, make sure
to check out some related sessions.

444
00:25:12,045 --> 00:25:14,681
Dive deeper into Swift
and learn about the new additions

445
00:25:14,715 --> 00:25:19,620
to the language to get the most out of
MusicKit and other Apple Frameworks.

446
00:25:19,653 --> 00:25:23,257
Check out the MusicKit session from 2021
to learn how to set up your app

447
00:25:23,290 --> 00:25:28,662
to use the framework, initiate playback,
and present subscription offers.

448
00:25:28,695 --> 00:25:32,432
And if you're interested in integrating
with Apple Music on Android or the web,

449
00:25:32,466 --> 00:25:36,370
we have another session that goes over
how to use Apple Music API directly.

450
00:25:37,538 --> 00:25:40,207
I hope you enjoyed our session,
and make sure to stay updated

451
00:25:40,240 --> 00:25:42,442
and engaged through our developer forums.

452
00:25:42,476 --> 00:25:46,847
Thank you for watching,
and enjoy WWDC 2022.

