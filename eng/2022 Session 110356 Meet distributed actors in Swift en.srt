1
00:00:00,000 --> 00:00:03,003
♪ instrumental hip hop music ♪

2
00:00:03,003 --> 00:00:09,843
♪

3
00:00:09,843 --> 00:00:11,478
Hello! My name is Konrad

4
00:00:11,478 --> 00:00:13,080
and I'm an engineer
on the Swift team.

5
00:00:13,080 --> 00:00:15,482
Welcome to "Meet distributed
actors in Swift."

6
00:00:15,482 --> 00:00:17,317
In this session,
we'll learn how you can take

7
00:00:17,317 --> 00:00:21,588
your Swift concurrency-based
apps beyond a single process.

8
00:00:21,588 --> 00:00:23,624
Swift actors were designed
to protect you

9
00:00:23,624 --> 00:00:26,360
from low-level data races
in the same process.

10
00:00:26,360 --> 00:00:30,864
They do this by compile time
enforced actor isolation checks.

11
00:00:30,864 --> 00:00:33,934
Distributed actors refine
the same conceptual actor model

12
00:00:33,934 --> 00:00:36,036
and extend it
to multiple processes,

13
00:00:36,036 --> 00:00:39,506
such as multiple devices
or servers in a cluster.

14
00:00:39,506 --> 00:00:42,509
So just in case you are not yet
familiar with Swift actors,

15
00:00:42,509 --> 00:00:43,877
we recommend you first watch

16
00:00:43,877 --> 00:00:46,446
the "Protect mutable state
with Swift actors" session

17
00:00:46,446 --> 00:00:49,716
from WWDC 2021.

18
00:00:49,716 --> 00:00:51,351
The app we'll work on
during this session

19
00:00:51,351 --> 00:00:54,688
is a tic-tac-toe-style game
I've been developing recently:

20
00:00:54,688 --> 00:00:56,790
Tic Tac Fish!

21
00:00:56,790 --> 00:00:59,026
The fun idea here
is that you can select

22
00:00:59,026 --> 00:01:01,995
a team you're playing for,
which then corresponds to emojis

23
00:01:01,995 --> 00:01:05,132
that will be used to mark
your moves as you play the game.

24
00:01:05,132 --> 00:01:07,935
Then, as you mark
your moves on the field,

25
00:01:07,935 --> 00:01:10,637
emojis from your team
will be placed on the field

26
00:01:10,637 --> 00:01:12,639
until one of the players wins.

27
00:01:12,639 --> 00:01:15,676
Right now, I have only
implemented an offline mode,

28
00:01:15,676 --> 00:01:18,445
where I can play against
a bot opponent,

29
00:01:18,445 --> 00:01:21,014
but I'd like to introduce
a few multiplayer modes

30
00:01:21,014 --> 00:01:23,450
to take my app
to the next level.

31
00:01:23,450 --> 00:01:26,253
I'm already using actors in
this app to manage concurrency

32
00:01:26,253 --> 00:01:28,655
and model players
involved in the game.

33
00:01:28,655 --> 00:01:31,458
Let's see what it takes
to migrate those player actors

34
00:01:31,458 --> 00:01:34,461
to different processes,
and how distributed actors

35
00:01:34,461 --> 00:01:37,030
can help me do this.

36
00:01:37,030 --> 00:01:40,300
Before we jump to the code,
let us take a step back

37
00:01:40,300 --> 00:01:42,836
and visualize why actors
are so well-suited

38
00:01:42,836 --> 00:01:46,740
for building concurrent
and distributed applications.

39
00:01:46,740 --> 00:01:49,910
Throughout WWDC sessions,
you may hear us use the term

40
00:01:49,910 --> 00:01:52,913
"sea of concurrency"
when talking about actors.

41
00:01:52,913 --> 00:01:54,915
This is because
it's a great mental model

42
00:01:54,915 --> 00:01:56,717
to think about them.

43
00:01:56,717 --> 00:02:00,187
Each actor is its own island
in the sea of concurrency,

44
00:02:00,187 --> 00:02:02,823
and instead of accessing
each other's islands directly,

45
00:02:02,823 --> 00:02:05,525
they exchange messages
between them.

46
00:02:05,525 --> 00:02:08,295
In Swift, sending those
messages across islands

47
00:02:08,295 --> 00:02:12,165
is implemented as asynchronous
method calls and async/await.

48
00:02:12,165 --> 00:02:16,169
This, in combination
with actor state isolation,

49
00:02:16,169 --> 00:02:18,071
allows the compiler to guarantee

50
00:02:18,071 --> 00:02:20,540
that once an actor-based
program compiles,

51
00:02:20,540 --> 00:02:23,643
it is free from low-level
data races.

52
00:02:23,643 --> 00:02:26,613
Now let us now take
this same conceptual model

53
00:02:26,613 --> 00:02:28,248
and apply it to our game,

54
00:02:28,248 --> 00:02:30,884
reimagined as
a distributed system.

55
00:02:30,884 --> 00:02:33,153
We can think of each device,
node in a cluster,

56
00:02:33,153 --> 00:02:34,821
or process
of an operating system

57
00:02:34,821 --> 00:02:37,391
as if it were an independent
sea of concurrency,

58
00:02:37,391 --> 00:02:39,860
here marked as
the smaller dark rectangles.

59
00:02:39,860 --> 00:02:42,262
Within those, we were able
to synchronize information

60
00:02:42,262 --> 00:02:44,231
rather easily
since they were still

61
00:02:44,231 --> 00:02:46,400
sharing the same memory space.

62
00:02:46,400 --> 00:02:48,602
And while the same concept
of message passing

63
00:02:48,602 --> 00:02:50,504
works perfectly well
for concurrency

64
00:02:50,504 --> 00:02:52,005
as well as distribution,

65
00:02:52,005 --> 00:02:53,673
there are a few more
restrictions

66
00:02:53,673 --> 00:02:57,577
distribution needs to put
into place for it all to work.

67
00:02:57,577 --> 00:03:00,580
This is where distributed actors
come into the picture.

68
00:03:00,580 --> 00:03:03,717
By using distributed actors,
we're able to establish

69
00:03:03,717 --> 00:03:07,921
a channel between two processes
and send messages between them.

70
00:03:07,921 --> 00:03:11,291
In other words,
if Swift actors were islands

71
00:03:11,291 --> 00:03:15,062
in the sea of concurrency,
distributed actors are the same

72
00:03:15,062 --> 00:03:17,998
in the vast sea
of distributed systems.

73
00:03:17,998 --> 00:03:21,535
From a programming model,
not much has really changed --

74
00:03:21,535 --> 00:03:23,670
actors still isolate their state

75
00:03:23,670 --> 00:03:27,507
and still can only communicate
using asynchronous messages.

76
00:03:27,507 --> 00:03:29,476
We could even have
more distributed actors

77
00:03:29,476 --> 00:03:31,144
in the same process,

78
00:03:31,144 --> 00:03:33,313
and for all intents
and purposes,

79
00:03:33,313 --> 00:03:35,449
they are as useful
as local actors,

80
00:03:35,449 --> 00:03:37,217
with the difference
that they're also ready

81
00:03:37,217 --> 00:03:41,455
to participate in remote
interactions whenever necessary.

82
00:03:41,455 --> 00:03:44,724
This ability to be potentially
remote without having to change

83
00:03:44,724 --> 00:03:47,260
how we interact
with such distributed actor

84
00:03:47,260 --> 00:03:51,198
is called
"location transparency."

85
00:03:51,198 --> 00:03:52,899
This means that regardless

86
00:03:52,899 --> 00:03:55,168
where a distributed actor
is located,

87
00:03:55,168 --> 00:03:57,471
we can interact
with it the same way.

88
00:03:57,471 --> 00:03:59,339
This is not only
fantastic for testing,

89
00:03:59,339 --> 00:04:02,909
as we execute
the same logic in local actors,

90
00:04:02,909 --> 00:04:05,879
but also enables us
to transparently move our actors

91
00:04:05,879 --> 00:04:07,981
to wherever they
should be located,

92
00:04:07,981 --> 00:04:10,517
without having to change
their implementation.

93
00:04:10,517 --> 00:04:12,619
OK, I think we're ready
to look at some code

94
00:04:12,619 --> 00:04:15,922
and convert our first actor
to a distributed actor.

95
00:04:15,922 --> 00:04:19,192
First, let's have a quick look
at the general game UI,

96
00:04:19,192 --> 00:04:21,361
and how it interacts
with my player actors.

97
00:04:21,361 --> 00:04:24,231
The view is a pretty standard
SwiftUI code,

98
00:04:24,231 --> 00:04:26,833
and I have a few
text and button elements

99
00:04:26,833 --> 00:04:28,668
representing the game field.

100
00:04:28,668 --> 00:04:30,504
As a user clicks a GameCell,

101
00:04:30,504 --> 00:04:32,973
we ask the player actor
to generate a move

102
00:04:32,973 --> 00:04:36,209
and update the view models
that power the UI.

103
00:04:36,209 --> 00:04:37,644
Thanks to Swift concurrency,

104
00:04:37,644 --> 00:04:40,747
all those updates are
thread-safe and well-behaved.

105
00:04:40,747 --> 00:04:43,350
Currently, the actor
representing user input

106
00:04:43,350 --> 00:04:45,819
is implemented
as an offline player.

107
00:04:45,819 --> 00:04:47,587
Let's have a look at it next.

108
00:04:47,587 --> 00:04:50,090
This actor encapsulates
some state that allows it

109
00:04:50,090 --> 00:04:52,025
to generate game moves.

110
00:04:52,025 --> 00:04:55,729
Specifically, it needs to track
how many moves it already made

111
00:04:55,729 --> 00:04:58,064
and what team it is playing for.

112
00:04:58,064 --> 00:04:59,766
Because each team
has a number of emojis

113
00:04:59,766 --> 00:05:02,802
to chose from for each move,
use the number of moves made

114
00:05:02,802 --> 00:05:05,405
to select
the emoji character ID.

115
00:05:05,405 --> 00:05:09,109
I also need to update the model
once a move has been created.

116
00:05:09,109 --> 00:05:11,578
The model is
a MainActor isolated class,

117
00:05:11,578 --> 00:05:13,613
so mutations of it
are thread-safe.

118
00:05:13,613 --> 00:05:15,182
I do need to use "await"

119
00:05:15,182 --> 00:05:17,817
as I make
the userMadeMove call, though.

120
00:05:17,817 --> 00:05:20,654
Lastly, the offline player
also declares a method that is

121
00:05:20,654 --> 00:05:24,257
going to be called whenever
the opponent has made a move.

122
00:05:24,257 --> 00:05:27,327
The only thing we need to do
here is update the view model,

123
00:05:27,327 --> 00:05:29,596
which will make
the game field active again

124
00:05:29,596 --> 00:05:31,932
so the human player
can select their move,

125
00:05:31,932 --> 00:05:34,768
and the cycle continues
until the game ends.

126
00:05:34,768 --> 00:05:37,437
Our bot player is also
represented using an actor.

127
00:05:37,437 --> 00:05:39,606
Its implementation
is actually quite a bit simpler

128
00:05:39,606 --> 00:05:41,007
than the offline player

129
00:05:41,007 --> 00:05:44,077
since it does not have to worry
about updating the view model;

130
00:05:44,077 --> 00:05:46,012
it just keeps track
of the GameState

131
00:05:46,012 --> 00:05:47,681
and generates game moves.

132
00:05:47,681 --> 00:05:49,749
Since the bot player
is a bit simpler,

133
00:05:49,749 --> 00:05:51,751
I think it's a good one
to start our conversion

134
00:05:51,751 --> 00:05:53,887
to distributed actors.

135
00:05:53,887 --> 00:05:55,789
OK, I think we're ready
to look at some code

136
00:05:55,789 --> 00:05:59,092
and convert our first actor
to a distributed actor.

137
00:05:59,092 --> 00:06:01,761
The first step towards our
distributed Tic Tac Fish game

138
00:06:01,761 --> 00:06:03,897
will be to convert
the BotPlayer type

139
00:06:03,897 --> 00:06:04,998
to a distributed actor,

140
00:06:04,998 --> 00:06:07,200
while still only
using it locally.

141
00:06:07,200 --> 00:06:10,036
Let's open Xcode
and see how we can do that.

142
00:06:10,036 --> 00:06:12,539
In order to declare
a distributed actor,

143
00:06:12,539 --> 00:06:14,908
I'll need to import
the new distributed module,

144
00:06:14,908 --> 00:06:17,277
which we introduced
in Swift 5.7.

145
00:06:17,277 --> 00:06:19,479
This module contains
all the necessary types

146
00:06:19,479 --> 00:06:23,283
I'm going to need to declare
and use distributed actors.

147
00:06:23,283 --> 00:06:25,318
I can now add
the distributed keyword

148
00:06:25,318 --> 00:06:28,989
in front of the BotPlayer actor
declaration, like this.

149
00:06:28,989 --> 00:06:31,424
This will cause the actor
to automatically conform

150
00:06:31,424 --> 00:06:33,093
to the DistributedActor
protocol,

151
00:06:33,093 --> 00:06:36,029
and enable a number of
additional compile time checks.

152
00:06:36,029 --> 00:06:37,230
Let's see what kind of errors

153
00:06:37,230 --> 00:06:39,466
the compiler will ask us
to fix now.

154
00:06:39,466 --> 00:06:42,369
The compiler helpfully tells us
that the BotPlayer does not

155
00:06:42,369 --> 00:06:44,738
declare an ActorSystem
it can be used with.

156
00:06:44,738 --> 00:06:45,872
As distributed actors

157
00:06:45,872 --> 00:06:48,441
always belong to some
distributed actor system,

158
00:06:48,441 --> 00:06:50,510
which handles all
the serialization and networking

159
00:06:50,510 --> 00:06:52,579
necessary to perform
remote calls;

160
00:06:52,579 --> 00:06:55,215
we need to declare
what type of actor system

161
00:06:55,215 --> 00:06:57,784
this actor is intended
to be used with.

162
00:06:57,784 --> 00:07:00,720
Since, for now, my only goal
is to have the bot player

163
00:07:00,720 --> 00:07:03,056
pass all the distributed
isolation checks,

164
00:07:03,056 --> 00:07:06,393
without actually running it on
a remote host, I can use the

165
00:07:06,393 --> 00:07:08,561
LocalTestingDistributedActor
System

166
00:07:08,561 --> 00:07:10,797
that comes
with the Distributed module.

167
00:07:10,797 --> 00:07:11,931
I can tell the compiler

168
00:07:11,931 --> 00:07:14,067
about the actor system
we're going to use

169
00:07:14,067 --> 00:07:15,802
by either declaring
a module-wide

170
00:07:15,802 --> 00:07:18,405
DefaultDistributedActorSystem
typealias,

171
00:07:18,405 --> 00:07:22,809
or an ActorSystem typealias in
the body of the specific actor.

172
00:07:22,809 --> 00:07:27,314
The latter bit is a bit more
specific, so let's go with that.

173
00:07:32,319 --> 00:07:34,554
The next error is about
the "id" property,

174
00:07:34,554 --> 00:07:36,456
that I had previously
implemented manually

175
00:07:36,456 --> 00:07:39,092
in order to conform
to the Identifiable protocol

176
00:07:39,092 --> 00:07:41,895
that both my player actors
need to conform to.

177
00:07:41,895 --> 00:07:44,631
The error now says
that the ID property

178
00:07:44,631 --> 00:07:47,701
cannot be defined explicitly
as it conflicts

179
00:07:47,701 --> 00:07:50,870
with a distributed actor
synthesized property.

180
00:07:50,870 --> 00:07:53,707
IDs are a crucial piece
of distributed actors.

181
00:07:53,707 --> 00:07:56,076
They are used
to uniquely identify an actor

182
00:07:56,076 --> 00:08:00,113
in the entire distributed actor
system that it is part of.

183
00:08:00,113 --> 00:08:02,649
They are assigned by
the distributed actor system

184
00:08:02,649 --> 00:08:04,050
as the actor is initialized,

185
00:08:04,050 --> 00:08:06,286
and later managed
by that system.

186
00:08:06,286 --> 00:08:08,488
As such,
we cannot declare or assign

187
00:08:08,488 --> 00:08:10,323
the ID property manually --

188
00:08:10,323 --> 00:08:12,592
the actor system
will be doing this for us.

189
00:08:12,592 --> 00:08:15,428
In other words, I can simply
leave it to the actor system

190
00:08:15,428 --> 00:08:18,998
and remove my manually
declared ID property.

191
00:08:18,998 --> 00:08:20,934
The last error
we need to deal with here

192
00:08:20,934 --> 00:08:23,670
is the distributed
actor's initializer.

193
00:08:23,670 --> 00:08:26,206
The compiler says
that the actorSystem property

194
00:08:26,206 --> 00:08:28,742
has not been
initialized before use.

195
00:08:28,742 --> 00:08:31,077
This is another compiler
synthesized property

196
00:08:31,077 --> 00:08:33,413
that is part
of every distributed actor.

197
00:08:33,413 --> 00:08:36,282
Not only do we need to declare
the type of actor system

198
00:08:36,282 --> 00:08:38,718
we want to use,
but we also need to initialize

199
00:08:38,718 --> 00:08:40,887
the synthesized
actorSystem property

200
00:08:40,887 --> 00:08:43,156
with some concrete actor system.

201
00:08:43,156 --> 00:08:45,024
Generally,
the right thing to do here

202
00:08:45,024 --> 00:08:47,360
is to accept an actor system
in the initializer,

203
00:08:47,360 --> 00:08:49,462
and pass it through
to the property.

204
00:08:49,462 --> 00:08:52,198
This way, I could pass in
a different actor system

205
00:08:52,198 --> 00:08:56,469
implementation in my tests
to facilitate easy unit testing.

206
00:08:56,469 --> 00:08:59,205
We'll also have to pass
an instance whenever we create

207
00:08:59,205 --> 00:09:03,109
a new bot player,
so let's do this now.

208
00:09:11,117 --> 00:09:14,387
Awesome! We're done with
all the declaration side errors.

209
00:09:14,387 --> 00:09:15,889
But there's still
some call-site errors

210
00:09:15,889 --> 00:09:18,858
we need to address though.

211
00:09:18,858 --> 00:09:20,693
It seems that
only distributed methods

212
00:09:20,693 --> 00:09:23,963
can be called on potentially
remote distributed actors.

213
00:09:23,963 --> 00:09:27,434
This is similar to annotating
only some actors in your system

214
00:09:27,434 --> 00:09:29,402
as distributed actors.

215
00:09:29,402 --> 00:09:31,337
Not every method
on a distributed actor

216
00:09:31,337 --> 00:09:34,307
is necessarily designed
to be called remotely.

217
00:09:34,307 --> 00:09:36,342
They can have
small helper functions,

218
00:09:36,342 --> 00:09:38,244
or functions
which assume the caller

219
00:09:38,244 --> 00:09:40,380
has already been authenticated.

220
00:09:40,380 --> 00:09:43,116
This is why Swift asks you
to be explicit about

221
00:09:43,116 --> 00:09:45,251
the distributed API surface,

222
00:09:45,251 --> 00:09:47,720
you want to expose
to remote callers.

223
00:09:47,720 --> 00:09:50,457
Thankfully, this is also
easily fixed by just adding

224
00:09:50,457 --> 00:09:53,393
the distributed keyword
to those functions.

225
00:09:53,393 --> 00:09:55,895
As both makeMove
and opponentMoved methods

226
00:09:55,895 --> 00:09:57,831
are intended
to be called remotely,

227
00:09:57,831 --> 00:10:01,935
let me add the distributed
keyword to them to both of them.

228
00:10:06,439 --> 00:10:09,375
OK! With that,
there's only one last thing

229
00:10:09,375 --> 00:10:11,311
we need to take care of.

230
00:10:11,311 --> 00:10:14,214
As distributed method calls
can cross network boundaries,

231
00:10:14,214 --> 00:10:16,583
we need to ensure
that all of their parameters

232
00:10:16,583 --> 00:10:19,352
and return values conform
to the serialization requirement

233
00:10:19,352 --> 00:10:21,321
of the actor system.

234
00:10:21,321 --> 00:10:24,123
In our case, the actor system
is using Codable,

235
00:10:24,123 --> 00:10:26,459
Swift's native
serialization mechanism.

236
00:10:26,459 --> 00:10:28,995
Specifically, the compiler
tells us that,

237
00:10:28,995 --> 00:10:31,664
"Result type GameMove
does not conform

238
00:10:31,664 --> 00:10:34,634
to the serialization
requirement Codable."

239
00:10:34,634 --> 00:10:37,737
Let me have a quick look
at the GameMove type.

240
00:10:37,737 --> 00:10:40,640
Luckily, it seems that
it's a clean little data type

241
00:10:40,640 --> 00:10:42,375
that I can easily make Codable

242
00:10:42,375 --> 00:10:44,944
by just adding
the necessary conformance.

243
00:10:44,944 --> 00:10:46,546
The Swift compiler
will synthesize

244
00:10:46,546 --> 00:10:49,115
the necessary Codable
implementation for me.

245
00:10:49,115 --> 00:10:50,450
And with that, we're done!

246
00:10:50,450 --> 00:10:53,486
I can check
the game runs as expected.

247
00:10:55,488 --> 00:10:57,690
OK, a point for team fish!

248
00:10:57,690 --> 00:10:59,792
And although
the bot player still executing

249
00:10:59,792 --> 00:11:02,529
on the same local device,
we have already paved the way

250
00:11:02,529 --> 00:11:04,864
for the exciting next step.

251
00:11:04,864 --> 00:11:06,566
In this step, we'll actually
reap the benefits

252
00:11:06,566 --> 00:11:10,770
of the bot player's newly gained
location transparency powers.

253
00:11:10,770 --> 00:11:12,639
I have already prepared
a WebSocket-based

254
00:11:12,639 --> 00:11:15,608
sample actor system
that we can use for this.

255
00:11:15,608 --> 00:11:17,343
By making use
of this actor system,

256
00:11:17,343 --> 00:11:18,945
we'll be able
to move our bot player

257
00:11:18,945 --> 00:11:20,880
to a server-side
Swift application,

258
00:11:20,880 --> 00:11:24,350
and resolve a remote reference
to it from our mobile game.

259
00:11:24,350 --> 00:11:26,185
As far as the actor
is concerned,

260
00:11:26,185 --> 00:11:28,988
we only need to change
the declared ActorSystem

261
00:11:28,988 --> 00:11:31,658
from the LocalTesting
DistributedActor System

262
00:11:31,658 --> 00:11:34,928
to the
SampleWebSocketActorSystem

263
00:11:34,928 --> 00:11:37,230
that I prepared
for the sample app.

264
00:11:37,230 --> 00:11:40,366
The rest of the actor code
remains the same.

265
00:11:40,366 --> 00:11:43,570
Next, let us resolve
a remote bot player reference,

266
00:11:43,570 --> 00:11:45,672
rather than
creating one locally.

267
00:11:45,672 --> 00:11:49,442
It is worth keeping in mind that
the terms "local" and "remote"

268
00:11:49,442 --> 00:11:52,645
are a matter of perspective when
it comes to distributed actors.

269
00:11:52,645 --> 00:11:55,748
For every remote reference,
there is some corresponding

270
00:11:55,748 --> 00:11:57,784
local instance
on some other node

271
00:11:57,784 --> 00:11:59,485
in the distributed actor system.

272
00:11:59,485 --> 00:12:01,888
Creating a local instance
of a distributed actor

273
00:12:01,888 --> 00:12:05,091
is performed much the same way
as any other Swift object:

274
00:12:05,091 --> 00:12:06,726
by calling its initializer.

275
00:12:06,726 --> 00:12:10,029
Obtaining a remote reference
to a distributed actor, however,

276
00:12:10,029 --> 00:12:12,565
follows a slightly
different pattern.

277
00:12:12,565 --> 00:12:14,400
Instead of creating an actor,

278
00:12:14,400 --> 00:12:17,036
we will attempt to resolve
an actor ID

279
00:12:17,036 --> 00:12:19,072
using a concrete actor system.

280
00:12:19,072 --> 00:12:22,609
The static resolve method allows
us to ask an actor system

281
00:12:22,609 --> 00:12:25,111
to attempt to give us
an existing actor instance

282
00:12:25,111 --> 00:12:27,113
for an actor with that ID

283
00:12:27,113 --> 00:12:31,017
or, return a remote reference
to an actor identified by it.

284
00:12:31,017 --> 00:12:33,519
Actor systems should not
perform actual remote lookups

285
00:12:33,519 --> 00:12:36,389
when resolving identifiers
because as you can see,

286
00:12:36,389 --> 00:12:38,958
the resolve method
is not asynchronous,

287
00:12:38,958 --> 00:12:40,793
and therefore
should return quickly

288
00:12:40,793 --> 00:12:42,328
and not perform any networking

289
00:12:42,328 --> 00:12:44,263
or otherwise
blocking operations.

290
00:12:44,263 --> 00:12:47,033
If an identity looks valid,
and seems to be pointing

291
00:12:47,033 --> 00:12:50,036
at a valid remote location,
systems shall assume

292
00:12:50,036 --> 00:12:53,973
that such actor exists and
return a remote reference to it.

293
00:12:53,973 --> 00:12:57,343
Keep in mind that
at the time of resolving an ID,

294
00:12:57,343 --> 00:13:00,079
the actual instance
on the remote system

295
00:13:00,079 --> 00:13:01,948
may not even exist yet!

296
00:13:01,948 --> 00:13:04,517
For example, here we're
making up a random identifier

297
00:13:04,517 --> 00:13:05,985
for an opponent bot player

298
00:13:05,985 --> 00:13:08,821
that should be dedicated
to playing a game with us.

299
00:13:08,821 --> 00:13:11,124
This bot does not exist yet,
but it will be created

300
00:13:11,124 --> 00:13:13,426
on the server-side system
as the first message

301
00:13:13,426 --> 00:13:16,062
designated to this ID
is received.

302
00:13:16,062 --> 00:13:19,198
Now moving on to
a server-side Swift application.

303
00:13:19,198 --> 00:13:22,001
Thanks to the sample WebSocket
actor system I prepared,

304
00:13:22,001 --> 00:13:24,704
implementing that
will be a breeze.

305
00:13:24,704 --> 00:13:28,608
First, we create the WebSocket
actor system in server mode,

306
00:13:28,608 --> 00:13:30,309
which makes it bind
and listen to the port

307
00:13:30,309 --> 00:13:32,912
rather than connect to it.

308
00:13:32,912 --> 00:13:36,716
And we have the app wait
until the system is terminated.

309
00:13:36,716 --> 00:13:38,985
Next, we'll somehow need
to handle the pattern

310
00:13:38,985 --> 00:13:40,520
of creating actors on demand

311
00:13:40,520 --> 00:13:43,322
as we receive messages
addressed to IDs

312
00:13:43,322 --> 00:13:46,759
that are not yet assigned
any actor instances.

313
00:13:46,759 --> 00:13:49,696
Generally, the actor system
will receive incoming messages,

314
00:13:49,696 --> 00:13:52,432
attempt to resolve
their recipient IDs

315
00:13:52,432 --> 00:13:55,268
in order locate a local
distributed actor instance,

316
00:13:55,268 --> 00:13:59,672
and then execute a remote call
on the located actor.

317
00:13:59,672 --> 00:14:01,107
As we just discussed though,

318
00:14:01,107 --> 00:14:03,943
our bot player IDs
are literally made up,

319
00:14:03,943 --> 00:14:07,647
so the system can't possibly
know about them

320
00:14:07,647 --> 00:14:11,684
and even less so create the
right type of actor by itself.

321
00:14:11,684 --> 00:14:14,253
Thankfully, our sample actor
system implementation

322
00:14:14,253 --> 00:14:16,756
has just the right pattern
prepared for us:

323
00:14:16,756 --> 00:14:18,725
on-demand actor creation.

324
00:14:18,725 --> 00:14:21,160
Please note here
that this is only a pattern,

325
00:14:21,160 --> 00:14:22,995
and not something built in
or provided by

326
00:14:22,995 --> 00:14:25,098
the distributed actor module.

327
00:14:25,098 --> 00:14:27,366
It is, however,
a great example of how flexible

328
00:14:27,366 --> 00:14:30,737
and powerful actor system
implementations can be.

329
00:14:30,737 --> 00:14:32,939
A system can offer
various patterns

330
00:14:32,939 --> 00:14:36,209
and make complex tasks
simple to deal with.

331
00:14:36,209 --> 00:14:38,978
Using this pattern,
the actor system attempts

332
00:14:38,978 --> 00:14:42,815
to resolve a local actor
for all incoming IDs as usual.

333
00:14:42,815 --> 00:14:45,585
However, when it fails
to find an existing actor,

334
00:14:45,585 --> 00:14:47,920
it attempts to
resolveCreateOnDemand.

335
00:14:47,920 --> 00:14:50,089
Since we are in control
of both our client code

336
00:14:50,089 --> 00:14:53,059
making up the IDs
and the piece of server code,

337
00:14:53,059 --> 00:14:55,061
we can help
the actor system out

338
00:14:55,061 --> 00:14:58,064
by creating
the necessary actors on demand.

339
00:14:58,064 --> 00:15:00,933
Since the bot identifiers
we have been making up

340
00:15:00,933 --> 00:15:04,103
on the client are using some
recognizable naming scheme --

341
00:15:04,103 --> 00:15:06,906
like adding tags
to the ActorIdentity

342
00:15:06,906 --> 00:15:09,542
or just using
some recognizable names --

343
00:15:09,542 --> 00:15:12,211
we can detect those IDs
and create a new bot opponent

344
00:15:12,211 --> 00:15:15,681
for every message that does not
have one active yet.

345
00:15:15,681 --> 00:15:17,583
We'll only create
a new bot player

346
00:15:17,583 --> 00:15:19,685
for the first message
designated to it,

347
00:15:19,685 --> 00:15:21,154
as subsequent remote calls

348
00:15:21,154 --> 00:15:24,157
will simply resolve
the existing instance.

349
00:15:24,157 --> 00:15:25,992
And that's all there is to it!

350
00:15:25,992 --> 00:15:27,693
Our server implementation
is complete

351
00:15:27,693 --> 00:15:30,963
and we can now play a game
with our remote bot player.

352
00:15:30,963 --> 00:15:34,467
We can run the server from the
command line using Swift run,

353
00:15:34,467 --> 00:15:37,403
or using Xcode
and selecting the server scheme

354
00:15:37,403 --> 00:15:39,472
and clicking Run as usual.

355
00:15:39,472 --> 00:15:41,207
As we're done
making our first move,

356
00:15:41,207 --> 00:15:44,343
we ask the bot player to do
the same by calling makeMove

357
00:15:44,343 --> 00:15:46,846
on the remote player reference
we have created.

358
00:15:46,846 --> 00:15:49,615
This triggers a resolve
in the server-side system.

359
00:15:49,615 --> 00:15:52,285
It can't find an existing bot
for this ID,

360
00:15:52,285 --> 00:15:55,788
so it attempts and succeeds,
creating a bot on demand.

361
00:15:55,788 --> 00:15:58,291
The bot receives
a makeMove call,

362
00:15:58,291 --> 00:16:01,327
and replies with the GameMove
it generated.

363
00:16:01,327 --> 00:16:03,162
That was pretty great already!

364
00:16:03,162 --> 00:16:05,064
While we did have to do
some up-front work

365
00:16:05,064 --> 00:16:07,567
to convert our bot player
to a distributed actor,

366
00:16:07,567 --> 00:16:09,368
actually moving it
to the remote system

367
00:16:09,368 --> 00:16:11,370
was pretty straightforward.

368
00:16:11,370 --> 00:16:13,172
And we didn't have
to deal with any networking

369
00:16:13,172 --> 00:16:16,576
or serialization implementation
details at all!

370
00:16:16,576 --> 00:16:18,077
All the heavy lifting
was done for us

371
00:16:18,077 --> 00:16:19,846
by the distributed actor system.

372
00:16:19,846 --> 00:16:21,414
And while there aren't
many hardened

373
00:16:21,414 --> 00:16:24,050
feature-complete implementations
available just yet,

374
00:16:24,050 --> 00:16:25,818
this ease of going distributed

375
00:16:25,818 --> 00:16:28,287
is something we're striving
for with this feature.

376
00:16:28,287 --> 00:16:29,755
Next,
let's see how we can build

377
00:16:29,755 --> 00:16:32,725
a true multiplayer experience
for our game.

378
00:16:32,725 --> 00:16:34,961
Our previous example
used distributed actors

379
00:16:34,961 --> 00:16:37,096
in a client/server scenario,
which you may be

380
00:16:37,096 --> 00:16:39,932
familiar with already
from other apps you worked on.

381
00:16:39,932 --> 00:16:42,101
However, distributed actors
can also be used

382
00:16:42,101 --> 00:16:43,836
in peer-to-peer systems,

383
00:16:43,836 --> 00:16:46,772
where there isn't a dedicated
server component at all.

384
00:16:46,772 --> 00:16:48,774
This matches another idea
I had for our game.

385
00:16:48,774 --> 00:16:51,010
Sometimes when traveling,
you end up in these locations

386
00:16:51,010 --> 00:16:53,179
that don't really have
great internet,

387
00:16:53,179 --> 00:16:55,581
but the local Wi-Fi works great.

388
00:16:55,581 --> 00:16:57,216
I'd like to still
be able to challenge

389
00:16:57,216 --> 00:16:58,251
and play with my friends --

390
00:16:58,251 --> 00:16:59,952
which are connected
to the same network --

391
00:16:59,952 --> 00:17:02,321
as I end up in such a situation.

392
00:17:02,321 --> 00:17:03,756
I went ahead and implemented

393
00:17:03,756 --> 00:17:06,058
another actor system
implementation,

394
00:17:06,058 --> 00:17:07,693
this time using
local networking features

395
00:17:07,693 --> 00:17:10,029
offered by Network framework.

396
00:17:10,029 --> 00:17:11,864
While we don't dive into
the implementation

397
00:17:11,864 --> 00:17:14,367
of that actor system
in this talk, you can watch

398
00:17:14,367 --> 00:17:18,571
"Advances in Networking, Part 2"
from WWDC 2019

399
00:17:18,571 --> 00:17:21,440
to learn how you would implement
such custom protocol.

400
00:17:21,440 --> 00:17:24,310
It is also worth pointing out
that access to local network

401
00:17:24,310 --> 00:17:26,946
can expose very
privacy-sensitive information,

402
00:17:26,946 --> 00:17:29,548
so please take care
to use it respectfully.

403
00:17:29,548 --> 00:17:31,083
Since this time
we'll be dealing with

404
00:17:31,083 --> 00:17:33,920
already existing distributed
actors on other devices,

405
00:17:33,920 --> 00:17:36,122
we can no longer
just make up the IDs

406
00:17:36,122 --> 00:17:38,424
like we did in the previous
example.

407
00:17:38,424 --> 00:17:40,226
We have to discover
the specific actor

408
00:17:40,226 --> 00:17:42,962
on the other device
we'd like to play a game with.

409
00:17:42,962 --> 00:17:45,331
This problem isn't unique
to distributed actors,

410
00:17:45,331 --> 00:17:48,467
and is generally solved using
service discovery mechanisms.

411
00:17:48,467 --> 00:17:50,970
However, in the domain
of distributed actors,

412
00:17:50,970 --> 00:17:53,272
there is a common pattern
and style of API

413
00:17:53,272 --> 00:17:55,775
actor systems are expected
to offer that allows you

414
00:17:55,775 --> 00:17:59,278
to stick to strongly-typed APIs
throughout all your code.

415
00:17:59,278 --> 00:18:01,414
We call it
the receptionist pattern,

416
00:18:01,414 --> 00:18:04,684
because similar to a hotel,
actors need to check in with it

417
00:18:04,684 --> 00:18:08,321
in order to become known and
available for others to meet.

418
00:18:08,321 --> 00:18:10,690
Every actor system
has its own receptionist

419
00:18:10,690 --> 00:18:13,659
and they can use whatever means
most suitable for the underlying

420
00:18:13,659 --> 00:18:16,996
transport mechanisms
to implement actor discovery.

421
00:18:16,996 --> 00:18:20,533
Sometimes this may rely on
existing service discovery APIs,

422
00:18:20,533 --> 00:18:23,703
and only layer a type-safe API
on top of them,

423
00:18:23,703 --> 00:18:26,405
or it may implement
a gossip-based mechanism,

424
00:18:26,405 --> 00:18:28,240
or something else entirely.

425
00:18:28,240 --> 00:18:30,209
This, however,
is an implementation detail

426
00:18:30,209 --> 00:18:33,145
from the perspective
of the user of the actor system;

427
00:18:33,145 --> 00:18:35,815
all we need to care about
is checking in our actor

428
00:18:35,815 --> 00:18:37,350
to make it discoverable

429
00:18:37,350 --> 00:18:39,352
and look up actors
by some tag or type

430
00:18:39,352 --> 00:18:41,487
when we need to discover them.

431
00:18:41,487 --> 00:18:44,290
Let's have a look at a simple
receptionist I have implemented

432
00:18:44,290 --> 00:18:46,926
for our
SampleLocalNetworkActorSystem.

433
00:18:46,926 --> 00:18:50,863
It allows an actor to check in,
which enables all receptionists

434
00:18:50,863 --> 00:18:53,499
in the distributed actor system
to discover it.

435
00:18:53,499 --> 00:18:57,403
We can then get a listing
of all actors of a specific type

436
00:18:57,403 --> 00:19:00,806
and tag as they become
available in that system.

437
00:19:00,806 --> 00:19:03,009
Let's use this receptionist
to discover

438
00:19:03,009 --> 00:19:06,679
a concrete opponent actor
we'd like to play a game with.

439
00:19:06,679 --> 00:19:09,448
Previously, our GameView
directly created --

440
00:19:09,448 --> 00:19:12,852
or resolved -- an opponent
in its view initializer.

441
00:19:12,852 --> 00:19:15,354
We can no longer do this,
as we need to asynchronously

442
00:19:15,354 --> 00:19:18,157
wait for an opponent
to appear on the network.

443
00:19:18,157 --> 00:19:21,460
To do this, let me introduce
a matchmaking view

444
00:19:21,460 --> 00:19:23,596
that will show a "Looking for
opponent..." message

445
00:19:23,596 --> 00:19:25,731
while we're trying
to discover one.

446
00:19:25,731 --> 00:19:28,701
As this view appears,
we'll kick off the matchmaking.

447
00:19:28,701 --> 00:19:29,835
The matchmaking will be done

448
00:19:29,835 --> 00:19:32,571
in a new unstructured task
in which we'll ask

449
00:19:32,571 --> 00:19:34,807
the local actor system's
receptionist

450
00:19:34,807 --> 00:19:36,909
for a listing
of all actors tagged

451
00:19:36,909 --> 00:19:39,545
using the opposing team's tag.

452
00:19:39,545 --> 00:19:41,580
So if we're playing
for team fish,

453
00:19:41,580 --> 00:19:44,750
we'll be looking for players
from the team rodents,

454
00:19:44,750 --> 00:19:45,785
and vice versa.

455
00:19:45,785 --> 00:19:47,953
Next,
we'll use an async for loop

456
00:19:47,953 --> 00:19:50,156
to await incoming
opponent actors.

457
00:19:50,156 --> 00:19:52,992
As the system discovers
a nearby device with an opponent

458
00:19:52,992 --> 00:19:56,128
we could play with,
this task loop will be resumed.

459
00:19:56,128 --> 00:19:58,998
Let's assume the opponent
is always ready to play a game

460
00:19:58,998 --> 00:20:00,766
and immediately store it
in our model

461
00:20:00,766 --> 00:20:02,435
and start a game with them.

462
00:20:02,435 --> 00:20:03,936
We use a helper function
to decide

463
00:20:03,936 --> 00:20:06,338
who should make the first move,
and finally,

464
00:20:06,338 --> 00:20:09,442
tell the opponent that we want
to start a game with them.

465
00:20:09,442 --> 00:20:11,744
Be sure to return here,
in order to break out

466
00:20:11,744 --> 00:20:14,447
of the async for loop,
as we only need one opponent

467
00:20:14,447 --> 00:20:16,615
to be done
with our matchmaking task.

468
00:20:16,615 --> 00:20:19,285
For this gameplay mode,
we do have to change

469
00:20:19,285 --> 00:20:21,720
our OfflinePlayer implementation
a little.

470
00:20:21,720 --> 00:20:24,056
Let's call it
LocalNetworkPlayer,

471
00:20:24,056 --> 00:20:27,793
and it'll be using the
SampleLocalNetworkActorSystem.

472
00:20:27,793 --> 00:20:31,330
What's most interesting about it
is that the makeMove method

473
00:20:31,330 --> 00:20:33,699
of the the actor
representing a human player

474
00:20:33,699 --> 00:20:35,701
may now be invoked remotely!

475
00:20:35,701 --> 00:20:37,470
But making the move is actually

476
00:20:37,470 --> 00:20:39,705
the responsibility
of a human player.

477
00:20:39,705 --> 00:20:41,340
In order to solve
this challenge,

478
00:20:41,340 --> 00:20:43,442
we introduce
a humanSelectedField

479
00:20:43,442 --> 00:20:46,045
asynchronous function
to our view model.

480
00:20:46,045 --> 00:20:48,380
It is powered by a @Published
value that is triggered

481
00:20:48,380 --> 00:20:51,450
when the human
user clicks on one of the
fields.

482
00:20:51,450 --> 00:20:53,219
As the human player
clicks a field,

483
00:20:53,219 --> 00:20:56,388
our makeMove function resumes,
and we complete the remote call

484
00:20:56,388 --> 00:20:59,825
by returning the performed
GameMove to the remote caller.

485
00:20:59,825 --> 00:21:01,827
And again,
that's all there is to it!

486
00:21:01,827 --> 00:21:03,429
We had to change
the actor implementation

487
00:21:03,429 --> 00:21:06,332
a little to handle our
true multiplayer game mode,

488
00:21:06,332 --> 00:21:07,533
but nothing really changed

489
00:21:07,533 --> 00:21:09,668
in the overall design
of the system.

490
00:21:09,668 --> 00:21:11,170
And most importantly,

491
00:21:11,170 --> 00:21:13,572
nothing in our game logic
changes was really specific

492
00:21:13,572 --> 00:21:16,075
to the fact we'll be using
local networking.

493
00:21:16,075 --> 00:21:18,477
We discover an opponent
and play a game with them

494
00:21:18,477 --> 00:21:21,280
by invoking distributed methods
on player actors.

495
00:21:21,280 --> 00:21:24,783
To demo this game mode, I'll
need an opponent to play with.

496
00:21:24,783 --> 00:21:27,386
Let's ask my fluffy assistant
Caplin the Capybara.

497
00:21:27,386 --> 00:21:29,588
I heard he's pretty good at it!

498
00:21:32,925 --> 00:21:35,961
OK, he's pretty smart.

499
00:21:38,731 --> 00:21:41,567
He is pretty good at it.

500
00:21:41,567 --> 00:21:44,670
Let me try here.

501
00:21:44,670 --> 00:21:46,272
Oh, he got me!

502
00:21:46,272 --> 00:21:47,806
This time you win,
little critter,

503
00:21:47,806 --> 00:21:49,942
but we'll play another session.

504
00:21:49,942 --> 00:21:52,311
Thanks for your help, Caplin!

505
00:21:52,311 --> 00:21:53,412
Last but not least,

506
00:21:53,412 --> 00:21:55,414
let me give you an idea
of what we can achieve

507
00:21:55,414 --> 00:21:57,483
by combining
different actor systems.

508
00:21:57,483 --> 00:22:00,653
For example, we can use
the WebSocket system to register

509
00:22:00,653 --> 00:22:03,055
device-hosted actor
player actors

510
00:22:03,055 --> 00:22:04,957
in a server-side lobby system

511
00:22:04,957 --> 00:22:07,126
that will pair them up
and act as a proxy

512
00:22:07,126 --> 00:22:10,262
for distributed calls
between them.

513
00:22:10,262 --> 00:22:12,398
We might implement
a GameLobby actor,

514
00:22:12,398 --> 00:22:14,466
with which device-hosted
player actors

515
00:22:14,466 --> 00:22:16,468
are able to register themselves.

516
00:22:16,468 --> 00:22:18,637
As devices enter
the play online mode,

517
00:22:18,637 --> 00:22:21,707
they would discover the
GameLobby using a receptionist,

518
00:22:21,707 --> 00:22:23,442
and call join on it.

519
00:22:23,442 --> 00:22:25,844
The GameLobby keeps track
of available players

520
00:22:25,844 --> 00:22:27,613
and starts a game session

521
00:22:27,613 --> 00:22:30,149
when a pair of players
has been identified.

522
00:22:30,149 --> 00:22:32,952
A game session would act
as the driver of the game,

523
00:22:32,952 --> 00:22:34,286
polling moves and marking them

524
00:22:34,286 --> 00:22:36,922
in the server-stored
representation of the game.

525
00:22:36,922 --> 00:22:39,091
As the game completes,
we can collect results

526
00:22:39,091 --> 00:22:40,960
and report back to the lobby.

527
00:22:40,960 --> 00:22:42,795
More interestingly though,

528
00:22:42,795 --> 00:22:45,331
we can scale
this design horizontally.

529
00:22:45,331 --> 00:22:47,233
We can of course create
more game session actors

530
00:22:47,233 --> 00:22:50,369
to serve more games
concurrently on a single server,

531
00:22:50,369 --> 00:22:51,870
but thanks
to distributed actors,

532
00:22:51,870 --> 00:22:54,373
we could even create
a game session on other nodes

533
00:22:54,373 --> 00:22:56,675
in order to load balance
the number of concurrent games

534
00:22:56,675 --> 00:22:58,344
across a cluster.

535
00:22:58,344 --> 00:23:01,614
That is, if only we had
a cluster actor system.

536
00:23:01,614 --> 00:23:03,115
And, in fact, we do!

537
00:23:03,115 --> 00:23:06,118
We open-sourced a feature-rich
Cluster Actor system library

538
00:23:06,118 --> 00:23:08,387
for you to use
in such scenarios.

539
00:23:08,387 --> 00:23:10,856
It's implemented using SwiftNIO,
and specialized

540
00:23:10,856 --> 00:23:13,592
for server-side
data-center clustering.

541
00:23:13,592 --> 00:23:16,161
It applies advanced techniques
for failure detection,

542
00:23:16,161 --> 00:23:17,997
and comes with it's own
implementation

543
00:23:17,997 --> 00:23:20,266
of a cluster-wide receptionist.

544
00:23:20,266 --> 00:23:22,167
We encourage you
to have a look at it,

545
00:23:22,167 --> 00:23:24,770
as it is both an advanced
reference implementation

546
00:23:24,770 --> 00:23:25,971
of an actor system,

547
00:23:25,971 --> 00:23:28,974
and because of its powerful
server-side applications.

548
00:23:28,974 --> 00:23:31,610
Let's recap what we learned
during this session.

549
00:23:31,610 --> 00:23:34,513
First, we learned about
distributed actors

550
00:23:34,513 --> 00:23:36,849
and how we provide additional
compiler-assisted

551
00:23:36,849 --> 00:23:39,318
actor isolation
and serialization checking.

552
00:23:39,318 --> 00:23:42,054
We learned how they enable
location transparency,

553
00:23:42,054 --> 00:23:44,490
and how we can make use of it
to free our actors

554
00:23:44,490 --> 00:23:47,226
from the necessity of being
located in the same process

555
00:23:47,226 --> 00:23:48,794
as their caller.

556
00:23:48,794 --> 00:23:51,697
We also saw a few actor system
implementations in action

557
00:23:51,697 --> 00:23:53,799
to get you inspired about
what you could build

558
00:23:53,799 --> 00:23:55,701
using distributed actors.

559
00:23:55,701 --> 00:23:58,671
Distributed actors are only
as powerful as the actor systems

560
00:23:58,671 --> 00:24:00,139
they are used with.

561
00:24:00,139 --> 00:24:01,507
So for your reference,

562
00:24:01,507 --> 00:24:04,576
here is a list of actor systems
we saw during this session.

563
00:24:04,576 --> 00:24:07,946
The local testing system, which
ships by default with Swift,

564
00:24:07,946 --> 00:24:09,982
and two sample actor systems:

565
00:24:09,982 --> 00:24:12,685
a client/server style
WebSocket-based one

566
00:24:12,685 --> 00:24:15,120
and a local
networking-based system.

567
00:24:15,120 --> 00:24:16,722
These systems are rather
incomplete,

568
00:24:16,722 --> 00:24:18,524
and served more
as an inspiration

569
00:24:18,524 --> 00:24:21,293
for what you might build
using distributed actors.

570
00:24:21,293 --> 00:24:23,195
You can view them
in the sample code app

571
00:24:23,195 --> 00:24:25,531
associated with this session.

572
00:24:25,531 --> 00:24:27,900
And last but not least,
an open source

573
00:24:27,900 --> 00:24:30,836
fully featured server-side
clustering implementation.

574
00:24:30,836 --> 00:24:32,771
Available as
a beta package now,

575
00:24:32,771 --> 00:24:35,774
and it will be matured
alongside Swift 5.7.

576
00:24:35,774 --> 00:24:37,876
To learn more about
distributed actors,

577
00:24:37,876 --> 00:24:40,012
you can refer
to the following resources:

578
00:24:40,012 --> 00:24:42,581
the sample code associated
with this session,

579
00:24:42,581 --> 00:24:45,050
which includes all the steps
of our Tic Tac Fish game

580
00:24:45,050 --> 00:24:47,319
so you can deep dive
into the code yourself.

581
00:24:47,319 --> 00:24:49,054
The Swift evolution proposals

582
00:24:49,054 --> 00:24:52,191
associated with the distributed
actors language feature,

583
00:24:52,191 --> 00:24:55,761
which explain the mechanisms
powering them in great detail.

584
00:24:55,761 --> 00:24:57,563
You can also reach out
on the Swift forums,

585
00:24:57,563 --> 00:25:00,265
where you can find
a distributed actors category

586
00:25:00,265 --> 00:25:04,403
dedicated to actor system
developers and users alike.

587
00:25:04,403 --> 00:25:06,205
Thanks for listening, and I'm
looking forward to seeing

588
00:25:06,205 --> 00:25:08,907
what you'll use distributed
actors for in your apps!

589
00:25:08,907 --> 00:25:14,913
♪

