1
00:00:00,000 --> 00:00:03,070
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,070 --> 00:00:09,943
♪

3
00:00:09,943 --> 00:00:14,047
大家好 我是 Sara Frederixon
Health App 的工程师

4
00:00:14,047 --> 00:00:18,051
我将和您讨论如何将
SwiftUI 与 UIKit 结合使用

5
00:00:18,051 --> 00:00:22,189
像您们中的许多人一样
我在已有的 UIKit App 上工作

6
00:00:22,189 --> 00:00:25,158
对我来说这就是 Health App

7
00:00:25,158 --> 00:00:27,494
Health App 有许多可视化信息

8
00:00:27,494 --> 00:00:30,430
以帮助人们了解自己的健康数据

9
00:00:30,430 --> 00:00:33,867
但是构建这些视图可能非常复杂

10
00:00:33,867 --> 00:00:36,803
我一直对
使用 SwiftUI 带来的优势很感兴趣

11
00:00:36,803 --> 00:00:39,740
所以我与 UIKit
和 SwiftUI 团队一起工作

12
00:00:39,740 --> 00:00:43,477
以了解如何
将两者集成到同一个 App 中

13
00:00:43,477 --> 00:00:46,613
在这个视频中 我将为您展示

14
00:00:46,613 --> 00:00:50,784
在您自己的 UIKit App 中
使用 SwiftUI 多么简单

15
00:00:50,784 --> 00:00:54,354
首先 我将介绍现有
UIHostingController

16
00:00:54,354 --> 00:00:58,959
它包含一些更新内容 灵活性也更强

17
00:00:58,959 --> 00:01:01,962
接下来我将深入讲解用您的 App

18
00:01:01,962 --> 00:01:05,165
中的现有
数据填充 SwiftUI 视图

19
00:01:05,165 --> 00:01:07,935
以及如何确保在数据出现变更时

20
00:01:07,935 --> 00:01:11,071
及时更新 SwiftUI 视图

21
00:01:11,071 --> 00:01:14,107
然后 我将介绍一些
令人兴奋的新功能

22
00:01:14,107 --> 00:01:16,276
它们可以让您用 SwiftUI

23
00:01:16,276 --> 00:01:20,514
构建 UICollectionView
和 UITableView 单元格

24
00:01:20,514 --> 00:01:24,251
最后 我将介绍数据流
有哪些独特的方面

25
00:01:24,251 --> 00:01:25,919
当您在 collection 和 table view 单元格内

26
00:01:25,919 --> 00:01:29,890
使用 SwiftUI 视图

27
00:01:29,890 --> 00:01:33,727
我们先来讨论一下
UIHostingController

28
00:01:33,727 --> 00:01:36,763
UIHostingController
是一个 UIViewController

29
00:01:36,763 --> 00:01:39,967
它包含 SwiftUI 视图层次结构

30
00:01:39,967 --> 00:01:41,735
能在 UIKit 中
使用视图控制器的地方

31
00:01:41,735 --> 00:01:45,372
就可以使用托管控制器

32
00:01:45,372 --> 00:01:46,974
这让 UIHostingController

33
00:01:46,974 --> 00:01:50,444
成为了开始使用
SwiftUI 的简便方法

34
00:01:50,444 --> 00:01:53,814
让我们来看看
托管控制器是如何工作的

35
00:01:53,814 --> 00:01:56,817
托管控制器是一个视图控制器

36
00:01:56,817 --> 00:02:01,355
这意味着它的视图属性中
存储了一个 UIView

37
00:02:01,355 --> 00:02:02,589
那个视图里面就是

38
00:02:02,589 --> 00:02:05,559
绘制 SwiftUI 内容的地方

39
00:02:05,559 --> 00:02:09,696
让我们举例说明如何使用托管控制器

40
00:02:09,696 --> 00:02:14,434
在这里 我们创建一个 HeartRateView
一个 SwiftUI 视图

41
00:02:14,434 --> 00:02:17,571
然后 我们创建一个托管控制器

42
00:02:17,571 --> 00:02:21,041
将 HeartRateView
作为它的根视图 并呈现出来

43
00:02:21,041 --> 00:02:22,709
UIHostingController 可与所有

44
00:02:22,709 --> 00:02:26,880
UIKit 视图控制器
API 搭配使用

45
00:02:26,880 --> 00:02:30,484
让我们来看看另一个例子

46
00:02:30,484 --> 00:02:32,119
我们有相同的 HeartRateView

47
00:02:32,119 --> 00:02:34,922
以及和以前一样的托管控制器

48
00:02:34,922 --> 00:02:36,957
在这里 我们添加托管控制器

49
00:02:36,957 --> 00:02:39,193
将其作为子视图控制器

50
00:02:39,193 --> 00:02:43,830
然后 我们可以调整
托管控制器的视图位置和大小

51
00:02:43,830 --> 00:02:47,968
当 UIHostingController 中的
SwiftUI 内容发生变化时

52
00:02:47,968 --> 00:02:51,471
您需要调整视图的大小

53
00:02:51,471 --> 00:02:54,908
作为 iOS 16 中的新功能
UIHostingController

54
00:02:54,908 --> 00:02:57,511
允许您启用

55
00:02:57,511 --> 00:03:00,380
视图控制器首选内容大小

56
00:03:00,380 --> 00:03:03,851
和视图固有内容大小的自动更新

57
00:03:03,851 --> 00:03:07,221
您可以使用
UIHostingController 上的

58
00:03:07,221 --> 00:03:09,189
新 sizingOptions 属性
启用此功能

59
00:03:09,189 --> 00:03:12,292
我们举个例子

60
00:03:12,292 --> 00:03:14,795
首先 我们制作 HeartRateView

61
00:03:14,795 --> 00:03:18,031
并创建 hostingController

62
00:03:18,031 --> 00:03:22,336
我们使用新 sizingOptions API
让托管控制器

63
00:03:22,336 --> 00:03:27,641
自动更新其 preferredContentSize

64
00:03:27,641 --> 00:03:30,077
然后 我们进行设置

65
00:03:30,077 --> 00:03:31,712
让 modalPresentationStyle 弹出

66
00:03:31,712 --> 00:03:35,682
使用新 sizingOptions API 可确保

67
00:03:35,682 --> 00:03:41,221
弹出框的大小适合 SwiftUI 内容

68
00:03:41,221 --> 00:03:43,690
现在您已经熟悉了
UIHostingController

69
00:03:43,690 --> 00:03:46,827
我们来谈谈
如何将 UIKit App 的

70
00:03:46,827 --> 00:03:49,730
其他部分中的数据
导入 SwiftUI

71
00:03:49,730 --> 00:03:52,399
并确保当该数据发生变更时

72
00:03:52,399 --> 00:03:55,502
您的 SwiftUI 视图
能及时更新

73
00:03:55,502 --> 00:03:58,438
这是您 UIKit App 的图表

74
00:03:58,438 --> 00:04:00,440
它包含一个现有的模型层

75
00:04:00,440 --> 00:04:04,411
它拥有并管理
App 的数据模型对象

76
00:04:04,411 --> 00:04:07,848
您的 App 还包含
许多视图控制器

77
00:04:07,848 --> 00:04:11,585
如果您想开始使用 SwiftUI
您需要一个托管控制器

78
00:04:11,585 --> 00:04:15,589
其中一个视图控制器中
有 SwiftUI 视图

79
00:04:15,589 --> 00:04:18,892
您将用仍然您现有模型层所有的数据

80
00:04:18,892 --> 00:04:22,496
填充此 SwiftUI 视图

81
00:04:22,496 --> 00:04:25,999
在本部分 我们将重点介绍如何

82
00:04:25,999 --> 00:04:30,370
跨越 UIKit
和 SwiftUI 的界限桥接数据

83
00:04:30,370 --> 00:04:33,574
SwiftUI 提供了多种数据流原语

84
00:04:33,574 --> 00:04:36,443
以帮助您管理 App 中的数据

85
00:04:36,443 --> 00:04:39,413
让我们来看看不同的选项

86
00:04:39,413 --> 00:04:44,418
要存储由 SwiftUI 视图
创建和拥有的数据

87
00:04:44,418 --> 00:04:49,556
SwiftUI 提供了 @State
和 @StateObject 属性包装器

88
00:04:49,556 --> 00:04:52,993
由于我们专注于
SwiftUI 之外的数据

89
00:04:52,993 --> 00:04:56,296
这些属性包装器并不合适

90
00:04:56,296 --> 00:04:58,765
所以 我不会在
本视频中介绍这些内容

91
00:04:58,765 --> 00:05:01,435
观看“SwiftUI 中的数据要点”

92
00:05:01,435 --> 00:05:06,039
以了解有关 SwiftUI 视图
拥有的数据的更多信息

93
00:05:06,039 --> 00:05:08,809
处理 SwiftUI
外部数据的一种方法

94
00:05:08,809 --> 00:05:12,846
是在初始化视图时直接传递数值

95
00:05:12,846 --> 00:05:15,249
因为只是传递并非由 SwiftUI

96
00:05:15,249 --> 00:05:18,819
拥有或管理的原始数据

97
00:05:18,819 --> 00:05:22,623
所以您负责在数据发生变化时

98
00:05:22,623 --> 00:05:25,225
手动更新 UIHostingController

99
00:05:25,225 --> 00:05:27,528
我们举个例子

100
00:05:27,528 --> 00:05:31,665
这是一个名为
HeartRateView 的 SwiftUI 视图

101
00:05:31,665 --> 00:05:33,600
这个视图只有一个属性

102
00:05:33,600 --> 00:05:37,004
以整数形式
存储的每分钟的 beatsPerMinute 即心率

103
00:05:37,004 --> 00:05:39,940
并将此数值显示为文本

104
00:05:39,940 --> 00:05:41,608
我们通过在现有的名为

105
00:05:41,608 --> 00:05:43,777
HeartRateViewController 的
视图控制器中

106
00:05:43,777 --> 00:05:45,812
嵌入一个
UIHostingController

107
00:05:45,812 --> 00:05:48,515
来显示这个
HeartRateView

108
00:05:48,515 --> 00:05:50,684
我们保存对托管控制器的引用

109
00:05:50,684 --> 00:05:53,253
以便稍后更新它的根视图

110
00:05:53,253 --> 00:05:57,357
请记住 SwiftUI HeartRateView
是一个值类型

111
00:05:57,357 --> 00:06:00,827
所以单独存储它
会创建一个单独的副本

112
00:06:00,827 --> 00:06:04,431
让我们不能更新 UI

113
00:06:04,431 --> 00:06:06,900
HeartRateViewController 拥有

114
00:06:06,900 --> 00:06:09,770
用于填充 HeartRateView 数据

115
00:06:09,770 --> 00:06:13,240
此数据存储在
beatsPerMinute 属性中

116
00:06:13,240 --> 00:06:15,542
当 beatsPerMinute 值发生变化时

117
00:06:15,542 --> 00:06:19,413
我们将调用一个方法来更新视图

118
00:06:19,413 --> 00:06:23,383
在更新方法中 我们使用
最新的 beatsPerMinute 值

119
00:06:23,383 --> 00:06:26,119
创建一个新的 HeartRateView

120
00:06:26,119 --> 00:06:28,155
然后将该视图指定为

121
00:06:28,155 --> 00:06:31,225
托管控制器的 rootView

122
00:06:31,225 --> 00:06:37,064
这是将数据从 UIKit
导入 SwiftUI 的简单方法

123
00:06:37,064 --> 00:06:39,766
但您需要在数据发生变化时

124
00:06:39,766 --> 00:06:43,871
及时手动更新托管控制器的 rootView

125
00:06:43,871 --> 00:06:46,540
让我们看看
其他 SwiftUI 数据原语

126
00:06:46,540 --> 00:06:49,743
以实现数据自动更新

127
00:06:49,743 --> 00:06:52,246
@ObservedObject
和 @EnvironmentObject

128
00:06:52,246 --> 00:06:54,548
属性包装器允许您引用

129
00:06:54,548 --> 00:06:56,283
ObservableObject 协议的

130
00:06:56,283 --> 00:06:59,853
外部模型对象

131
00:06:59,853 --> 00:07:01,688
当您使用这些属性包装器时

132
00:07:01,688 --> 00:07:07,294
SwiftUI 会在数据更改时
自动更新您的视图

133
00:07:07,294 --> 00:07:10,364
在此视频中 我们将重点介绍

134
00:07:10,364 --> 00:07:12,032
@ObservedObject 属性包装器

135
00:07:12,032 --> 00:07:14,902
您可以在前面提到的

136
00:07:14,902 --> 00:07:18,805
“SwiftUI 中的数据要”点视频中
了解 EnvironmentObject 的更多内容

137
00:07:18,805 --> 00:07:22,576
让我们来看看
如何创建 @ObservedObject

138
00:07:22,576 --> 00:07:25,078
第一步是取一个 App 的现有部分

139
00:07:25,078 --> 00:07:27,614
拥有的模型对象

140
00:07:27,614 --> 00:07:31,985
并使其符合
ObservableObject 协议

141
00:07:31,985 --> 00:07:35,522
接下来
我们在我 SwiftUI 视图中

142
00:07:35,522 --> 00:07:38,759
将模型存储为
@ObservedObject 属性

143
00:07:38,759 --> 00:07:42,129
将 ObservableObject
连接到 SwiftUI

144
00:07:42,129 --> 00:07:46,567
使它能够
在其中一个属性更改时更新视图

145
00:07:46,567 --> 00:07:48,769
回顾一下 HeartRateView 示例

146
00:07:48,769 --> 00:07:51,038
并将其连接起来

147
00:07:51,038 --> 00:07:53,340
我们的 App 有一个
名为 HeartData 的类别

148
00:07:53,340 --> 00:07:56,777
其中包含每分钟
beatsPerMinute 属性

149
00:07:56,777 --> 00:08:01,548
我们按照协议使其成为
ObservableObject

150
00:08:01,548 --> 00:08:04,218
然后我们将
@Published 属性包装器

151
00:08:04,218 --> 00:08:06,720
添加到 beatsPerMinute 属性中

152
00:08:06,720 --> 00:08:09,456
此属性包装器会在发生变化时

153
00:08:09,456 --> 00:08:12,926
触发 SwiftUI 更新我们的视图

154
00:08:12,926 --> 00:08:15,462
在 HeartRateView 里
我们将 HeartData 存储在

155
00:08:15,462 --> 00:08:17,397
标有 @ObservedObject

156
00:08:17,397 --> 00:08:20,567
属性包装器的属性中

157
00:08:20,567 --> 00:08:23,637
在视图的主体部分
我们显示直接来源于

158
00:08:23,637 --> 00:08:26,240
HeartData 的 beatsPerMinute

159
00:08:26,240 --> 00:08:30,043
现在 让我们
在视图控制器中使用一下所有功能

160
00:08:30,043 --> 00:08:33,347
这是我们的
HeartRateViewController

161
00:08:33,347 --> 00:08:37,751
它将 HeartData
ObservableObject 存储在一个属性中

162
00:08:37,751 --> 00:08:40,821
因为这个属性
不在 SwiftUI 视图中

163
00:08:40,821 --> 00:08:44,157
所以我们不需要
在这里使用属性包装器

164
00:08:44,157 --> 00:08:46,193
HeartRateViewController
已用 HeartData 实例

165
00:08:46,193 --> 00:08:47,895
进行了初始化

166
00:08:47,895 --> 00:08:50,130
该数据用于
创建 HeartRateView

167
00:08:50,130 --> 00:08:54,468
此视图将成为托管控制器的 rootView

168
00:08:54,468 --> 00:08:57,671
该图说明了它们是如何结合在一起的

169
00:08:57,671 --> 00:09:00,307
我们获取
当前的 HeartData 实例

170
00:09:00,307 --> 00:09:04,278
其中包含心率每分钟 78 次

171
00:09:04,278 --> 00:09:07,748
然后我们
用此 HeartData 实例

172
00:09:07,748 --> 00:09:09,950
创建一个
新 HeartRateViewController

173
00:09:09,950 --> 00:09:14,555
并将 HeartData 连接到
SwiftUI HeartRateView

174
00:09:14,555 --> 00:09:15,923
几秒钟后

175
00:09:15,923 --> 00:09:18,692
即当下一个心率数据样本到达时

176
00:09:18,692 --> 00:09:24,231
HeartData 的
beatsPerMinute 属性更新为 94

177
00:09:24,231 --> 00:09:26,433
因为这更改了
ObservableObject

178
00:09:26,433 --> 00:09:29,036
上的 published 属性

179
00:09:29,036 --> 00:09:33,307
HeartRateView
会自动更新以显示新值

180
00:09:33,307 --> 00:09:36,443
所以我们不再需要在数据发生变更时

181
00:09:36,443 --> 00:09:38,178
手动更新托管控制器

182
00:09:38,178 --> 00:09:41,782
这就是为什么 ObservableObject

183
00:09:41,782 --> 00:09:44,785
是桥接从 UIKit
到 SwiftUI 的数据的好方法

184
00:09:44,785 --> 00:09:48,889
接下来说一下在集合视图以及

185
00:09:48,889 --> 00:09:52,292
表格视图单元格中使用 SwiftUI

186
00:09:52,292 --> 00:09:56,296
iOS 16 中的新功能是
UIHostingConfiguration

187
00:09:56,296 --> 00:09:58,999
它可以让您在您现有的
UIKit、集合和表格视图中

188
00:09:58,999 --> 00:10:03,470
使用 SwiftUI 的强大功能

189
00:10:03,470 --> 00:10:06,273
UIHostingConfiguration
让您可以轻松地

190
00:10:06,273 --> 00:10:09,643
使用 SwiftUI 实现自定义单元格

191
00:10:09,643 --> 00:10:13,514
同时您不必担心嵌入
额外的视图或视图控制器

192
00:10:13,514 --> 00:10:16,383
在我们深入了解
UIHostingConfiguration 之前

193
00:10:16,383 --> 00:10:20,420
让我们介绍一下
UIKit 中的单元格配置

194
00:10:20,420 --> 00:10:23,190
单元格配置是一种
在 UIKit 中定义

195
00:10:23,190 --> 00:10:28,228
单元格的内容、样式
和行为的现代方式

196
00:10:28,228 --> 00:10:31,198
与 UIView
或 UIViewController 不同

197
00:10:31,198 --> 00:10:34,101
配置只是一个轻量级结构

198
00:10:34,101 --> 00:10:36,770
创建成本不高

199
00:10:36,770 --> 00:10:38,972
配置只是描述单元格的外观

200
00:10:38,972 --> 00:10:41,742
因此需要应用

201
00:10:41,742 --> 00:10:45,078
到单元格才有效果

202
00:10:45,078 --> 00:10:46,880
配置是可组合的

203
00:10:46,880 --> 00:10:48,882
并可用于 UICollectionView

204
00:10:48,882 --> 00:10:51,385
和 UITableView 单元格

205
00:10:51,385 --> 00:10:56,123
要了解更多详情
您可以观看“现代单元格配置”

206
00:10:56,123 --> 00:10:58,325
有了这些知识

207
00:10:58,325 --> 00:11:02,429
我们将开始探究并使用
UIHostingConfiguration

208
00:11:02,429 --> 00:11:05,332
UIHostingConfiguration
是一个内容配置

209
00:11:05,332 --> 00:11:08,902
它使用 SwiftUI ViewBuilder
进行初始化

210
00:11:08,902 --> 00:11:11,305
这意味着我们可以
开始编写 SwiftUI 代码

211
00:11:11,305 --> 00:11:15,142
以直接在其中创建视图

212
00:11:15,142 --> 00:11:17,744
为了渲染托管配置

213
00:11:17,744 --> 00:11:20,347
我们将其设置为 UICollectionView

214
00:11:20,347 --> 00:11:23,951
或 UITableView 单元格中的
contentConfiguration 属性

215
00:11:23,951 --> 00:11:25,986
让我们开始在此托管配置中
编写一些 SwiftUI 代码

216
00:11:25,986 --> 00:11:30,624
以构建自定义心率单元格

217
00:11:30,624 --> 00:11:34,394
首先 我们将创建一个 label
带有“Heart Rate”文本

218
00:11:34,394 --> 00:11:36,463
和一颗心形图像

219
00:11:36,463 --> 00:11:38,999
SwiftUI 视图根据其使用环境

220
00:11:38,999 --> 00:11:41,835
接收默认样式

221
00:11:41,835 --> 00:11:43,770
但我们可以使用标准的

222
00:11:43,770 --> 00:11:47,841
SwiftUI 视图修饰符自定义样式

223
00:11:47,841 --> 00:11:51,345
我们将 foregroundStyle
和 font 修饰符添加到标签中

224
00:11:51,345 --> 00:11:55,649
以将图像和文本设置为粉红色并加粗

225
00:11:55,649 --> 00:11:58,485
因为我们只是在
编写常规的 SwiftUI 代码

226
00:11:58,485 --> 00:12:01,021
我们可以根据需要随时

227
00:12:01,021 --> 00:12:03,857
将代码提出为一个独立的视图

228
00:12:03,857 --> 00:12:06,827
在这里 我们创建一个
新的 SwiftUI 视图

229
00:12:06,827 --> 00:12:09,696
命名为 HeartRateTitleView

230
00:12:09,696 --> 00:12:12,299
并将前面的代码移动到其 body 中

231
00:12:12,299 --> 00:12:14,635
然后在托管配置中嵌入

232
00:12:14,635 --> 00:12:16,637
HeartRateTitleView

233
00:12:16,637 --> 00:12:17,838
如单元格所示

234
00:12:17,838 --> 00:12:22,276
结果是完全相同的

235
00:12:22,276 --> 00:12:24,811
现在我们可以在
HeartRateTitleView 中

236
00:12:24,811 --> 00:12:27,514
开始添加更多视图

237
00:12:27,514 --> 00:12:32,152
我将 label 和 spacer 放在
HStack 里面

238
00:12:32,152 --> 00:12:36,156
然后在旁边的
Text 视图中添加当前时间

239
00:12:36,156 --> 00:12:38,392
到目前为止看起来还不错

240
00:12:38,392 --> 00:12:41,428
我们来向
HeartRateTitleView 下方的

241
00:12:41,428 --> 00:12:44,865
自定义单元格中添加更多内容

242
00:12:44,865 --> 00:12:47,434
为此 我们将在托管配置中

243
00:12:47,434 --> 00:12:49,203
插入一个 Vstack 堆栈

244
00:12:49,203 --> 00:12:53,774
这样我们就可以在
HeartRateTitleView 下添加更多内容

245
00:12:53,774 --> 00:12:56,610
然后 我们将两个 Text 视图一起

246
00:12:56,610 --> 00:13:00,714
放在 HStack 中
以显示 90 BPM

247
00:13:00,714 --> 00:13:05,319
然后 应用一些修饰符
以按照需要设置样式

248
00:13:05,319 --> 00:13:08,155
就像我们之前对
HeartRateTitleView 所做的那样

249
00:13:08,155 --> 00:13:14,294
我们可以将这个新代码移动到
其自己的 SwiftUI 视图中

250
00:13:14,294 --> 00:13:17,431
现在 相同的代码被提取到了

251
00:13:17,431 --> 00:13:20,033
HeartRateBPMView 的 body 中

252
00:13:20,033 --> 00:13:21,768
我们的单元格看起来很棒

253
00:13:21,768 --> 00:13:25,305
不过我觉得我们还可以添加一个东西

254
00:13:25,305 --> 00:13:29,743
iOS 16 中有一个新功能是
Swift Charts 框架

255
00:13:29,743 --> 00:13:33,113
只需编写几行代码

256
00:13:33,113 --> 00:13:35,816
您就可以用漂亮的图表来显示数据

257
00:13:35,816 --> 00:13:38,552
让我们试着用它在单元格内

258
00:13:38,552 --> 00:13:41,889
显示一个小的折线图

259
00:13:41,889 --> 00:13:45,459
我们使用新的 Chart 视图
创建一个小折线图

260
00:13:45,459 --> 00:13:47,895
以显示最近的心率样本

261
00:13:47,895 --> 00:13:52,566
并把它放在
单元格中的 BPM 视图旁边

262
00:13:52,566 --> 00:13:53,700
要生成图表

263
00:13:53,700 --> 00:13:56,937
我们需要传入一组心率样本

264
00:13:56,937 --> 00:14:01,074
并绘制一个连接所有样本的 LineMark

265
00:14:01,074 --> 00:14:02,609
我们可以添加圆圈符号

266
00:14:02,609 --> 00:14:04,811
以表示折线上的每个样本

267
00:14:04,811 --> 00:14:07,214
并应用粉色的前景样式

268
00:14:07,214 --> 00:14:11,285
以为图表着色 从而匹配
HeartRateTitleView

269
00:14:11,285 --> 00:14:14,154
我们仅仅介绍了

270
00:14:14,154 --> 00:14:16,890
新 Swift Charts 框架的几个功能

271
00:14:16,890 --> 00:14:20,260
请务必观看
“Hello Swift Charts”视频

272
00:14:20,260 --> 00:14:22,229
以了解更多信息

273
00:14:22,229 --> 00:14:25,732
我们制作的心率单元格很棒

274
00:14:25,732 --> 00:14:29,269
而且只需要几分钟就可以完成

275
00:14:29,269 --> 00:14:32,039
用 UIHostingConfiguration 和 SwiftUI

276
00:14:32,039 --> 00:14:35,509
构建自定义单元格就是这么简单

277
00:14:35,509 --> 00:14:37,377
我们来聊一聊
UIHostingConfiguration

278
00:14:37,377 --> 00:14:40,848
支持的四大特别功能

279
00:14:40,848 --> 00:14:44,418
默认情况下
根级 SwiftUI 内容

280
00:14:44,418 --> 00:14:46,687
和单元格边缘有一定间距

281
00:14:46,687 --> 00:14:50,691
是基于 UIKit 中
单元格的布局边距决定的

282
00:14:50,691 --> 00:14:52,626
这确保了单元格内容

283
00:14:52,626 --> 00:14:55,729
与相邻单元格的内容和导航栏等

284
00:14:55,729 --> 00:14:59,900
其他 UI 元素正确对齐

285
00:14:59,900 --> 00:15:02,936
有时 您可能想使用不同的边距

286
00:15:02,936 --> 00:15:07,074
或让内容延伸到单元格的边缘

287
00:15:07,074 --> 00:15:10,177
对于这些情况 您可以在
UIHostingConfiguration 上

288
00:15:10,177 --> 00:15:15,415
使用边距修饰符以更改默认边距

289
00:15:15,415 --> 00:15:18,051
如果您想 用 SwiftUI
自定义单元格的背景外观

290
00:15:18,051 --> 00:15:21,588
您可以使用
UIHostingConfiguration 上的

291
00:15:21,588 --> 00:15:24,491
background 修饰符

292
00:15:24,491 --> 00:15:26,560
UIHostingConfiguration 的
背景及其内容

293
00:15:26,560 --> 00:15:31,632
之间有几个关键区别

294
00:15:31,632 --> 00:15:34,735
背景位于单元格的背面

295
00:15:34,735 --> 00:15:39,173
即单元格内容视图中的
SwiftUI 内容下方

296
00:15:39,173 --> 00:15:41,508
此外 虽然内容通常是

297
00:15:41,508 --> 00:15:43,944
从单元格边缘插入的

298
00:15:43,944 --> 00:15:48,182
但背景通常会从
单元格的一边拓展到另一边

299
00:15:48,182 --> 00:15:51,151
最后 当使用自定尺寸单元格时

300
00:15:51,151 --> 00:15:56,690
只有单元格的内容
会影响单元格的大小

301
00:15:56,690 --> 00:15:59,626
接下来 让我们看看
UIHostingConfiguration

302
00:15:59,626 --> 00:16:02,095
的另外两个特殊功能

303
00:16:02,095 --> 00:16:04,731
您可以将其用于集合视图列表

304
00:16:04,731 --> 00:16:06,700
或表格视图中的单元格

305
00:16:06,700 --> 00:16:08,969
在列表中 托管配置默认将

306
00:16:08,969 --> 00:16:11,905
单元格下方的间隔符

307
00:16:11,905 --> 00:16:14,875
自动与 SwiftUI 文本对齐

308
00:16:14,875 --> 00:16:18,178
在本例中 请注意间隔符的前缘

309
00:16:18,178 --> 00:16:21,915
是如何跳过图像

310
00:16:21,915 --> 00:16:23,383
以与单元格中的文本对齐

311
00:16:23,383 --> 00:16:24,985
如果需要使间隔符与托管配置中

312
00:16:24,985 --> 00:16:28,422
的不同 SwiftUI 视图对齐

313
00:16:28,422 --> 00:16:32,226
请使用 alignmentGuide 修饰符

314
00:16:32,226 --> 00:16:34,995
在集合视图列表或表格视图中

315
00:16:34,995 --> 00:16:40,300
您可以直接使用
SwiftUI 为一行配置滑动操作

316
00:16:40,300 --> 00:16:43,770
通过在 swipeActions
修饰符中创建按钮

317
00:16:43,770 --> 00:16:45,639
您将能够滑动单元格

318
00:16:45,639 --> 00:16:49,142
以显示和执行自定义操作

319
00:16:49,142 --> 00:16:50,911
下载此视频的示例代码

320
00:16:50,911 --> 00:16:53,714
以找到一个完整的例子

321
00:16:53,714 --> 00:16:55,482
定义滑动操作时

322
00:16:55,482 --> 00:16:57,985
确保您的按钮使用所代表的项目

323
00:16:57,985 --> 00:17:01,755
的稳定标识符执行其操作

324
00:17:01,755 --> 00:17:03,524
不要使用索引路径 因为它可能会

325
00:17:03,524 --> 00:17:06,059
在单元格可见的情况下发生变化

326
00:17:06,059 --> 00:17:10,597
从而导致滑动操作作用于错误的项目

327
00:17:10,597 --> 00:17:12,900
当在单元格中使用
UIHostingConfiguration 时

328
00:17:12,900 --> 00:17:16,370
请记住单元格的交互

329
00:17:16,370 --> 00:17:18,805
例如点击处理 高亮显示

330
00:17:18,805 --> 00:17:21,208
和选择将仍然通过

331
00:17:21,208 --> 00:17:24,411
集合视图或表格视图处理

332
00:17:24,411 --> 00:17:27,281
如果需要为
任何这些 UIKit 单元格状态

333
00:17:27,281 --> 00:17:29,683
自定义 SwiftUI 视图

334
00:17:29,683 --> 00:17:32,085
您可以在单元格的
configurationUpdateHandler 中

335
00:17:32,085 --> 00:17:35,923
创建您的托管配置

336
00:17:35,923 --> 00:17:40,394
并使用 SwiftUI 代码中提供的状态

337
00:17:40,394 --> 00:17:43,030
只要单元格状态发生变化

338
00:17:43,030 --> 00:17:45,699
configurationUpdateHandler
就会再次运行

339
00:17:45,699 --> 00:17:47,868
为新状态创建一个
新 UIHostingConfiguration

340
00:17:47,868 --> 00:17:51,205
并将其应用于单元格

341
00:17:51,205 --> 00:17:54,541
在此例中 我们使用状态
来添加一个复选标记图像

342
00:17:54,541 --> 00:17:57,511
它代表单元格被选中

343
00:17:57,511 --> 00:18:00,013
现在您已经熟悉了
UIHostingConfiguration

344
00:18:00,013 --> 00:18:04,218
让我们讨论一下如何管理
数据流动 从模型层传递到

345
00:18:04,218 --> 00:18:07,020
UICollectionView 或者
UITableView 的单元格

346
00:18:07,020 --> 00:18:10,557
其内部由 SwiftUI 填充

347
00:18:10,557 --> 00:18:14,561
我们的目标是建立病症清单

348
00:18:14,561 --> 00:18:17,931
在此例中 我们使用了一个
UICollectionView

349
00:18:17,931 --> 00:18:22,769
但我们讨论的所有内容
都同样适用于 UITableView

350
00:18:22,769 --> 00:18:25,939
让我们来看看所涉及的构件

351
00:18:25,939 --> 00:18:30,377
我们的 App 有一个
MedicalCondition 模型对象集合

352
00:18:30,377 --> 00:18:33,347
我们将在集合视图中显示

353
00:18:33,347 --> 00:18:35,616
对于此集合中的每个项目

354
00:18:35,616 --> 00:18:38,318
我们想在集合视图中创建一个单元格

355
00:18:38,318 --> 00:18:41,588
以显示该病症

356
00:18:41,588 --> 00:18:44,992
为此 我们将创建一个连接到

357
00:18:44,992 --> 00:18:47,561
集合视图的可区分的数据源

358
00:18:47,561 --> 00:18:51,965
然后 我们需要
填充一个可区分数据源快照

359
00:18:51,965 --> 00:18:55,669
以及数据集合中的

360
00:18:55,669 --> 00:18:58,739
MedicalCondition 模型对象的标识符

361
00:18:58,739 --> 00:19:01,775
可区分数据源快照必须

362
00:19:01,775 --> 00:19:05,546
包含每个 MedicalCondition 的唯一标识符

363
00:19:05,546 --> 00:19:08,882
而不是 MedicalCondition 对象本身

364
00:19:08,882 --> 00:19:13,053
这确保了可区分数据源可以准确跟踪

365
00:19:13,053 --> 00:19:15,189
每个项目本身

366
00:19:15,189 --> 00:19:17,758
并在稍后应用新快照时

367
00:19:17,758 --> 00:19:20,627
计算正确的变化

368
00:19:20,627 --> 00:19:23,497
通过将具有这些项目标识符的快照

369
00:19:23,497 --> 00:19:25,365
应用于可区分数据源

370
00:19:25,365 --> 00:19:28,068
它会自动更新集合视图

371
00:19:28,068 --> 00:19:32,239
这将为每个项目创建一个新单元格

372
00:19:32,239 --> 00:19:36,376
在 UIHostingConfiguration 中
使用 SwiftUI 视图

373
00:19:36,376 --> 00:19:42,282
将每个单元格配置为
显示一个 MedicalCondition

374
00:19:42,282 --> 00:19:45,018
现在我们正在显示使用
SwiftUI 构建的单元格

375
00:19:45,018 --> 00:19:49,323
当数据发生变更时
我们需要处理 UI 更新

376
00:19:49,323 --> 00:19:51,058
有两种不同类型的变化

377
00:19:51,058 --> 00:19:54,061
我们需要分别单独处理

378
00:19:54,061 --> 00:19:58,465
第一种是数据集合本身发生变化时

379
00:19:58,465 --> 00:20:04,538
例如插入、重新排序或删除项目

380
00:20:04,538 --> 00:20:07,841
这些变更通过将新快照

381
00:20:07,841 --> 00:20:10,844
应用于可区分数据源来处理

382
00:20:10,844 --> 00:20:14,748
可区分数据源将区分新旧快照

383
00:20:14,748 --> 00:20:18,218
并对集合视图执行必要的更新

384
00:20:18,218 --> 00:20:23,257
以插入、移动或删除单元格

385
00:20:23,257 --> 00:20:25,893
因为数据集合本身的变化

386
00:20:25,893 --> 00:20:28,762
不会影响单元格内的任何东西

387
00:20:28,762 --> 00:20:31,365
您以相同的方式处理这些类型的更改

388
00:20:31,365 --> 00:20:35,802
无论是使用 UIKit
还是 SwiftUI 构建单元格

389
00:20:35,802 --> 00:20:37,971
我们需要处理的第二种变更

390
00:20:37,971 --> 00:20:43,343
是单个模型对象的属性发生变更

391
00:20:43,343 --> 00:20:46,146
这些变更通常需要

392
00:20:46,146 --> 00:20:48,115
您更新现在单元格中的视图

393
00:20:48,115 --> 00:20:49,883
因为可区分数据源

394
00:20:49,883 --> 00:20:53,120
仅在其快照中包含项目标识符

395
00:20:53,120 --> 00:20:55,088
它不知道现有项目

396
00:20:55,088 --> 00:20:57,991
的属性何时发生变更

397
00:20:57,991 --> 00:21:01,562
按照传统
使用 UIKit 时您需要手动

398
00:21:01,562 --> 00:21:04,998
告知可变数据源这些变更

399
00:21:04,998 --> 00:21:08,802
方式是重新配置
或重新加载快照中的项目

400
00:21:08,802 --> 00:21:13,373
但是当在单元格中使用 SwiftUI 时
您就不再需要这么做了

401
00:21:13,373 --> 00:21:16,410
通过在我们的 SwiftUI 视图的
ObservableObject 属性中

402
00:21:16,410 --> 00:21:20,447
存储 ObservedObject 模型

403
00:21:20,447 --> 00:21:22,583
对模型的已发布属性的更改

404
00:21:22,583 --> 00:21:25,686
会自动触发 SwiftUI

405
00:21:25,686 --> 00:21:27,254
刷新视图

406
00:21:27,254 --> 00:21:30,791
这在模型和单元格内的 SwiftUI 视图

407
00:21:30,791 --> 00:21:34,161
之间建立了直接连接

408
00:21:34,161 --> 00:21:35,429
当做出更改时

409
00:21:35,429 --> 00:21:38,932
单元格中的 SwiftUI 视图直接更新

410
00:21:38,932 --> 00:21:41,335
无需通过可区分数据源

411
00:21:41,335 --> 00:21:44,404
或 UICollectionView 进行更新

412
00:21:44,404 --> 00:21:45,973
当单元格的数据发生变更时

413
00:21:45,973 --> 00:21:48,675
单元格可能需要扩大或缩小

414
00:21:48,675 --> 00:21:51,144
以适应新的内容

415
00:21:51,144 --> 00:21:54,982
但是如果直接更新
SwiftUI 单元格内容

416
00:21:54,982 --> 00:21:56,917
而无需通过 UIKit

417
00:21:56,917 --> 00:22:00,754
集合视图如何知道
需要调整单元格的大小呢？

418
00:22:00,754 --> 00:22:04,358
UIHostingConfiguration
利用了 UIKit 中的

419
00:22:04,358 --> 00:22:07,327
一项全新功能以完成这项工作

420
00:22:07,327 --> 00:22:11,999
在 iOS 16 中
UICollectionView 和 UITableView 中的

421
00:22:11,999 --> 00:22:16,537
自行调整大小单元格
现在也可以自行调整大小！

422
00:22:16,537 --> 00:22:18,172
这是默认启用的

423
00:22:18,172 --> 00:22:21,041
这样当您使用
UIHostingConfiguration

424
00:22:21,041 --> 00:22:24,411
并且 SwiftUI 内容发生变更时

425
00:22:24,411 --> 00:22:28,682
相应的单元格
就会视需要自动调整大小

426
00:22:28,682 --> 00:22:31,151
请在 WWDC 2022 的
UIKit 中的新功能视频中

427
00:22:31,151 --> 00:22:37,691
详细了解这项新功能的工作原理

428
00:22:37,691 --> 00:22:39,493
您可能需要处理数据流的另一个问题

429
00:22:39,493 --> 00:22:43,463
那就是将 SwiftUI 视图中的数据

430
00:22:43,463 --> 00:22:48,035
发回到 App 的其他部分

431
00:22:48,035 --> 00:22:52,606
ObservableObject
也可以帮您解决这个问题！

432
00:22:52,606 --> 00:22:55,642
您可以为一个
ObservableObject 的已发布属性

433
00:22:55,642 --> 00:22:57,911
创建一个双向绑定

434
00:22:57,911 --> 00:23:02,683
不仅数据会从
ObservableObject 流入 SwiftUI

435
00:23:02,683 --> 00:23:06,019
SwiftUI 也可将变更写回到

436
00:23:06,019 --> 00:23:08,755
模型对象的属性上

437
00:23:08,755 --> 00:23:10,490
我们来举一个简单的示例

438
00:23:10,490 --> 00:23:12,226
介绍一下通过使
MedicalCondition 单元格中的文本可编辑

439
00:23:12,226 --> 00:23:16,997
创建双向绑定

440
00:23:16,997 --> 00:23:21,401
这是我们的 ObservableObject
即 MedicalCondition

441
00:23:21,401 --> 00:23:25,672
它将唯一标识符
存储在 ID 属性中

442
00:23:25,672 --> 00:23:27,674
这是用于填充可区分

443
00:23:27,674 --> 00:23:30,711
数据源快照的标识符

444
00:23:30,711 --> 00:23:33,046
这个 published 属性

445
00:23:33,046 --> 00:23:35,916
存储病症文本

446
00:23:35,916 --> 00:23:37,651
这是 MedicalConditionView

447
00:23:37,651 --> 00:23:42,422
它显示每个单元格内的病症文本

448
00:23:42,422 --> 00:23:44,892
现在这个文本是只读的

449
00:23:44,892 --> 00:23:47,594
我们要让它变成可编辑的

450
00:23:47,594 --> 00:23:52,399
我们需要做的就是
将 Text 视图更改为 TextField

451
00:23:52,399 --> 00:23:54,935
并通过添加 $ 符号前缀

452
00:23:54,935 --> 00:23:59,439
创建 MedicalCondition
文本属性的绑定

453
00:23:59,439 --> 00:24:01,141
当您在 TextField 中键入时

454
00:24:01,141 --> 00:24:04,645
此绑定允许 SwiftUI

455
00:24:04,645 --> 00:24:07,481
直接将更改写回到
ObservableObject

456
00:24:07,481 --> 00:24:09,183
使用 SwiftUI 设置双向数据流

457
00:24:09,183 --> 00:24:14,454
就是这么简单

458
00:24:14,454 --> 00:24:16,924
UIHostingController 非常强大

459
00:24:16,924 --> 00:24:21,595
可将 SwiftUI 内容
嵌入到 UIKit App 中

460
00:24:21,595 --> 00:24:23,397
您的 SwiftUI 视图

461
00:24:23,397 --> 00:24:25,832
在托管控制器的视图内渲染

462
00:24:25,832 --> 00:24:27,601
并且只要可以
在 UIKit 中使用视图控制器

463
00:24:27,601 --> 00:24:33,440
就可以使用托管控制器

464
00:24:33,440 --> 00:24:35,342
使用 UIHostingController 时

465
00:24:35,342 --> 00:24:37,945
请务必在 App 中

466
00:24:37,945 --> 00:24:41,381
添加视图控制器和视图

467
00:24:41,381 --> 00:24:45,752
许多 SwiftUI 功能 比如
工具栏、键盘快捷键

468
00:24:45,752 --> 00:24:49,089
以及使用了 UIViewControllerRepresentable
的视图

469
00:24:49,089 --> 00:24:51,992
需要连接到 UIKit 中的
视图控制器层次结构

470
00:24:51,992 --> 00:24:54,995
以正确集成

471
00:24:54,995 --> 00:24:57,664
所以切勿将托管控制器视图

472
00:24:57,664 --> 00:25:01,168
和托管控制器本身分隔开来

473
00:25:01,168 --> 00:25:03,070
为了形成对比

474
00:25:03,070 --> 00:25:05,939
在将 UIHostingConfiguration
应用于单元格时

475
00:25:05,939 --> 00:25:08,308
您的 SwiftUI 视图
会托管在单元格中

476
00:25:08,308 --> 00:25:11,111
而没有 UIViewController

477
00:25:11,111 --> 00:25:14,081
UIHostingConfiguration
支持绝大多数

478
00:25:14,081 --> 00:25:16,049
SwiftUI 功能

479
00:25:16,049 --> 00:25:18,285
但请记住 依赖于
UIViewControllerRepresentable

480
00:25:18,285 --> 00:25:20,988
的 SwiftUI 视图

481
00:25:20,988 --> 00:25:23,590
不能在单元格内使用

482
00:25:23,590 --> 00:25:26,860
在 UIHostingController
和 UIHostingConfiguration 的帮助下

483
00:25:26,860 --> 00:25:29,897
您可以通过两种绝佳方式

484
00:25:29,897 --> 00:25:32,966
将 SwiftUI 整合到
UIKit App 中

485
00:25:32,966 --> 00:25:37,638
SwiftUI 可无缝集成
到现有的 UIKit App 中

486
00:25:37,638 --> 00:25:42,943
使用 UIHostingController
在整个 App 中添加 SwiftUI

487
00:25:42,943 --> 00:25:46,046
使用 UIHostingConfiguration
在集合和表格视图

488
00:25:46,046 --> 00:25:49,449
中创建自定义单元格

489
00:25:49,449 --> 00:25:51,952
并利用 ObservableObject

490
00:25:51,952 --> 00:25:55,422
使数据和 UI 始终保持同步

491
00:25:55,422 --> 00:25:59,259
立即将 SwiftUI
添加到您的 App 中吧！

492
00:25:59,259 --> 00:26:00,727
谢谢收看！

493
00:26:00,727 --> 00:26:05,566
♪

