1
00:00:00,234 --> 00:00:03,470
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,470 --> 00:00:09,409
♪

3
00:00:09,409 --> 00:00:13,280
欢迎收看
“静候高效：SwiftUI 的后台任务”

4
00:00:13,280 --> 00:00:17,050
我是 watchOS 框架团队
的工程师 John Gallagher

5
00:00:17,050 --> 00:00:20,420
本期视频将介绍
一个全新 SwiftUI API

6
00:00:20,420 --> 00:00:22,990
该 API 可运用 Swift 并发性
来处理后台任务

7
00:00:22,990 --> 00:00:26,493
且在 Apple 的所有平台上
都能够平稳运行

8
00:00:26,493 --> 00:00:29,930
首先 我们将以一款名为
Stormy 的 App 作为示例

9
00:00:29,930 --> 00:00:32,599
该 App 专用于
在暴风雨天气拍摄天空

10
00:00:32,599 --> 00:00:36,236
其中就用到了后台任务

11
00:00:36,236 --> 00:00:39,940
接着 我们将深入了解
App 是如何使用后台任务的

12
00:00:39,940 --> 00:00:44,811
后台任务又是如何在幕后工作的

13
00:00:44,811 --> 00:00:48,081
接下去 我们将介绍
如何使用新的 SwiftUI API

14
00:00:48,081 --> 00:00:52,319
来处理后台任务

15
00:00:52,319 --> 00:00:57,124
最后是回顾该 API
如何通过运用 Swift 并发性

16
00:00:57,124 --> 00:01:03,096
将后台任务简化到了前所未有的程度

17
00:01:03,096 --> 00:01:07,568
新的 API 在多种平台通用
如 watchOS iOS tvOS

18
00:01:07,568 --> 00:01:09,503
Mac Catalyst 和小组件

19
00:01:09,503 --> 00:01:11,972
包括运行于 Mac 的 iOS App

20
00:01:11,972 --> 00:01:13,874
也就是说 您学会在一个平台

21
00:01:13,874 --> 00:01:15,976
处理后台任务后

22
00:01:15,976 --> 00:01:19,046
其概念和模式也适用于其他平台

23
00:01:19,046 --> 00:01:22,683
新 API 通过 Swift 并发性

24
00:01:22,683 --> 00:01:25,319
减少了深度嵌套的
完成处理程序及回调的需要

25
00:01:25,319 --> 00:01:26,987
因此也自然而然地

26
00:01:26,987 --> 00:01:29,923
减少了大部分可变状态

27
00:01:29,923 --> 00:01:32,492
有了 Swift 并发性原生的
任务取消功能

28
00:01:32,492 --> 00:01:35,863
App 能够以合适方式
及时完成任务

29
00:01:35,863 --> 00:01:40,100
不必被系统关闭后台进程

30
00:01:40,100 --> 00:01:42,402
我们所开发的这款
名为 Stormy 的 App

31
00:01:42,402 --> 00:01:44,338
适合爱好拍摄云层的用户

32
00:01:44,338 --> 00:01:46,507
该 App 能够在
风雨即将到来的时候

33
00:01:46,507 --> 00:01:49,076
提醒用户拍摄时机

34
00:01:49,076 --> 00:01:51,945
如果当天有暴风雨
该 App 将在中午显示通知

35
00:01:51,945 --> 00:01:56,884
提醒用户拍摄天空

36
00:01:56,884 --> 00:01:58,719
用户只需要点击通知

37
00:01:58,719 --> 00:02:01,121
就能够拍摄天空
并将照片上传到个人资料

38
00:02:01,121 --> 00:02:03,090
以供日后欣赏

39
00:02:03,090 --> 00:02:07,561
这张照片将在后台上传

40
00:02:07,561 --> 00:02:09,196
上传完成后

41
00:02:09,196 --> 00:02:11,965
该 App 会再次通知

42
00:02:11,965 --> 00:02:15,602
让我们深入了解下
后台任务是如何做到的

43
00:02:15,602 --> 00:02:18,372
我们将运用这张图表
站在更高层次观察

44
00:02:18,372 --> 00:02:20,274
看看如何运用后台任务

45
00:02:20,274 --> 00:02:23,677
做到只在暴风雨天气发送通知

46
00:02:23,677 --> 00:02:26,280
我们将用左边的进度条

47
00:02:26,280 --> 00:02:28,282
表示 App 的前台运行时间

48
00:02:28,282 --> 00:02:32,219
中间的进度条表示
App 后台运行时间

49
00:02:32,219 --> 00:02:36,857
右侧的则是系统运行时间

50
00:02:36,857 --> 00:02:40,027
当该 App 第一次被前台启动时

51
00:02:40,027 --> 00:02:41,728
这是我们的第一个时机

52
00:02:41,728 --> 00:02:46,834
可以安排一个中午时
后台刷新 App 的任务

53
00:02:46,834 --> 00:02:50,971
由此 当 App
因用户退出被暂停时

54
00:02:50,971 --> 00:02:53,540
系统将按照预定的时间

55
00:02:53,540 --> 00:02:57,544
在后台再次唤醒我们的 App

56
00:02:57,544 --> 00:02:59,913
我们把任务安排在中午

57
00:02:59,913 --> 00:03:02,416
这样系统就会
按时在后台唤醒 App

58
00:03:02,416 --> 00:03:07,421
并发送后台 App 刷新任务

59
00:03:07,421 --> 00:03:08,922
安排好了后台运行时间

60
00:03:08,922 --> 00:03:11,325
接下来 我们需要弄清楚
外面是否是暴风雨天气

61
00:03:11,325 --> 00:03:16,029
确认后再向用户发送通知

62
00:03:16,029 --> 00:03:19,366
一开始 我们将向天气服务
发出网络请求

63
00:03:19,366 --> 00:03:22,703
来检查当前天气

64
00:03:22,703 --> 00:03:25,272
URL 会话已经安排在后台

65
00:03:25,272 --> 00:03:26,974
App 可以暂停

66
00:03:26,974 --> 00:03:30,711
以等待网络请求完成

67
00:03:30,711 --> 00:03:32,179
当获取天气数据的请求

68
00:03:32,179 --> 00:03:33,780
在后台完成后

69
00:03:33,780 --> 00:03:36,850
我们的 App 将
使用新的 URL 会话任务

70
00:03:36,850 --> 00:03:41,855
在后台继续运行

71
00:03:41,855 --> 00:03:44,892
有了天气数据请求的结果

72
00:03:44,892 --> 00:03:47,961
我们的 App 就知道了
是否有暴风雨天气

73
00:03:47,961 --> 00:03:50,097
并且可以选择是否发送通知

74
00:03:50,097 --> 00:03:55,602
来提醒用户拍摄天空照片

75
00:03:55,602 --> 00:03:58,672
现在 那个 URL 任务的工作
已经完成

76
00:03:58,672 --> 00:04:02,943
系统可以再次暂停 App

77
00:04:02,943 --> 00:04:06,013
让我们继续深入
看看单个后台任务的详情

78
00:04:06,013 --> 00:04:07,814
看看它是如何工作的

79
00:04:07,814 --> 00:04:11,351
为此 需要仔细观察
单个 App 刷新

80
00:04:11,351 --> 00:04:14,321
后台任务的生命周期

81
00:04:14,321 --> 00:04:19,026
来把这里放大一点

82
00:04:19,026 --> 00:04:21,962
首先 系统会唤醒我们的 App

83
00:04:21,962 --> 00:04:25,732
并向其发送 App 刷新后台任务

84
00:04:25,732 --> 00:04:29,236
然后 我们在后台继续发出网络请求

85
00:04:29,236 --> 00:04:32,840
查看外面是否为暴风雨天气

86
00:04:32,840 --> 00:04:35,776
理想情况下
在分配给该 App 刷新

87
00:04:35,776 --> 00:04:38,745
的后台运行时时间内

88
00:04:38,745 --> 00:04:41,949
网络请求就能完成

89
00:04:41,949 --> 00:04:43,650
得到网络响应后

90
00:04:43,650 --> 00:04:47,154
就可以立即发布通知

91
00:04:47,154 --> 00:04:48,856
通知发出后

92
00:04:48,856 --> 00:04:52,192
刷新期间需要做的事情都已完成

93
00:04:52,192 --> 00:04:56,296
系统可以再次暂停 App

94
00:04:56,296 --> 00:04:59,233
但是 如果获取天气数据的请求

95
00:04:59,233 --> 00:05:02,069
没有及时完成呢？

96
00:05:02,069 --> 00:05:04,838
如果 App 在处理当前任务时

97
00:05:04,838 --> 00:05:06,240
后台运行时间不足

98
00:05:06,240 --> 00:05:08,942
系统会向 App 发出
时间不足的信号

99
00:05:08,942 --> 00:05:13,113
提醒我们好好处理这种情况

100
00:05:13,113 --> 00:05:15,516
如果在后台运作时间结束之前

101
00:05:15,516 --> 00:05:18,118
App 尚未发出任务完成信号

102
00:05:18,118 --> 00:05:20,721
App 可能会被系统退出

103
00:05:20,721 --> 00:05:24,525
也无法发送未来的后台任务请求

104
00:05:24,525 --> 00:05:27,427
在这种情况下 应该要
确保我们的网络请求

105
00:05:27,427 --> 00:05:29,830
是后台网络请求

106
00:05:29,830 --> 00:05:33,233
才能够立即完成 App 刷新任务

107
00:05:33,233 --> 00:05:34,468
然后再次唤醒

108
00:05:34,468 --> 00:05:36,103
来争取额外的后台运行时间

109
00:05:36,103 --> 00:05:39,840
直到网络请求完成

110
00:05:39,840 --> 00:05:42,075
后台 URL 会话安排下去后

111
00:05:42,075 --> 00:05:45,646
系统可以再次暂停 App

112
00:05:45,646 --> 00:05:49,783
接下来 让我们深入了解
SwiftUI 的后台任务 API

113
00:05:49,783 --> 00:05:52,686
是如何帮助我们
构建 Stormy 的

114
00:05:52,686 --> 00:05:56,356
首先 我们需要一个基础 App

115
00:05:56,356 --> 00:06:00,294
然后 我们将编写一个函数
来让后台 App

116
00:06:00,294 --> 00:06:02,796
在明天中午刷新

117
00:06:02,796 --> 00:06:07,601
先创建一个代表明天中午的日期

118
00:06:07,601 --> 00:06:10,904
接着创建一个
后台 App 刷新请求

119
00:06:10,904 --> 00:06:13,407
最早开始日期为明天中午

120
00:06:13,407 --> 00:06:15,742
将其提交给调度程序

121
00:06:15,742 --> 00:06:18,078
这样 就能够让系统在明天中午

122
00:06:18,078 --> 00:06:21,014
唤醒 App

123
00:06:21,014 --> 00:06:22,916
我们想要在用户
第一次打开 App 时

124
00:06:22,916 --> 00:06:25,118
以及每天中午请求天气数据的时候

125
00:06:25,118 --> 00:06:29,122
调用这个函数

126
00:06:29,122 --> 00:06:31,225
我们可以使用
新的后台任务场景修饰符

127
00:06:31,225 --> 00:06:32,860
来注册一个和已安排后台任务

128
00:06:32,860 --> 00:06:38,098
相对应的处理程序

129
00:06:38,098 --> 00:06:40,367
当 App 收到后台任务时

130
00:06:40,367 --> 00:06:42,636
使用此修饰符注册的块会开始运行

131
00:06:42,636 --> 00:06:46,440
而该修饰符必须
与收到的后台任务匹配

132
00:06:46,440 --> 00:06:50,177
在本例中 我们使用的
任务类型是 appRefresh

133
00:06:50,177 --> 00:06:51,745
该类型可以提前安排

134
00:06:51,745 --> 00:06:54,448
来为 App 在指定日期

135
00:06:54,448 --> 00:06:57,584
提供一定的后台运行时间

136
00:06:57,584 --> 00:06:59,953
请求和后台任务修饰符中的处理程序

137
00:06:59,953 --> 00:07:02,823
使用相同的标识符

138
00:07:02,823 --> 00:07:05,592
这样能够在您的
App 收到相应任务时

139
00:07:05,592 --> 00:07:10,731
让系统识别出要调用的处理程序

140
00:07:10,731 --> 00:07:12,266
为了能够保证

141
00:07:12,266 --> 00:07:14,134
下一天继续安排任务

142
00:07:14,134 --> 00:07:16,370
我们将通过调用刚刚编写的
scheduleAppRefresh 函数

143
00:07:16,370 --> 00:07:19,339
来启动我们的后台任务

144
00:07:19,339 --> 00:07:24,912
好在明天中午
再次安排后台运行时间

145
00:07:24,912 --> 00:07:28,282
现在 安排在中午的
后台任务再次启动了

146
00:07:28,282 --> 00:07:29,783
提出网络请求

147
00:07:29,783 --> 00:07:31,718
检查外面是否有暴风雨

148
00:07:31,718 --> 00:07:36,323
并使用 Swift 关键字
await 来等待结果

149
00:07:36,323 --> 00:07:38,859
那么 如果网络请求返回后显示

150
00:07:38,859 --> 00:07:40,928
确实是暴风雨天气

151
00:07:40,928 --> 00:07:43,697
就可以等着向用户发送通知

152
00:07:43,697 --> 00:07:46,834
提醒他们上传天空照片

153
00:07:46,834 --> 00:07:48,902
当我们的闭包体返回时

154
00:07:48,902 --> 00:07:50,404
系统分配给我们 App 的

155
00:07:50,404 --> 00:07:52,306
底层后台任务

156
00:07:52,306 --> 00:07:54,708
将被隐式标记为完成

157
00:07:54,708 --> 00:07:58,512
系统可以再次暂停我们的 App

158
00:07:58,512 --> 00:08:01,748
使用 Swift 并发性
可以在有需要时

159
00:08:01,748 --> 00:08:04,251
进行需要长时间操作的后台任务

160
00:08:04,251 --> 00:08:06,420
且无需在工作完成时

161
00:08:06,420 --> 00:08:08,589
进行显式回调

162
00:08:08,589 --> 00:08:11,024
Apple 平台上的许多 API

163
00:08:11,024 --> 00:08:12,726
例如添加通知

164
00:08:12,726 --> 00:08:14,661
已经支持将 Swift 并发

165
00:08:14,661 --> 00:08:16,830
用于异步操作

166
00:08:16,830 --> 00:08:20,000
这是照片 notifyForPhoto

167
00:08:20,000 --> 00:08:22,135
直接就可以使用

168
00:08:22,135 --> 00:08:24,805
使用的异步添加通知方法

169
00:08:24,805 --> 00:08:29,076
可以在 UserNotificationCenter 找到

170
00:08:29,076 --> 00:08:32,513
让我们深入说说 该如何在一些
繁重工作中应用

171
00:08:32,513 --> 00:08:34,314
Swift 并发性和异步/等待

172
00:08:34,314 --> 00:08:38,452
让处理后台任务变得比以往更容易

173
00:08:38,452 --> 00:08:41,121
还是使用本期的示例

174
00:08:41,121 --> 00:08:43,490
让我们编写异步 isStormy 函数

175
00:08:43,490 --> 00:08:46,293
异步功能需要发出网络请求

176
00:08:46,293 --> 00:08:49,563
来检查外面的天气

177
00:08:49,563 --> 00:08:52,199
首先 我们将获得
共享的 URL 会话

178
00:08:52,199 --> 00:08:56,336
并实例化对天气数据的请求

179
00:08:56,336 --> 00:08:59,006
URL 会话
采用了 Swift 并发

180
00:08:59,006 --> 00:09:01,275
并且可以从异步上下文中等待的网络

181
00:09:01,275 --> 00:09:06,480
下载数据

182
00:09:06,480 --> 00:09:08,582
有了网络响应

183
00:09:08,582 --> 00:09:12,786
我们可以读取天气数据并返回结果

184
00:09:12,786 --> 00:09:14,788
但是当我们的 App

185
00:09:14,788 --> 00:09:16,657
无法运行时间到期之前

186
00:09:16,657 --> 00:09:19,927
完成网络请求的话该怎么办呢

187
00:09:19,927 --> 00:09:23,297
回想一下 在这种情况下需要保证

188
00:09:23,297 --> 00:09:27,167
已经将 URL 会话
设置为后台会话

189
00:09:27,167 --> 00:09:30,103
并确保其将使用
URL 会话后台任务

190
00:09:30,103 --> 00:09:34,441
把启动事件发送到 App

191
00:09:34,441 --> 00:09:37,010
回到代码

192
00:09:37,010 --> 00:09:41,448
我们使用了共享的 URL 会话

193
00:09:41,448 --> 00:09:44,451
相反 我们这次应该从后台配置

194
00:09:44,451 --> 00:09:46,954
创建一个 URL 会话

195
00:09:46,954 --> 00:09:51,191
且将 sessionSendsLaunchEvents
属性设置为 true

196
00:09:51,191 --> 00:09:54,661
以此 即使 App 暂停
也能让系统

197
00:09:54,661 --> 00:09:58,398
运行部分网络请求
然后唤醒 App

198
00:09:58,398 --> 00:10:02,903
继续完成 URL 会话后台任务

199
00:10:02,903 --> 00:10:06,373
请注意 这在
watchOS 上尤为重要

200
00:10:06,373 --> 00:10:09,409
因为在 watchOS 上
后台 App 的所有网络请求

201
00:10:09,409 --> 00:10:16,049
都必须通过
后台 URL 会话进行请求

202
00:10:16,049 --> 00:10:18,318
不过 目前为止还没有完成

203
00:10:18,318 --> 00:10:22,322
回想一下 当后台任务运行时到期时

204
00:10:22,322 --> 00:10:24,391
系统将取消异步任务

205
00:10:24,391 --> 00:10:26,026
而该任务正在运行

206
00:10:26,026 --> 00:10:28,929
提供给后台任务修饰符的闭包

207
00:10:28,929 --> 00:10:32,466
这意味着 后台运行时到期时

208
00:10:32,466 --> 00:10:38,772
从这里发出的网络请求也将被取消

209
00:10:38,772 --> 00:10:41,041
为了对任务取消进行响应和处理

210
00:10:41,041 --> 00:10:43,810
我们可以使用
Swift 并发内置的

211
00:10:43,810 --> 00:10:47,114
withTaskCancellationHandler
即 任务取消处理程序函数

212
00:10:47,114 --> 00:10:49,483
而不是单单等待结果

213
00:10:49,483 --> 00:10:54,721
我们将下载放入
withTaskCancellationHandler 的调用中

214
00:10:54,721 --> 00:10:57,057
和其他的一起等待

215
00:10:57,057 --> 00:11:00,327
传递给 withTaskCancellationHandler
的第一个块

216
00:11:00,327 --> 00:11:03,897
是我们想要运行和等待的异步过程

217
00:11:03,897 --> 00:11:07,768
第二个尾随闭包的
onCancel 是将运行的代码

218
00:11:07,768 --> 00:11:10,237
当任务被取消时

219
00:11:10,237 --> 00:11:13,507
看这里 当即时网络请求

220
00:11:13,507 --> 00:11:15,442
由于运行时间到期被取消时

221
00:11:15,442 --> 00:11:19,112
将网络请求提升为后台下载任务

222
00:11:19,112 --> 00:11:20,647
可以用于调用恢复

223
00:11:20,647 --> 00:11:23,150
触发即使 App 暂停

224
00:11:23,150 --> 00:11:26,286
也会继续运行的后台下载

225
00:11:26,286 --> 00:11:30,023
此代码没有发出两次底层网络请求

226
00:11:30,023 --> 00:11:33,227
因为背后使用的是
相同的 URL 会话

227
00:11:33,227 --> 00:11:36,930
而 URL 会话将在后台删除

228
00:11:36,930 --> 00:11:41,301
重复的进程中请求

229
00:11:41,301 --> 00:11:44,605
最后 需要确保
App 已完成设置

230
00:11:44,605 --> 00:11:48,275
以处理后台 URL 会话的启动

231
00:11:48,275 --> 00:11:51,078
我们可以再次使用后台任务修饰符

232
00:11:51,078 --> 00:11:54,781
但这次是 URL 会话任务类型

233
00:11:54,781 --> 00:11:56,483
通过使用和之前的

234
00:11:56,483 --> 00:11:59,887
后台 URL 会话
配置相同的标识符

235
00:11:59,887 --> 00:12:02,756
我们可以确保这个块只在

236
00:12:02,756 --> 00:12:08,662
特定的 URL 会话产生
后台任务时被调用

237
00:12:08,662 --> 00:12:12,132
我们已经深入了解了
用于处理后台任务的

238
00:12:12,132 --> 00:12:13,767
全新统一 SwiftUI API

239
00:12:13,767 --> 00:12:16,303
也知道了 Swift 并发性
如何简化了

240
00:12:16,303 --> 00:12:20,607
管理任务完成和到期的过程

241
00:12:20,607 --> 00:12:23,377
有关 Swift 并发的更多信息

242
00:12:23,377 --> 00:12:25,946
请查看 WWDC 2021 讲话

243
00:12:25,946 --> 00:12:29,049
“Swift 中的异步/等待”

244
00:12:29,049 --> 00:12:31,385
要了解更多 SwiftUI
并发性相关信息

245
00:12:31,385 --> 00:12:34,054
推荐收看同样是
WWDC 2021 讲话的

246
00:12:34,054 --> 00:12:37,090
“在 SwiftUI 中发现并发”

247
00:12:37,090 --> 00:12:38,091
感谢收看

248
00:12:38,091 --> 00:12:41,795
“静候高效：SwiftUI 的后台任务”

249
00:12:41,795 --> 00:12:46,133
♪

