1
00:00:00,267 --> 00:00:03,270
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,270 --> 00:00:09,843
♪

3
00:00:09,843 --> 00:00:10,944
大家好

4
00:00:10,944 --> 00:00:14,414
我是 SwiftUI 团队的
工程师 Jeff

5
00:00:14,414 --> 00:00:16,149
今天 我很高兴与您讨论

6
00:00:16,149 --> 00:00:19,520
如何在 iPadOS 和 macOS 上
为您的 SwiftUI App

7
00:00:19,520 --> 00:00:22,756
引入多个窗口

8
00:00:22,756 --> 00:00:25,659
在本期视频中 我们将从

9
00:00:25,659 --> 00:00:29,162
SwiftUI 生命周期中
各种场景类型的概览开始

10
00:00:29,162 --> 00:00:32,799
其中包括我们
正在引入的一些新类型

11
00:00:32,799 --> 00:00:35,135
接下来展示这些场景类型如何

12
00:00:35,135 --> 00:00:39,573
通过添加辅助场景组合在一起

13
00:00:39,573 --> 00:00:42,643
然后我们将介绍
一些用于在您的 App 中

14
00:00:42,643 --> 00:00:45,512
为特定场景打开窗口的新 API

15
00:00:45,512 --> 00:00:47,447
我们将用几种方法来

16
00:00:47,447 --> 00:00:51,018
自定义 App 的场景

17
00:00:51,018 --> 00:00:54,388
在深入研究一些新类型之前

18
00:00:54,388 --> 00:00:57,057
我们先从现有场景类型的概览开始

19
00:00:57,057 --> 00:01:00,894
您还记得在之前的视频中
SwiftUI 中的 App

20
00:01:00,894 --> 00:01:03,730
是由场景和视图组成

21
00:01:03,730 --> 00:01:08,001
场景通常用屏幕上的
窗口来展示其中的内容

22
00:01:08,001 --> 00:01:10,170
例如 这是我构建的一个 App

23
00:01:10,170 --> 00:01:12,206
我用它跟踪我正在阅读的书籍

24
00:01:12,206 --> 00:01:14,274
我将其定义为单个窗口组

25
00:01:14,274 --> 00:01:17,811
以适合平台的方式
显示我的阅读列表

26
00:01:17,811 --> 00:01:20,581
在支持多个窗口的平台上

27
00:01:20,581 --> 00:01:22,983
例如 iPadOS
和 macOS

28
00:01:22,983 --> 00:01:26,753
可以使用多个窗口
来展示一个场景中的内容

29
00:01:26,753 --> 00:01:30,123
场景的行为和表现形式

30
00:01:30,123 --> 00:01:32,359
根据使用的类型不尽相同

31
00:01:32,359 --> 00:01:35,262
例如 一个场景可能只用一个实例

32
00:01:35,262 --> 00:01:36,930
便可展示自身内容

33
00:01:36,930 --> 00:01:39,433
而无论平台能力如何

34
00:01:39,433 --> 00:01:41,869
我们来看看
SwiftUI 中当前的

35
00:01:41,869 --> 00:01:43,136
场景类型列表

36
00:01:43,136 --> 00:01:47,007
WindowGroup 提供了
一种跨 Apple 平台构建

37
00:01:47,007 --> 00:01:49,776
数据驱动 App 的方法

38
00:01:49,776 --> 00:01:52,513
DocumentGroup
可让您在 iOS 和 macOS 上

39
00:01:52,513 --> 00:01:54,848
构建基于文档的 App

40
00:01:54,848 --> 00:01:57,050
并且 Settings 定义了
一个接口

41
00:01:57,050 --> 00:02:01,288
用于表示 macOS
上的 App 内设置值

42
00:02:01,288 --> 00:02:03,290
这些场景类型可以组合在一起

43
00:02:03,290 --> 00:02:05,492
来扩展您 App 的功能

44
00:02:05,492 --> 00:02:08,996
我们正在通过两个
新增内容扩展场景列表

45
00:02:08,996 --> 00:02:12,432
第一个是 Window
一个代表所有平台上

46
00:02:12,432 --> 00:02:16,403
单个 唯一窗口的场景

47
00:02:16,403 --> 00:02:20,374
以及适用于 macOS 的
新场景类型：MenuBarExtra

48
00:02:20,374 --> 00:02:24,578
在系统菜单栏中呈现为持久控件

49
00:02:24,578 --> 00:02:26,180
与其他场景类型一样

50
00:02:26,180 --> 00:02:27,915
您可以将
Window 和 MenuBarExtra

51
00:02:27,915 --> 00:02:30,450
作为独立的场景使用

52
00:02:30,450 --> 00:02:33,253
或与您 App 中的其他场景组合

53
00:02:33,253 --> 00:02:36,523
与 WindowGroup 不同的是
Window 场景只会以单一

54
00:02:36,523 --> 00:02:41,261
唯一的窗口实例展示其中的内容

55
00:02:41,261 --> 00:02:43,063
此特性会很有用

56
00:02:43,063 --> 00:02:46,500
体现在当您的场景
内容代表某个全局 App 状态

57
00:02:46,500 --> 00:02:48,969
且不一定适合

58
00:02:48,969 --> 00:02:52,806
macOS
和 iPadOS 上的

59
00:02:52,806 --> 00:02:54,908
WindowGroups
多窗口演示样式

60
00:02:54,908 --> 00:02:58,011
例如 游戏可能只允许

61
00:02:58,011 --> 00:03:01,315
单个主窗口来呈现其内容

62
00:03:01,315 --> 00:03:04,751
MenuBarExtra 是一种
新的 macOS 专用场景类型

63
00:03:04,751 --> 00:03:06,286
其与其他场景

64
00:03:06,286 --> 00:03:08,088
行为略有不同

65
00:03:08,088 --> 00:03:10,891
MenuBarExtra 不会
在窗口中呈现其内容

66
00:03:10,891 --> 00:03:13,560
而是将其标签放在菜单栏中

67
00:03:13,560 --> 00:03:17,431
并将其内容显示在锚定到标签上的

68
00:03:17,431 --> 00:03:19,333
菜单或窗口中

69
00:03:19,333 --> 00:03:21,435
此外 只要其关联 App
正在运行

70
00:03:21,435 --> 00:03:24,671
就可以使用
MenuBarExtra

71
00:03:24,671 --> 00:03:27,474
无论该 App 是否位于最前端

72
00:03:27,474 --> 00:03:31,512
MenuBarExtra 非常
适合创建可轻松访问其功能的

73
00:03:31,512 --> 00:03:34,481
独立实用 App

74
00:03:34,481 --> 00:03:36,450
或者可以与其他场景组合

75
00:03:36,450 --> 00:03:41,321
提供访问 App 功能的替代方式

76
00:03:41,321 --> 00:03:45,225
它还支持两种
渲染风格：一是默认风格

77
00:03:45,225 --> 00:03:47,594
可在菜单中显示内容

78
00:03:47,594 --> 00:03:50,364
改菜单从菜单栏下拉显示

79
00:03:50,364 --> 00:03:53,500
以及在锚定到菜单栏的无镶边窗口中

80
00:03:53,500 --> 00:03:56,904
显示其内容的风格

81
00:03:56,904 --> 00:03:59,873
随着这两种新场景类型的加入

82
00:03:59,873 --> 00:04:04,077
SwiftUI App
可以代表我们平台上

83
00:04:04,077 --> 00:04:07,047
更丰富的功能集

84
00:04:07,047 --> 00:04:09,816
让我们看看如何将这些新的 API

85
00:04:09,816 --> 00:04:13,320
与我们现有的场景类型结合使用

86
00:04:13,320 --> 00:04:15,289
这是我的 BookClub App 的定义

87
00:04:15,289 --> 00:04:17,024
我之前展示过

88
00:04:17,024 --> 00:04:19,826
其目前包含一个窗口组

89
00:04:19,826 --> 00:04:22,696
在 macOS 上
我的 BookClub App 可能

90
00:04:22,696 --> 00:04:24,431
受益于一个额外的窗口

91
00:04:24,431 --> 00:04:27,201
来显示我们的阅读活动

92
00:04:27,201 --> 00:04:31,271
这是一个很好的例子
其说明了 macOS App 如何利用

93
00:04:31,271 --> 00:04:33,240
该平台上存在的

94
00:04:33,240 --> 00:04:35,209
额外屏幕空间

95
00:04:35,209 --> 00:04:37,177
和灵活的窗口安排

96
00:04:37,177 --> 00:04:39,146
我们将在我们的
App 中添加一个辅助场景

97
00:04:39,146 --> 00:04:41,215
用于表示此界面

98
00:04:41,215 --> 00:04:43,584
我们的 Activity 窗口
数据来自

99
00:04:43,584 --> 00:04:45,719
我们的整体 App 状态

100
00:04:45,719 --> 00:04:48,856
所以窗口场景便是其理想选择

101
00:04:48,856 --> 00:04:50,657
打开多个具有相同状态的窗口

102
00:04:50,657 --> 00:04:52,726
不符合我们的设计

103
00:04:52,726 --> 00:04:55,963
提供给我们场景的
标题将用作菜单项的标签

104
00:04:55,963 --> 00:05:00,834
该菜单项已
添加到 Window 菜单部分

105
00:05:00,834 --> 00:05:04,137
选择此项时
如果尚未打开场景的窗口

106
00:05:04,137 --> 00:05:05,873
则会将其打开

107
00:05:05,873 --> 00:05:08,408
否则 会将其带到前端

108
00:05:08,408 --> 00:05:10,544
现在我们已经
介绍了将辅助场景添加到

109
00:05:10,544 --> 00:05:12,179
我们的 BookClub App

110
00:05:12,179 --> 00:05:15,249
我想介绍一些我们
即将推出的新的场景呈现 API

111
00:05:15,249 --> 00:05:18,318
以及如何将其
集成到您的 App 中

112
00:05:18,318 --> 00:05:21,221
来提供更丰富的体验

113
00:05:21,221 --> 00:05:24,358
我们的 BookClub App
具有一个上下文菜单

114
00:05:24,358 --> 00:05:26,693
可以为我们的
“内容列表”窗格中的任何书籍调用

115
00:05:26,693 --> 00:05:28,829
此上下文菜单包含一个按钮

116
00:05:28,829 --> 00:05:31,465
用于触发我们的窗口展示

117
00:05:31,465 --> 00:05:33,500
稍后我会详解介绍

118
00:05:33,500 --> 00:05:36,170
SwiftUI 通过环境
提供了几种

119
00:05:36,170 --> 00:05:39,039
新的可调用类型 用于呈现

120
00:05:39,039 --> 00:05:41,909
与您的 App 定义的
场景相关联的窗口

121
00:05:41,909 --> 00:05:44,578
第一个是
openWindow 操作

122
00:05:44,578 --> 00:05:45,712
可为 WindowGroup

123
00:05:45,712 --> 00:05:49,216
或窗口场景呈现窗口

124
00:05:49,216 --> 00:05:52,653
传递给操作的标识符必须匹配

125
00:05:52,653 --> 00:05:56,056
您 App 中定义的场景的标识符

126
00:05:56,056 --> 00:06:00,060
openWindow 操作
也可以取一个演示值

127
00:06:00,060 --> 00:06:03,330
已呈现的场景将用该值显示其内容

128
00:06:03,330 --> 00:06:07,000
这种形式的操作
只有使用新初始化程序的

129
00:06:07,000 --> 00:06:10,204
WindowGroup 支持
稍后我将详细介绍

130
00:06:10,204 --> 00:06:12,339
值的类型必须匹配

131
00:06:12,339 --> 00:06:15,776
提供给场景初始化程序的类型

132
00:06:15,776 --> 00:06:17,945
呈现文档窗口的环境中

133
00:06:17,945 --> 00:06:22,349
还有两种可调用类型：
一是 newDocument 操作

134
00:06:22,349 --> 00:06:24,384
支持为
FileDocuments

135
00:06:24,384 --> 00:06:28,255
和 ReferenceFileDocuments
打开新的文档窗口

136
00:06:28,255 --> 00:06:31,358
该操作需要您 App 中
相应的 DocumentGroup

137
00:06:31,358 --> 00:06:34,895
定义为具有编辑角色

138
00:06:34,895 --> 00:06:37,397
提供给此操作的文档将在

139
00:06:37,397 --> 00:06:39,933
每次呈现窗口时创建

140
00:06:39,933 --> 00:06:43,237
为了显示由磁盘上
现有文件提供内容的

141
00:06:43,237 --> 00:06:45,772
文档窗口

142
00:06:45,772 --> 00:06:48,008
可以使用
openDocument 操作

143
00:06:48,008 --> 00:06:51,712
此操作需要一个
指向您要打开的文件的 URL

144
00:06:51,712 --> 00:06:53,747
您的 App 必须
定义一个用于展示窗口的

145
00:06:53,747 --> 00:06:55,282
DocumentGroup

146
00:06:55,282 --> 00:06:57,918
并且该组的文档类型必须允许

147
00:06:57,918 --> 00:07:01,588
在提供的 URL 处
读取文件的类型

148
00:07:01,588 --> 00:07:03,857
回到我们的按钮 我们将在

149
00:07:03,857 --> 00:07:06,860
我们的视图中添加
openWindow 环境属性

150
00:07:06,860 --> 00:07:10,097
由于这种类型是可调用的
我们可以直接

151
00:07:10,097 --> 00:07:11,965
从我们按钮的操作中调用

152
00:07:11,965 --> 00:07:15,102
我们的“书籍”类型是可识别的

153
00:07:15,102 --> 00:07:18,872
所以我们将其标识符
作为要呈现的值传递

154
00:07:18,872 --> 00:07:22,242
在我们继续之前 我想介绍传递到

155
00:07:22,242 --> 00:07:23,977
openWindow 操作的值

156
00:07:23,977 --> 00:07:26,980
我注意到我正在传递该书籍的标识符

157
00:07:26,980 --> 00:07:30,184
且该标识符是 UUID 类型的值

158
00:07:30,184 --> 00:07:32,986
一般来说 您更倾向于
用上述方式使用

159
00:07:32,986 --> 00:07:35,422
您模型的标识符

160
00:07:35,422 --> 00:07:37,424
而不使用值本身

161
00:07:37,424 --> 00:07:39,826
请注意 我们的
“书籍”类型是一个值类型

162
00:07:39,826 --> 00:07:43,530
因此 如果我们将其用作呈现值

163
00:07:43,530 --> 00:07:45,666
我们的新窗口将获得一份

164
00:07:45,666 --> 00:07:47,968
原始演示的副本

165
00:07:47,968 --> 00:07:50,904
对其中任何一个的编辑
都不会影响到另一个

166
00:07:50,904 --> 00:07:53,640
使用书籍的标识符让我们的模型存储

167
00:07:53,640 --> 00:07:56,310
成为这些值的真实来源

168
00:07:56,310 --> 00:07:59,379
而不是通过为单个值提供多个绑定

169
00:07:59,379 --> 00:08:01,548
有关值类型语义的更多信息

170
00:08:01,548 --> 00:08:03,750
请参阅开发者文档

171
00:08:03,750 --> 00:08:06,220
呈现的类型也必须符合

172
00:08:06,220 --> 00:08:10,123
Hashable
和 Codable 协议

173
00:08:10,123 --> 00:08:13,694
需要 Hashable 一致性
来将呈现的值

174
00:08:13,694 --> 00:08:15,195
和打开的窗口关联

175
00:08:15,195 --> 00:08:17,664
需要 Codable 一致性

176
00:08:17,664 --> 00:08:20,200
来保持状态恢复的

177
00:08:20,200 --> 00:08:21,502
呈现值

178
00:08:21,502 --> 00:08:23,036
稍后 我将更详细地

179
00:08:23,036 --> 00:08:24,872
介绍这两种行为

180
00:08:24,872 --> 00:08:29,109
最后 如果可以的话
尽量倾向于传递轻量级值

181
00:08:29,109 --> 00:08:32,446
我们书籍的标识符
也是一个很好的例子

182
00:08:32,446 --> 00:08:35,182
由于 SwiftUI 将保留该值

183
00:08:35,182 --> 00:08:38,118
以进行状态恢复 因此使用较小的值

184
00:08:38,118 --> 00:08:41,688
将提高您 App 的响应速度

185
00:08:41,688 --> 00:08:44,091
现在 我们的按钮具备了必要组件

186
00:08:44,091 --> 00:08:45,959
来呈现我们的详细窗口

187
00:08:45,959 --> 00:08:48,128
但是将其选择后不会显示任何内容

188
00:08:48,128 --> 00:08:51,498
这是因为我们
已告知 SwiftUI 呈现

189
00:08:51,498 --> 00:08:53,333
某种数据类型的窗口

190
00:08:53,333 --> 00:08:56,170
但尚未在我们的 App 中
定义反映这一点的场景

191
00:08:56,170 --> 00:08:58,505
我们回到我们的 App
并进行更改

192
00:08:58,505 --> 00:09:00,541
除了我们主要的
WindowGroup

193
00:09:00,541 --> 00:09:02,242
和辅助窗口

194
00:09:02,242 --> 00:09:04,178
我们还将添加一个
用于处理我们书籍详情的

195
00:09:04,178 --> 00:09:05,913
额外 WindowGroup

196
00:09:05,913 --> 00:09:09,583
我们的书籍详情 WindowGroup
使用的是一个新的初始化程序

197
00:09:09,583 --> 00:09:12,119
除了标题 我们还注意到该组

198
00:09:12,119 --> 00:09:15,022
显示 Book.ID 类型的数据

199
00:09:15,022 --> 00:09:16,957
在我们的例子则是 UUID

200
00:09:16,957 --> 00:09:19,593
此类型应与我们传递到之前添加的

201
00:09:19,593 --> 00:09:22,596
openWindow 操作的值
相匹配

202
00:09:22,596 --> 00:09:24,164
当向 WindowGroup 提供

203
00:09:24,164 --> 00:09:26,533
给定值用于演示时

204
00:09:26,533 --> 00:09:30,103
SwiftUI 将为该值
创建一个新的子场景

205
00:09:30,103 --> 00:09:32,406
并且该值将使用组的视图构建器

206
00:09:32,406 --> 00:09:36,944
定义场景窗口的根内容

207
00:09:36,944 --> 00:09:40,681
每个独特呈现的值将创造一个新场景

208
00:09:40,681 --> 00:09:43,584
该值的等同性将用于确定

209
00:09:43,584 --> 00:09:45,686
是否应该创建一个新窗口

210
00:09:45,686 --> 00:09:48,055
或者是否可以重新使用现有窗口

211
00:09:48,055 --> 00:09:50,190
当 openWindow 呈现一个

212
00:09:50,190 --> 00:09:53,093
已存在窗口的值时

213
00:09:53,093 --> 00:09:56,463
该组将使用该已存在窗口
而不会创建一个新窗口

214
00:09:56,463 --> 00:09:58,866
以我们的 BookClub App 为例

215
00:09:58,866 --> 00:10:01,502
为已经在窗口中呈现的书籍

216
00:10:01,502 --> 00:10:04,404
选择上下文菜单操作

217
00:10:04,404 --> 00:10:07,040
将导致该窗口被排在前面

218
00:10:07,040 --> 00:10:09,543
而不是显示同一本书的第二个窗口

219
00:10:09,543 --> 00:10:12,713
呈现的值也将由
SwiftUI 自动保留

220
00:10:12,713 --> 00:10:16,216
以用于状态恢复

221
00:10:16,216 --> 00:10:18,285
您的视图将被绑定到

222
00:10:18,285 --> 00:10:20,687
初始呈现值

223
00:10:20,687 --> 00:10:22,723
可在窗口打开时随时

224
00:10:22,723 --> 00:10:24,057
修改此绑定

225
00:10:24,057 --> 00:10:26,927
当重新创建场景以进行状态恢复时

226
00:10:26,927 --> 00:10:29,429
SwiftUI 将
向窗口的内容视图

227
00:10:29,429 --> 00:10:31,932
传递最新的值

228
00:10:31,932 --> 00:10:36,336
在此 我们将 Book.ID
绑定到我们的详细视图

229
00:10:36,336 --> 00:10:38,572
该视图可以查找我们模型存储中的

230
00:10:38,572 --> 00:10:40,707
指定项以用于显示

231
00:10:40,707 --> 00:10:42,342
随着我们所有的组件都准备到位

232
00:10:42,342 --> 00:10:45,212
现在我们可以选择上下文菜单项

233
00:10:45,212 --> 00:10:48,115
并在单独的窗口中查看书籍详情

234
00:10:48,115 --> 00:10:50,684
最后 我想介绍一些

235
00:10:50,684 --> 00:10:54,321
可以让您在 App 中
自定义场景的方法

236
00:10:54,321 --> 00:10:57,591
由于我们用两个 WindowGroup
场景定义了我们的 App

237
00:10:57,591 --> 00:10:59,193
一个用于主查看器窗口

238
00:10:59,193 --> 00:11:01,161
另一个用于我们的详情窗口

239
00:11:01,161 --> 00:11:04,298
所以 SwiftUI 会
默认为“文件”菜单中的

240
00:11:04,298 --> 00:11:06,633
每个组添加菜单项

241
00:11:06,633 --> 00:11:08,235
但是 我们详情窗口的菜单项

242
00:11:08,235 --> 00:11:10,671
不太适合我们的用例

243
00:11:10,671 --> 00:11:13,407
我更倾向于只能通过

244
00:11:13,407 --> 00:11:16,376
之前添加的上下文菜单打开窗口

245
00:11:16,376 --> 00:11:19,613
一个新的场景修改器
commandsRemoved

246
00:11:19,613 --> 00:11:21,782
允许您修改场景

247
00:11:21,782 --> 00:11:25,252
使其不再提供默认命令

248
00:11:25,252 --> 00:11:26,954
比如“文件”菜单中的命令

249
00:11:26,954 --> 00:11:30,891
应用此修改器后
我们的“文件”菜单现在只包含

250
00:11:30,891 --> 00:11:34,995
用于为主要
WindowGroup 打开窗口的项

251
00:11:34,995 --> 00:11:37,064
我对目前用于显示我阅读活动的

252
00:11:37,064 --> 00:11:40,968
辅助窗口场景的演示还不太满意

253
00:11:40,968 --> 00:11:43,136
那么 我们接下来仔细研究一下

254
00:11:43,136 --> 00:11:46,273
由于我要对其应用一些修改器

255
00:11:46,273 --> 00:11:48,575
所以我会将其提取到自定义场景中

256
00:11:48,575 --> 00:11:50,844
这将使我的 App 定义更加清晰

257
00:11:50,844 --> 00:11:53,547
没有任何以前的窗口状态

258
00:11:53,547 --> 00:11:57,784
SwiftUI 将默认
将其放置在屏幕的中央

259
00:11:57,784 --> 00:11:59,786
但是 我更倾向于将“阅读活动”

260
00:11:59,786 --> 00:12:03,090
默认放置于不同的位置

261
00:12:03,090 --> 00:12:05,626
通过添加新的
defaultPosition 修改器

262
00:12:05,626 --> 00:12:08,228
当没有先前的状态可用时

263
00:12:08,228 --> 00:12:11,031
我可以指定要使用的位置

264
00:12:11,031 --> 00:12:14,201
该位置将适用屏幕大小

265
00:12:14,201 --> 00:12:17,137
并按照当前的位置设置

266
00:12:17,137 --> 00:12:19,773
将窗口放置在适当的位置

267
00:12:19,773 --> 00:12:22,743
该新位置有助于将我的“活动”窗口

268
00:12:22,743 --> 00:12:25,579
与屏幕上的其他查看窗口相区分

269
00:12:25,579 --> 00:12:27,147
我还想让我的“活动”窗口

270
00:12:27,147 --> 00:12:31,418
默认以特定大小显示
但仍可调整大小

271
00:12:31,418 --> 00:12:33,554
除了 defaultPosition

272
00:12:33,554 --> 00:12:36,089
我还将添加
defaultSize 修饰器

273
00:12:36,089 --> 00:12:39,826
已向其提供的值将提供给布局系统

274
00:12:39,826 --> 00:12:43,163
来导出窗口的初始大小

275
00:12:43,163 --> 00:12:46,300
现在我已经自定义了窗口的呈现方式

276
00:12:46,300 --> 00:12:49,469
我们再添加
一个修改器来自定义其行为

277
00:12:49,469 --> 00:12:52,539
keyboardShortcut 修饰器

278
00:12:52,539 --> 00:12:54,675
也已扩展为适用于场景类型

279
00:12:54,675 --> 00:12:56,376
在场景级别使用时

280
00:12:56,376 --> 00:12:58,612
此修改器影响创建

281
00:12:58,612 --> 00:12:59,813
新窗口的命令

282
00:12:59,813 --> 00:13:03,483
在此 我修改了我的“活动”窗口
以便可以使用

283
00:13:03,483 --> 00:13:06,787
快捷键 Option-Command-0
将其打开

284
00:13:06,787 --> 00:13:09,756
通过提供常用场景的快捷指令

285
00:13:09,756 --> 00:13:13,227
可以很好地自定义 App

286
00:13:13,227 --> 00:13:16,630
也可用于自定义
Command-N 的默认

287
00:13:16,630 --> 00:13:18,031
快捷方式

288
00:13:18,031 --> 00:13:21,134
且该快捷方式已添加到
App 的主 WindowGroup 中

289
00:13:21,134 --> 00:13:23,203
介绍新场景
和 SwiftUI 中窗口功能

290
00:13:23,203 --> 00:13:25,639
的旅途到此就结束了

291
00:13:25,639 --> 00:13:28,642
我们认为
这些新 API 的潜力巨大

292
00:13:28,642 --> 00:13:29,810
希望您也如此认为！

293
00:13:29,810 --> 00:13:32,312
有关如何在
您的 iPadOS 和 macOS App 中

294
00:13:32,312 --> 00:13:35,115
添加功能的更多信息

295
00:13:35,115 --> 00:13:37,451
请查看其他视频

296
00:13:37,451 --> 00:13:40,354
“iPad 上的 SwiftUI：
组织您的界面”

297
00:13:40,354 --> 00:13:43,824
和“iPad 上的 SwiftUI：
添加工具栏、标题等”

298
00:13:44,925 --> 00:13:46,527
感谢您的观看

299
00:13:46,527 --> 00:13:50,998
♪

