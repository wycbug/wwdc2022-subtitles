1
00:00:00,501 --> 00:00:08,509
♪ ♪

2
00:00:09,810 --> 00:00:13,046
Jack 许: 欢迎来到
分析并优化您的游戏内存

3
00:00:13,080 --> 00:00:16,149
我是 Jack 许
来自 Apple 的 GPU Software 团队

4
00:00:16,183 --> 00:00:18,952
还有我的同事 Seth 陆

5
00:00:18,986 --> 00:00:21,688
在过去的几年里 我们团队

6
00:00:21,722 --> 00:00:23,490
一直和与大家一样的

7
00:00:23,524 --> 00:00:26,560
游戏开发者们共同协作
致力于改善游戏内存

8
00:00:26,593 --> 00:00:28,996
今天 我们将为大家分享成果

9
00:00:29,029 --> 00:00:32,933
让您在调试游戏内存
创建精彩的游戏

10
00:00:32,966 --> 00:00:36,803
设计最佳的游戏体验中
可抢占先机

11
00:00:37,905 --> 00:00:42,943
我们从 CPU 和 GPU 对象方面
来分解您游戏内存使用情况

12
00:00:43,877 --> 00:00:46,680
另外 分析您游戏的内存分配

13
00:00:46,713 --> 00:00:48,549
物理内存的实际使用情况

14
00:00:48,582 --> 00:00:51,285
以及对象间的引用

15
00:00:51,318 --> 00:00:53,554
因为内存有许多部分

16
00:00:53,587 --> 00:00:58,292
我们的开发者工具也从
不同的方面来揭开其面纱

17
00:00:58,325 --> 00:01:02,296
在这场旅程中
我们能体验如何使用

18
00:01:02,329 --> 00:01:06,800
Xcode Instruments 和
Terminal 中的命令行工具

19
00:01:06,834 --> 00:01:12,039
今天的旅程将以理解游戏内存
拉开帷幕

20
00:01:12,072 --> 00:01:15,275
并开始分析内存和内存增长

21
00:01:15,309 --> 00:01:18,679
Seth 也会与我们分享
Instruments 的知识

22
00:01:18,712 --> 00:01:23,383
了解 Instruments 的时序方案后
我们继续深入旅行

23
00:01:23,417 --> 00:01:28,488
用 Xcode 和 Terminal 工具
来分析您游戏的内存图

24
00:01:28,522 --> 00:01:31,658
这些工作流主要侧重于
当前内存使用状态

25
00:01:31,692 --> 00:01:35,329
以及分解整体游戏内存

26
00:01:35,362 --> 00:01:38,765
最后 Seth 将与大家分享
您如何使用 Metal Debugger

27
00:01:38,799 --> 00:01:40,734
来优化 Metal 资源

28
00:01:40,767 --> 00:01:45,739
虽然从某种程度上说 它在游戏内存中
相对独立 但仍然是核心领域

29
00:01:45,772 --> 00:01:50,177
现在 我们先从理解游戏内存开始

30
00:01:51,044 --> 00:01:53,213
您从 Xcode 启动游戏时

31
00:01:53,247 --> 00:01:56,316
比如 Metal 的
示例代码 Modern Rendering

32
00:01:56,350 --> 00:02:00,420
可以打开 Xcode 调试导航器中的
这份内存报告

33
00:02:00,454 --> 00:02:04,825
初步展示了您游戏当前和近期
内存使用情况

34
00:02:04,858 --> 00:02:07,127
及其在系统中的影响水平

35
00:02:08,862 --> 00:02:12,866
测量仪中数字展示了
游戏当前内存使用情况

36
00:02:12,900 --> 00:02:15,002
内存调试的第一步非常重要

37
00:02:15,035 --> 00:02:17,504
即理解这些数字的含义

38
00:02:19,173 --> 00:02:20,707
用一行文字来表示

39
00:02:20,741 --> 00:02:25,979
游戏中的实际内存使用
与内存分配并不相同

40
00:02:26,013 --> 00:02:28,682
实际内存使用是在
物理内存上的

41
00:02:28,715 --> 00:02:31,952
而内存分配是游戏在
虚拟存储地址空间

42
00:02:31,985 --> 00:02:34,221
所需要的内存

43
00:02:34,254 --> 00:02:38,125
不同的内存分配是
自然分开计算的

44
00:02:41,061 --> 00:02:42,896
当您的游戏分配内存时

45
00:02:42,930 --> 00:02:47,134
那些新分配的内存并不会
立即或直接占用

46
00:02:47,167 --> 00:02:48,602
物理内存的空间

47
00:02:48,635 --> 00:02:53,006
相反 它们会在虚拟存储地址空间
预留一定空间

48
00:02:53,040 --> 00:02:56,577
虚拟地址空间
是系统为每个进程提供的

49
00:02:56,610 --> 00:02:59,646
当程序后续
实际使用该内存分配时

50
00:02:59,680 --> 00:03:02,850
系统将在物理内存中准备空间

51
00:03:04,518 --> 00:03:08,055
同类的内存分配会经过分类

52
00:03:08,088 --> 00:03:11,291
并稀疏地占领虚拟地址空间

53
00:03:11,325 --> 00:03:13,760
这些分类包括

54
00:03:13,794 --> 00:03:16,363
程序的可执行二进制文件

55
00:03:16,396 --> 00:03:18,799
所有库和框架

56
00:03:18,832 --> 00:03:22,002
栈 为本地和临时变量

57
00:03:22,035 --> 00:03:24,872
及一些函数参数提供存储

58
00:03:24,905 --> 00:03:27,641
动态内存区域 也称为堆

59
00:03:27,674 --> 00:03:29,543
包括类实例存储

60
00:03:29,576 --> 00:03:32,679
程序手动分配的内存

61
00:03:32,713 --> 00:03:37,017
从只读资源 如游戏资源文件中
映射的区域

62
00:03:37,050 --> 00:03:39,620
当然 还有您游戏的 Metal 对象

63
00:03:39,653 --> 00:03:44,691
如缓冲区 纹理和管线状态对象

64
00:03:44,725 --> 00:03:48,729
这些分类是由区域组成的

65
00:03:48,762 --> 00:03:53,767
在底层 存储操作处理
的粒度是内存页面

66
00:03:53,800 --> 00:03:57,905
在现代 Apple 设备中有 16KB

67
00:03:57,938 --> 00:04:01,708
这意味着每个区域会占据
一个或多个页面

68
00:04:01,742 --> 00:04:04,344
最少有 16KB 的大小

69
00:04:05,646 --> 00:04:10,017
随着游戏的持续运行
其内存状态不断改变

70
00:04:10,050 --> 00:04:11,952
新对象被分配

71
00:04:11,985 --> 00:04:14,021
旧项目被销毁

72
00:04:14,054 --> 00:04:16,757
区域持续变化

73
00:04:16,790 --> 00:04:20,227
但只有区域中的被使用的页面
才占用物理内存

74
00:04:20,260 --> 00:04:23,263
系统会努力计入你的游戏

75
00:04:23,297 --> 00:04:25,332
如其它 App 一样

76
00:04:27,234 --> 00:04:30,070
您游戏的内存页面
可能是以下三者之一

77
00:04:30,103 --> 00:04:32,973
dirty compressed 和 clean

78
00:04:33,006 --> 00:04:35,776
我们来看看它们分别是什么

79
00:04:35,809 --> 00:04:39,980
Dirty 内存页面包括
您游戏写入的内存

80
00:04:40,013 --> 00:04:42,850
包括堆和框架分配的内存

81
00:04:42,883 --> 00:04:47,888
只要你的游戏修改过
这些变量或者符号

82
00:04:47,921 --> 00:04:49,890
在搭载 Apple 芯片的设备中

83
00:04:49,923 --> 00:04:53,660
被访问的 Metal 资源
同样也属于该分类

84
00:04:53,694 --> 00:04:59,132
这是因为 CPU 和 GPU
共享快速统一内存池

85
00:05:00,501 --> 00:05:04,071
然而 如果有些 dirty 页面
长时间未使用

86
00:05:04,104 --> 00:05:07,207
系统可能会减少它们在物理内存的占用

87
00:05:07,241 --> 00:05:10,944
通过压缩这些页面的方式
或将其存储在闪存或者磁盘上

88
00:05:10,978 --> 00:05:12,913
也被称为交换 (swap)

89
00:05:12,946 --> 00:05:17,050
这让设备可以运行更多 App
和服务

90
00:05:17,084 --> 00:05:20,387
随后 您的游戏如果再次请求这些页面

91
00:05:20,420 --> 00:05:24,024
系统会解压或从磁盘换入

92
00:05:24,057 --> 00:05:29,663
注意 计入您的游戏的
仍然是未压缩的大小

93
00:05:29,696 --> 00:05:31,598
而在 clean 内存页面方面

94
00:05:31,632 --> 00:05:34,635
它们包括从磁盘中映射的只读文件

95
00:05:34,668 --> 00:05:37,804
如纹理或音频资产

96
00:05:37,838 --> 00:05:40,874
以及加载到进程中的框架

97
00:05:40,908 --> 00:05:45,279
该系统可于任何时间对它们
进行清空或重新加载

98
00:05:45,312 --> 00:05:48,582
因此不会计入您游戏的内存足迹

99
00:05:48,615 --> 00:05:51,852
然而 它们可能常驻于内存中

100
00:05:51,885 --> 00:05:57,057
且过量使用会减缓系统
和游戏的速度

101
00:05:57,090 --> 00:06:01,361
通常前面两个部分最值得关注

102
00:06:01,395 --> 00:06:04,064
这两个部分合在一起称为内存足迹

103
00:06:04,097 --> 00:06:07,868
系统用它来实施内存限制

104
00:06:09,970 --> 00:06:13,507
在一些术语系统中
人们提到 ”dirty 内存”

105
00:06:13,540 --> 00:06:18,345
指的是内存足迹
因为 dirty 是 clean 的反义词

106
00:06:18,378 --> 00:06:21,281
但是不用担心 当变得模糊时

107
00:06:21,315 --> 00:06:24,184
我们会明确所指的是哪一个

108
00:06:24,218 --> 00:06:29,089
现在您知道内存的工作方式
以及系统如何在游戏中衡量它

109
00:06:29,990 --> 00:06:32,292
除了这个 Xcode 内存测量仪

110
00:06:32,326 --> 00:06:36,129
您还可以在系统的许多地方
看到内存足迹

111
00:06:36,163 --> 00:06:39,433
包括 Mac 上的 Activity Monitor App

112
00:06:39,466 --> 00:06:43,770
以及一些 Apple 平台用它来
作为 App 内存限制

113
00:06:43,804 --> 00:06:47,908
您的游戏也可以使用这个指标
来指导内存使用

114
00:06:47,941 --> 00:06:53,413
有一些有用的 API 可查询
当前足迹以及可用内存

115
00:06:53,447 --> 00:06:54,915
我们来快速浏览下

116
00:06:54,948 --> 00:07:00,153
要为 iOS iPadOS 或 tvOS 游戏
取得可用系统内存

117
00:07:00,187 --> 00:07:05,459
调用在 os/proc.h 头文件中声明的
os_proc_available_memory

118
00:07:07,261 --> 00:07:10,264
而任意 Apple 平台的内存足迹

119
00:07:10,297 --> 00:07:13,100
均可通过 proc_pid_rusage 来获得

120
00:07:13,133 --> 00:07:15,802
传入通过 getpid 获得进程 ID

121
00:07:15,836 --> 00:07:19,573
RUSAGE_INFO_CURRENT 当前为版本 6

122
00:07:19,606 --> 00:07:22,543
以及数据存储结构

123
00:07:22,576 --> 00:07:26,847
然后获取其物理足迹
或最大物理足迹属性

124
00:07:28,148 --> 00:07:33,687
我们来回顾下 在第一部分中
我们浏览了关于内存的一些概念

125
00:07:33,720 --> 00:07:37,624
游戏的内存分配在
虚拟存储地址空间进行

126
00:07:37,658 --> 00:07:42,496
它们经由游戏访问后
作为 16KB 页面

127
00:07:42,529 --> 00:07:45,299
占据物理内存空间

128
00:07:45,332 --> 00:07:50,771
内存足迹在 Apple 平台中
作为主要和通用测量指标

129
00:07:50,804 --> 00:07:53,574
确定游戏实际内存使用

130
00:07:53,607 --> 00:07:58,779
内存足迹包括 dirty 压缩
和交换页面

131
00:07:58,812 --> 00:08:03,183
在 Apple 芯片上
包括 CPU 和 GPU 对象

132
00:08:03,217 --> 00:08:06,920
它可用于实施内存限制

133
00:08:06,954 --> 00:08:12,893
您的游戏可以调用系统 API
来获取其足迹以及可用内存

134
00:08:12,926 --> 00:08:16,063
现在您知道内存在底层
是如何工作了

135
00:08:16,096 --> 00:08:18,332
我们来看看它在您游戏中
是怎样的

136
00:08:18,365 --> 00:08:21,869
我们有请 Seth 来分享更多内容

137
00:08:21,902 --> 00:08:23,170
Seth 陆: 谢谢 Jack

138
00:08:23,203 --> 00:08:26,573
现在 我们开始捕获一个游戏的
内存增长

139
00:08:26,607 --> 00:08:30,611
我会继续使用 Modern Renderer
示例项目

140
00:08:30,644 --> 00:08:32,446
当您从 Xcode 中运行游戏时

141
00:08:32,479 --> 00:08:36,183
Memory Gauge 能显示
不同时间下的内存足迹

142
00:08:36,216 --> 00:08:39,286
然而 您可以通过在
Instruments 中分析游戏

143
00:08:39,319 --> 00:08:42,289
获得更详细的内存使用情况

144
00:08:42,322 --> 00:08:46,260
因为通常来说 游戏在启用期间
可以分配许多内存

145
00:08:46,293 --> 00:08:48,495
您可在新游戏启动时就开始分析

146
00:08:48,529 --> 00:08:51,732
而不是在当前运行期间来分析

147
00:08:51,765 --> 00:08:54,968
在 Xcode 中 要快速开始
分析游戏

148
00:08:55,002 --> 00:08:59,206
按下运行按钮不放
然后选择 “Profile”

149
00:08:59,239 --> 00:09:02,109
这可以自动跳转到 Instruments

150
00:09:02,142 --> 00:09:05,012
Instruments App 包括一组分析工具

151
00:09:05,045 --> 00:09:07,447
可在一条时间线内
从不同方面记录系统

152
00:09:07,481 --> 00:09:10,517
并将记录数据可视化

153
00:09:10,551 --> 00:09:12,853
今年全新推出了
Game Memory 模板

154
00:09:12,886 --> 00:09:15,856
可以帮助您更好地了解
您的 Metal 游戏中的内存增长

155
00:09:17,291 --> 00:09:21,428
该模板附带有 Allocations
和 Metal Resource Events 工具

156
00:09:21,461 --> 00:09:24,531
来记录内存分配的历史

157
00:09:24,565 --> 00:09:27,801
VM Tracker 可记录内存足迹

158
00:09:27,835 --> 00:09:31,605
Virtual Memory Trace 可记录
虚拟内存活动

159
00:09:31,638 --> 00:09:35,442
Metal Application 和 GPU
可记录与 Metal 相关的事件

160
00:09:37,477 --> 00:09:40,814
在这个 demo 中
我将着重强调前面三个工具

161
00:09:40,848 --> 00:09:44,685
Allocations Metal Resource Events
和 VM Tracker

162
00:09:44,718 --> 00:09:47,955
但首先 我们先记录一份
游戏的 trace

163
00:09:47,988 --> 00:09:51,391
您可以按下这里的记录按钮
开始记录

164
00:09:51,425 --> 00:09:53,193
随后 停止记录

165
00:09:53,227 --> 00:09:57,130
您可以按下同样的按钮
或退出游戏

166
00:09:57,164 --> 00:09:59,399
趁着 Instruments
在记录 Modern Renderer 时

167
00:09:59,433 --> 00:10:03,036
我给大家看下另一个
记录 trace 的方法

168
00:10:03,070 --> 00:10:06,974
xctrace 指令让您可以
用编程方式运行记录

169
00:10:07,007 --> 00:10:09,376
在自动化工作流中可能会有用

170
00:10:10,944 --> 00:10:13,514
此外 您可以指定设备名称

171
00:10:13,547 --> 00:10:17,751
选择 iPhone iPad 或 Apple TV
为目标

172
00:10:18,819 --> 00:10:21,021
现在我已经抓取了
Instruments trace

173
00:10:21,054 --> 00:10:23,624
首先看看 Allocations

174
00:10:23,657 --> 00:10:27,261
Allocations 为您提供了
内存分配的详细视图

175
00:10:27,294 --> 00:10:30,330
包括它们的大小和对象引用计数

176
00:10:30,364 --> 00:10:34,067
然而 不包括私有 Metal 资源

177
00:10:34,101 --> 00:10:38,338
Statistics 视图展示了
所有堆的内存分配以及匿名 VM

178
00:10:40,274 --> 00:10:45,779
All Heap Allocations 包括
可能包含对象的 malloc 分配的缓冲区

179
00:10:45,812 --> 00:10:50,617
All Anonymous VM 包括
值得关注的可能为 dirty 的 VM 区域

180
00:10:50,651 --> 00:10:54,388
我们稍后会看到这一分类下的
一些 Metal 资源

181
00:10:56,123 --> 00:10:59,660
现在 我们来看看
All Heap Allocations 内部

182
00:10:59,693 --> 00:11:03,964
通常 大内存空间分配
更值得关注优化

183
00:11:03,997 --> 00:11:07,634
要找到单一最大的内存分配
您可以点击 Size 表列

184
00:11:07,668 --> 00:11:09,837
来根据内存分配大小排序

185
00:11:11,238 --> 00:11:13,774
在内存分配中
您可以点击这个箭头

186
00:11:13,807 --> 00:11:17,878
来查看 Swift 和 Objective-C
对象的引用计数变化

187
00:11:20,147 --> 00:11:22,583
在列表中选择这个大内存分配后

188
00:11:22,616 --> 00:11:26,887
在 inspector 面板有
内存分配历史的栈踪迹

189
00:11:26,920 --> 00:11:31,592
点击按钮可以隐藏系统库或框架

190
00:11:31,625 --> 00:11:34,228
这里 根据栈踪迹

191
00:11:34,261 --> 00:11:37,531
Modern Renderer 加载资产时
会进行内存分配

192
00:11:38,866 --> 00:11:43,136
双击框可进入源代码

193
00:11:43,170 --> 00:11:47,374
现在 我们返回看下
“All Anonymous VM” 分类内部

194
00:11:48,809 --> 00:11:52,646
在 Metal 游戏中 您会看到
IOAccelerator 和 IOSurface 分类下

195
00:11:52,679 --> 00:11:55,582
有很多内存分配

196
00:11:55,616 --> 00:11:59,453
Allocations 中的 IOAccelerator
对应 Metal 资源

197
00:12:00,854 --> 00:12:04,892
根据栈踪迹 您可以看到
加载资产时的内存分配

198
00:12:06,493 --> 00:12:10,497
Allocations 中的 IOSurface
对应 drawable

199
00:12:10,531 --> 00:12:14,401
这里 栈踪迹显示了
MetalKit 视图请求了 drawable

200
00:12:16,036 --> 00:12:20,307
默认设置下 Allocations 工具
可将内存分配大小可视化

201
00:12:20,340 --> 00:12:23,544
但是也会有其它的外观形式

202
00:12:23,577 --> 00:12:26,013
您可点击 Allocations 轨中的
箭头按钮

203
00:12:26,046 --> 00:12:29,616
自定显示模式
将 Allocation Density 可视化

204
00:12:29,650 --> 00:12:33,520
这可更新图表 为您展示
不同时间下内存分配的数量

205
00:12:33,554 --> 00:12:36,657
显示内存分配的峰值

206
00:12:36,690 --> 00:12:39,726
这些峰值可能是
内存增长的来源

207
00:12:39,760 --> 00:12:43,263
所以 Allocations 中显示的数据
是很底层的

208
00:12:43,297 --> 00:12:46,300
要更好地理解分配的 Metal 资源

209
00:12:46,333 --> 00:12:50,003
我们接着看 Metal Resource Events

210
00:12:50,037 --> 00:12:54,775
Metal Resource Events 工具
是围绕 Metal 资源来设计的

211
00:12:54,808 --> 00:12:56,310
在 Resource Events 视图中

212
00:12:56,343 --> 00:13:00,681
您可以找到 Metal 资源分配
和释放的历史记录

213
00:13:00,714 --> 00:13:04,218
这里您可以通过标签
区分 Metal 资源

214
00:13:04,251 --> 00:13:08,222
您可通过 Metal API
用编程方式进行指定标签

215
00:13:08,255 --> 00:13:10,290
与 Allocations 工具类似

216
00:13:10,324 --> 00:13:13,894
您可以在 inspector 中
为内存分配历史记录找到栈踪迹

217
00:13:15,929 --> 00:13:19,399
该工具也会在 Metal 设备下
添加 Allocation

218
00:13:19,433 --> 00:13:21,034
和 Deallocations 轨

219
00:13:21,068 --> 00:13:23,804
帮助可视化事件密度

220
00:13:23,837 --> 00:13:26,740
到目前为止
Allocations 和 Metal Resource Events

221
00:13:26,773 --> 00:13:29,676
可以帮助理解内存分配

222
00:13:29,710 --> 00:13:33,814
然而 内存分配并不一定
会转变为内存足迹

223
00:13:33,847 --> 00:13:37,351
因此 我们接着到 VM Tracker 下
查看实际内存使用情况

224
00:13:38,352 --> 00:13:41,154
VM Tracker 工具展示了
非压缩 dirty

225
00:13:41,188 --> 00:13:44,057
压缩或交换内存

226
00:13:44,091 --> 00:13:48,061
Dirty Size 代表了
非压缩 dirty 内存

227
00:13:48,095 --> 00:13:52,165
Swapped Size 表示压缩
或交换内存

228
00:13:52,199 --> 00:13:54,868
在这条记录中
Modern Renderer 内

229
00:13:54,902 --> 00:13:57,538
没有压缩或交换内存使用

230
00:13:57,571 --> 00:14:00,874
详细的 Summary 视图
显示了 VM 区域

231
00:14:00,908 --> 00:14:04,244
在 “mapped file” 区域中
您可能会看到一些映射内存资源

232
00:14:04,278 --> 00:14:06,280
比如您的游戏资产

233
00:14:06,313 --> 00:14:10,384
Modern Renderer 将 bistro 资产
映射到内存

234
00:14:10,417 --> 00:14:13,320
这是Instruments 中 Allocations
Metal Resource Events 和

235
00:14:13,353 --> 00:14:17,090
VM Tracker 的简要概述

236
00:14:17,124 --> 00:14:20,394
我们快速回顾下您可以
如何分析内存增长

237
00:14:20,427 --> 00:14:22,930
首先 选择 Game Memory 模板

238
00:14:22,963 --> 00:14:25,766
然后 记录和分析 trace

239
00:14:25,799 --> 00:14:28,168
有时 重现或验证
内存增长模式时

240
00:14:28,202 --> 00:14:31,839
这个过程可能需要重复多次

241
00:14:31,872 --> 00:14:34,474
我们希望新的 Game Memory 模板
可帮助您更好地理解

242
00:14:34,508 --> 00:14:37,945
您游戏中的内存分配
或足迹增长

243
00:14:37,978 --> 00:14:42,115
请查看其它视频来了解更多
关于 Instruments 的使用方法

244
00:14:42,149 --> 00:14:43,917
现在 交回给 Jack

245
00:14:45,619 --> 00:14:48,055
Jack: Game Memory 模板看起来
实在太赞了

246
00:14:48,088 --> 00:14:51,491
肯定能大大帮助我们理解
不同时间下

247
00:14:51,525 --> 00:14:53,861
内存使用情况的变化

248
00:14:53,894 --> 00:14:57,631
另外 您可能会想抓取
指定时间内游戏的内存状态

249
00:14:57,664 --> 00:15:01,268
这样您可以深入研究该内存状态

250
00:15:01,301 --> 00:15:04,571
并从不同的角度进行审视

251
00:15:04,605 --> 00:15:08,275
为了实现这一目的 我们有
内存图和一套工具

252
00:15:09,710 --> 00:15:13,347
内存图是有效存储
您游戏内存状态的

253
00:15:13,380 --> 00:15:15,082
完整快照文件

254
00:15:15,115 --> 00:15:17,150
包括对象创建历史

255
00:15:17,184 --> 00:15:20,153
引用 以及所有压缩或交换

256
00:15:21,788 --> 00:15:23,957
您可以在任意时间生成快照

257
00:15:23,991 --> 00:15:27,160
如问题发生时
或生成一对

258
00:15:27,194 --> 00:15:31,865
分别在问题发生前和发生后
用来比较

259
00:15:31,899 --> 00:15:35,035
我们来加点趣味 用菜谱类比法

260
00:15:35,068 --> 00:15:38,739
来分析内存图的内存

261
00:15:38,772 --> 00:15:41,909
包括配料和备料

262
00:15:43,710 --> 00:15:47,080
配料方面 您需要的是您的游戏准备

263
00:15:47,114 --> 00:15:49,550
被称为 Malloc Stack Logging 的配置

264
00:15:49,583 --> 00:15:52,586
以及抓取一个内存图

265
00:15:52,619 --> 00:15:55,055
配置 Malloc Stack Logging

266
00:15:55,088 --> 00:15:56,723
和抓取内存图很便捷

267
00:15:58,592 --> 00:16:03,030
Malloc Stack Logging 在游戏进程中
记录分配信息

268
00:16:03,063 --> 00:16:05,299
您可以在 Scheme 设置中找到

269
00:16:05,332 --> 00:16:08,669
选择 Run action 进入 Diagnostics

270
00:16:08,702 --> 00:16:11,271
勾选 Malloc Stack Logging
复选框

271
00:16:13,040 --> 00:16:15,642
如果您想知道这两个选项是什么

272
00:16:15,676 --> 00:16:19,313
All Allocation and Free History
追踪所有的对象

273
00:16:19,346 --> 00:16:22,049
即使对象已经释放

274
00:16:22,082 --> 00:16:24,351
日志数据可能会耗费更多内存

275
00:16:24,384 --> 00:16:28,622
但调试如分片的问题时会很有用

276
00:16:28,655 --> 00:16:33,160
另一方面 Live Allocation Only
从它的历史记录中

277
00:16:33,193 --> 00:16:36,263
丢弃已释放对象 所以更轻

278
00:16:36,296 --> 00:16:39,199
在这种情况下 我只是研究

279
00:16:39,233 --> 00:16:43,437
存在对象上的引用
所以我选择这个选项

280
00:16:43,470 --> 00:16:45,572
实际上 大部分时间中

281
00:16:45,606 --> 00:16:49,209
Live Allocation Only 都会是
您的推荐选项

282
00:16:50,677 --> 00:16:56,049
或者 如果没有从 Xcode 中启动
您可以设置环境变量

283
00:16:56,083 --> 00:17:00,187
查看 malloc 手册页面
以获得关于记录模式的信息

284
00:17:00,220 --> 00:17:03,190
随后 准备内存图

285
00:17:03,223 --> 00:17:05,626
在调试区域点击

286
00:17:05,659 --> 00:17:07,895
调试内存图按钮

287
00:17:07,928 --> 00:17:09,863
Xcode 会抓取内存快照

288
00:17:09,897 --> 00:17:13,667
对其进行处理 进入内存调试器

289
00:17:13,700 --> 00:17:18,505
Xcode Memory Debugger 为游戏
内存使用情况提供直观视角

290
00:17:18,539 --> 00:17:22,142
我们花一分钟来看下其视图

291
00:17:22,176 --> 00:17:25,445
左边 Debug Navigator 给您

292
00:17:25,479 --> 00:17:28,482
对象实例的分级列表

293
00:17:30,484 --> 00:17:34,421
右边 File Inspector 提供
如内存足迹 运行时间

294
00:17:34,454 --> 00:17:38,625
和抓取日期的有用信息

295
00:17:40,928 --> 00:17:44,164
位于中间区域的是

296
00:17:44,198 --> 00:17:47,134
左边选定对象的内存图视图

297
00:17:47,167 --> 00:17:50,771
以及引用是如何连接至对象的

298
00:17:50,804 --> 00:17:53,740
我稍后会再详细解释这个图

299
00:17:56,109 --> 00:17:59,847
File 菜单给您提供了
保存内存图的选项

300
00:17:59,880 --> 00:18:03,517
从而进行进一步分析
或可以快捷地与您的团队共享

301
00:18:05,118 --> 00:18:07,888
对于 Mac 游戏 您也可以
用进程 ID 或名称

302
00:18:07,921 --> 00:18:12,659
通过 leaks 命令行程序抓取内存图

303
00:18:12,693 --> 00:18:16,163
这意味着您可以
通过 ssh 远程操作

304
00:18:16,196 --> 00:18:18,031
而让光标保留在游戏中

305
00:18:18,065 --> 00:18:23,103
以使您游戏全屏运行并保持焦点

306
00:18:23,136 --> 00:18:26,907
这就是您开始内存图分析所需的

307
00:18:28,275 --> 00:18:32,880
现在来看下在 Terminal 中
用 Xcode Memory Debugger

308
00:18:32,913 --> 00:18:36,083
和一些多功能命令行工具分析内存图

309
00:18:36,116 --> 00:18:41,121
来查看内存分配 足迹甚至更多

310
00:18:41,154 --> 00:18:45,759
第一步最好是按类别
分解内存使用情况

311
00:18:45,792 --> 00:18:48,629
footprint 程序正是作为此用

312
00:18:50,430 --> 00:18:56,203
footprint 使用内存图中的信息
来重建高度概括

313
00:18:56,236 --> 00:19:01,241
通常 您首先会关注大一些的类别

314
00:19:01,275 --> 00:19:05,812
对于如这个来自 Modern Rendering
示例代码的游戏内存图来说

315
00:19:05,846 --> 00:19:09,783
IOAccelerator 通常是最大的

316
00:19:09,816 --> 00:19:14,988
如 Seth 所说 它包括
Metal 资源

317
00:19:15,022 --> 00:19:20,494
堆内存分配会分为
几个 MALLOC_ 开头的类别

318
00:19:20,527 --> 00:19:25,899
系统为了提升性能
将内存分配按大小分到对应内存池

319
00:19:25,933 --> 00:19:30,170
这些对象可能会来自许多地方
如第三方 plugins

320
00:19:30,204 --> 00:19:34,875
或游戏处理音效
或物理模拟的库

321
00:19:36,343 --> 00:19:39,479
这个内存图来自一个非常精彩的
Apple Arcade 游戏

322
00:19:39,513 --> 00:19:43,283
名为 Manifold Garden
是 William “Cheer” Studio 制作的

323
00:19:43,317 --> 00:19:46,753
我很高兴他们允许我向您展示
这款游戏的内存使用情况

324
00:19:46,787 --> 00:19:51,558
如果您的游戏使用了游戏引擎
如同 Manifold Garden 使用了 Unity

325
00:19:51,592 --> 00:19:54,528
或基于内存映射使用自定义分配器

326
00:19:54,561 --> 00:19:58,899
内存像这样显示为
untagged VM_ALLOCATE

327
00:19:58,932 --> 00:20:01,702
这里有一个专业意见
在 Apple 平台中

328
00:20:01,735 --> 00:20:04,872
您的游戏可以使用
最多 16 个 App 专有标签

329
00:20:04,905 --> 00:20:08,442
这样您在深入研究内存使用时
能更清晰

330
00:20:08,475 --> 00:20:11,144
这和修改一行代码一样简单

331
00:20:12,312 --> 00:20:16,283
首先 通过 16 个选项之一
创建标签

332
00:20:16,316 --> 00:20:21,522
然后 当调用 mmap 时
用这个新标签作为文件描述符

333
00:20:21,555 --> 00:20:24,091
来代替这个 -1

334
00:20:24,124 --> 00:20:28,562
您可以查看 mmap 的手册页面
以学习如何定义标签和分类

335
00:20:30,597 --> 00:20:32,833
如果您使用 mach_vm_allocate

336
00:20:32,866 --> 00:20:37,171
在分配时在标记参数中使用
同样的标记

337
00:20:39,573 --> 00:20:41,642
在 footprint 程序世界中

338
00:20:41,675 --> 00:20:45,245
dirty 大小同样包括交换和压缩

339
00:20:45,279 --> 00:20:48,982
所以要将其作为每个类别的总计量

340
00:20:50,250 --> 00:20:53,754
这是当前内存使用的组成

341
00:20:53,787 --> 00:20:56,857
以及它如何组成足迹的简要概念

342
00:20:56,890 --> 00:21:01,361
有些较少使用的内存
会压缩或交换

343
00:21:01,395 --> 00:21:04,364
它们可能是节省内存的来源

344
00:21:04,398 --> 00:21:07,167
下一步是找到游戏使用了多少

345
00:21:07,201 --> 00:21:10,871
压缩或交换内存 然后优化

346
00:21:12,773 --> 00:21:16,610
那您需要对内存图运行 vmmap

347
00:21:16,643 --> 00:21:19,580
它会给您 dirty 和交换的大小

348
00:21:19,613 --> 00:21:22,082
而不是两者的结合

349
00:21:22,115 --> 00:21:24,985
该 dirty 列包括当前未交换

350
00:21:25,018 --> 00:21:27,487
或压缩的常规 dirty 内存

351
00:21:27,521 --> 00:21:30,524
而交换列包括压缩或交换内存的

352
00:21:30,557 --> 00:21:33,694
原始大小

353
00:21:33,727 --> 00:21:37,965
系统将这两列加在一起
来确定足迹

354
00:21:37,998 --> 00:21:42,636
但由于交换尺寸列中的内存
并非经常使用

355
00:21:42,669 --> 00:21:45,772
这可很好地提示优化游戏内存时

356
00:21:45,806 --> 00:21:48,442
需要查看的内容是什么

357
00:21:48,475 --> 00:21:51,345
还有 这是有虚拟尺寸列的

358
00:21:51,378 --> 00:21:54,114
内存分配大小

359
00:21:54,147 --> 00:21:58,285
常驻大小包括 clean 页面
如可执行文件

360
00:21:58,318 --> 00:22:00,521
和内存映射文件等

361
00:22:02,422 --> 00:22:07,294
很方便的是 vmmap 会用一个
不同的表来显示内存分配

362
00:22:07,327 --> 00:22:09,363
在其输出底部

363
00:22:09,396 --> 00:22:13,300
vmmap 按区域对内存分组

364
00:22:13,333 --> 00:22:18,172
这些区域反映了它们在您游戏中的
使用情况或生命周期

365
00:22:18,205 --> 00:22:20,674
因为我打开了 MallocStackLogging

366
00:22:20,707 --> 00:22:24,811
堆上的内存分配在工具区域

367
00:22:24,845 --> 00:22:27,714
不然 它们按内存分配大小
会在两个默认区域

368
00:22:27,748 --> 00:22:33,887
MallocHelperZone
和 DefaultMallocZone

369
00:22:33,921 --> 00:22:40,594
通常 您会跳过小一点的
系统利用区域 如 QuartzCore 区域

370
00:22:42,196 --> 00:22:47,334
而且 如果您想查看
高分片大小指示的分片

371
00:22:47,367 --> 00:22:52,439
或者百分比 如数十或数百兆字节

372
00:22:52,472 --> 00:22:57,411
WWDC 2021 讲座有更多
关于分片的问题

373
00:22:58,645 --> 00:23:02,282
运行没有 --summary 的 vmmap

374
00:23:02,316 --> 00:23:04,718
或在标准模式使用 vmmap

375
00:23:04,751 --> 00:23:09,223
可以在这些分类中逐行显示
每个 vm 区域

376
00:23:09,256 --> 00:23:14,595
就好像我们之前谈到的
虚拟地址空间一样

377
00:23:14,628 --> 00:23:21,068
所以有 vmmap 您可以将经常使用的
dirty 内存中与较少使用的部分区分开

378
00:23:21,101 --> 00:23:23,871
通常游戏中也有很多

379
00:23:23,904 --> 00:23:27,207
不同大小的动态分配

380
00:23:27,241 --> 00:23:30,010
或 malloc 分配的堆内存使用

381
00:23:30,043 --> 00:23:32,045
它们尤其需要关注

382
00:23:32,880 --> 00:23:36,550
heap 工具按类别分组
malloc 分配的资源

383
00:23:36,583 --> 00:23:39,253
根据实例计数来排序

384
00:23:39,286 --> 00:23:43,524
这些类在 C++ 中由 VTable

385
00:23:43,557 --> 00:23:45,993
或通过 Objective-C 或 Swift 来确定的

386
00:23:47,628 --> 00:23:49,997
我们使用的是 --quiet 参数

387
00:23:50,030 --> 00:23:53,734
来跳过关于
一些元数据的头部信息

388
00:23:53,767 --> 00:23:59,206
今年新推出的 heap 在
识别对象类型上更智能

389
00:23:59,239 --> 00:24:02,676
它使用通过 Malloc Stack Logging
记录的信息

390
00:24:02,709 --> 00:24:05,979
来展示调用者或相关库

391
00:24:06,013 --> 00:24:09,683
因此巨大的 non-object 已经是过往

392
00:24:10,584 --> 00:24:14,888
这个还是 Manifold Garden 的内存图

393
00:24:14,922 --> 00:24:18,392
这个例子首次揭示了

394
00:24:18,425 --> 00:24:23,463
如 FMOD Studio 的插件和
如 GameAssembly.dylib 的游戏组件

395
00:24:23,497 --> 00:24:27,801
占用了多少堆使用空间

396
00:24:27,835 --> 00:24:32,306
所以现在您更了解
内存是如何分布的

397
00:24:32,339 --> 00:24:38,078
这也可以通过获得这些对象的
更多信息了解应该往那个方向调查

398
00:24:38,111 --> 00:24:42,216
在这个例子中 开发者
打开了 FMOD Studio

399
00:24:42,249 --> 00:24:45,919
来调整游戏中的音轨和音效

400
00:24:45,953 --> 00:24:50,691
或者到 Unity 中
查看可优化的游戏代码等等

401
00:24:52,593 --> 00:24:55,295
有时 按类总大小排序

402
00:24:55,329 --> 00:24:58,765
而不是类实例计数
会更为有帮助

403
00:24:58,799 --> 00:25:01,535
在 Modern Rendering 示例项目的
内存图中

404
00:25:01,568 --> 00:25:07,641
顶级贡献者是一个使用了
超过 258MB 的类

405
00:25:07,674 --> 00:25:11,512
要继续查看 Modern Rendering 示例中
较大的对象

406
00:25:11,545 --> 00:25:17,584
使用 heap 加上 --sortBySize
按类总大小排序对象

407
00:25:17,618 --> 00:25:21,688
加上 --showSize 列出所有对象

408
00:25:21,722 --> 00:25:24,725
而不是每个类的概览

409
00:25:24,758 --> 00:25:28,629
在 Bytes Storage 中
有一个 NSConcreteMutableData 对象

410
00:25:28,662 --> 00:25:34,201
大小在 255MB

411
00:25:34,234 --> 00:25:37,971
看起来是值得注意的

412
00:25:38,005 --> 00:25:40,908
接下来 我想研究下这是什么

413
00:25:40,941 --> 00:25:44,278
首先 我想知道它的地址

414
00:25:44,311 --> 00:25:49,816
我添加了 --address
输入 NSConcreteMutableData 匹配符

415
00:25:49,850 --> 00:25:53,153
然后是通配符 .*

416
00:25:53,187 --> 00:25:55,355
还有括号里的大小过滤器

417
00:25:55,389 --> 00:26:00,093
只列出 10MB 大小及以上的对象

418
00:26:00,127 --> 00:26:02,796
这是对象地址

419
00:26:02,829 --> 00:26:07,334
我会在后续的步骤中使用
来做进一步的分析

420
00:26:07,367 --> 00:26:13,407
这是对实例做了对象识别改进的
heap 工具

421
00:26:13,440 --> 00:26:16,276
到目前为止 已经看到了三种工具
来理解

422
00:26:16,310 --> 00:26:18,979
游戏中什么对象在使用内存

423
00:26:19,012 --> 00:26:21,548
它们都会提供不同的视图

424
00:26:21,582 --> 00:26:24,351
我展示的只是一个工作流

425
00:26:24,384 --> 00:26:26,620
根据您游戏中特定的内存模式

426
00:26:26,653 --> 00:26:28,889
或使用的技术

427
00:26:28,922 --> 00:26:31,692
您可以按需求进行使用

428
00:26:33,894 --> 00:26:36,163
发现我们不确定

429
00:26:36,196 --> 00:26:39,066
其存在的对象

430
00:26:39,099 --> 00:26:41,835
下一步就是要找到其来源

431
00:26:41,869 --> 00:26:44,104
及其分配调用堆栈

432
00:26:45,172 --> 00:26:48,575
在 Modern Rendering 中的
200MB 对象中

433
00:26:48,609 --> 00:26:50,944
我用了 --callTree 模式

434
00:26:50,978 --> 00:26:54,915
将其地址传到 malloc_history

435
00:26:54,948 --> 00:26:57,451
与额外的 invert 参数一起

436
00:26:57,484 --> 00:27:01,655
我可以集中于最接近
内存分配的函数

437
00:27:01,688 --> 00:27:03,156
然后就好了

438
00:27:03,190 --> 00:27:06,793
这是内存分配的反向跟踪

439
00:27:06,827 --> 00:27:12,065
同样的 Xcode Memory Debugger
也展示了 inspector 中一个对象的

440
00:27:12,099 --> 00:27:13,600
内存分配历史

441
00:27:13,634 --> 00:27:17,371
选择一个对象
点击 Memory Inspector

442
00:27:17,404 --> 00:27:20,774
就好了

443
00:27:20,807 --> 00:27:24,344
另一个例子
传入 VM_ALLOCATE 作为类模式

444
00:27:24,378 --> 00:27:27,281
而不是地址

445
00:27:27,314 --> 00:27:31,084
来检查您游戏或 plugin 中的
匿名 VM 使用

446
00:27:31,118 --> 00:27:34,888
如调试自定义分配器

447
00:27:34,922 --> 00:27:37,958
不管是使用 Xcode
或 malloc_history

448
00:27:37,991 --> 00:27:40,294
您可以知道内存分配反向跟踪

449
00:27:40,327 --> 00:27:43,030
确定是否想要进一步研究

450
00:27:43,063 --> 00:27:46,800
包括首先在这行设置断点

451
00:27:48,802 --> 00:27:55,475
最后 它也可以帮助
研究对象引用

452
00:27:55,509 --> 00:27:58,846
内存图总是记录对象引用

453
00:27:58,879 --> 00:28:04,017
甚至当 MallocStackLogging
由于多种原因未被启用时

454
00:28:04,051 --> 00:28:08,689
我们在前面使用 leaks
来在 Xcode 外抓取内存图

455
00:28:08,722 --> 00:28:10,190
leaks 能做的更多

456
00:28:10,224 --> 00:28:12,993
它检查内存图中所有引用

457
00:28:13,026 --> 00:28:17,431
所以它了解泄露和保留周期

458
00:28:17,464 --> 00:28:20,634
leaks 通过使用跟踪树状参数
和堆中的对象地址

459
00:28:20,667 --> 00:28:24,905
来获取对象的引用树

460
00:28:24,938 --> 00:28:28,909
然而 这个例子中
这是一个很大的树状结构

461
00:28:28,942 --> 00:28:32,679
从某种程度上说 有比在 Terminal 中
更好的方式来查看

462
00:28:34,281 --> 00:28:37,751
通过 Xcode 14 我们重新设计了
内存图视图

463
00:28:37,784 --> 00:28:42,289
展示选定对象的入边和出边

464
00:28:43,357 --> 00:28:46,059
甚至有新的邻居选择弹窗

465
00:28:46,093 --> 00:28:49,396
来选择您希望 Xcode 绘制的边缘

466
00:28:49,429 --> 00:28:52,132
在复杂游戏状态中
尝试理解对象引用时

467
00:28:52,165 --> 00:28:56,603
会极大的提升效率

468
00:28:58,105 --> 00:29:00,541
在探索一圈后

469
00:29:00,574 --> 00:29:05,345
我很确定是纹理管理工具
在访问这个对象

470
00:29:05,379 --> 00:29:07,814
对您的游戏来说
考虑使用 leaks 工具

471
00:29:07,848 --> 00:29:12,386
和内存图视图来找到
重要的对象引用关系

472
00:29:12,419 --> 00:29:16,190
来研究这些对象是如何
在游戏中被访问的

473
00:29:16,223 --> 00:29:18,992
这就是如何使用 leaks 或者 Xcode

474
00:29:19,026 --> 00:29:22,729
展示和找到对象的重要引用

475
00:29:22,763 --> 00:29:24,565
您可查看 leaks 的手册页面

476
00:29:24,598 --> 00:29:28,268
以及 Xcode 的帮助以获取更多
关于这些工具的使用信息

477
00:29:29,603 --> 00:29:32,039
在这个内存图的分析菜谱中

478
00:29:32,072 --> 00:29:35,375
每步都使用了具体的工具

479
00:29:35,409 --> 00:29:40,047
它们共同完成内存图的分析

480
00:29:41,548 --> 00:29:45,552
总的来说 当您希望用
内存图来抓取和分析内存时

481
00:29:45,586 --> 00:29:50,991
首先是
要启用 MallocStackLogging

482
00:29:51,024 --> 00:29:54,595
然后通过 Xcode
为你的游戏抓取内存图

483
00:29:54,628 --> 00:29:58,765
或给您的 Mac 游戏
使用 leaks 工具

484
00:29:58,799 --> 00:30:02,870
接下来 找到尺寸大的惹麻烦的对象

485
00:30:02,903 --> 00:30:07,474
footprint vmmap 和 heap 工具
提供从高层面到细节

486
00:30:07,508 --> 00:30:11,111
的内存分解

487
00:30:11,144 --> 00:30:15,282
使用 malloc_history
您可以查看对象是在哪里分配

488
00:30:15,315 --> 00:30:19,820
leaks 可分析对象使用或引用

489
00:30:19,853 --> 00:30:22,756
之前这些讲座包含了
这些工具使用情况的

490
00:30:22,789 --> 00:30:26,260
深入指导和演示

491
00:30:26,293 --> 00:30:30,063
到目前为止 我们迟迟未开始
Metal 资源的探索

492
00:30:30,097 --> 00:30:32,533
现在是时候了

493
00:30:32,566 --> 00:30:35,769
我们有请 Seth 为我们
介绍详细内容

494
00:30:35,802 --> 00:30:37,104
Seth: 大家好 又见面了

495
00:30:37,137 --> 00:30:40,807
在游戏中 Metal 资源可以使用
非常大的内存

496
00:30:40,841 --> 00:30:43,310
但是也是有办法优化
它们的内存使用的

497
00:30:44,411 --> 00:30:46,513
这里 我总结了一个
节省内存的清单

498
00:30:46,547 --> 00:30:50,551
让您可以优化游戏中 Metal 资源的使用

499
00:30:50,584 --> 00:30:54,254
我们看下 Metal Debugger
是如何帮助您审计资源

500
00:30:54,288 --> 00:30:58,025
并学习更多进一步减少游戏内存的
高级技巧

501
00:30:59,026 --> 00:31:03,230
Metal Debugger 可一站式
调试您的 Metal 游戏

502
00:31:03,263 --> 00:31:05,365
进行 GPU 帧抓取后

503
00:31:05,399 --> 00:31:07,334
您可以看到一个总结页面

504
00:31:07,367 --> 00:31:10,604
为您提供关于抓取工作负荷的
概括数据

505
00:31:12,172 --> 00:31:13,740
在页面的后半部分

506
00:31:13,774 --> 00:31:17,477
有一个分为四个类别的
insights 列表

507
00:31:17,511 --> 00:31:22,115
Memory 分类中的 Insights
为您游戏中的内存节约提出建议

508
00:31:22,149 --> 00:31:25,752
针对这一 trace 没有太多的
内存 insights

509
00:31:25,786 --> 00:31:29,356
访问这些 insights 后
我们只能节省数兆字节的内存

510
00:31:31,225 --> 00:31:35,095
然而 您游戏可能有更多
可节省内存的具体部分

511
00:31:35,128 --> 00:31:38,265
要获得 Metal 资源
所使用内存的完整图像

512
00:31:38,298 --> 00:31:41,435
您可以点击 Show Memory 按钮
使用 Memory Viewer

513
00:31:42,903 --> 00:31:47,441
Memory Viewer 为您提供
抓取自游戏的完整资源列表

514
00:31:47,474 --> 00:31:50,844
上半部分展示了可过滤的不同分类

515
00:31:50,878 --> 00:31:54,681
您可以用其来快速查看资源
比方说纹理

516
00:31:54,715 --> 00:31:58,785
在下半部分中
表格只展示了纹理

517
00:31:58,819 --> 00:32:01,755
我们先关掉过滤器

518
00:32:01,788 --> 00:32:06,059
资源表格有许多列
来帮助您优化游戏

519
00:32:06,093 --> 00:32:09,329
我着重介绍可以帮助您快速识别

520
00:32:09,363 --> 00:32:10,964
一些有趣资源的几列

521
00:32:13,100 --> 00:32:17,337
Insights 列和我们在总结页面
看到的类似

522
00:32:17,371 --> 00:32:19,706
当用该列排序表格时 您可以快速

523
00:32:19,740 --> 00:32:23,343
用 insights 查看所有资源

524
00:32:23,377 --> 00:32:26,313
点击 insight 图标
可以展示弹窗

525
00:32:26,346 --> 00:32:30,717
解释所发现的内容
提供一些可能的行动

526
00:32:30,751 --> 00:32:34,288
旁边列是 Allocated Size

527
00:32:34,321 --> 00:32:37,991
您可以按该列来排序
查看最大的资源是哪个

528
00:32:38,025 --> 00:32:41,361
这对于审计有些资源
是否确实充分利用了它们的内存大小

529
00:32:41,395 --> 00:32:43,397
可能会有用

530
00:32:43,430 --> 00:32:47,601
例如 有些纹理可能可以重新调整为
小一点的分辨率

531
00:32:47,634 --> 00:32:51,305
有些在缓冲区中加载的模型
可能可以使用较低的多边形计数

532
00:32:51,338 --> 00:32:55,242
只要这样做并不会影响
游戏的视觉品质

533
00:32:55,275 --> 00:32:57,377
有一些替代方法可以节省
纹理内存

534
00:32:57,411 --> 00:32:59,680
我稍后会再提到

535
00:32:59,713 --> 00:33:03,050
这还有另一个有趣的列
是 Time Since Last Bound

536
00:33:03,083 --> 00:33:08,222
您可以通过该列来筛选资源
来查看有哪些是近期没有使用的

537
00:33:08,255 --> 00:33:09,857
如果资源没有使用过

538
00:33:09,890 --> 00:33:14,428
最好可以再次检查
看资产是否值得加载

539
00:33:14,461 --> 00:33:16,763
有一段时间没有绑定的资源

540
00:33:16,797 --> 00:33:20,734
且未来不会再使用
您可能要考虑将其释放

541
00:33:20,767 --> 00:33:24,972
或者您可以将其可清除状态
设置为 volatile

542
00:33:25,005 --> 00:33:28,475
Metal 资源可能处于
以下三种可清除状态之一

543
00:33:28,509 --> 00:33:32,346
non-volatile volatile 和 empty

544
00:33:32,379 --> 00:33:35,949
在默认设置下 资源是 non-volatile 的

545
00:33:35,983 --> 00:33:37,918
通过将可清除状态
设置为 volatile

546
00:33:37,951 --> 00:33:39,887
Metal 可从内存中清理该资源

547
00:33:39,920 --> 00:33:42,656
应对系统内存压力过高的情况

548
00:33:42,689 --> 00:33:45,325
一旦资源为空 系统不再需要将其

549
00:33:45,359 --> 00:33:47,995
计入游戏内存足迹

550
00:33:48,028 --> 00:33:49,663
当您的游戏再次需要该资源时

551
00:33:49,696 --> 00:33:53,367
检查内容是否还在该位置
在需要的时候重新加载

552
00:33:53,400 --> 00:33:56,870
对于频繁使用的资源
只考虑使用 volatile

553
00:33:56,904 --> 00:33:59,339
这样可清除状态不会对您不利

554
00:34:01,375 --> 00:34:05,012
所以这些是针对所有资源的
通用事项

555
00:34:05,045 --> 00:34:08,015
现在 我们来详细看看纹理

556
00:34:08,949 --> 00:34:12,219
Memory Viewer 并不是
默认显示所有列

557
00:34:12,252 --> 00:34:15,289
右击表头可选择显示和隐藏列

558
00:34:15,322 --> 00:34:18,158
如纹理的 Pixel Format

559
00:34:18,192 --> 00:34:23,163
您可以通过优化纹理的像素格式
获得不同的节省量

560
00:34:23,197 --> 00:34:27,000
游戏中的许多纹理
会使用 16 位半像素精度格式

561
00:34:27,034 --> 00:34:29,837
来减少内存使用和带宽

562
00:34:29,870 --> 00:34:32,940
在您需要
单一 alpha 通道的纹理时

563
00:34:32,973 --> 00:34:35,642
您可以避免多个色彩通道

564
00:34:35,676 --> 00:34:39,146
最后 一些只读纹理
可能会得益于块压缩

565
00:34:39,179 --> 00:34:41,615
来降低内存占用

566
00:34:41,648 --> 00:34:43,717
对于块压缩像素格式来说

567
00:34:43,750 --> 00:34:46,687
有如 ASTC 和 BC 的选项

568
00:34:46,720 --> 00:34:49,122
此外 自 A15 仿生开始

569
00:34:49,156 --> 00:34:51,892
您可以对纹理和渲染目标
使用有损压缩

570
00:34:51,925 --> 00:34:55,562
在尽可能保持画质的同时
节省内存

571
00:34:55,596 --> 00:34:58,432
请查看之前的视频
以获取更多信息

572
00:35:00,634 --> 00:35:03,203
以上是您使用 Memory Viewer
可快速发现

573
00:35:03,237 --> 00:35:05,172
一些内存节省的方法

574
00:35:05,205 --> 00:35:07,341
但您还可以使用一些其它技术

575
00:35:07,374 --> 00:35:09,977
来进一步优化您的游戏

576
00:35:10,010 --> 00:35:12,546
如果只有单一通道使用纹理

577
00:35:12,579 --> 00:35:14,648
您可以将其存储模式
设置为 memoryless

578
00:35:14,681 --> 00:35:16,783
从而节省内存和带宽

579
00:35:16,817 --> 00:35:19,620
memoryless 纹理
非常适合临时渲染目标

580
00:35:19,653 --> 00:35:23,156
如深度 stencil 或多样本纹理

581
00:35:23,190 --> 00:35:26,293
另外 如果只有 GPU 使用纹理

582
00:35:26,326 --> 00:35:28,061
您可以将其存储模式设置为私有

583
00:35:28,095 --> 00:35:31,131
而不是共享或托管

584
00:35:31,164 --> 00:35:34,601
提醒下 Apple 芯片 Mac 中
是不需要托管模式的

585
00:35:34,635 --> 00:35:37,371
正如在 iPhone 和 iPad 中一样

586
00:35:37,404 --> 00:35:39,473
以下是示例

587
00:35:39,506 --> 00:35:42,876
游戏用的是
Depth32Float_Stencil8 纹理

588
00:35:42,910 --> 00:35:46,079
深度纹理会跨通道使用

589
00:35:46,113 --> 00:35:48,215
但 Stencil 纹理内容会被丢弃

590
00:35:48,248 --> 00:35:51,318
后续在帧中也不会使用

591
00:35:51,351 --> 00:35:54,154
所以 游戏可以使用两张纹理

592
00:35:54,188 --> 00:35:57,925
将 Stencil 纹理设置为 memoryless
从而节省内存和带宽

593
00:35:59,359 --> 00:36:02,930
最后 我要说下另一个充分利用
您游戏内存的技术

594
00:36:02,963 --> 00:36:05,432
您可能会感兴趣

595
00:36:05,465 --> 00:36:07,901
您可以使用堆中的别名资源

596
00:36:07,935 --> 00:36:09,937
如果您游戏没有
同时使用它们的话

597
00:36:09,970 --> 00:36:12,973
它们可以共享在同一内存分配
支持下的内存

598
00:36:13,006 --> 00:36:17,411
但是在同步这些资源的访问时
要格外小心

599
00:36:17,444 --> 00:36:19,780
您可以查看
“利用 Metal 3 实现无绑定” 的讲座

600
00:36:19,813 --> 00:36:23,317
以了解更多关于使用
堆分配资源的信息

601
00:36:23,350 --> 00:36:26,820
我们可以总结下节省内存的
检查清单

602
00:36:26,854 --> 00:36:30,190
我希望这个清单能帮助您
审计游戏中的 Metal 资源

603
00:36:31,725 --> 00:36:33,861
请查看其它 WWDC 讲座
以了解更多关于

604
00:36:33,894 --> 00:36:38,031
使用 Metal Debugger
来优化您游戏内存的内容

605
00:36:38,065 --> 00:36:39,499
再次有请 Jack

606
00:36:41,235 --> 00:36:42,503
Jack: 谢谢 Seth

607
00:36:42,536 --> 00:36:46,340
在今天的旅程中
我们探索了许多有趣的东西

608
00:36:46,373 --> 00:36:50,177
让大家可以理解和改进
游戏的内存使用

609
00:36:50,210 --> 00:36:53,981
首先 内存足迹是理解

610
00:36:54,014 --> 00:36:56,650
游戏内存使用的首要指标

611
00:36:56,683 --> 00:37:01,722
它包括 dirty 和 compressed
和交换内存

612
00:37:01,755 --> 00:37:05,859
然后 我们体验了强大的
内存调试工具

613
00:37:05,893 --> 00:37:09,496
Seth 给我们展示了
Instruments 如何用有用的

614
00:37:09,530 --> 00:37:11,865
测量跟踪来助力内存分析

615
00:37:11,899 --> 00:37:16,537
全新的 Game Memory 模板
是为这一工作量身定制的

616
00:37:16,570 --> 00:37:22,442
随后 我展示了用内存图
来存储游戏内存状态的快照

617
00:37:22,476 --> 00:37:25,712
有灵活 强大的命令行程序

618
00:37:25,746 --> 00:37:28,315
来分析内存图中的对象

619
00:37:28,348 --> 00:37:31,652
引用和分配历史

620
00:37:31,685 --> 00:37:35,822
heap 工具的改进
和 Xcode Memory Debugger 的重新设计

621
00:37:35,856 --> 00:37:38,825
将会强化游戏内存分析

622
00:37:38,859 --> 00:37:42,329
最后 Seth 与我们共享了
Metal 资源的

623
00:37:42,362 --> 00:37:44,231
内存节省检查清单

624
00:37:44,264 --> 00:37:47,334
以及 Metal Debugger 可以如何

625
00:37:47,367 --> 00:37:51,138
回答您游戏中关于 Metal
资源使用的问题

626
00:37:51,171 --> 00:37:54,575
您可以查看其它
WWDC 讲座

627
00:37:54,608 --> 00:37:57,444
文件和手册页面以了解更多内容

628
00:37:58,445 --> 00:38:02,349
我们持续致力于为大家开发
最灵活的工具

629
00:38:02,382 --> 00:38:04,318
所以何不尽情一试呢

630
00:38:04,351 --> 00:38:06,720
它们可能正好就是您需要的

631
00:38:07,955 --> 00:38:11,525
有任何反馈请随时

632
00:38:11,558 --> 00:38:15,162
通过多种渠道与我们分享
如 Feedback Assistant

633
00:38:15,195 --> 00:38:17,064
祝大家有一个愉快的内存
探索旅程

634
00:38:17,097 --> 00:38:18,465
感谢大家的观看

