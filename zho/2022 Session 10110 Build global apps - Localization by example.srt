1
00:00:09,776 --> 00:00:12,112
Andreas: 大家好
欢迎来到全球开发者大会

2
00:00:12,145 --> 00:00:14,481
我是来自 Apple 本地化团队的 Andreas

3
00:00:14,515 --> 00:00:16,917
今天我想和您分享一些
关于如何创建高质量的

4
00:00:16,950 --> 00:00:19,820
本地化 App 的示例

5
00:00:20,988 --> 00:00:23,524
国际化意味着让您的 App

6
00:00:23,557 --> 00:00:26,126
在世界各地的设备上运行

7
00:00:26,159 --> 00:00:29,696
如果本地化做得好
所有人都能享受到同样棒的

8
00:00:29,730 --> 00:00:33,867
体验和功用
不管他们说的是什么语言

9
00:00:33,901 --> 00:00:36,303
使用 Apple 提供的 API

10
00:00:36,336 --> 00:00:39,239
您的 App 的大多数部分
都会易于国际化

11
00:00:39,273 --> 00:00:41,341
开箱即用

12
00:00:41,375 --> 00:00:43,744
在本期演讲中 您将从我们的经验中

13
00:00:43,777 --> 00:00:46,480
学习如何让 Apple App
吸引不同的受众

14
00:00:46,513 --> 00:00:49,249
包括存在的一些挑战
和我们该如何解决它们

15
00:00:49,283 --> 00:00:53,153
我将从声明和加载本地化文本开始

16
00:00:53,187 --> 00:00:57,558
字符串中很容易包含
格式化的日期 时间等

17
00:00:57,591 --> 00:01:02,563
我将特别强调一些选项
并将研究一个复杂的示例

18
00:01:02,596 --> 00:01:05,766
您的 Swift 软件包
可能也包括本地化文本

19
00:01:05,799 --> 00:01:09,970
您将会了解到本地化工作流程的改进

20
00:01:10,003 --> 00:01:14,408
最后 我将谈谈 SwiftUI 的
布局和新功能

21
00:01:14,441 --> 00:01:18,345
在 Apple 我们会确保我们的 App

22
00:01:18,378 --> 00:01:20,113
能为世界各地的用户提供卓越的体验

23
00:01:20,147 --> 00:01:22,783
天气 App 就是一个例子

24
00:01:22,816 --> 00:01:26,486
每天都有数百万用户打开它
查看天气预报

25
00:01:26,520 --> 00:01:30,457
无论他们身在何处
他们眼中的 App 都是这样的

26
00:01:30,490 --> 00:01:34,094
注意 UI 中的所有内容是如何
根据他们的首选项进行调整的

27
00:01:34,127 --> 00:01:37,064
我们将对当前天气状况的描述本地化

28
00:01:37,097 --> 00:01:39,199
并格式化数字

29
00:01:39,233 --> 00:01:41,568
UI 也会根据语言是从左到右的

30
00:01:41,602 --> 00:01:45,305
还是从右到左的进行适当调整

31
00:01:45,339 --> 00:01:48,909
让我们从翻译开始仔细看看某个

32
00:01:48,942 --> 00:01:50,611
自定义的内容

33
00:01:50,644 --> 00:01:54,348
这个视图用英语写着
“风让体感更凉爽”（Wind is making it feel cooler.）

34
00:01:54,381 --> 00:01:57,317
这是它在其他语言中的样子

35
00:01:57,351 --> 00:02:00,120
为了正确地运行它们
我们所要做的就是使用

36
00:02:00,153 --> 00:02:02,489
(本地化的)String 声明字符串

37
00:02:02,523 --> 00:02:05,125
Xcode 会在导出本地化时发现它

38
00:02:05,158 --> 00:02:09,296
然后我们就可以将结果
发送给我们的翻译人员

39
00:02:09,329 --> 00:02:11,598
我将使用 Mac 上的
Mail App 来做到这一点

40
00:02:11,632 --> 00:02:13,867
既然我们说到这儿了
我想给您看样东西

41
00:02:13,901 --> 00:02:16,136
如果我打开电子邮件的快捷菜单

42
00:02:16,170 --> 00:02:19,273
我可以把它移动到一个
名为 Archive 的特殊文件夹

43
00:02:19,306 --> 00:02:22,509
它位于我的侧边栏中

44
00:02:22,543 --> 00:02:25,812
注意这两个单词在英语中
都是 Archive

45
00:02:25,846 --> 00:02:28,682
但是其他语言 如西班牙语
关于操作和文件夹名称

46
00:02:28,715 --> 00:02:31,018
有不同的单词

47
00:02:31,051 --> 00:02:33,020
即使英语单词是相同的

48
00:02:33,053 --> 00:02:35,088
但是当它们出现在不同的语境中时

49
00:02:35,122 --> 00:02:37,824
其他语言可能会使用不同的单词

50
00:02:37,858 --> 00:02:40,561
在这种情况下
应该在代码中使用两个字符串

51
00:02:40,594 --> 00:02:45,832
为此 今年我们给字符串初始化器
添加了新的 API

52
00:02:45,866 --> 00:02:50,037
它现在接受了一个默认值
我们可以将其用于英语字符串

53
00:02:50,070 --> 00:02:52,539
然后 我们要修改本地化字符串的键

54
00:02:52,573 --> 00:02:55,542
使翻译人员清楚地了解区别

55
00:02:55,576 --> 00:02:58,812
通过这种方式用英语运行 App 时

56
00:02:58,846 --> 00:03:02,349
会显示相同的单词
而西班牙语翻译可以提供不同的单词

57
00:03:02,382 --> 00:03:04,918
去年的演讲
“Streamline your localized strings”

58
00:03:04,952 --> 00:03:07,721
帮助您理解了管理字符串的基本知识

59
00:03:07,754 --> 00:03:11,458
并进一步介绍了本地化过程

60
00:03:11,491 --> 00:03:15,929
我希望您从这个例子中学到
有时候同一个英文单词

61
00:03:15,963 --> 00:03:20,267
甚至是一个完整的句子
会在 UI 里不同的环境中显示

62
00:03:20,300 --> 00:03:25,339
在这些情况下 请确保在代码中
使用两个不同的字符串

63
00:03:25,372 --> 00:03:27,708
天气不仅仅与 App 有关

64
00:03:27,741 --> 00:03:30,477
它也能很好地集成到系统中

65
00:03:30,511 --> 00:03:33,313
在这里 我们能看到一个用户活动
建议打开 App

66
00:03:33,347 --> 00:03:36,316
来检查当前位置的天气

67
00:03:36,350 --> 00:03:39,520
让我们看看如何实现它

68
00:03:39,553 --> 00:03:41,889
可以像这样使用字符串插入（String Interpolation）

69
00:03:41,922 --> 00:03:45,659
插入任何位置名称来声明
加载字符串

70
00:03:45,692 --> 00:03:50,163
这个名字可以是一个城市
也可以是当前位置的一个术语

71
00:03:50,197 --> 00:03:51,932
这个结果在英语中效果很好

72
00:03:51,965 --> 00:03:53,433
分别是 “Show weather in Cupertino”

73
00:03:53,467 --> 00:03:56,970
和 “Show weather in my location”

74
00:03:57,004 --> 00:04:00,741
但是 在其他语言中
我们可能会遇到语法问题

75
00:04:00,774 --> 00:04:04,244
例如 在德语中
介词可以用于城市名称前

76
00:04:04,278 --> 00:04:07,814
但插入表示当前位置的词前时
就错误了

77
00:04:07,848 --> 00:04:10,651
我们需要一个不同的翻译来代替

78
00:04:10,684 --> 00:04:13,153
解决方案很简单

79
00:04:13,187 --> 00:04:15,556
用两个不同的字符串

80
00:04:15,589 --> 00:04:17,925
在第一个字符串中
插入城市名称没有问题

81
00:04:17,958 --> 00:04:21,061
对于当前位
我们要使用另一个字符串

82
00:04:21,094 --> 00:04:24,231
这可以确保翻译人员
能够使用正确的

83
00:04:24,264 --> 00:04:25,666
语言语法

84
00:04:25,699 --> 00:04:28,435
这些在英语和德语中都很好用

85
00:04:28,468 --> 00:04:32,439
我做这个例子是为了向您展示
插入一个变量

86
00:04:32,472 --> 00:04:34,374
会对整个句子产生影响

87
00:04:34,408 --> 00:04:38,478
在其他语言中 连接字符串
可能会产生令人惊讶的结果

88
00:04:38,512 --> 00:04:43,050
它们可能需要改变语法
或者可能在大写方面有问题

89
00:04:43,083 --> 00:04:46,353
但要在编写代码之前
想到这一点很困难

90
00:04:46,386 --> 00:04:48,789
让会说这门语言的人测试 App

91
00:04:48,822 --> 00:04:51,491
是工作流程的重要部分

92
00:04:51,525 --> 00:04:55,295
当您试图以编程方式构造字符串时
请记住这一点

93
00:04:57,297 --> 00:05:00,634
现在我们已经很好地理解了
字符串是如何在代码中被声明的

94
00:05:00,667 --> 00:05:03,270
让我们来聊一聊它们的注释

95
00:05:03,303 --> 00:05:07,774
下面是我们上一个例子中的字符串
并附有适当的注释

96
00:05:07,808 --> 00:05:10,277
注释对翻译来说非常非常重要

97
00:05:10,310 --> 00:05:13,647
您应该确保为它们
能提供翻译所需的上下文

98
00:05:13,680 --> 00:05:17,851
使译文与您声明
字符串时的意图保持一致

99
00:05:17,885 --> 00:05:21,421
一个好的注释解释了字符串
显示在哪个界面元素中

100
00:05:21,455 --> 00:05:23,824
类似于标签或按钮

101
00:05:23,857 --> 00:05:28,629
它还解释了 UI 元素的上下文
以及它在屏幕上显示的位置

102
00:05:28,662 --> 00:05:33,567
它可以是一个段落头
一个快捷菜单 或者一个用户活动

103
00:05:33,600 --> 00:05:35,002
如果字符串包含变量

104
00:05:35,035 --> 00:05:37,604
请确保在运行时解释它们的值

105
00:05:37,638 --> 00:05:40,407
如我们在例子中看到的

106
00:05:40,440 --> 00:05:42,543
这对于匹配句子的语法非常重要

107
00:05:42,576 --> 00:05:45,779
记住 翻译在翻译内容时

108
00:05:45,812 --> 00:05:47,514
可能不会看到运行时的 App

109
00:05:47,548 --> 00:05:50,417
但是通过这些技巧
您应该能够在字符串的声明

110
00:05:50,450 --> 00:05:53,253
和翻译 它在您的 App 中

111
00:05:53,287 --> 00:05:56,256
扮演的角色之间建立一个共识

112
00:05:56,290 --> 00:05:57,858
现在 您可能从来没有想过

113
00:05:57,891 --> 00:06:00,827
但天气 App 实际上
并不能控制天气

114
00:06:00,861 --> 00:06:03,664
相反 数据是从服务器下载下来的

115
00:06:03,697 --> 00:06:05,866
它可能位于世界上的任何地方

116
00:06:05,899 --> 00:06:09,636
甚至可能不知道用什么语言发送内容

117
00:06:09,670 --> 00:06:11,772
当内容被下载到用户的设备时

118
00:06:11,805 --> 00:06:15,843
它应该一直以用户
更愿意使用的语言呈现

119
00:06:15,876 --> 00:06:19,780
只本地化应用的某些部分
可能会让人非常困惑

120
00:06:20,747 --> 00:06:23,717
在这里 天气 App 显示了
一个恶劣天气警报

121
00:06:23,750 --> 00:06:26,286
它是从服务器加载来的

122
00:06:26,320 --> 00:06:27,621
这看起来真的很严重

123
00:06:27,654 --> 00:06:31,992
如果它没有翻译成我的语言
我之后可能会遇到麻烦

124
00:06:32,025 --> 00:06:34,595
让我们看看可以做些什么
来确保用户能

125
00:06:34,628 --> 00:06:37,231
持续读取远程内容

126
00:06:38,999 --> 00:06:42,336
您的服务器可以向 App
发送支持的语言列表

127
00:06:42,369 --> 00:06:44,738
这应该是一个语言 ID 的阵列

128
00:06:44,771 --> 00:06:48,308
设备有关于用户喜欢哪种语言的
所有数据

129
00:06:48,342 --> 00:06:51,445
这样您就不必自己检查比较它们

130
00:06:51,478 --> 00:06:55,415
您可以通过调用 “Bundle.preferredLocalizations”
来利用 Apple 的框架

131
00:06:55,449 --> 00:06:57,818
它会帮您匹配

132
00:06:57,851 --> 00:07:00,053
它会返回一个候选语言的数组

133
00:07:00,087 --> 00:07:03,857
根据它们与用户的语言选择的
匹配程度排序

134
00:07:03,891 --> 00:07:08,962
第一个通常是最合适的
所以您要用这个

135
00:07:08,996 --> 00:07:13,300
然后 应将该语言用于
对服务器的任何后续请求

136
00:07:13,333 --> 00:07:16,403
它会用它生成一个回应

137
00:07:16,436 --> 00:07:19,273
其内容是用户能够理解的语言

138
00:07:19,306 --> 00:07:21,041
使用这种技术
您可以确保来自服务器的字符串

139
00:07:21,074 --> 00:07:24,711
为更新 UI 和向用户显示警报

140
00:07:24,745 --> 00:07:27,948
做好了准备

141
00:07:27,981 --> 00:07:30,951
因此 为了使用户在显示远程内容时

142
00:07:30,984 --> 00:07:34,388
避免困惑 请下载可用的语言

143
00:07:34,421 --> 00:07:36,490
将其与用户的语言偏好进行匹配

144
00:07:36,523 --> 00:07:40,594
并在加载面向用户内容的任何请求时
使用该结果

145
00:07:40,627 --> 00:07:42,729
但现在让我们再看看更好的天气

146
00:07:42,763 --> 00:07:45,465
无论晴雨
天气 App 的数据都非常丰富

147
00:07:45,499 --> 00:07:48,802
它的许多方面都包含数字和计数

148
00:07:48,836 --> 00:07:51,238
让我们关注其中一个

149
00:07:51,271 --> 00:07:56,443
降水（Precipitation） 下面写着
“最近 6 小时内会有 0 毫米。”

150
00:07:56,476 --> 00:07:58,979
让我们假设您想要构建类似的内容

151
00:07:59,012 --> 00:08:01,648
但这里改为 “ 1 小时”

152
00:08:01,682 --> 00:08:04,017
这就是在代码中声明字符串的方式

153
00:08:04,051 --> 00:08:06,286
在英语中 如果小时数大于 1

154
00:08:06,320 --> 00:08:08,655
您就需要使用复数形式

155
00:08:08,689 --> 00:08:11,692
1 小时是 hour 但 2 小时是 hours

156
00:08:11,725 --> 00:08:13,794
在乌克兰语中要使用另一种变体

157
00:08:13,827 --> 00:08:16,330
其规则更加复杂

158
00:08:16,363 --> 00:08:19,099
您不会希望在代码中实现这种逻辑

159
00:08:19,132 --> 00:08:22,703
这就是为什么要利用 Apple 框架

160
00:08:22,736 --> 00:08:25,138
您所要做的
就是在代码中声明字符串

161
00:08:25,172 --> 00:08:29,543
并提供一个 stringsdict 文件
该文件会对复数规则进行编码

162
00:08:29,576 --> 00:08:33,413
另一个选择是使用
自动语法协议（Automatic Grammar Agreement）

163
00:08:33,447 --> 00:08:35,549
您可以在去年的演讲
“Streamline your localized strings” 中

164
00:08:35,582 --> 00:08:39,219
了解更多关于这两种技术的内容

165
00:08:39,253 --> 00:08:42,356
尽管这很简单
但您不应该总是将复数规则

166
00:08:42,389 --> 00:08:44,992
应用于所有字符串

167
00:08:45,025 --> 00:08:47,561
例如 如果您的句子不要计数

168
00:08:47,594 --> 00:08:51,999
也不包括数字
您就不应该使用复数规则

169
00:08:52,032 --> 00:08:54,201
在这里
“Remove this city from your favorites”

170
00:08:54,234 --> 00:08:56,537
不需要该规则 因为其中没有数字

171
00:08:56,570 --> 00:09:00,007
而且同样适用于多个城市

172
00:09:00,040 --> 00:09:02,009
但如果字符串确实包含一个数字

173
00:09:02,042 --> 00:09:05,179
您应该考虑使用复数变形

174
00:09:05,212 --> 00:09:09,316
前面示例中的字符串
计算了未来几个小时的降雨量

175
00:09:09,349 --> 00:09:14,154
我们刚刚学习了让它依据
大于 1 的数字改进是多么容易

176
00:09:14,188 --> 00:09:17,491
但是 如果句子中有一个单位
比如持续时间

177
00:09:17,524 --> 00:09:21,595
时间或百分比
您应该考虑使用格式化器

178
00:09:21,628 --> 00:09:24,364
所以 现在让我们来聊聊格式化器（Formatter）吧

179
00:09:24,398 --> 00:09:28,368
气候会在这个视图中
以百分比显示当前湿度

180
00:09:28,402 --> 00:09:32,239
要在 SwiftUI 中实现这一点
只需要一行代码

181
00:09:32,272 --> 00:09:35,609
您只需在 Text() 中填入您需要的值

182
00:09:35,642 --> 00:09:37,444
并指定您希望如何格式化这个数字

183
00:09:37,477 --> 00:09:39,479
等效的 Swift 代码也很简单

184
00:09:39,513 --> 00:09:42,115
您只需要在值上调用 .formatted

185
00:09:43,417 --> 00:09:45,085
这就是您需要做的全部工作

186
00:09:45,118 --> 00:09:48,222
而格式化器会处理其他所有事情

187
00:09:48,255 --> 00:09:50,624
它不仅会将百分号
放在数字的前面或后面

188
00:09:50,657 --> 00:09:52,960
并添加空格

189
00:09:52,993 --> 00:09:56,630
它还会适应用户偏好的编号系统

190
00:09:56,663 --> 00:10:00,601
这是阿拉伯语和印地语用户所期望的

191
00:10:00,634 --> 00:10:04,972
但这仅仅是可以格式化的
数据类型的开始

192
00:10:05,005 --> 00:10:07,474
几乎所有的东西都有格式化器

193
00:10:07,508 --> 00:10:11,912
我建议您再看一次讲座
“Formatters: Make data human-friendly”

194
00:10:14,715 --> 00:10:17,417
正如我们所看到的
天气并不总是晴朗的

195
00:10:17,451 --> 00:10:19,686
有些日子会下雨

196
00:10:19,720 --> 00:10:23,357
当然 天气 App 也不能缺少这个亮点

197
00:10:23,390 --> 00:10:28,462
降雨（Rainfall）  一栏写着 “50 mm expected
in next 24 hours”（预计未来 24 小时内会有 50 毫米。）

198
00:10:28,495 --> 00:10:32,699
我真的很高兴这不是我的
所在地的情况

199
00:10:32,733 --> 00:10:34,535
在英语中 情况很简单

200
00:10:34,568 --> 00:10:38,705
我们会说 “50 millimeters expected
in next 24 hours.”

201
00:10:38,739 --> 00:10:41,241
但是在西班牙语中 事情要复杂得多

202
00:10:41,275 --> 00:10:44,444
我们需要依据降水量是单数或复数

203
00:10:44,478 --> 00:10:47,114
来改变翻译

204
00:10:47,147 --> 00:10:51,652
我们可以通过结合格式化器
和复数规则来解决这个问题

205
00:10:51,685 --> 00:10:54,354
字符串 2mm 是由格式化器生成的

206
00:10:54,388 --> 00:10:59,560
它被嵌入到了一个在西班牙语中
需要改为复数形式的句子中

207
00:10:59,593 --> 00:11:03,463
好的 让我们看看
如何在代码中做到这一点

208
00:11:03,497 --> 00:11:06,500
我们首先要声明一个
带有一个参数

209
00:11:06,533 --> 00:11:10,170
关于降水量的函数 单位是毫米

210
00:11:10,204 --> 00:11:13,807
它可能是从服务器上下载的

211
00:11:13,841 --> 00:11:16,376
首先 我们要向系统请求一个
UnitLength

212
00:11:16,410 --> 00:11:18,512
它会对用户的配置进行编码

213
00:11:18,545 --> 00:11:23,217
并为要显示降雨的情况
选择正确的长度

214
00:11:23,250 --> 00:11:26,253
如果用户没有将其系统
配置为使用公制

215
00:11:26,286 --> 00:11:29,890
那么可以很容易地将
Measurement 类型转换为偏好单位

216
00:11:31,692 --> 00:11:35,162
接下来 格式化 API
会让我们能够在一行代码中为值

217
00:11:35,195 --> 00:11:38,031
生成格式化字符串

218
00:11:38,065 --> 00:11:40,667
偏好单位已经有了我们想要显示的

219
00:11:40,701 --> 00:11:42,102
降雨信息

220
00:11:42,135 --> 00:11:45,939
所以格式化时 我们要
将用法设置为 asProvided

221
00:11:45,973 --> 00:11:49,276
如果降雨量超过 1 毫米或 1 英寸

222
00:11:49,309 --> 00:11:51,512
我们希望使用复数形式

223
00:11:51,545 --> 00:11:55,082
我们要把这个值转换成一个整数
这样我们就可以检查它了

224
00:11:55,115 --> 00:11:58,085
接下来 我们要加载一个
带有给定键的本地化字符串

225
00:11:58,118 --> 00:12:00,988
并提供一个默认值

226
00:12:01,021 --> 00:12:04,258
在这里 我们要用字符串插值
来包含 integerValue

227
00:12:04,291 --> 00:12:07,294
格式化值和数字 24

228
00:12:07,327 --> 00:12:11,365
这个数字是在代码中定义的
因为它永远是 24 小时

229
00:12:11,398 --> 00:12:13,734
使用字符串插值能自动确保

230
00:12:13,767 --> 00:12:17,671
使用正确的编号系统

231
00:12:17,704 --> 00:12:19,673
该键在 stringsdict 文件中被声明

232
00:12:19,706 --> 00:12:22,442
让我们来看看

233
00:12:22,476 --> 00:12:26,780
stringsdict 以我们刚刚
在代码中使用的键开始

234
00:12:26,813 --> 00:12:29,449
在英语中 我们不需要为复数
改变字符串的形式

235
00:12:29,483 --> 00:12:33,086
所以我们可以用
Other 这一类别来表示它

236
00:12:33,120 --> 00:12:36,690
第一个参数会定义
在运行时选择哪个类别

237
00:12:36,723 --> 00:12:39,493
记住 它是整数值

238
00:12:39,526 --> 00:12:43,230
参数 2 和 3 出现在格式化字符串中

239
00:12:43,263 --> 00:12:47,034
这定义了句子在运行时的样子

240
00:12:47,067 --> 00:12:49,837
西班牙语的 stringsdict
具有相同的结构

241
00:12:49,870 --> 00:12:54,007
只是我们同时提供了
单数和复数的翻译

242
00:12:56,143 --> 00:13:00,180
我们现在已经用代码格式化了数据
并将其放入一个句子中

243
00:13:00,214 --> 00:13:02,449
stringsdict 文件包含复数规则

244
00:13:02,482 --> 00:13:05,886
这样西班牙语翻译
使用的就是正确的语法

245
00:13:05,919 --> 00:13:08,989
有时候 提供一个适合所有语言的
完全本地化的 UI

246
00:13:09,022 --> 00:13:11,491
是很有挑战性的

247
00:13:11,525 --> 00:13:15,128
同样 连接字符串在英语中可以运作

248
00:13:15,162 --> 00:13:18,732
但在其他语言中可能会产生
令人惊讶的结果

249
00:13:18,765 --> 00:13:21,401
这可能需要一些全面的代码来完成

250
00:13:21,435 --> 00:13:24,938
但现在您知道了该如何
使它能适合所有用户

251
00:13:24,972 --> 00:13:28,242
有时候您的字符串会处在依赖关系中

252
00:13:28,275 --> 00:13:30,978
或者在 App 使用的模块中

253
00:13:31,011 --> 00:13:34,081
或者您也可以使用
Swift 软件包将自己的代码

254
00:13:34,114 --> 00:13:36,083
分发给其他开发人员

255
00:13:36,116 --> 00:13:39,019
让我们看看本地化的新内容

256
00:13:39,052 --> 00:13:41,922
要定义一个 Swift 软件包
您需要通过使用

257
00:13:41,955 --> 00:13:45,025
Swift 本身来声明结构和构建配置

258
00:13:45,058 --> 00:13:48,061
如果您有面向用户的内容
您可以使用参数

259
00:13:48,095 --> 00:13:51,331
default Localization 来声明
内容使用英语

260
00:13:51,365 --> 00:13:53,267
作为主要语言

261
00:13:53,300 --> 00:13:58,272
这类似于指定 App 项目的
开发语言

262
00:13:58,305 --> 00:14:01,875
Xcode 现在会读取这个参数
并识别出

263
00:14:01,909 --> 00:14:05,445
您对提供本地化体验感兴趣

264
00:14:05,479 --> 00:14:10,250
因此 它将向 Product 菜单添加
Export Localizations 选项

265
00:14:10,284 --> 00:14:13,120
您可能已习惯于在您的主 App 中
使用这个功能

266
00:14:13,153 --> 00:14:16,123
现在它也适用于 Swift 软件包

267
00:14:16,156 --> 00:14:21,161
如果您点击 Export 那么Xcode就会
读取您的代码并提取所有的字符串

268
00:14:21,195 --> 00:14:25,532
它们被放在 .xcloc 文件中
发送给翻译人员

269
00:14:25,566 --> 00:14:28,702
要将本地化后的内容导入到包中
需要使用

270
00:14:28,735 --> 00:14:30,404
Import Localization

271
00:14:30,437 --> 00:14:34,675
Xcode 会将本地化后的文件
放到包中正确的文件路径里

272
00:14:34,708 --> 00:14:39,580
现在 本地化一个 Swift 软件包的
工作流程和本地化您的 App 是一样的

273
00:14:41,615 --> 00:14:44,451
但是记住 在 Swift 软件包中
加载一个字符串

274
00:14:44,484 --> 00:14:47,387
需要指定 bundle 参数

275
00:14:47,421 --> 00:14:50,357
您可以在演讲
“Swift package:

276
00:14:50,390 --> 00:14:54,328
resources and localization”中
了解到更多

277
00:14:54,361 --> 00:14:58,432
如果您是一个以 Swift 软件包
形式发布的库的作者

278
00:14:58,465 --> 00:15:01,635
您现在有了一个保持项目更新

279
00:15:01,668 --> 00:15:05,572
并使本地化成为您工作流程的
常规部分的简单方法

280
00:15:05,606 --> 00:15:08,442
您在您的项目中投入了
大量的精力和关注

281
00:15:08,475 --> 00:15:12,513
将其本地化将为所有客户端
节省大量的时间

282
00:15:12,546 --> 00:15:14,581
这一定能让它脱颖而出

283
00:15:14,615 --> 00:15:16,750
让人们意识到您是在额外付出

284
00:15:16,783 --> 00:15:19,486
用您的软件为他们提供最好的体验

285
00:15:19,520 --> 00:15:21,221
所以去大胆地告诉他们吧

286
00:15:21,255 --> 00:15:25,192
对您所支持的语言保持开放的态度

287
00:15:25,225 --> 00:15:27,928
作为一名 App 开发人员
您需要特别考虑

288
00:15:27,961 --> 00:15:29,162
依赖关系

289
00:15:29,196 --> 00:15:32,065
不仅仅是从代码质量的角度考虑

290
00:15:32,099 --> 00:15:34,935
您使用的组件应该支持
与 App 其他部分

291
00:15:34,968 --> 00:15:39,072
相同的语言和高质量的翻译

292
00:15:39,106 --> 00:15:42,943
在第三方代码没有本地化到
所需语言的情况下

293
00:15:42,976 --> 00:15:45,546
您仍然可以创建包的本地副本

294
00:15:45,579 --> 00:15:48,448
并在那里更新本地化

295
00:15:48,482 --> 00:15:53,120
确保您用了 App 支持的语言
测试的它所有部分

296
00:15:53,153 --> 00:15:56,023
这样就可以确保里面没有

297
00:15:56,056 --> 00:15:58,792
不适合用户语言的 UI 元素

298
00:15:58,825 --> 00:16:00,894
大多数情况下 翻译后的字符串

299
00:16:00,928 --> 00:16:03,497
会比对应的英文字符串更长或更短

300
00:16:03,530 --> 00:16:06,400
这总是会影响 App 的布局

301
00:16:06,433 --> 00:16:08,836
让我们看看这对天气 App
意味着什么

302
00:16:08,869 --> 00:16:11,071
这是用英语运行的 App

303
00:16:11,104 --> 00:16:14,408
在右边您可以看到
它用阿拉伯语运行的情况

304
00:16:14,441 --> 00:16:17,778
很明显 不仅翻译适应了语言

305
00:16:17,811 --> 00:16:22,616
布局也遵循了适当的方向性

306
00:16:22,649 --> 00:16:25,319
如果您想了解更多

307
00:16:25,352 --> 00:16:28,021
关于如何创建适用于
所有语言的布局以及哪些类型的符号

308
00:16:28,055 --> 00:16:30,023
提供了本地化的替代方案

309
00:16:30,057 --> 00:16:32,492
以及对于从右到左书写的语言
还需要考虑什么

310
00:16:32,526 --> 00:16:36,363
请务必观看演讲
“Get it right... to left”

311
00:16:37,731 --> 00:16:40,000
在这里 右边是用印度语
运行的 App

312
00:16:40,033 --> 00:16:42,302
让我们放大看看

313
00:16:42,336 --> 00:16:45,639
这种语言的脚本往往更高

314
00:16:45,672 --> 00:16:48,342
如果您仔细观察
您会发现标签的高度

315
00:16:48,375 --> 00:16:50,944
也相应地调整了

316
00:16:50,978 --> 00:16:52,946
系统会自动完成这项任务

317
00:16:52,980 --> 00:16:54,615
您所要做的就是确保您没有

318
00:16:54,648 --> 00:16:57,784
给 UI 元素一个固定的高度

319
00:16:57,818 --> 00:17:00,621
不要假定所有文字
都能在 44 像素点以内

320
00:17:00,654 --> 00:17:03,690
只是因为它足以放下英文字符串

321
00:17:03,724 --> 00:17:07,661
请根据不同的情况
做好您的文字会更高的准备

322
00:17:09,062 --> 00:17:11,398
回到主视图 滚上去

323
00:17:11,431 --> 00:17:13,333
天气有一个 10 天的预测视图

324
00:17:13,367 --> 00:17:15,736
便于查看下个星期的天气

325
00:17:17,304 --> 00:17:20,374
这个屏幕上最引人注目的

326
00:17:20,407 --> 00:17:24,044
是它如何根据最长的标签
动态调整元素的位置

327
00:17:24,077 --> 00:17:28,215
在英语中 Today 比所有
工作日名称的缩写都要长

328
00:17:28,248 --> 00:17:31,552
但是 在西班牙语中
它们都有三个字符宽

329
00:17:31,585 --> 00:17:36,123
而在希腊语中
“今天”一词的长度几乎是两倍

330
00:17:36,156 --> 00:17:40,227
不过 在所有语言中
天气图标都是垂直对齐的

331
00:17:40,260 --> 00:17:43,697
这意味着它们与相邻元素之间
没有固定的间隔

332
00:17:43,730 --> 00:17:47,534
而是根据 “最长工作日” 标签流动

333
00:17:47,568 --> 00:17:51,104
在创建与国际化配合良好的布局时

334
00:17:51,138 --> 00:17:55,008
您应该始终记住标签需要灵活

335
00:17:55,042 --> 00:17:58,745
您已经看到了使它们
在垂直方向上具有灵活性是多么重要

336
00:17:58,779 --> 00:18:03,283
但同时也准备好标签会随着
较长的译文在水平方向上增长

337
00:18:03,317 --> 00:18:06,286
在某些布局中 比如在这个例子中

338
00:18:06,320 --> 00:18:07,921
要适应这一点可能是一个挑战

339
00:18:07,955 --> 00:18:10,591
但今年 SwiftUI 增加了对 Grid 的支持

340
00:18:10,624 --> 00:18:15,195
这是一个新的视图
可以帮助您更易于构建这种布局

341
00:18:15,229 --> 00:18:18,999
让我们仔细看看如何使用 Grid

342
00:18:19,032 --> 00:18:22,002
首先 您要先用前导对齐来声明 Grid

343
00:18:22,035 --> 00:18:25,405
这意味着 UI 元素在从左到右
书写的语言中

344
00:18:25,439 --> 00:18:26,940
会从屏幕的左边开始

345
00:18:26,974 --> 00:18:31,512
在从右到左的书写语言中
会从屏幕的右边开始

346
00:18:31,545 --> 00:18:35,382
然后 为每个水平组
添加一个 GridRow

347
00:18:35,415 --> 00:18:38,752
最后 要声明行内容

348
00:18:38,785 --> 00:18:41,622
这就是创建这个高级布局
所需要的全部内容

349
00:18:41,655 --> 00:18:43,557
当标签需要更多的空间时

350
00:18:43,590 --> 00:18:48,061
Capsule 可以缩小大小
因为它是最灵活的元素

351
00:18:48,095 --> 00:18:50,964
SwiftUI 完成了所有繁重的工作
如测量

352
00:18:50,998 --> 00:18:55,569
改变大小 定位视图 这完全是自动的

353
00:18:55,602 --> 00:18:58,672
另一个挑战是在有限的空间内
比如在 Apple Watch 上

354
00:18:58,705 --> 00:19:02,576
使用较长的翻译作品制作视图

355
00:19:02,609 --> 00:19:05,045
在这里 Tip Function 的
德语翻译太长了

356
00:19:05,078 --> 00:19:07,581
无法放在一行里

357
00:19:07,614 --> 00:19:11,685
我们不用为解决这个问题删除
文本旁的图标 以腾出更多空间

358
00:19:11,718 --> 00:19:15,556
解决方案是在需要时
使用两行或两行以上的文本

359
00:19:15,589 --> 00:19:17,958
这是默认行为

360
00:19:17,991 --> 00:19:19,660
如果没有足够的空间 我们不鼓励您

361
00:19:19,693 --> 00:19:22,896
改变或者隐藏界面元素

362
00:19:22,930 --> 00:19:25,365
通常会有一种调整布局的方法

363
00:19:25,399 --> 00:19:28,902
使其能够适应语言的需要

364
00:19:28,936 --> 00:19:31,205
邮件 App 以一种创造性的方式
做到了这一点

365
00:19:32,206 --> 00:19:37,077
在表单演示中 有四个按钮
能对这封电子邮件执行行动

366
00:19:37,110 --> 00:19:40,247
当一个按钮标题的翻译太长时

367
00:19:40,280 --> 00:19:43,050
我们不用剪切文本或换行

368
00:19:43,083 --> 00:19:45,819
这会让视图看起来不平衡

369
00:19:45,853 --> 00:19:49,089
相反 整个布局从水平堆（Horizontal Stack）

370
00:19:49,122 --> 00:19:51,758
过渡为了两行垂直堆

371
00:19:53,060 --> 00:19:55,662
今年 SwiftUI 增加了另一个

372
00:19:55,696 --> 00:19:58,098
很棒的工具
使创建动态布局更容易

373
00:19:58,131 --> 00:20:00,033
它就是 ViewThatFits

374
00:20:00,067 --> 00:20:02,469
本质上 它会允许您在空间受限和

375
00:20:02,503 --> 00:20:05,939
视图不适合的情况下提供替代的布局

376
00:20:07,608 --> 00:20:10,277
您只需声明您的视图彼此独立

377
00:20:10,310 --> 00:20:12,980
并把它们放在 ViewThatFits 中

378
00:20:13,013 --> 00:20:16,383
SwiftUI 会自动检测视图
是否不适合 但不会进行剪切

379
00:20:16,416 --> 00:20:19,486
并切换到提供的下一个视图

380
00:20:19,520 --> 00:20:22,389
记住 您应该只切换布局

381
00:20:22,422 --> 00:20:26,627
仅仅因为翻译太长而隐藏视图
是一种糟糕的做法

382
00:20:26,660 --> 00:20:30,430
这会使得用户更难使用 UI

383
00:20:30,464 --> 00:20:33,400
通过灵活的布局
尽量为所有界面元素

384
00:20:33,433 --> 00:20:34,868
腾出空间

385
00:20:36,303 --> 00:20:38,672
这不仅有助于本地化

386
00:20:38,705 --> 00:20:41,875
当用户喜欢更小或更大的文本

387
00:20:41,909 --> 00:20:45,412
并且使用不同的设备时
这种布局也会很有效

388
00:20:45,445 --> 00:20:48,882
如果您想要了解更多今年
SwiftUI 出色的新布局功能

389
00:20:48,916 --> 00:20:53,787
我建议您观看演讲
“Compose custom layouts with SwiftUI”

390
00:20:53,820 --> 00:20:56,123
拥有不同的辅助功能偏好设置

391
00:20:56,156 --> 00:20:59,560
和本地化文本对布局来说是一个挑战

392
00:20:59,593 --> 00:21:02,496
界面元素可以更高更宽

393
00:21:02,529 --> 00:21:05,599
调整布局以适应它可能是一项挑战

394
00:21:05,632 --> 00:21:08,335
但今年有了 SwiftUI 就容易多了

395
00:21:09,770 --> 00:21:13,273
我希望您从这次演讲中了解到
在支持其他语言时

396
00:21:13,307 --> 00:21:16,143
在代码中构造字符串
是很有挑战性的

397
00:21:16,176 --> 00:21:18,612
要听取全球用户和测试人员的反馈

398
00:21:18,645 --> 00:21:23,183
确保所有人都能顺利使用

399
00:21:23,217 --> 00:21:25,252
在 Swift 中格式化值很简单

400
00:21:25,285 --> 00:21:27,921
通常只需要一行代码

401
00:21:27,955 --> 00:21:30,290
这样 格式化的值

402
00:21:30,324 --> 00:21:32,426
就会自动地顺应用户的偏好设置

403
00:21:33,727 --> 00:21:35,529
当您提供一个 Swift 软件包时

404
00:21:35,562 --> 00:21:38,165
利用新的 Xcode 本地化工作流程

405
00:21:38,198 --> 00:21:42,336
为您的客户端提供完全本地化的体验

406
00:21:42,369 --> 00:21:44,538
现在 无论使用 SwiftUI 与否

407
00:21:44,571 --> 00:21:47,407
您的布局都应该能够适应翻译文本

408
00:21:47,441 --> 00:21:49,476
和辅助功能的设置

409
00:21:49,510 --> 00:21:52,312
使用您的布局工具使布局灵活

410
00:21:52,346 --> 00:21:55,315
而不隐藏界面元素

411
00:21:55,349 --> 00:21:57,818
最后 您的用户会对此感到庆幸的

412
00:21:57,851 --> 00:22:00,954
因为他们会希望您的 App
能融入他们的生活

413
00:22:00,988 --> 00:22:03,857
这包括尊重他们的语言

414
00:22:03,891 --> 00:22:06,093
现在 我正期待着一个
阳光灿烂的星期

415
00:22:06,126 --> 00:22:07,728
请享受余下的 WWDC

416
00:22:07,761 --> 00:22:09,630
感谢观看

