1
00:00:00,334 --> 00:00:06,340
[欢快的音乐]

2
00:00:09,743 --> 00:00:10,911
Alè: 大家好 欢迎

3
00:00:10,944 --> 00:00:15,048
我是 Alè Segovia Azapian
来自 Apple GPU Software 团队

4
00:00:15,082 --> 00:00:18,385
Mayur: 我是 Mayur
也是来自 GPU Software 团队

5
00:00:18,418 --> 00:00:21,755
Alè: 在本次讲座中 我们将与
大家一起探究下无绑定渲染

6
00:00:21,788 --> 00:00:25,692
无绑定渲染模型是
为着色器提供资源

7
00:00:25,726 --> 00:00:29,096
解锁高级渲染技巧 如光线追踪的
全新方法

8
00:00:29,129 --> 00:00:34,201
今天 我首先与大家回顾下
无绑定渲染模型的运作

9
00:00:34,234 --> 00:00:39,339
您用 Metal 3 可以如何在
游戏和 App 中应用无绑定

10
00:00:40,440 --> 00:00:44,111
无绑定渲染通过汇总数据
为提高 CPU 和 GPU 的性能

11
00:00:44,144 --> 00:00:47,247
提供了新机会

12
00:00:47,281 --> 00:00:52,519
我今天会给您两个具体的
改善 CPU 和 GPU 时间的方法

13
00:00:53,387 --> 00:00:54,755
然后将会由 Mayur

14
00:00:54,788 --> 00:00:58,859
为大家展示这些工具
是如何帮您应用无绑定模型的

15
00:00:59,760 --> 00:01:02,129
在无绑定模型中
资源是通过参数缓冲区

16
00:01:02,162 --> 00:01:04,998
聚合连接到一起的

17
00:01:05,032 --> 00:01:07,501
从概念上讲 看起来是这样的

18
00:01:07,534 --> 00:01:12,005
在这个示例中 一个数组
聚合了场景中所有网格

19
00:01:12,039 --> 00:01:15,676
在传统绑定模型下
每个资源独立绑定

20
00:01:15,709 --> 00:01:17,644
到管线的具体位置中

21
00:01:17,678 --> 00:01:22,082
而无绑定模型则不同
资源首先在内存中连接在一起

22
00:01:22,115 --> 00:01:25,786
让您的着色器可以通过
自由遍历单个缓冲区

23
00:01:25,819 --> 00:01:27,888
来访问所需的资源

24
00:01:27,921 --> 00:01:32,259
以计算复杂的表面和光照

25
00:01:32,292 --> 00:01:34,261
App 采用无绑定后

26
00:01:34,294 --> 00:01:36,997
光线追踪着色器可访问
它们需要的所有数据

27
00:01:37,030 --> 00:01:39,800
绘制漂亮的反射

28
00:01:39,833 --> 00:01:42,069
这个 App 可以将
3D 模型和纹理

29
00:01:42,102 --> 00:01:46,073
包括地面 卡车 它们的材料
甚至天空

30
00:01:46,106 --> 00:01:48,175
全部放置在参数缓冲区

31
00:01:48,208 --> 00:01:51,979
让光线追踪着色器获取

32
00:01:52,012 --> 00:01:54,815
更好的是 无绑定渲染
与其它 Metal 例如堆的功能配对时

33
00:01:54,848 --> 00:01:59,319
减少了 CPU 压力

34
00:01:59,353 --> 00:02:02,489
让 App 和游戏获得更好的性能

35
00:02:02,523 --> 00:02:05,792
我给大家解释下 Metal 3 中
对无绑定渲染来说比较有用的

36
00:02:05,826 --> 00:02:08,929
四个具体的增强功能

37
00:02:09,530 --> 00:02:12,833
参数缓冲区作为
基础 Metal 构造

38
00:02:12,866 --> 00:02:15,702
允许您将资源连接在一起

39
00:02:15,736 --> 00:02:20,007
它们引用了资源
如纹理和其它缓冲区

40
00:02:20,040 --> 00:02:24,278
有了 Metal 3
写入参数缓冲区比之前更简单

41
00:02:24,311 --> 00:02:28,315
因为现在您不再需要
参数编码器对象

42
00:02:28,348 --> 00:02:31,785
对非固定数组也一样

43
00:02:31,818 --> 00:02:34,254
您现在可以从 Metal 堆中

44
00:02:34,288 --> 00:02:36,223
分配加速结构

45
00:02:36,256 --> 00:02:39,092
如果资源没有驻留在
GPU 内存中

46
00:02:39,126 --> 00:02:42,496
着色器验证层会
发出警告

47
00:02:42,529 --> 00:02:47,467
这四个功能让无绑定
变得更为简单

48
00:02:48,735 --> 00:02:54,107
特别是在 Metal 3 中写入
参数缓冲区轻松愉快

49
00:02:54,141 --> 00:02:56,343
要将场景编码到参数缓冲区中

50
00:02:56,376 --> 00:02:58,512
您可以将场景数据写入
这些缓冲区

51
00:02:58,545 --> 00:03:03,150
如实例 网格 材料和纹理

52
00:03:03,183 --> 00:03:07,621
在 Metal 2 中
这些是用参数编码器来完成的

53
00:03:07,654 --> 00:03:10,858
所以 我先带大家回顾下
这些对象是如何工作的

54
00:03:10,891 --> 00:03:14,928
然后我给大家演示
Metal 3 可以如何简化您的代码

55
00:03:14,962 --> 00:03:19,299
用参数编码器 第一步是
创建编码器实例

56
00:03:19,333 --> 00:03:21,568
您可通过着色器函数映射

57
00:03:21,602 --> 00:03:25,105
或通过向 Metal
描述结构体成员来创建

58
00:03:25,138 --> 00:03:29,309
有了编码器实例后
设置其记录目标和

59
00:03:29,343 --> 00:03:32,145
到目标参数缓冲的偏移

60
00:03:32,179 --> 00:03:36,083
然后使用其方法将数据
写入缓冲区

61
00:03:36,116 --> 00:03:38,151
您可查看去年的无绑定讲座

62
00:03:38,185 --> 00:03:42,856
回顾更多关于参数缓冲区
和参数编码器的信息

63
00:03:42,890 --> 00:03:44,725
现在这个机制非常好

64
00:03:44,758 --> 00:03:48,562
但是编码器对象有时候
不好管理

65
00:03:48,595 --> 00:03:51,798
Metal 提供了两种创建
参数编码器的机制

66
00:03:51,832 --> 00:03:55,369
哪种适合您的 App
可能不太明确

67
00:03:55,402 --> 00:04:00,507
此外 在多线程中使用
参数编码器需要格外小心

68
00:04:00,541 --> 00:04:04,111
开发者们都很直观地了解
如何写一个 C 结构体

69
00:04:04,144 --> 00:04:09,316
有了 Metal 3 您可以用同样的方法
使用参数缓冲区

70
00:04:09,349 --> 00:04:12,319
Metal 3 可让您
方便地写入参数缓冲区

71
00:04:12,352 --> 00:04:16,857
就象其他任何 CPU 端的结构一样
直接写入

72
00:04:16,890 --> 00:04:20,060
现在您可以访问
虚拟 GPU 地址

73
00:04:20,093 --> 00:04:23,797
和您资源的资源 ID 了

74
00:04:23,830 --> 00:04:26,366
当您直接将这些写入
参数缓冲区时

75
00:04:26,400 --> 00:04:29,937
Metal 现在理解您要引用的
是哪种资源

76
00:04:29,970 --> 00:04:32,873
和之前用参数编码器
来编码引用的方式相比

77
00:04:32,906 --> 00:04:37,678
两者在功能上是一样的
只是不再需要编码器了

78
00:04:37,711 --> 00:04:41,915
这种功能支持所有支持
二级参数缓冲区的设备

79
00:04:41,949 --> 00:04:45,452
也就是说 所有高于
2016 版本的 Mac

80
00:04:45,485 --> 00:04:50,123
和所有搭载 A13 仿生芯片
或更高版本的 iOS 设备

81
00:04:51,892 --> 00:04:54,962
如果您不确定设备是否支持
二级参数缓冲区

82
00:04:54,995 --> 00:05:00,267
可使用 MTLDevice 对象中的
功能咨询 非常方便

83
00:05:00,300 --> 00:05:03,904
该过程在 Metal 3 中
是这样的

84
00:05:03,937 --> 00:05:09,376
首先 定义 CPU 可见的结构
缓冲区的地址和纹理的 MTLResourceID

85
00:05:09,409 --> 00:05:13,680
需要使用 64 位类型

86
00:05:13,714 --> 00:05:16,550
然后 分配参数缓冲区

87
00:05:16,583 --> 00:05:23,056
您可直接从 MTLDevice
或从 MTLHeap 分配缓冲区

88
00:05:23,090 --> 00:05:29,062
您获得缓冲区内容 并将它转换为
参数缓冲区结构类型

89
00:05:29,096 --> 00:05:34,001
最后 将地址和资源 ID
写入结构体成员

90
00:05:34,034 --> 00:05:37,938
看下这在混合渲染示范程序中
是如何操作的

91
00:05:37,971 --> 00:05:41,542
这是代码 是不是很简单

92
00:05:41,575 --> 00:05:46,880
宿主结构直接存储
法线缓冲区的 GPU 地址

93
00:05:46,914 --> 00:05:52,653
这是 64 位 无符号整数
所以我使用了 uint64_t

94
00:05:52,686 --> 00:05:54,488
现在没有编码器对象了

95
00:05:54,521 --> 00:05:59,459
对于参数缓冲区
您只需使用结构体大小

96
00:05:59,493 --> 00:06:03,697
Metal 可确保 GPU
和 CPU 结构的尺寸和对齐

97
00:06:03,730 --> 00:06:07,100
与 clang 和 Metal 着色器编译器
相匹配

98
00:06:08,769 --> 00:06:13,273
接下来 如往常一样分配缓冲区

99
00:06:13,307 --> 00:06:16,143
如果缓冲区的存储模式是
Managed 或 Shared

100
00:06:16,176 --> 00:06:21,648
可将缓冲区的指针
强制转换为结构类型

101
00:06:21,682 --> 00:06:25,185
最后 将法线成员
设置为 gpuAddress

102
00:06:25,219 --> 00:06:29,623
如果需要，
再加上对齐 GPU 内存所需的地址偏移

103
00:06:32,359 --> 00:06:35,963
有一点要强调的是 结构声明
如何在 Metal 着色语言

104
00:06:35,996 --> 00:06:39,833
和 C 语言声明之间改变

105
00:06:39,867 --> 00:06:42,135
在这个例子中 这些是独立的

106
00:06:42,169 --> 00:06:46,573
但如果您愿意 可以在
共享头文件上只做一次结构声明

107
00:06:46,607 --> 00:06:49,243
使用条件编译来区分

108
00:06:49,276 --> 00:06:52,412
着色器编译器类型
和 C 语言类型

109
00:06:53,146 --> 00:06:56,149
这是 C 语言中的统一声明

110
00:06:56,183 --> 00:07:00,254
__METAL_VERSION__ 宏只在
编译着色器代码时定义

111
00:07:00,287 --> 00:07:05,692
用它在头文件声明中
区分 GPU 和 CPU 代码

112
00:07:05,726 --> 00:07:09,062
如果您的 App 以 C++ 为目标
可将其更进一步

113
00:07:09,096 --> 00:07:12,866
用模板来统一声明

114
00:07:13,867 --> 00:07:18,005
看下参数缓冲区
示例代码的最佳实践方法

115
00:07:18,038 --> 00:07:20,374
你可以这样写一个结构

116
00:07:20,407 --> 00:07:24,378
但您也可以用无限数组
来写入多个结构

117
00:07:24,411 --> 00:07:28,315
您可能在 Metal 中已经通过参数编码器
实现了无限数组

118
00:07:28,348 --> 00:07:31,251
但 Metal 3 进一步简化了流程

119
00:07:31,285 --> 00:07:35,122
使其可以仅填写一个结构数组

120
00:07:36,223 --> 00:07:40,160
这就是与写入
一个结构之间的区别

121
00:07:40,194 --> 00:07:46,400
您现在需要为您想要存储的
所有结构分配足够的存储空间

122
00:07:46,433 --> 00:07:52,539
然后 循环访问数组
为每个结构写入数据

123
00:07:53,540 --> 00:07:57,244
回到代码示例
首先 扩展缓冲区大小

124
00:07:57,277 --> 00:08:01,615
以便存储场景中
所有网格的结构

125
00:08:01,648 --> 00:08:05,385
这与您在 CPU 缓冲区的所做的
是完全一样的

126
00:08:05,419 --> 00:08:10,524
用网格数量乘以结构大小

127
00:08:10,557 --> 00:08:13,827
我想要花点时间
看下这有多强大

128
00:08:13,861 --> 00:08:17,631
这一个变量完全控制了
数组的大小

129
00:08:17,664 --> 00:08:19,600
着色器完全不需要
向 Metal 着色器编译器

130
00:08:19,633 --> 00:08:21,835
声明该大小

131
00:08:21,869 --> 00:08:24,771
而且可随意索引任何位置

132
00:08:24,805 --> 00:08:28,475
这就是 Metal 中无绑定模型
如此灵活的部分原因

133
00:08:28,509 --> 00:08:32,579
因为您可以编写着色器
毫无约束地访问任何大小的数组

134
00:08:32,613 --> 00:08:34,448
真的很好用

135
00:08:36,416 --> 00:08:40,187
接下来 分配这个大小的缓冲区

136
00:08:40,220 --> 00:08:44,892
将指向内容的指针强制转换为
正确的结构类型

137
00:08:46,860 --> 00:08:50,397
现在缓冲区已经足够大了
可以通过简单的循环

138
00:08:50,430 --> 00:08:55,102
按照网格结构的大小递进

139
00:08:55,135 --> 00:08:59,706
最后 直接设置数组中
每个结构的 GPUAddress

140
00:08:59,740 --> 00:09:02,309
以及根据需要添加对齐偏移

141
00:09:04,144 --> 00:09:06,613
从 GPU 端的着色器来说

142
00:09:06,647 --> 00:09:09,650
这是代表无限数组的
一种方法

143
00:09:09,683 --> 00:09:14,955
这里 我将其声明为网格指针参数
传送到着色器

144
00:09:16,657 --> 00:09:19,893
这样它可以
如所有 C 语言数组一样

145
00:09:19,927 --> 00:09:22,529
直接自由访问内容

146
00:09:25,365 --> 00:09:30,370
另一个选项是将所有无限数组
放入一个结构

147
00:09:30,404 --> 00:09:35,275
这可以通过在单一位置聚合数据
保持着色器整洁

148
00:09:35,309 --> 00:09:37,377
在这个例子中
所有网格和材料

149
00:09:37,411 --> 00:09:40,347
都统一在一个场景结构中

150
00:09:42,549 --> 00:09:45,719
使用该场景结构
场景可通过绑定一个缓冲区

151
00:09:45,752 --> 00:09:47,421
直接传递到着色器

152
00:09:47,454 --> 00:09:50,691
而不是独立传送
每个无限数组

153
00:09:52,459 --> 00:09:54,394
访问也如往常一样

154
00:09:54,428 --> 00:09:58,832
现在 可以通过场景结构
获取网格数组了

155
00:09:59,666 --> 00:10:04,371
这就是在 Metal 3 中写入
参数缓冲区和无限数组的方法

156
00:10:04,404 --> 00:10:07,241
完整修订的 API 现在
让其更直观

157
00:10:07,274 --> 00:10:12,212
与您在 CPU 结构或结构数组中
的做法相匹配

158
00:10:12,246 --> 00:10:14,114
通过今年的光线追踪更新

159
00:10:14,147 --> 00:10:17,284
光线追踪加速结构可
与您的缓冲区和纹理一起

160
00:10:17,317 --> 00:10:19,786
通过 Metal 堆分配

161
00:10:21,722 --> 00:10:24,491
这意味着它们可以彼此聚合在一起

162
00:10:24,525 --> 00:10:26,960
也可以与其它资源类型聚合

163
00:10:26,994 --> 00:10:30,864
这就很好 因为如果您将
所有加速结构聚合到堆

164
00:10:30,898 --> 00:10:35,269
就可以用 useHeap 在单次调用中
将它们全部标记为常驻

165
00:10:35,302 --> 00:10:38,438
这在您 App 的渲染线程中

166
00:10:38,472 --> 00:10:41,041
可极大地节约 CPU

167
00:10:42,476 --> 00:10:46,113
这是一些在堆中
使用加速结构的技巧

168
00:10:46,146 --> 00:10:49,349
首先 从堆中配置时
加速结构在对齐和大小方面

169
00:10:49,383 --> 00:10:53,787
有一定的要求
且因设备而异

170
00:10:53,820 --> 00:10:56,790
这是一项新的查询
查看堆分配的加速结构的

171
00:10:56,823 --> 00:11:00,227
大小和对齐

172
00:11:00,260 --> 00:11:03,864
使用 MTLDevice 的 heapAccelerationStructureSize
andAlignWithDescriptor 方法

173
00:11:03,897 --> 00:11:06,834
为结构描述符

174
00:11:06,867 --> 00:11:09,803
确定 SizeAndAlignment

175
00:11:09,837 --> 00:11:11,705
要记住 这和 MTLDevice 设备中的

176
00:11:11,738 --> 00:11:14,408
accelerationStructureSizes
WithDescriptor 方法

177
00:11:14,441 --> 00:11:16,443
是不同的

178
00:11:18,612 --> 00:11:22,015
现在加速结构
在 MTLHeap 对象中了

179
00:11:22,049 --> 00:11:25,652
调用 useHeap: 通过一次调用
让它们都成为常驻

180
00:11:25,686 --> 00:11:31,758
这比为每个独立资源
调用 useResource 更快

181
00:11:31,792 --> 00:11:35,095
记住 除非您选择堆为
风险跟踪

182
00:11:35,128 --> 00:11:38,999
Metal 不会防止
资源的竞态条件

183
00:11:39,032 --> 00:11:41,768
所以您需要同步彼此之间的
加速结构构建

184
00:11:41,802 --> 00:11:44,938
且与光线追踪运行同步

185
00:11:44,972 --> 00:11:47,441
不过不用担心
我稍后会再详细阐述这部分

186
00:11:48,942 --> 00:11:50,310
记得要查看今年的

187
00:11:50,344 --> 00:11:53,180
“Maximize your Metal ray tracing
performance” 讲座

188
00:11:53,213 --> 00:11:54,081
以获得更多关于

189
00:11:54,114 --> 00:11:58,118
这个话题和 Metal 3 其它
光线追踪性能改进的信息

190
00:11:58,151 --> 00:12:02,122
使用堆分配的加速结构
在必要的时候

191
00:12:02,155 --> 00:12:06,059
让你有机会减少 App 的
CPU 使用率

192
00:12:06,093 --> 00:12:09,763
最后 这是我今年最喜欢的
功能之一

193
00:12:09,796 --> 00:12:12,866
即着色器验证增强功能

194
00:12:13,867 --> 00:12:16,436
在 useResource
和 useHeap 的话题中

195
00:12:16,470 --> 00:12:18,972
非常重要的一点是
App 为 Metal

196
00:12:19,006 --> 00:12:22,075
对所有间接访问资源标注驻留

197
00:12:22,109 --> 00:12:25,712
如果忘了这一操作意味着
支持这些资源的存储页面

198
00:12:25,746 --> 00:12:28,582
不一定会在渲染时间出现

199
00:12:28,615 --> 00:12:34,188
这可能会导致指令缓冲失败
GPU 重启或甚至图像损坏

200
00:12:34,221 --> 00:12:37,457
不幸的是 这些问题在开启了

201
00:12:37,491 --> 00:12:40,494
无绑定流程期间很常遇到
因为在无绑定中

202
00:12:40,527 --> 00:12:43,864
场景资源的大部分
是间接访问的

203
00:12:43,897 --> 00:12:48,769
着色器在运行期间
做出指针遍历决策

204
00:12:48,802 --> 00:12:51,705
今年 Metal 3 推出了全新的

205
00:12:51,738 --> 00:12:54,908
着色器验证层功能
可帮助您追踪

206
00:12:54,942 --> 00:12:58,712
指令缓冲执行过程中
未驻留的资源

207
00:12:58,745 --> 00:13:01,181
我给大家看一个具体的例子

208
00:13:01,215 --> 00:13:03,951
在混合渲染 App 的
更新过程中

209
00:13:03,984 --> 00:13:09,356
我们有时会遇到反射错误的
现实问题

210
00:13:09,389 --> 00:13:14,127
我给大家演示下验证层
是如何帮助诊断和修正问题的

211
00:13:15,362 --> 00:13:19,533
要向 Metal 标记驻留
App 在加载期间将所有独立的

212
00:13:19,566 --> 00:13:24,538
不是分配在堆上的
资源存入一个可变集合

213
00:13:24,571 --> 00:13:28,809
App 添加缓冲区
添加纹理

214
00:13:28,842 --> 00:13:32,779
在渲染期间 在 App 发送
光线追踪核心程序前

215
00:13:32,813 --> 00:13:37,050
它向 Metal 示意使用
集内的所有资源

216
00:13:37,084 --> 00:13:39,953
这是一个简单的流程
App 在遍历集合

217
00:13:39,987 --> 00:13:43,190
在每个元素上
调用 useResource

218
00:13:43,223 --> 00:13:46,026
随后 Metal 在开始
光线追踪工作前

219
00:13:46,059 --> 00:13:49,263
将所有资源设为驻留

220
00:13:49,296 --> 00:13:53,800
这是 App 将资源
加入集合的部分代码

221
00:13:53,834 --> 00:13:58,772
App 将其作为参数缓冲区
写入流程的一部分

222
00:13:58,805 --> 00:14:03,810
App 的加载函数
遍历每个子网格

223
00:14:03,844 --> 00:14:06,346
它抓取所需要的数据
写入参数缓冲区

224
00:14:06,380 --> 00:14:11,151
即索引数据 材料的纹理数据

225
00:14:11,185 --> 00:14:16,123
然后将索引缓冲区地址
存入参数缓冲区

226
00:14:16,156 --> 00:14:18,959
而在材料方面 它查看纹理数组

227
00:14:18,992 --> 00:14:24,865
将纹理 GPU 资源 ID
写入参数缓冲区

228
00:14:24,898 --> 00:14:27,935
最后 它将子网格材料中
所有独立纹理

229
00:14:27,968 --> 00:14:31,138
添加到 sceneResources 集

230
00:14:31,171 --> 00:14:34,174
从而在发送的时候
将它们标记为驻留

231
00:14:35,976 --> 00:14:39,713
不幸的是 这里有一个
小 bug

232
00:14:39,746 --> 00:14:41,648
App 运行指令缓冲区

233
00:14:41,682 --> 00:14:45,285
在某些情况下 反射会丢失

234
00:14:45,319 --> 00:14:49,556
之前 这很难追踪

235
00:14:49,590 --> 00:14:53,827
现在 在 Metal 3 中
着色器验证层可以帮上大忙

236
00:14:53,861 --> 00:14:57,865
这种问题现在会在
指令缓冲执行期间生成错误

237
00:14:57,898 --> 00:15:01,768
示意错误的内容

238
00:15:01,802 --> 00:15:03,604
错误信息会指示

239
00:15:03,637 --> 00:15:07,007
触发问题的着色器名称

240
00:15:07,040 --> 00:15:09,409
通道名称

241
00:15:09,443 --> 00:15:14,181
metal 文件和检测到访问的
代码行

242
00:15:14,214 --> 00:15:17,317
甚至是缓冲区标签和大小

243
00:15:17,351 --> 00:15:20,554
以及它未驻留的事实

244
00:15:20,587 --> 00:15:24,825
作为一个专业建议 标记 Metal 对象
总是最佳实践

245
00:15:24,858 --> 00:15:27,694
工具使用标签 在尝试识别

246
00:15:27,728 --> 00:15:30,831
调试您 App 的对象时很有用

247
00:15:30,864 --> 00:15:32,799
手上有了这些细节信息

248
00:15:32,833 --> 00:15:36,770
现在就很容易在着色器代码中
找到丢失的资源了

249
00:15:36,803 --> 00:15:40,340
更好的是 当调试断点启用后

250
00:15:40,374 --> 00:15:44,011
Xcode 很方便地展示了
着色器验证检测到问题的

251
00:15:44,044 --> 00:15:47,447
具体着色器代码行

252
00:15:47,481 --> 00:15:51,852
在 demo App 中
索引缓冲区没有驻留

253
00:15:51,885 --> 00:15:55,422
修正方法就很直接了

254
00:15:55,455 --> 00:15:57,658
回到代码

255
00:15:57,691 --> 00:15:59,960
App 现在将丢失的索引缓冲区

256
00:15:59,993 --> 00:16:02,829
存储到了驻留资源集中

257
00:16:02,863 --> 00:16:05,532
有了这些调整
在稍后的光线追踪时间内

258
00:16:05,566 --> 00:16:10,838
Metal 知道要让索引缓冲区
对于 GPU 可用 从而解决问题

259
00:16:10,871 --> 00:16:13,841
这是一个很必要的工具
也是一个游戏改变者

260
00:16:13,874 --> 00:16:19,079
这能在您无绑定旅程中
大大节约了潜在的调试时间

261
00:16:19,112 --> 00:16:22,349
所以这些就是 Metal 3 带来的
管理和引用

262
00:16:22,382 --> 00:16:24,685
无绑定资源的增强功能

263
00:16:24,718 --> 00:16:27,321
现在我要换个话题
跟大家分享下在无绑定过程中

264
00:16:27,354 --> 00:16:30,190
如何最大化游戏性能

265
00:16:30,224 --> 00:16:32,793
在这一部分 我会讲两个话题

266
00:16:32,826 --> 00:16:36,597
非持有资源及
未追踪资源

267
00:16:36,630 --> 00:16:40,133
这些技巧可以帮助您
在有长期和聚合的资源时

268
00:16:40,167 --> 00:16:44,638
可获得更好的 CPU
和 GPU 性能

269
00:16:44,671 --> 00:16:48,509
现在我们来看下如何通过
长期资源提高 CPU 性能

270
00:16:48,542 --> 00:16:51,678
我先与大家回顾下
Metal 资源的生命周期

271
00:16:51,712 --> 00:16:56,884
Objective-C 和 Swift 通过
引用计数处理对象生命周期

272
00:16:56,917 --> 00:16:59,319
Metal 资源沿袭了这一模型

273
00:16:59,353 --> 00:17:02,222
资源的 retainCount 始于 1

274
00:17:02,256 --> 00:17:07,461
在所有强引用消失后
运行时会释放它们

275
00:17:07,494 --> 00:17:10,998
因为 CPU 和 GPU
是并行操作的

276
00:17:11,031 --> 00:17:14,401
如果 CPU 在 GPU 还在使用时
就允许 retainCount 达到 0

277
00:17:14,434 --> 00:17:18,672
并释放这个资源
将会导致问题

278
00:17:19,706 --> 00:17:23,377
为了避免这一问题 Metal
指令缓冲区为其使用的

279
00:17:23,410 --> 00:17:25,179
所有资源创建了强引用

280
00:17:25,212 --> 00:17:30,284
确保 retainCount 最少为 1

281
00:17:30,317 --> 00:17:33,120
Metal 为您直接绑定至管线的

282
00:17:33,153 --> 00:17:35,222
资源创建了强引用

283
00:17:35,255 --> 00:17:39,693
如通过 setVertexBuffer
或 setFragmentTexture 这些函数

284
00:17:39,726 --> 00:17:42,896
也还包括渲染附件

285
00:17:42,930 --> 00:17:48,168
您通过 useHeap API 标记为
驻留的 Metal 堆对象

286
00:17:48,202 --> 00:17:50,637
以及您通过 useResource API

287
00:17:50,671 --> 00:17:55,475
设为驻留的间接资源
即使它们是堆的一部分

288
00:17:55,509 --> 00:17:58,078
您可查看今年的 “Program Metal
in C++ with metal-cpp” 讲座

289
00:17:58,111 --> 00:18:03,317
以了解更多关于 Mental 对象
生命周期的信息

290
00:18:03,350 --> 00:18:06,486
现在 Metal 创建这些引用
是非常有用的

291
00:18:06,520 --> 00:18:08,722
因为作为程序设计员来说
您无需担心

292
00:18:08,755 --> 00:18:13,393
可能释放了
GPU 正在使用的对象

293
00:18:13,427 --> 00:18:17,264
Metal 为您提供的这种安全保证
可以很快执行

294
00:18:17,297 --> 00:18:20,534
但也还是会带来一个小小的
CPU 成本

295
00:18:20,567 --> 00:18:25,305
在无绑定模型中
Apps 将资源聚合为堆

296
00:18:25,339 --> 00:18:28,842
这些应该是长期的
与应用范围相匹配

297
00:18:28,876 --> 00:18:34,214
例如 在游戏中 资源
在整个关卡的持续时间都是活跃的

298
00:18:34,248 --> 00:18:36,917
在这种情况下 针对资源的
生命周期

299
00:18:36,950 --> 00:18:40,587
Metal 无需提供额外的保证

300
00:18:41,288 --> 00:18:44,324
那您可以通过让 Metal
指令缓冲器不要保持

301
00:18:44,358 --> 00:18:49,329
它们到资源的引用
来收回 CPU 成本

302
00:18:50,564 --> 00:18:53,133
要关闭 Metal 的自动保持
资源引用计数的功能

303
00:18:53,166 --> 00:18:57,271
只要创建一个非持有引用的
指令缓冲区

304
00:18:57,304 --> 00:19:00,040
您可以直接从 MTLCommandQueue
来完成

305
00:19:00,073 --> 00:19:03,143
如同您创建常规指令缓冲区一样

306
00:19:03,177 --> 00:19:05,479
您不需要对 App 做出任何改变

307
00:19:05,512 --> 00:19:08,815
只要您已确保了资源生命周期

308
00:19:09,783 --> 00:19:12,519
要记住这个设置的粒度级别

309
00:19:12,553 --> 00:19:14,454
是整个指令缓冲区

310
00:19:14,488 --> 00:19:18,825
它要么持有所有引用资源
或要么完全不持有

311
00:19:19,826 --> 00:19:21,361
在小规模基准测试中

312
00:19:21,395 --> 00:19:26,099
仅仅通过转换为非持有引用的
指令缓冲区

313
00:19:26,133 --> 00:19:29,403
CPU 使用率在指令缓冲区的
生命周期就减少了 2%

314
00:19:29,436 --> 00:19:32,172
但这些时间完全用在了

315
00:19:32,206 --> 00:19:36,043
创建和摧毁不必要的强引用上

316
00:19:37,044 --> 00:19:42,216
总的来说 非持有资源
在您已经确保了资源生命周期时

317
00:19:42,249 --> 00:19:46,220
提供了节约额外 CPU 的机会

318
00:19:46,253 --> 00:19:49,456
与非持有资源相似
非跟踪资源

319
00:19:49,489 --> 00:19:52,359
提供了一个禁用安全功能

320
00:19:52,392 --> 00:19:55,095
获取更多性能的机会

321
00:19:55,128 --> 00:19:58,599
有许多视觉技巧都需要
先渲染到中间纹理和写入缓存区

322
00:19:58,632 --> 00:20:02,803
并在后续的通道中使用

323
00:20:02,836 --> 00:20:07,674
阴影映射 蒙皮和后期处理
都是很好的例子

324
00:20:07,708 --> 00:20:11,378
现在 生成并立即消费资源

325
00:20:11,411 --> 00:20:15,115
会带来写完后再读的风险

326
00:20:15,148 --> 00:20:18,318
此外 如多个通道
写到同一个资源中

327
00:20:18,352 --> 00:20:19,520
如两条渲染通道

328
00:20:19,553 --> 00:20:22,956
相继绘制到同一个附件中

329
00:20:22,990 --> 00:20:26,226
或两个位块传输编码器
写入同一个资源中

330
00:20:26,260 --> 00:20:28,662
由于 Metal 在 GPU 上
调度工作的方式

331
00:20:28,695 --> 00:20:33,133
会产生写完后再写的风险

332
00:20:33,166 --> 00:20:36,436
当您使用被跟踪资源时
Metal 自动使用

333
00:20:36,470 --> 00:20:41,375
同步原语以避免
GPU 时间线上的风险

334
00:20:41,408 --> 00:20:43,810
比如 Metal 让 GPU 等到

335
00:20:43,844 --> 00:20:46,547
写入缓冲区的
计算蒙皮通道结束后

336
00:20:46,580 --> 00:20:50,617
再启动读取同样缓冲区的
场景渲染通道

337
00:20:51,652 --> 00:20:52,819
这非常好

338
00:20:52,853 --> 00:20:57,090
正因为如此 Metal 被认为是
易于接受的图形 API

339
00:20:57,124 --> 00:20:59,193
但对于聚合资源到堆的
App 来说

340
00:20:59,226 --> 00:21:02,229
还是有一些性能考虑的

341
00:21:03,230 --> 00:21:05,265
思考下这个示例

342
00:21:05,299 --> 00:21:06,867
这个 GPU 正在运行中

343
00:21:06,900 --> 00:21:09,036
相继绘制两帧
包含顶点蒙皮

344
00:21:09,069 --> 00:21:13,640
渲染场景 应用色调映射

345
00:21:13,674 --> 00:21:17,578
GPU 在 App 的指示下持续运行
Metal 基于资源依赖关系

346
00:21:17,611 --> 00:21:22,850
发现渲染和计算工作
可重叠的机会

347
00:21:22,883 --> 00:21:26,019
如没有对应的依赖关系
条件也合适

348
00:21:26,053 --> 00:21:29,756
Metal 会重叠调度工作
并行运行

349
00:21:29,790 --> 00:21:33,293
这能让 GPU 的工作饱和
在同样的时间内

350
00:21:33,327 --> 00:21:36,296
能完成更多工作

351
00:21:38,298 --> 00:21:41,568
现在 App 将资源聚合到堆时

352
00:21:41,602 --> 00:21:45,606
所有子资源都以一个整体
出现在 Metal 前

353
00:21:45,639 --> 00:21:48,642
因此堆的协作更高效

354
00:21:48,675 --> 00:21:52,779
但这意味着 Metal
看到读写工作是在同一资源上

355
00:21:52,813 --> 00:21:56,950
且必须谨慎计划 以避免竞态条件

356
00:21:56,984 --> 00:22:00,087
哪怕并没有实际风险存在时

357
00:22:02,823 --> 00:22:06,393
如您所料
这个情况称为“伪共享”

358
00:22:06,426 --> 00:22:10,464
它增加了 GPU 工作
执行的持续时间

359
00:22:10,497 --> 00:22:12,232
所以有一个性能方面的小技巧

360
00:22:12,266 --> 00:22:15,969
如果您知道堆中的资源
没有依赖关系

361
00:22:16,003 --> 00:22:17,938
那您可以避免这一行为

362
00:22:18,939 --> 00:22:23,310
要避免伪共享 您可将资源
排除在风险追踪之外

363
00:22:23,343 --> 00:22:27,681
直接向 Metal 示意
细粒度依赖关系

364
00:22:27,714 --> 00:22:29,383
您通过将资源描述符的

365
00:22:29,416 --> 00:22:34,121
hazardTracking 设置为 Untracked
从而将资源追踪排除

366
00:22:34,154 --> 00:22:37,591
因为这太重要了
所以这是堆的默认设置

367
00:22:37,624 --> 00:22:40,494
它允许您解锁更多

368
00:22:40,527 --> 00:22:43,397
GPU 得以立刻
并行运行工作的机会

369
00:22:43,430 --> 00:22:45,499
一旦您开始使用非追踪资源

370
00:22:45,532 --> 00:22:48,969
您要使用以下原语
传达依赖关系

371
00:22:49,002 --> 00:22:54,675
基于不同的情况
使用 Fences Events

372
00:22:54,708 --> 00:22:58,946
Shared Events 或 Memory Barriers

373
00:22:58,979 --> 00:23:02,282
Metal Fences 可以为
同一指令队列内

374
00:23:02,316 --> 00:23:04,585
不同的渲染和计算通道间

375
00:23:04,618 --> 00:23:07,921
访问一个或更多资源做同步

376
00:23:07,955 --> 00:23:10,290
这是一种分离屏障式的原语

377
00:23:10,324 --> 00:23:15,195
因此消费者通道会等到
生产者发出 Fence 信号

378
00:23:18,966 --> 00:23:22,202
您唯一需要记住的要求是
当使用 Fences 时

379
00:23:22,236 --> 00:23:26,006
就是先提交或入队
生产者指令缓冲区

380
00:23:26,039 --> 00:23:29,643
再到消费者指令缓冲区

381
00:23:29,676 --> 00:23:31,378
当您无法保证顺序

382
00:23:31,411 --> 00:23:34,615
或是为同一设备上
多个队列来同步时

383
00:23:34,648 --> 00:23:37,150
可以使用 MTL Events

384
00:23:37,184 --> 00:23:41,622
使用 Events 消费者者指令缓冲区
等待生产者的指令缓冲区

385
00:23:41,655 --> 00:23:44,992
发出指定数值的 Event 信号

386
00:23:45,025 --> 00:23:48,829
在其发出数值信号后
就可安全读取资源

387
00:23:48,862 --> 00:23:54,568
使用 Events 来提示 GPU
暂停工作 直至指令发出 Event 信号

388
00:23:54,601 --> 00:23:58,372
MTLSharedEvents 与常规 Events
行为非常相似

389
00:23:58,405 --> 00:24:02,743
但工作范围更大
可以超越单独 GPU 工作

390
00:24:02,776 --> 00:24:04,945
使用这些来同步不同
Metal 设备之间的

391
00:24:04,978 --> 00:24:08,815
资源访问 甚至包括 CPU

392
00:24:08,849 --> 00:24:11,185
例如 使用 Shared Events 来
处理 GPU

393
00:24:11,218 --> 00:24:14,188
取自 CPU 的 计算结果

394
00:24:14,221 --> 00:24:16,123
以下是示例

395
00:24:16,156 --> 00:24:19,526
这个例子中的 GPU
用计算通道为网格蒙皮

396
00:24:19,560 --> 00:24:23,530
CPU 存储姿态到磁盘

397
00:24:23,564 --> 00:24:25,899
因为有两个独立的设备

398
00:24:25,933 --> 00:24:31,471
使用 Shared Event 让 CPU 等待
直到 GPU 生成资源

399
00:24:31,505 --> 00:24:34,107
起初 CPU 无条件地开始等待

400
00:24:34,141 --> 00:24:38,846
GPU 发出 Shared Event 信号

401
00:24:38,879 --> 00:24:42,482
当 GPU 生成资源
将其放置于统一内存中时

402
00:24:42,516 --> 00:24:44,518
它发出 Shared Event 信号

403
00:24:44,551 --> 00:24:47,921
在这时 CPU 的等待线程唤醒

404
00:24:47,955 --> 00:24:50,424
安全使用资源

405
00:24:52,426 --> 00:24:55,462
最后一种原语类型
是 Memory Barriers

406
00:24:55,495 --> 00:24:58,765
Memory Barriers 强迫所有
单一渲染或计算通道中的

407
00:24:58,799 --> 00:25:02,936
后续指令等待
直到之前的所有指令完成

408
00:25:02,970 --> 00:25:08,208
在大部分情况下 barrier 的成本
与 Fence 的成本接近

409
00:25:08,242 --> 00:25:10,944
然而 只有一个例外

410
00:25:14,348 --> 00:25:19,186
这个例外就是渲染通道中
片元阶段后的 barriers

411
00:25:19,219 --> 00:25:21,622
这些 barriers 成本非常高

412
00:25:21,655 --> 00:25:24,525
相当于打断了渲染通道

413
00:25:24,558 --> 00:25:28,462
Metal 在 Apple GPUs 上
禁用片元阶段后的 barriers

414
00:25:28,495 --> 00:25:32,199
从而帮助您的 Apps
保持在最快的驱动路径

415
00:25:32,232 --> 00:25:35,469
如果您在 Apple GPUs 上
在片元阶段后添加 barrier

416
00:25:35,502 --> 00:25:39,940
Metal 调试层甚至会生成
验证错误

417
00:25:39,973 --> 00:25:43,110
推荐使用 Fence 来

418
00:25:43,143 --> 00:25:45,345
同步片元阶段后资源访问

419
00:25:46,413 --> 00:25:48,916
以下是同步原语的简短总结

420
00:25:48,949 --> 00:25:51,185
以及该何时使用它们

421
00:25:51,218 --> 00:25:53,987
最好使用 Fences
以确保成本最低

422
00:25:54,021 --> 00:25:55,789
它适合提交和入队的工作

423
00:25:55,822 --> 00:25:59,793
在同一指令队列
以先生成再消费的顺序情况下

424
00:25:59,826 --> 00:26:04,298
Fences 对大多数常用情况来说
是很好的

425
00:26:04,331 --> 00:26:06,500
当提交指令无法确定顺序时

426
00:26:06,533 --> 00:26:11,138
或当有多个指令队列时
使用 Metal Events

427
00:26:11,171 --> 00:26:14,107
Shared Events 允许
多 GPUs 相互之间

428
00:26:14,141 --> 00:26:16,243
或与 CPU 同步

429
00:26:16,276 --> 00:26:20,948
只在这些特定的
多设备情况下来使用它们

430
00:26:20,981 --> 00:26:25,586
在通道内的同步场景
最好使用 Memory Barriers

431
00:26:25,619 --> 00:26:28,255
Barriers 是大部分案例下的
快速原语

432
00:26:28,288 --> 00:26:32,226
如并发的计算通道
及 draw call 之间的顶点阶段

433
00:26:32,259 --> 00:26:36,230
但温馨提示下 在通道间的
片元阶段后同步

434
00:26:36,263 --> 00:26:38,765
使用 Fence
而不是 barrier

435
00:26:38,799 --> 00:26:42,936
因为这些 barriers 成本很高
Apple GPUs 并不允许

436
00:26:44,071 --> 00:26:47,741
使用非跟踪资源及
手动细粒度追踪

437
00:26:47,774 --> 00:26:51,712
您现在可以在最大化
GPU 并行时

438
00:26:51,745 --> 00:26:55,782
拥有数据聚合的所有优势

439
00:26:55,816 --> 00:26:59,186
这些是通过无绑定

440
00:26:59,219 --> 00:27:02,923
充分利用 CPU 和 GPU
提升性能的技巧

441
00:27:02,956 --> 00:27:05,359
对于 Metal 3 如何解锁简化

442
00:27:05,392 --> 00:27:07,194
和高效的无绑定工作流
我今天说了很多

443
00:27:07,227 --> 00:27:09,429
但写代码只是等式的一半

444
00:27:09,463 --> 00:27:12,266
另一半是这些可用的工具
如何帮助您验证

445
00:27:12,299 --> 00:27:15,002
GPU 是如何看待
和执行工作的

446
00:27:15,035 --> 00:27:16,570
现在我们有请 Mayur

447
00:27:16,603 --> 00:27:19,806
来为大家分享下 Metal 3 的
无绑定工具有哪些更新

448
00:27:19,840 --> 00:27:22,576
Mayur: 谢谢 Alè

449
00:27:22,609 --> 00:27:26,046
今天 很高兴能为大家演示
Metal Debugger 的一些

450
00:27:26,079 --> 00:27:31,752
强大的新功能 帮助您调试
和优化无绑定 Apps

451
00:27:31,785 --> 00:27:34,788
我用 Alè 刚刚给您看的
混合渲染 App 中

452
00:27:34,821 --> 00:27:37,191
抓取的一帧为例

453
00:27:37,224 --> 00:27:39,660
当您在 Metal Debugger 中
抓到一帧

454
00:27:39,693 --> 00:27:41,795
您会先看到 Summary 页面

455
00:27:41,828 --> 00:27:44,698
给您提供帧概览

456
00:27:44,731 --> 00:27:50,037
以及如何提升 App 性能的
帮助建议

457
00:27:50,070 --> 00:27:54,308
但今天 我很高兴地问您展示
一个全新的依赖关系图

458
00:27:54,341 --> 00:28:00,347
要打开它 您只需点击
左边的 Dependencies

459
00:28:00,380 --> 00:28:02,683
这是新的依赖关系图

460
00:28:02,716 --> 00:28:08,088
其特点在于全新功能带来的
全新的设计

461
00:28:08,121 --> 00:28:12,593
依赖关系图将您的
工作负荷

462
00:28:12,626 --> 00:28:14,928
用基于图形的方式来展示

463
00:28:14,962 --> 00:28:18,866
图形中的每个节点
都代表一个通道

464
00:28:18,899 --> 00:28:25,439
由一个指令编码器编码
和它的输出资源

465
00:28:25,472 --> 00:28:31,245
边缘展现了通道之间的
资源依赖

466
00:28:31,278 --> 00:28:34,381
通过今年新推出的功能
您可以根据两种依赖关系

467
00:28:34,414 --> 00:28:37,751
来分析您的工作负荷

468
00:28:37,784 --> 00:28:40,387
数据流和同步

469
00:28:40,420 --> 00:28:43,690
实线代表数据流

470
00:28:43,724 --> 00:28:47,294
它们为您展示了
数据在您 App 上是如何流动的

471
00:28:47,327 --> 00:28:52,199
虚线代表同步
它们展示了通道之间

472
00:28:52,232 --> 00:28:57,738
进行 GPU 同步的依赖关系

473
00:28:57,771 --> 00:29:03,343
您可以点击任意编码器
资源或边缘来了解更多信息

474
00:29:03,377 --> 00:29:09,283
调试器会在新的侧边栏为您展示
许多详细信息

475
00:29:09,316 --> 00:29:12,886
例如 这一边缘添加了同步

476
00:29:12,920 --> 00:29:17,391
且在这些通道间有数据流

477
00:29:17,424 --> 00:29:21,295
默认情况下依赖关系图
同时展示数据流

478
00:29:21,328 --> 00:29:23,964
和同步依赖关系

479
00:29:23,997 --> 00:29:27,501
但您可以最底部的菜单

480
00:29:27,534 --> 00:29:31,238
来查看一个依赖类型

481
00:29:31,271 --> 00:29:36,977
这里 我只查看同步

482
00:29:37,010 --> 00:29:41,281
如 Alè 刚才所说
伪共享是在追踪堆里

483
00:29:41,315 --> 00:29:45,853
读写不同资源的常见问题

484
00:29:45,886 --> 00:29:50,424
依赖关系图让捕捉这些问题
变得更简单

485
00:29:50,457 --> 00:29:54,027
我抓取的这一示例
来自早期的开发版本

486
00:29:54,061 --> 00:29:57,097
正是出现了该问题

487
00:29:57,130 --> 00:30:02,069
如果我点击这个堆
依赖关系图会显示

488
00:30:02,102 --> 00:30:04,438
该堆已被追踪

489
00:30:04,471 --> 00:30:09,910
因此在两条通道之间添加同步

490
00:30:09,943 --> 00:30:16,016
依赖关系图也强调了
在堆内部分配的资源

491
00:30:16,049 --> 00:30:21,054
如这个渲染编码器存储的
渲染目标纹理

492
00:30:21,088 --> 00:30:26,593
以及计算编码器读取和写入的
缓冲区

493
00:30:26,627 --> 00:30:32,633
问题在于 两条通道之间的同步
并不必要

494
00:30:32,666 --> 00:30:39,139
因为计算编码器没有使用
之前编码器中的任何资源

495
00:30:39,173 --> 00:30:44,545
要移除该依赖关系
我可以调整 App 以使用非跟踪堆

496
00:30:44,578 --> 00:30:48,615
在同步需要的地方插入 Fences

497
00:30:48,649 --> 00:30:55,022
通过这一调整 这两条通道
现在可并行运行了

498
00:30:55,055 --> 00:30:58,192
Xcode 14 中另一个改进

499
00:30:58,225 --> 00:31:02,729
帮助调试您的无绑定 App
是最新的资源清单

500
00:31:02,763 --> 00:31:09,002
我可以导航到想要调试的 draw call
并打开它

501
00:31:09,036 --> 00:31:13,373
当使用无绑定时
数百个甚至数千个资源

502
00:31:13,407 --> 00:31:17,144
在 GPU 任意时间都是可用的

503
00:31:17,177 --> 00:31:20,714
今年 Metal 调试器为您提供了

504
00:31:20,747 --> 00:31:24,585
检查 draw call 访问的是
哪个资源的能力

505
00:31:24,618 --> 00:31:29,189
只要点击顶上的
“Accessed” 模式即可

506
00:31:29,223 --> 00:31:33,594
现在调试器只展示了
draw call 访问的

507
00:31:33,627 --> 00:31:40,267
少数资源 以及每个访问的类型

508
00:31:40,300 --> 00:31:46,173
这对于理解您的着色器
从参数缓冲区访问了

509
00:31:46,206 --> 00:31:48,675
哪些资源非常有用

510
00:31:48,709 --> 00:31:53,213
知道您的 draw call 使用了
哪些资源 这样太好了

511
00:31:53,247 --> 00:31:56,550
但如果它只展示了
非您预期的资源

512
00:31:56,583 --> 00:32:01,321
您可以使用着色器调试器
来看下是什么情况

513
00:32:01,355 --> 00:32:03,223
要启动着色器调试器

514
00:32:03,257 --> 00:32:07,694
只要点击底部工具栏的
调试按钮

515
00:32:07,728 --> 00:32:11,465
选择您要调试的像素

516
00:32:11,498 --> 00:32:15,102
点击调试按钮

517
00:32:15,135 --> 00:32:19,072
现在您已进入着色器调试器

518
00:32:19,106 --> 00:32:24,912
着色器调试器展示了
您的代码是如何逐行执行的

519
00:32:24,945 --> 00:32:29,149
包括访问了哪个资源

520
00:32:29,183 --> 00:32:35,122
在这些行中
着色器从参数缓冲区读取纹理

521
00:32:35,155 --> 00:32:39,026
我可将详细视图扩展到右侧栏

522
00:32:39,059 --> 00:32:43,730
查看读取的是哪个资源

523
00:32:43,764 --> 00:32:47,835
这可帮助识别您的着色器访问了

524
00:32:47,868 --> 00:32:51,605
哪个错误的参数缓冲区元素

525
00:32:51,638 --> 00:32:56,009
在这个 demo 中 我问大家展示了
如何使用新的依赖关系视图

526
00:32:56,043 --> 00:32:59,446
来分析和验证资源依赖关系

527
00:32:59,479 --> 00:33:03,717
如何使用新的资源清单
来理解 draw call 访问了

528
00:33:03,750 --> 00:33:05,686
哪个资源

529
00:33:05,719 --> 00:33:09,690
以及如何使用着色器调试器
来逐行分析

530
00:33:09,723 --> 00:33:12,159
着色器是如何执行的

531
00:33:12,192 --> 00:33:15,262
我已经迫不及待看看大家
是如何使用这些新功能

532
00:33:15,295 --> 00:33:17,931
来创建强大的 Metal
无绑定 Apps 了

533
00:33:17,965 --> 00:33:19,666
交回给您 Alè

534
00:33:19,700 --> 00:33:23,003
Alè: 谢谢 Mayur
非常了不起的 demo

535
00:33:23,036 --> 00:33:27,474
总结一下 Metal 3
为无绑定带来了许多改进

536
00:33:27,508 --> 00:33:29,743
通过简化参数缓冲区编码

537
00:33:29,776 --> 00:33:31,812
分配在堆上的加速结构

538
00:33:31,845 --> 00:33:34,715
提升验证层和工具

539
00:33:34,748 --> 00:33:36,650
Metal 3 是一个优秀的 API

540
00:33:36,683 --> 00:33:40,654
能为您的游戏和 App
带来有效和高性能的无绑定

541
00:33:40,687 --> 00:33:45,225
通过今年的增强功能
混合渲染 App 比之前更好了

542
00:33:45,259 --> 00:33:47,461
我们将它公布在了
Metal 示例代码库中

543
00:33:47,494 --> 00:33:51,098
有更新版本 App 的
全部源码

544
00:33:51,131 --> 00:33:53,367
您可以下载 学习和修改

545
00:33:53,400 --> 00:33:56,103
作为练习 我给大家一个考验
将其更进一步

546
00:33:56,136 --> 00:33:59,306
为镜像表面增加递归

547
00:33:59,339 --> 00:34:01,074
我等不及看看您能用这个功能
来做什么了

548
00:34:01,108 --> 00:34:04,845
Metal 3 迎来了前所未有的
无绑定时代

549
00:34:04,878 --> 00:34:06,914
感谢大家的观看

550
00:34:06,947 --> 00:34:09,950
[欢快的音乐]

