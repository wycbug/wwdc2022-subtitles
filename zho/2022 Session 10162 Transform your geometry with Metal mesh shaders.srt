1
00:00:01,034 --> 00:00:07,040
[欢快的音乐]

2
00:00:09,309 --> 00:00:11,411
大家好 我是 Andrei

3
00:00:11,445 --> 00:00:15,282
是 Metal Frameworks 团队的
GPU 软件工程师

4
00:00:15,315 --> 00:00:19,686
今天 我很高兴能为大家介绍
我们新推出的 Metal 网格着色器

5
00:00:19,720 --> 00:00:23,290
网格着色器是 Metal 中
全新灵活的管线

6
00:00:23,323 --> 00:00:26,927
可用于 GPU 驱动的
几何元素生成和处理

7
00:00:26,960 --> 00:00:31,231
它可以提高顶点/片元管线
增加灵活性

8
00:00:31,265 --> 00:00:34,968
消除顶点处理限制

9
00:00:35,002 --> 00:00:38,605
它有多重应用 包括但不限于

10
00:00:38,639 --> 00:00:41,108
细粒度几何裁剪

11
00:00:41,141 --> 00:00:44,478
GPU 上可扩展程序化几何体创建

12
00:00:44,511 --> 00:00:47,080
允许自定义几何输入

13
00:00:47,114 --> 00:00:49,283
如压缩顶点流

14
00:00:49,316 --> 00:00:52,553
meshlet 和复杂程序化算法

15
00:00:52,586 --> 00:00:55,289
这三点也是我今天想要分享的内容

16
00:00:55,322 --> 00:00:59,359
首先 我会介绍
Metal 网格着色器是什么

17
00:00:59,393 --> 00:01:03,430
然后 我会为大家展示两个
网格着色器的使用案例

18
00:01:03,463 --> 00:01:06,800
网格着色器对生成
程序化几何体极为有效

19
00:01:06,834 --> 00:01:09,102
如渲染程式化头发

20
00:01:09,136 --> 00:01:13,207
网格着色器也可以帮助
改善场景处理和渲染

21
00:01:13,240 --> 00:01:15,909
最常见的一个例子就是
使用网格着色器

22
00:01:15,943 --> 00:01:18,979
来进行 GPU 驱动的
meshlet 裁剪

23
00:01:19,012 --> 00:01:21,348
我们先介绍下网格着色器

24
00:01:21,381 --> 00:01:23,383
这个是 Stanford Bunny

25
00:01:23,417 --> 00:01:27,855
代表了您在 GPU 上
可以渲染的典型网格

26
00:01:27,888 --> 00:01:31,458
为了渲染该网格 顶点和索引数据

27
00:01:31,491 --> 00:01:34,962
首先要放入设备内存中

28
00:01:34,995 --> 00:01:39,733
然后 您要使用渲染指令编码器
来执行绘制调用

29
00:01:39,766 --> 00:01:44,304
传统渲染管线包含三个基础阶段

30
00:01:44,338 --> 00:01:49,176
一个可编程的顶点着色阶段
一个固定函数光栅化阶段

31
00:01:49,209 --> 00:01:52,346
以及一个可编程的片元着色阶段

32
00:01:52,379 --> 00:01:54,848
顶点着色阶段从设备内存中
提取几何体

33
00:01:54,882 --> 00:01:57,751
作为输入并进一步处理

34
00:01:57,784 --> 00:02:00,888
光栅化程序生成屏幕空间片元

35
00:02:00,921 --> 00:02:04,391
片元着色器将其着色
并生成最终图像

36
00:02:04,424 --> 00:02:08,862
这种管线自始至终都能
很好地服务于这个目标

37
00:02:08,896 --> 00:02:13,300
然而 它缺乏灵活性且有一定的限制

38
00:02:13,333 --> 00:02:15,335
我们来看一个例子

39
00:02:15,369 --> 00:02:19,606
假设您想要在 GPU 上
生成程序化几何体

40
00:02:19,640 --> 00:02:25,179
比如您决定在这个兔子上
添加程序化毛发

41
00:02:25,212 --> 00:02:30,117
我给大家演示下传统几何管线中
这个任务是如何完成的

42
00:02:30,150 --> 00:02:33,487
传统方法中 要生成程序化几何体

43
00:02:33,520 --> 00:02:37,057
您还要有计算指令编码器

44
00:02:37,090 --> 00:02:40,627
来调度计算内核

45
00:02:40,661 --> 00:02:44,064
计算内核将原始网格作为输入

46
00:02:44,097 --> 00:02:49,036
生成程序化几何体
并将其输出存回设备内存

47
00:02:49,069 --> 00:02:52,806
然后 您可以使用渲染指令编码器
来执行绘制调用

48
00:02:52,840 --> 00:02:57,444
将程序化几何体作为输入
生成最终图像

49
00:02:57,477 --> 00:03:00,547
这一方法需要两个指令编码器

50
00:03:00,581 --> 00:03:03,050
且需要您分配额外内存

51
00:03:03,083 --> 00:03:05,519
来存储程序化几何体

52
00:03:05,552 --> 00:03:09,056
如果是间接绘制调用
或扩散系数高的情况下

53
00:03:09,089 --> 00:03:13,327
该内存会非常高 且难以预测

54
00:03:13,360 --> 00:03:18,799
两个编码器之间还有一个屏障
使 GPU 间的工作序列化

55
00:03:18,832 --> 00:03:21,735
Metal 网格着色器
则可以解决以上所有问题

56
00:03:21,768 --> 00:03:24,538
网格着色器是一个
全新的几何管线

57
00:03:24,571 --> 00:03:29,209
用两个可编程的新阶段
替换了顶点着色阶段

58
00:03:29,243 --> 00:03:32,179
对象着色阶段和网格着色阶段

59
00:03:32,212 --> 00:03:36,383
在这个例子中 对象着色器
将几何体作为输入

60
00:03:36,416 --> 00:03:40,087
对其进行处理 输出我们称为
“payload” 的数据

61
00:03:40,120 --> 00:03:41,955
到网格着色器中

62
00:03:41,989 --> 00:03:45,058
该数据可由您自行决定

63
00:03:45,092 --> 00:03:50,264
网格着色器则会使用该数据
来生成程序化几何体

64
00:03:50,297 --> 00:03:54,635
该程序化几何体仅在
绘制调用中存在

65
00:03:54,668 --> 00:03:58,338
所以并不会要求您
分配任何设备内存

66
00:03:58,372 --> 00:04:02,075
它是管线式的 直接到光栅化程序

67
00:04:02,109 --> 00:04:06,613
然后到片元着色器
生成最终图像

68
00:04:06,647 --> 00:04:10,517
网格绘制调用使用
与传统绘制调用一样类型的

69
00:04:10,551 --> 00:04:12,819
渲染指令编码器来运行

70
00:04:12,853 --> 00:04:16,924
网格绘制调用和传统绘制调用
可以混合和匹配使用

71
00:04:16,957 --> 00:04:20,527
现在 我们来看下两个
新的可编程阶段

72
00:04:22,029 --> 00:04:23,964
与顶点着色器相比

73
00:04:23,997 --> 00:04:27,634
对象和网格着色器
都与计算内核相近

74
00:04:27,668 --> 00:04:30,571
它们是在线程组栅格中启动的

75
00:04:30,604 --> 00:04:33,941
每个线程组都是独立的线程栅格

76
00:04:33,974 --> 00:04:37,878
如同计算线程 它们可以相互沟通

77
00:04:37,911 --> 00:04:41,949
另外 每个对象线程组
可以生成一个网格栅格

78
00:04:41,982 --> 00:04:45,819
以编程方式确定
它启动网格栅格的大小

79
00:04:45,853 --> 00:04:48,255
提供足够的灵活性

80
00:04:48,288 --> 00:04:53,293
每个对象线程组将 payload 数据
传送给它生成的网格栅格

81
00:04:53,327 --> 00:04:57,231
如其名称所示
对象阶段处理的是对象

82
00:04:57,264 --> 00:05:01,201
对象是一个抽象的概念
您可以根据需求来定义

83
00:05:01,235 --> 00:05:04,705
可以是场景模型
场景模型的一部分

84
00:05:04,738 --> 00:05:09,743
比如 您想要生成程序化几何体的
空间区域

85
00:05:09,776 --> 00:05:12,546
网格阶段的设计是为了搭建网格

86
00:05:12,579 --> 00:05:15,516
直接向光栅化程序
发送几何体数据

87
00:05:15,549 --> 00:05:19,987
接下来两个例子能展示
对象和网格之间的关系

88
00:05:20,020 --> 00:05:23,657
第一个使用了网格着色器
来进行毛发渲染

89
00:05:23,690 --> 00:05:28,262
为了将任务简化一些
我用了简易的平面 而不是兔子模型

90
00:05:28,295 --> 00:05:32,432
要生成一撮毛发
我将输入几何体划分为分块

91
00:05:32,466 --> 00:05:35,636
每个分块会计算一层细节

92
00:05:35,669 --> 00:05:38,405
以及需要生成的发丝数量

93
00:05:38,438 --> 00:05:41,742
然后生成独立的发丝

94
00:05:41,775 --> 00:05:45,112
我为大家演示下如何在这个平面上
用网格着色器

95
00:05:45,145 --> 00:05:46,780
程序化地生成毛发

96
00:05:46,813 --> 00:05:49,016
平面可以划分为分块

97
00:05:49,049 --> 00:05:52,252
每个分块对应一个对象线程组

98
00:05:52,286 --> 00:05:55,722
每个对象线程组可计算
发丝数量

99
00:05:55,756 --> 00:05:59,693
为每根发丝生成曲线控制点

100
00:05:59,726 --> 00:06:01,762
这个会成为 payload

101
00:06:01,795 --> 00:06:04,765
然后 我们的对象线程组
启动网格栅格

102
00:06:04,798 --> 00:06:08,202
每个网格线程组代表一根发丝

103
00:06:08,235 --> 00:06:11,538
每个网格线程组输出网格
到光栅化程序

104
00:06:11,572 --> 00:06:14,308
新的几何体管线让您可以

105
00:06:14,341 --> 00:06:16,476
将几何处理更紧密地映射到硬件

106
00:06:16,510 --> 00:06:21,782
并让您可以充分利用
GPU 提供的所有线程

107
00:06:21,815 --> 00:06:25,552
在网格渲染管线中
输入几何体按对象着色栅格

108
00:06:25,586 --> 00:06:27,487
划分分块

109
00:06:27,521 --> 00:06:31,525
每个对象着色线程组
可以独立生成 payload

110
00:06:31,558 --> 00:06:33,260
并启动网格栅格

111
00:06:33,293 --> 00:06:37,464
每个来自栅格的
网格着色线程组生成 metal::mesh

112
00:06:37,497 --> 00:06:41,034
它在剩余的渲染管线中
被进一步处理

113
00:06:41,068 --> 00:06:46,006
我们仔细看看每个阶段
生成的数据

114
00:06:46,039 --> 00:06:48,709
payload 在对象着色器中定义

115
00:06:48,742 --> 00:06:51,245
每个对象线程组
向其生成的网格栅格

116
00:06:51,278 --> 00:06:55,349
传送到自定义 payload

117
00:06:55,382 --> 00:07:00,187
如果渲染头发 payload 包含
曲线控制点

118
00:07:00,220 --> 00:07:03,924
同时 网格着色器
通过新的 metal::mesh 类型

119
00:07:03,957 --> 00:07:08,795
输出顶点和图元数据
稍后我会详细解释

120
00:07:09,963 --> 00:07:12,332
对象和网格阶段输出接下来管线

121
00:07:12,366 --> 00:07:15,369
所需的网格数据

122
00:07:15,402 --> 00:07:18,572
与传统管线中的顶点输出相似

123
00:07:18,605 --> 00:07:21,708
光栅化程序首先处理网格数据

124
00:07:21,742 --> 00:07:25,546
然后执行片元着色器

125
00:07:25,579 --> 00:07:30,184
我们详细看下如何配置
毛发渲染网格管线

126
00:07:30,217 --> 00:07:34,755
首先 将要用毛发覆盖的平面
划分分块

127
00:07:34,788 --> 00:07:38,025
每个分块对应一个对象线程组

128
00:07:38,058 --> 00:07:41,228
对象线程组决定网格栅格大小

129
00:07:41,261 --> 00:07:45,332
将向网格传送的
payload 数据初始化

130
00:07:45,365 --> 00:07:50,771
在这个情况下 该分块中有 6 根发丝
与每根发丝的

131
00:07:50,804 --> 00:07:53,740
曲线 payload 数据一起
生成 3x2 网格栅格

132
00:07:54,408 --> 00:07:57,077
每个线程组生成独特的
网格栅格大小

133
00:07:57,110 --> 00:07:59,913
下一个线程组只需要生成

134
00:07:59,947 --> 00:08:01,615
4 根发丝

135
00:08:01,648 --> 00:08:03,750
所以与那 4 根发丝初始化的

136
00:08:03,784 --> 00:08:07,654
曲线 payload 数据一起
所以设置 2x2 网格

137
00:08:07,688 --> 00:08:11,592
这就是这一实现方法的
对象着色器

138
00:08:11,625 --> 00:08:14,361
object 属性已添加到 Metal 中

139
00:08:14,394 --> 00:08:17,564
以指定对象着色器的代码

140
00:08:17,598 --> 00:08:21,235
除了 payload 属性
和 object_data 地址空间

141
00:08:21,268 --> 00:08:24,738
允许 payload 参数
使用于着色器之外

142
00:08:26,139 --> 00:08:31,378
mesh_grid_properties 参数
用于编码网格栅格大小

143
00:08:31,411 --> 00:08:34,214
下一步是管线初始化

144
00:08:34,248 --> 00:08:38,018
首先 分配网格渲染管线描述符

145
00:08:38,051 --> 00:08:43,991
然后初始化对象函数
并制定所需的 payload 长度

146
00:08:44,024 --> 00:08:47,494
与每线程组的线程最大数量

147
00:08:47,528 --> 00:08:50,430
对象着色器上有一些限制

148
00:08:50,464 --> 00:08:54,434
Payload 格式和内容
全部可以自定义

149
00:08:54,468 --> 00:08:58,939
然而 payload 大小不能超过
16KB 的限值

150
00:08:58,972 --> 00:09:01,542
同时 每个对象线程组生成的
网格线程组

151
00:09:01,575 --> 00:09:06,013
最大数量不能超过 1024

152
00:09:06,046 --> 00:09:08,882
对象着色阶段准备好后
下一步就是

153
00:09:08,916 --> 00:09:11,718
初始化网格着色阶段

154
00:09:11,752 --> 00:09:15,222
网格着色器让用户定义 payload
以作为输入

155
00:09:15,255 --> 00:09:19,860
在这个例子中
payload 是一套曲线控制点

156
00:09:19,893 --> 00:09:22,529
每个网格线程组
生成一个 metal::mesh

157
00:09:22,563 --> 00:09:25,098
也就是一根发丝

158
00:09:25,132 --> 00:09:29,236
网格着色器的输出网格
必须有 metal::mesh 类型

159
00:09:29,269 --> 00:09:33,640
metal::mesh 是 Metal 中的内置结构
可为您提供输出顶点和图元数据

160
00:09:33,674 --> 00:09:38,879
到光栅化程序
和片元着色器的界面

161
00:09:38,912 --> 00:09:43,784
每个 metal::mesh 定义一个
顶点数据类型 就像

162
00:09:43,817 --> 00:09:45,319
顶点着色器的输出类型

163
00:09:45,352 --> 00:09:49,356
一个图元数据类型
顶点的最大数值

164
00:09:49,389 --> 00:09:51,725
图元的最大数值

165
00:09:51,758 --> 00:09:57,364
最后 网格拓扑
不管是点 线还是三角

166
00:09:57,397 --> 00:10:00,968
Metal 着色语言通过增加的
mesh 属性

167
00:10:01,001 --> 00:10:04,004
指定什么代码是网格着色器

168
00:10:04,037 --> 00:10:07,841
metal::mesh 用于
网格着色器中的输出结构

169
00:10:09,943 --> 00:10:13,213
网格着色器对 GPU 驱动的
几何体处理很有效

170
00:10:13,247 --> 00:10:15,849
因为它们能让您动态
生成这些 metal::mesh

171
00:10:15,883 --> 00:10:18,318
用于光栅化程序

172
00:10:18,352 --> 00:10:21,455
网格着色器用 metal::mesh
作为其优势

173
00:10:21,488 --> 00:10:24,324
这样您可以在处理过程中
加入更多渲染指令

174
00:10:24,358 --> 00:10:27,027
而无需额外计算通道

175
00:10:27,060 --> 00:10:31,265
编码网格在同一个线程组的
线程之间完成

176
00:10:31,298 --> 00:10:35,836
在这个例子中 线程组的
前 9 条线程可以编码发丝的顶点

177
00:10:35,869 --> 00:10:39,873
索引和图元数据

178
00:10:39,907 --> 00:10:45,279
线程 0 到 4 每个都在网格中
编码一个顶点

179
00:10:45,312 --> 00:10:50,017
线程组中的剩余线程
不编码网格中的顶点

180
00:10:50,050 --> 00:10:55,355
接下来 所有 9 条线程将 1 条索引
编码到网格目录中

181
00:10:57,291 --> 00:11:03,697
接下来 前 3 条线程
为 3 个三角形编码图元数据

182
00:11:03,730 --> 00:11:07,234
剩余的线程不编码任何
图元数据

183
00:11:07,267 --> 00:11:12,940
最后 1 条线程会为网格
编码图元数量

184
00:11:12,973 --> 00:11:16,076
我为大家演示下
这个网格着色器的源代码

185
00:11:16,109 --> 00:11:19,780
网格着色器会组织为
尽可能避免

186
00:11:19,813 --> 00:11:23,283
线程间的分化 遵循顶点

187
00:11:23,317 --> 00:11:26,486
索引和图元数据的编码步骤

188
00:11:26,520 --> 00:11:28,856
最后是图元数量的步骤

189
00:11:30,858 --> 00:11:34,394
我们回到初始化网格管线
描述符

190
00:11:34,428 --> 00:11:37,764
网格管线描述符设置了
网格函数

191
00:11:37,798 --> 00:11:41,301
和每网格线程组的最大线程

192
00:11:41,335 --> 00:11:45,239
metal::mesh 结构有一些
限制是需要严守的

193
00:11:45,272 --> 00:11:47,841
Metal 的网格着色器
有以下限制

194
00:11:47,875 --> 00:11:54,414
Metal::mesh 支持高达 256 个顶点
以及高达 512 个图元

195
00:11:54,448 --> 00:11:58,352
metal::mesh 总大小
不可超过 16KB

196
00:11:58,385 --> 00:12:01,255
现在网格栅格
已经生成 metal::mesh

197
00:12:01,288 --> 00:12:06,493
它们随后会被带到光栅化程序中
最后运行片元着色器

198
00:12:06,527 --> 00:12:09,530
所以 与传统渲染管线类似

199
00:12:09,563 --> 00:12:13,066
片元函数在网格管线
描述符上设置

200
00:12:13,100 --> 00:12:15,502
初始化描述符后

201
00:12:15,536 --> 00:12:18,572
管线状态已通过

202
00:12:18,605 --> 00:12:22,209
makeRenderPipelineState(descriptor:) 方法

203
00:12:22,242 --> 00:12:23,744
在 Metal 设备创建

204
00:12:23,777 --> 00:12:29,082
编码网格管线和编码
传统绘制调用很接近

205
00:12:29,116 --> 00:12:31,718
管线在编码器上设置

206
00:12:31,752 --> 00:12:34,788
管线的每个阶段都有资源绑定

207
00:12:34,821 --> 00:12:38,258
在这个例子中 绑定资源有

208
00:12:38,292 --> 00:12:40,861
对象阶段的对象缓冲区

209
00:12:40,894 --> 00:12:42,629
网格阶段的纹理

210
00:12:42,663 --> 00:12:46,667
片元阶段的片元缓冲区

211
00:12:46,700 --> 00:12:51,872
接下来 我定义几个启动
网格管线所需的常量

212
00:12:51,905 --> 00:12:54,141
对象栅格尺寸

213
00:12:54,174 --> 00:12:56,643
每对象线程组的线程数量

214
00:12:56,677 --> 00:12:59,546
每网格线程组的线程数量

215
00:12:59,580 --> 00:13:02,149
以及通过新的
drawMeshThreadgroups 方法

216
00:13:02,182 --> 00:13:04,718
使用这些常量来编码绘制

217
00:13:04,751 --> 00:13:07,754
用于渲染平面毛发的相同方法

218
00:13:07,788 --> 00:13:09,823
可以应用到整个兔子上

219
00:13:09,857 --> 00:13:13,360
通过网格管线
程序化地生成毛发

220
00:13:13,393 --> 00:13:16,630
接下来 我们看下使用
网格着色器的另一种方法

221
00:13:16,663 --> 00:13:19,233
网格着色器可以用
Meshlet 裁剪高效处理

222
00:13:19,266 --> 00:13:23,003
以及渲染大量几何体

223
00:13:23,036 --> 00:13:26,373
这一技术的基础就在于
将场景网格划分为

224
00:13:26,406 --> 00:13:28,909
称为 meshlet 的小块

225
00:13:33,213 --> 00:13:36,884
将场景几何体划分为 meshlet
增加了场景的粒度

226
00:13:36,917 --> 00:13:39,753
可以执行更高效 更深入的裁剪

227
00:13:39,786 --> 00:13:42,856
这也可以极大地减少
几何体开销

228
00:13:42,890 --> 00:13:44,858
利用 meshlet 粒度处理

229
00:13:44,892 --> 00:13:47,594
可允许高效的遮挡和裁剪算法

230
00:13:47,628 --> 00:13:51,632
如屏幕空间遮挡裁剪
和法线过滤程序

231
00:13:51,665 --> 00:13:54,835
您可以使用网格着色器
来执行全 GPU 驱动的裁剪

232
00:13:54,868 --> 00:13:56,069
和渲染管线

233
00:13:56,937 --> 00:13:59,873
这是传统 GPU 驱动的管线

234
00:13:59,907 --> 00:14:02,476
可用一种计算和一条渲染通道

235
00:14:02,509 --> 00:14:05,779
运行场景处理和渲染

236
00:14:05,812 --> 00:14:07,748
该场景数据可划分为 meshlet

237
00:14:07,781 --> 00:14:10,150
并用于计算通道

238
00:14:10,184 --> 00:14:12,853
从而负责视锥体剔除

239
00:14:12,886 --> 00:14:14,188
LOD 选择

240
00:14:14,221 --> 00:14:17,157
以及将绘制编码到设备内存中

241
00:14:17,191 --> 00:14:20,561
然后渲染通道为场景
执行绘制指令

242
00:14:20,594 --> 00:14:23,030
然后生成最终图像

243
00:14:23,063 --> 00:14:27,334
通过使用网格着色器
可以移除同步点

244
00:14:27,367 --> 00:14:31,138
通过将两条通道
合并到一个网格着色分发

245
00:14:31,171 --> 00:14:33,607
避免中间绘制指令

246
00:14:33,640 --> 00:14:35,375
我为大家演示下操作过程

247
00:14:35,409 --> 00:14:37,878
这是单一渲染通道

248
00:14:37,911 --> 00:14:39,947
可执行网格着色分发

249
00:14:39,980 --> 00:14:42,149
对象着色器运行视锥体剔除

250
00:14:42,182 --> 00:14:45,586
为每个可见的 meshlet
计算 LOD

251
00:14:45,619 --> 00:14:50,257
网格着色器的 payload 是
应编码的 meshlet IDs 列表

252
00:14:50,290 --> 00:14:53,527
然后 网格着色器编码用于光栅化

253
00:14:53,560 --> 00:14:55,863
和着色的 metal::mesh 对象

254
00:14:55,896 --> 00:14:58,465
然后最终图像在
片元着色器中着色

255
00:14:58,498 --> 00:15:00,801
与传统管线一样

256
00:15:00,834 --> 00:15:02,536
几何体处理完全在

257
00:15:02,569 --> 00:15:04,304
网格线程组指令内

258
00:15:04,338 --> 00:15:05,973
和单一编码器内完成

259
00:15:06,006 --> 00:15:08,242
不再需要通过中间缓冲区

260
00:15:08,275 --> 00:15:09,810
存储这些绘制指令

261
00:15:09,843 --> 00:15:12,746
因为三角形数据
会通过网格着色器编码

262
00:15:13,881 --> 00:15:15,983
我们现在来看下裁剪

263
00:15:16,016 --> 00:15:19,152
尤其是 meshlet 裁剪的执行

264
00:15:19,186 --> 00:15:22,956
该场景包含代表模型的形状

265
00:15:22,990 --> 00:15:27,628
在这个操作中 场景的每个模型
都会变成对象栅格的一部分

266
00:15:27,661 --> 00:15:30,564
网格栅格由对象着色线程组生成

267
00:15:30,597 --> 00:15:32,299
包含 meshlet

268
00:15:32,332 --> 00:15:35,636
模型表面的三角小块

269
00:15:35,669 --> 00:15:38,038
新的几何体管线灵活性很高

270
00:15:38,071 --> 00:15:41,708
您可以选择如何将场景
映射到对象栅格上

271
00:15:41,742 --> 00:15:45,379
在这个例子中 我将每个模型
都映射到对象线程组上

272
00:15:45,412 --> 00:15:48,982
但您可以使用更符合
您任务所需的映射

273
00:15:49,016 --> 00:15:51,919
现在 对象着色器可以用视锥

274
00:15:51,952 --> 00:15:53,554
来确定 meshlet 的可见性

275
00:15:53,587 --> 00:15:58,058
只分派在最终图像上可显示的内容

276
00:15:58,091 --> 00:16:00,794
我们来看场景中的两个模型

277
00:16:00,827 --> 00:16:04,498
对象着色器基于确定的
可见度来启动网格栅格

278
00:16:04,531 --> 00:16:09,570
然后 网格着色器处理 meshlet
并构建 metal::mesh

279
00:16:09,603 --> 00:16:12,773
可编程的网格栅格大小
可以灵活调度

280
00:16:12,806 --> 00:16:16,410
所以只有可见的 meshlet
能经由网格着色器处理

281
00:16:16,443 --> 00:16:21,315
这可以减少在后续管线中
处理不可见几何体的时间

282
00:16:21,348 --> 00:16:25,485
固定函数光栅化程序只接收
可见的表面

283
00:16:25,519 --> 00:16:27,621
而且可以减少处理和裁剪

284
00:16:27,654 --> 00:16:29,957
不可见几何体的时间

285
00:16:30,791 --> 00:16:35,262
最后 可编程片元着色器被调用
生成最终图像

286
00:16:35,996 --> 00:16:38,465
如您所见 新几何体管线
可供您处理

287
00:16:38,498 --> 00:16:41,101
各种不同的问题

288
00:16:41,134 --> 00:16:45,439
如创建程序化网格
或让您的绘制调用更高效

289
00:16:45,472 --> 00:16:48,308
正如这个 meshlet 裁剪样本
展示的一样

290
00:16:48,342 --> 00:16:52,346
Metal 现在包含了创新灵活的
全新几何体管线

291
00:16:52,379 --> 00:16:56,283
创建程序化几何更为简单

292
00:16:56,316 --> 00:16:59,253
正如头发渲染例子演示的一样

293
00:16:59,286 --> 00:17:02,489
另外 单一渲染通道中
GPU 驱动的

294
00:17:02,523 --> 00:17:04,691
工作可能性得以扩展

295
00:17:04,725 --> 00:17:08,529
无需额外计算通道或中间缓冲区

296
00:17:08,562 --> 00:17:10,964
正如在 meshlet 裁剪 demo 中
看到的一样

297
00:17:11,899 --> 00:17:16,270
这个全新的几何体管线
在 Family7 和 Mac2 设备中均可用

298
00:17:18,138 --> 00:17:21,575
为了帮助您开始
网格着色器的学习和操作

299
00:17:21,608 --> 00:17:24,344
Apple 开发者网站
有示例代码

300
00:17:24,378 --> 00:17:27,080
展示了如何使用新的 API

301
00:17:27,114 --> 00:17:29,583
我很期待看到您
如何使用这一功能

302
00:17:29,616 --> 00:17:32,853
利用 Apple GPU 强大的并行性

303
00:17:32,886 --> 00:17:35,022
来适应您几何体处理的需求

304
00:17:35,055 --> 00:17:36,857
感谢收看

