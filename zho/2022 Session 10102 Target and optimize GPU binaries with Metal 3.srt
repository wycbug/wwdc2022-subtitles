1
00:00:00,501 --> 00:00:08,509
♪ ♪

2
00:00:09,309 --> 00:00:10,744
Galo Avila: 大家好 欢迎大家

3
00:00:10,777 --> 00:00:13,747
我是 Galo Avila
GPU 软件开发经理

4
00:00:13,780 --> 00:00:15,782
在本次讲座中 我和 Eylon
将很高兴与大家分享

5
00:00:15,816 --> 00:00:19,353
如何使用 Metal 3 改进 App 的
GPU 二进制生成

6
00:00:19,386 --> 00:00:22,222
首先 我讲一下
如何通过离线编译帮助你

7
00:00:22,256 --> 00:00:26,660
减少 App 掉帧
首次启动和新关卡加载时间

8
00:00:26,693 --> 00:00:30,364
然后 Eylon 将介绍如何通过使用
优化大小的编译器选项

9
00:00:30,397 --> 00:00:34,067
来调整代码扩展转换
并缩短编译时间

10
00:00:35,636 --> 00:00:39,873
离线编译可以让你将 GPU 二进制
生成转移到项目构建期间

11
00:00:39,907 --> 00:00:43,443
为了充分了解采用这种方式可以为你的
Metal 应用程序带来的好处

12
00:00:43,477 --> 00:00:47,948
我首先回顾一下已有的
生成 GPU 二进制的方式

13
00:00:47,981 --> 00:00:52,920
在你的 Metal app 中
GPU 二进制在构建和运行时生成

14
00:00:52,953 --> 00:00:56,924
例如 假设你从源码实例化一个 Metal 库

15
00:00:56,957 --> 00:01:00,127
这将在 App 运行时生成
Apple's Intermediate Representation

16
00:01:00,160 --> 00:01:02,129
也被称为 AIR

17
00:01:02,162 --> 00:01:04,298
这会是一个 CPU 密集型操作

18
00:01:04,331 --> 00:01:05,699
你可以通过将源代码

19
00:01:05,732 --> 00:01:08,202
预编译成 Metal 库 然后从文件实例化

20
00:01:08,235 --> 00:01:11,171
将这一步转移到 App 构建时

21
00:01:11,205 --> 00:01:14,575
一旦将 Metal 库放入内存中
创建包含状态和函数的

22
00:01:14,608 --> 00:01:18,278
管线状态描述符
就是一个轻量级操作

23
00:01:18,312 --> 00:01:20,280
直到开始创建管线状态对象

24
00:01:20,314 --> 00:01:22,850
这会是另一个 CPU 密集型操作

25
00:01:22,883 --> 00:01:26,220
这里会实时生成 GPU 二进制

26
00:01:28,522 --> 00:01:32,759
由于在运行时生成 GPU 二进制
可能是 CPU 密集型操作

27
00:01:32,793 --> 00:01:36,063
Metal 会帮助你加速
管线状态对象的创建

28
00:01:36,096 --> 00:01:37,431
当你实例化 PSO 时

29
00:01:37,464 --> 00:01:41,235
Metal 将你的 GPU 二进制
存储在文件系统缓存中

30
00:01:41,268 --> 00:01:43,337
每创建一个新的 PSO

31
00:01:43,370 --> 00:01:46,373
就会添加所有新生成的函数

32
00:01:46,406 --> 00:01:48,976
因此 之前生成的
任何被引用的二进制

33
00:01:49,009 --> 00:01:50,577
都可以从缓存中加载

34
00:01:52,546 --> 00:01:56,316
Metal 还允许你使用二进制存档
明确控制何时何地

35
00:01:56,350 --> 00:01:58,519
缓存 GPU 二进制

36
00:01:58,552 --> 00:02:03,156
只需使用 PSO 描述符通过存档文件
缓存 GPU 二进制

37
00:02:03,190 --> 00:02:05,526
多少次都可以

38
00:02:05,559 --> 00:02:09,630
这样 创建 PSO 就变成了
一个轻量级操作

39
00:02:09,663 --> 00:02:11,965
二进制存档支持更灵活的缓存

40
00:02:11,999 --> 00:02:14,668
但它们仍然必须在运行时生成

41
00:02:14,701 --> 00:02:16,236
在许多情况下 你真正想要的

42
00:02:16,270 --> 00:02:18,438
是在构建时生成这些存档

43
00:02:18,472 --> 00:02:20,474
现在终于可以实现了

44
00:02:20,507 --> 00:02:23,610
通过离线二进制生成
你可以在项目构建时

45
00:02:23,644 --> 00:02:26,280
指定一个名为
Metal 管线脚本的新产物

46
00:02:26,313 --> 00:02:29,550
与 Metal 源代码或 Metal 库配合

47
00:02:29,583 --> 00:02:32,152
管线脚本在编译器工具链上

48
00:02:32,186 --> 00:02:35,222
相当于 API 中的管线描述符的集合

49
00:02:35,255 --> 00:02:38,659
编译过程的输出是二进制存档

50
00:02:38,692 --> 00:02:42,029
App 运行时无需再生成 GPU 代码

51
00:02:42,062 --> 00:02:46,600
只需加载离线构建的二进制存档
即可加速创建 PSO

52
00:02:48,435 --> 00:02:52,339
离线编译通过减少运行时的
CPU 占用率让你的 App 受益

53
00:02:52,372 --> 00:02:55,876
这是 Metal 作为底层 API 的核心价值

54
00:02:55,909 --> 00:03:00,681
此外 通过这种方式可以
从两个方面显著改善 App 的体验

55
00:03:00,714 --> 00:03:03,951
首次启动和新关卡的加载
会大大加快

56
00:03:03,984 --> 00:03:07,454
从而可能带来更好的参与度和互动

57
00:03:07,487 --> 00:03:10,123
由于运行时编译而导致的卡顿
或帧速率下降

58
00:03:10,157 --> 00:03:11,592
最终也可以消除

59
00:03:11,625 --> 00:03:15,429
无需再为预热帧提供内存或 CPU 成本

60
00:03:15,462 --> 00:03:18,465
接下来我将更详细地探讨这些优势

61
00:03:19,499 --> 00:03:22,803
这里是传统的 App 运行时的
二进制生成

62
00:03:22,836 --> 00:03:25,706
在这个例子中 你的 App 在加载屏幕后

63
00:03:25,739 --> 00:03:28,275
花费大约三分之二的时间编译
GPU 二进制

64
00:03:28,308 --> 00:03:31,011
然后你才能开始与它进行交互

65
00:03:31,044 --> 00:03:35,616
但是通过离线编译 你的运行时
着色器生成将移动到 APP 构建时间

66
00:03:35,649 --> 00:03:38,018
PSO 的创建只需要一小部分时间

67
00:03:38,051 --> 00:03:40,187
你可以更快地与 App 交互

68
00:03:40,220 --> 00:03:42,890
而不是在加载屏幕上空转

69
00:03:43,924 --> 00:03:47,694
离线编译也有助于减少卡顿

70
00:03:47,728 --> 00:03:49,930
使用传统的运行时二进制生成

71
00:03:49,963 --> 00:03:52,900
为了避免在加载时
创建过多的管线状态

72
00:03:52,933 --> 00:03:56,470
你可能会按需即时创建一些状态

73
00:03:56,503 --> 00:03:59,139
发生这种情况时 你可能会遇到

74
00:03:59,173 --> 00:04:02,476
由于编译而暂时中断命令编码
导致的掉帧

75
00:04:03,343 --> 00:04:05,979
离线编译消除了这些讨厌的气泡

76
00:04:06,013 --> 00:04:10,217
因为你可以在 App 构建时
编译更多的着色器

77
00:04:10,250 --> 00:04:12,352
接下来 我将分享一个
新的开发工作流

78
00:04:12,386 --> 00:04:15,389
帮助你利用离线编译的优势

79
00:04:16,590 --> 00:04:19,693
在以下工作流中
你将学习如何使用新的工具链功能

80
00:04:19,726 --> 00:04:21,962
离线构建 GPU 二进制

81
00:04:21,995 --> 00:04:25,732
我将向你们展示如何生成新的
管线脚本输入文件

82
00:04:25,766 --> 00:04:29,703
然后 如何调用工具链生成 GPU 二进制

83
00:04:29,736 --> 00:04:32,940
管线脚本文件是一个

84
00:04:32,973 --> 00:04:35,976
或多个 API 管线状态描述符的
JSON 格式描述

85
00:04:36,009 --> 00:04:38,145
可以通过多种方式生成

86
00:04:38,178 --> 00:04:41,181
例如 在你最喜欢的
JSON 编辑器中编写它们

87
00:04:41,215 --> 00:04:46,520
或者通过处理在开发和测试期间
序列化的二进制存档获取

88
00:04:46,553 --> 00:04:50,324
这里有一段 Metal 代码
它生成了一个具有

89
00:04:50,357 --> 00:04:54,528
状态和函数的渲染管线描述符
及其等效的 JSON 描述

90
00:04:54,561 --> 00:04:59,633
首先 将 API metal 库文件
指定为库路径属性

91
00:04:59,666 --> 00:05:04,471
然后你的 API 渲染描述符函数名称
作为渲染管线属性

92
00:05:04,505 --> 00:05:07,241
最后 其他管线状态
如 raster_sample_count

93
00:05:07,274 --> 00:05:11,111
或像素格式 也被记录为脚本属性

94
00:05:11,144 --> 00:05:15,082
在 Metal 的开发文档中
查找更多 JSON 结构定义详细信息

95
00:05:16,917 --> 00:05:19,753
你可能还想开启 JSON 脚本生成

96
00:05:19,786 --> 00:05:22,289
可以使用 Metal 运行时

97
00:05:22,322 --> 00:05:24,525
只需在运行时生成二进制存档

98
00:05:24,558 --> 00:05:27,728
并在开发和测试过程中将它们序列化

99
00:05:27,761 --> 00:05:31,098
现在我将向你们展示
如何使用 Metal API 完成此任务

100
00:05:32,933 --> 00:05:34,968
你们可以在运行时通过创建

101
00:05:35,002 --> 00:05:38,939
带有状态和函数的管线描述符
开始收集过程

102
00:05:38,972 --> 00:05:43,076
将其添加到生成
GPU 二进制的存档中

103
00:05:43,110 --> 00:05:45,779
并将其序列化到文件系统以导入

104
00:05:45,812 --> 00:05:47,981
你的 App 包 再从中加载

105
00:05:48,015 --> 00:05:52,419
Metal 3 运行时将你的管线描述符
与 GPU 二进制一起存储

106
00:05:52,452 --> 00:05:55,622
现在我将向你们展示如何提取它们

107
00:05:55,656 --> 00:05:58,292
metal-source 允许从现有存档中

108
00:05:58,325 --> 00:06:00,494
提取 JSON 管线脚本

109
00:06:00,527 --> 00:06:05,599
这对于将二进制生成从运行时
迁移到 App 构建时非常方便

110
00:06:05,632 --> 00:06:07,801
只需调用 metal-source 时
使用 flatbuffers 和

111
00:06:07,835 --> 00:06:10,137
输出目录选项

112
00:06:10,170 --> 00:06:11,805
就可以产生管线脚本文件

113
00:06:11,839 --> 00:06:14,942
你可以对其进行编辑
以生成额外的二进制

114
00:06:14,975 --> 00:06:18,912
现在 我将向你展示如何调用工具链

115
00:06:18,946 --> 00:06:22,983
在 Xcode 项目构建阶段
生成 GPU 二进制很容易

116
00:06:23,016 --> 00:06:26,553
只需象从终端调用 metal 一样
提供源代码 管线脚本

117
00:06:26,587 --> 00:06:29,523
和输出文件

118
00:06:29,556 --> 00:06:32,326
输出的 metal 库
现在就包含 GPU 二进制

119
00:06:32,359 --> 00:06:36,330
并且可以部署在
任何工具链支持的设备上

120
00:06:36,363 --> 00:06:38,866
如果你有一个 Metal 库而不是源码

121
00:06:38,899 --> 00:06:42,569
也可以将其传递给工具链

122
00:06:42,603 --> 00:06:45,072
使用 Metal 转换工具
从现有的 Metal 库

123
00:06:45,105 --> 00:06:48,141
生成二进制也同样简单

124
00:06:48,175 --> 00:06:51,512
只需像在终端中调用 metal-tt 一样

125
00:06:51,545 --> 00:06:53,947
提供源码 管线脚本和输出文件

126
00:06:53,981 --> 00:06:56,550
得到的 Metal 库现在包含所有工具链

127
00:06:56,583 --> 00:07:00,787
支持设备的 GPU 二进制

128
00:07:00,821 --> 00:07:03,056
现在你知道如何离线创建二进制

129
00:07:03,090 --> 00:07:05,459
我将回顾如何加载它们

130
00:07:05,492 --> 00:07:09,162
只需在创建存档描述符时
提供二进制的 URL

131
00:07:09,196 --> 00:07:10,964
并使用它来实例化存档

132
00:07:10,998 --> 00:07:12,299
就是这样

133
00:07:12,332 --> 00:07:14,935
有关 Metal 的
二进制存档 API 的更多信息

134
00:07:14,968 --> 00:07:18,071
请查阅我们过去几年的演讲

135
00:07:18,105 --> 00:07:21,275
最后 是关于 Metal 如何处理
这些通过离线生成的

136
00:07:21,308 --> 00:07:25,145
GPU 二进制的兼容性的一点说明

137
00:07:25,179 --> 00:07:27,681
为确保离线生成的二进制

138
00:07:27,714 --> 00:07:30,317
与未来的操作系统版本
和产品前向兼容

139
00:07:30,350 --> 00:07:33,420
Metal 会在操作系统更新期间
或 App 安装时优雅地升级

140
00:07:33,453 --> 00:07:34,688
你的二进制存档

141
00:07:34,721 --> 00:07:38,392
它会在后台异步执行此操作

142
00:07:38,425 --> 00:07:41,495
我迫不及待地想
让你们利用离线编译的优势

143
00:07:41,528 --> 00:07:45,632
来消除运行时卡顿
并减少首次启动和新关卡加载时间

144
00:07:45,666 --> 00:07:47,701
这种提升对其他人来说是切实可见的

145
00:07:47,734 --> 00:07:49,837
并增强了他们的整体使用体验

146
00:07:49,870 --> 00:07:51,538
现在 让我们交给 Eylon

147
00:07:51,572 --> 00:07:53,507
Eylon: 谢谢 Galo

148
00:07:53,540 --> 00:07:55,976
接下来 我将介绍新的编译选项

149
00:07:56,009 --> 00:07:58,278
用于优化大小

150
00:07:58,312 --> 00:08:02,549
Metal 编译器积极优化代码
以提高运行时性能

151
00:08:02,583 --> 00:08:05,919
一些优化会扩大 GPU 程序的大小

152
00:08:05,953 --> 00:08:09,223
这可能会带来意想不到的成本

153
00:08:09,256 --> 00:08:12,292
例如 函数内联是一种避免

154
00:08:12,326 --> 00:08:14,828
函数调用消耗的优化

155
00:08:14,862 --> 00:08:19,099
它通过将被调用函数的函数体
内联到调用点来实现

156
00:08:19,132 --> 00:08:22,035
这个示例内核看起来没有很多代码

157
00:08:22,069 --> 00:08:23,670
但内联之后

158
00:08:23,704 --> 00:08:26,206
它将包含函数 f 和 g 的副本

159
00:08:26,240 --> 00:08:29,176
可能还包含从 f 和 g 调用的函数

160
00:08:29,209 --> 00:08:32,412
比如辅助函数和非原始库函数

161
00:08:34,114 --> 00:08:36,817
另一种优化是循环展开

162
00:08:36,850 --> 00:08:39,052
它会内联循环体的额外副本

163
00:08:39,086 --> 00:08:41,388
以暴露迭代之间的并行性

164
00:08:41,421 --> 00:08:44,591
并避免分支消耗

165
00:08:44,625 --> 00:08:48,562
编译器有可能只展开循环的两次迭代

166
00:08:48,595 --> 00:08:53,734
也可能展开具有
固定边界的循环的所有迭代

167
00:08:53,767 --> 00:08:56,937
当通过象这样的优化创建一个
非常大的程序时

168
00:08:56,970 --> 00:09:00,073
编译器也必须花费
更多的时间来编译它

169
00:09:00,107 --> 00:09:04,511
在某些情况下
你可能希望避免这些成本

170
00:09:04,545 --> 00:09:10,684
Xcode 14 推出了一种新的
Metal 优化模式 尺寸优化

171
00:09:10,717 --> 00:09:13,287
当编译器应用性能优化时

172
00:09:13,320 --> 00:09:15,389
此模式限制了尺寸扩展转换

173
00:09:15,422 --> 00:09:18,592
例如内联和循环展开

174
00:09:18,625 --> 00:09:21,895
这样做的好处是
可以使 GPU 的二进制代码更小

175
00:09:21,929 --> 00:09:25,399
编译时间更短
特别在默认优化

176
00:09:25,432 --> 00:09:27,534
代价过大的情况下

177
00:09:27,568 --> 00:09:29,203
在对大小进行优化时

178
00:09:29,236 --> 00:09:32,606
可能会造成较低的运行时性能

179
00:09:32,639 --> 00:09:35,275
这是否真的发生取决于程序

180
00:09:35,309 --> 00:09:39,713
所以你们需要尝试两种优化模式
并进行比较

181
00:09:39,746 --> 00:09:43,650
优化大小可能不会提高所有
着色器的大小和编译时间

182
00:09:43,684 --> 00:09:46,553
它最有可能对具有深度调用路径

183
00:09:46,587 --> 00:09:48,488
和循环的大型程序有益

184
00:09:48,522 --> 00:09:50,958
内联和展开在这些程序里很常见

185
00:09:50,991 --> 00:09:52,926
当遇到默认优化导致的编译时间

186
00:09:52,960 --> 00:09:57,064
异常长时 该选项值得尝试

187
00:09:57,097 --> 00:10:02,236
无论在项目构建期
还是程序运行时编译 该选项都可用

188
00:10:02,269 --> 00:10:06,206
在这种情况下
对大小进行优化会产生不同的效果

189
00:10:06,240 --> 00:10:09,843
Cycles 是 Blender 3D 设计环境的

190
00:10:09,877 --> 00:10:12,112
产品渲染器的开源项目

191
00:10:12,145 --> 00:10:15,148
最近进行了更新以支持 Metal

192
00:10:15,182 --> 00:10:17,918
Apple 最近加入了 Blender 开发基金

193
00:10:17,951 --> 00:10:21,688
我们所了解的是 Blender 的
路径跟踪算法

194
00:10:21,722 --> 00:10:25,425
使用了大型计算着色器
有许多辅助函数和循环

195
00:10:25,459 --> 00:10:28,328
它的编译时间加起来可以达到几分钟

196
00:10:28,362 --> 00:10:31,365
事实证明 这些正是可以
从 Metal 3 的

197
00:10:31,398 --> 00:10:34,334
新尺寸优化选项中受益的着色器

198
00:10:36,136 --> 00:10:39,439
在 Apple 芯片 GPU 上渲染这些场景时

199
00:10:39,473 --> 00:10:42,776
启用优化尺寸会改善
Blender 的设置时间

200
00:10:42,809 --> 00:10:48,215
包括编译着色器管线 最多快 1.4 倍

201
00:10:48,248 --> 00:10:52,953
它提供了加速
对渲染时间影响很小甚至没有影响

202
00:10:52,986 --> 00:10:55,022
有些渲染速度下降了 4%

203
00:10:55,055 --> 00:10:57,457
有些根本没有下降

204
00:10:57,491 --> 00:11:00,227
因此 有可能运行时性能会降低

205
00:11:00,260 --> 00:11:04,531
但在某些情况下 对大小进行优化
也可能提高运行时性能

206
00:11:04,565 --> 00:11:07,334
这是个例子

207
00:11:07,367 --> 00:11:10,204
这些是在英特尔 GPU 上
启用尺寸优化后

208
00:11:10,237 --> 00:11:14,174
相同场景的渲染时间加速

209
00:11:14,208 --> 00:11:16,610
好处不仅在于更快的编译速度

210
00:11:16,643 --> 00:11:20,480
还在于更快的渲染速度
最高可达 1.6 倍

211
00:11:20,514 --> 00:11:21,481
怎么样

212
00:11:21,515 --> 00:11:25,018
因为较小的 GPU 程序可以避免一些

213
00:11:25,052 --> 00:11:26,620
大尺寸带来的运行时损失

214
00:11:26,653 --> 00:11:28,922
它可以受益于更少的指令缓存缺失

215
00:11:28,956 --> 00:11:30,757
或者需要更少的寄存器

216
00:11:30,791 --> 00:11:32,659
这意味着更少溢出到内存

217
00:11:32,693 --> 00:11:35,295
甚至更多的并行线程

218
00:11:35,329 --> 00:11:38,932
请记住 这些结果并不是所有
着色器和场景的典型结果

219
00:11:38,966 --> 00:11:40,868
性能下降是有可能的

220
00:11:40,901 --> 00:11:44,104
对于你的项目 需要评估对编译时间

221
00:11:44,137 --> 00:11:47,107
和运行性能的实际影响

222
00:11:47,140 --> 00:11:50,677
你们可以在三种不同的环境中

223
00:11:50,711 --> 00:11:53,046
从 Metal 源代码编译时启用优化大小

224
00:11:53,080 --> 00:11:55,349
在 Xcode 14 用户界面中

225
00:11:55,382 --> 00:11:58,352
在构建设置中指定尺寸优化

226
00:11:58,385 --> 00:12:00,888
在 Metal Compiler - Build Options 下

227
00:12:00,921 --> 00:12:03,290
找到 Optimization Level 设置

228
00:12:03,323 --> 00:12:07,528
“Default” 级别优化了性能
正如 Metal 过去所做的那样

229
00:12:07,561 --> 00:12:10,397
“Size” 级别可以优化大小

230
00:12:11,899 --> 00:12:14,268
通过命令行编译 Metal 源码时

231
00:12:14,301 --> 00:12:18,238
使用选项 -Os 指定尺寸优化

232
00:12:18,272 --> 00:12:23,343
第一个示例指定单个编译
和链接命令的选项

233
00:12:23,377 --> 00:12:25,946
第二个示例有两个编译命令

234
00:12:25,979 --> 00:12:28,115
并指定其中一个选项

235
00:12:28,148 --> 00:12:30,551
使其只对一些着色器启用

236
00:12:30,584 --> 00:12:32,920
该选项不需要传递给 link 命令

237
00:12:32,953 --> 00:12:34,721
或任何后续命令

238
00:12:34,755 --> 00:12:38,125
你们可以选择
是否和本演讲前面介绍的

239
00:12:38,158 --> 00:12:42,529
生成 GPU 二进制的命令一起
使用尺寸优化

240
00:12:44,398 --> 00:12:49,069
最后 在运行时使用 Metal Framework API
编译 Metal 源代码时

241
00:12:49,102 --> 00:12:51,138
例如通过 newLibraryWithSource

242
00:12:51,171 --> 00:12:54,942
指定为尺寸优化
只需在 MTLCompileOptions 对象中

243
00:12:54,975 --> 00:12:57,811
使用属性 optimizationLevel

244
00:12:57,845 --> 00:13:02,316
优化级别可以是 “default” 或 “size”

245
00:13:02,349 --> 00:13:05,719
我希望你们的项目能够
从 Metal 编译器中的

246
00:13:05,752 --> 00:13:07,988
这种新优化模式中受益

247
00:13:08,021 --> 00:13:10,657
Galo：总结一下 我介绍了离线编译

248
00:13:10,691 --> 00:13:14,328
这是一种完全在 App 构建时
生成 GPU 二进制的新工作流

249
00:13:14,361 --> 00:13:18,298
以减少应用内卡顿 首次启动
和新关卡加载时间

250
00:13:18,332 --> 00:13:20,934
Eylon：然后我提出了尺寸优化

251
00:13:20,968 --> 00:13:23,871
一种在源代码编译时新的
Metal 优化模式

252
00:13:23,904 --> 00:13:27,541
以减少程序大小和编译时间

253
00:13:27,574 --> 00:13:29,710
Galo: 我们希望这些改进
能够帮助你的 App

254
00:13:29,743 --> 00:13:31,578
或游戏提供更好的用户体验

255
00:13:31,612 --> 00:13:34,648
Eylon: 让设置和加载时间更短
卡顿更少

256
00:13:34,681 --> 00:13:39,253
还有新的工作流程
感谢运行时更低的编译消耗

257
00:13:39,286 --> 00:13:41,221
齐: 感谢收看

