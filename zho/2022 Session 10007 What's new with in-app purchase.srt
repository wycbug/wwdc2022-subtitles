1
00:00:00,033 --> 00:00:03,003
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,003 --> 00:00:09,576
♪

3
00:00:09,576 --> 00:00:10,978
Dani Chootong：大家好 欢迎收看

4
00:00:10,978 --> 00:00:13,213
“App 内购买的新功能”

5
00:00:13,213 --> 00:00:16,550
我是 Dani
StoreKit 团队的工程师

6
00:00:16,550 --> 00:00:19,186
今天将由我和同事 lan 一起

7
00:00:19,186 --> 00:00:20,854
为大家介绍
今年在 App 内购买中

8
00:00:20,854 --> 00:00:23,657
添加的新功能

9
00:00:23,657 --> 00:00:26,126
去年 我们推出了 StoreKit 2

10
00:00:26,126 --> 00:00:29,096
这是一组全新设计的 API

11
00:00:29,096 --> 00:00:32,032
用于简化 App 内购买的步骤

12
00:00:32,032 --> 00:00:34,902
StoreKit 2 使用现代语言功能

13
00:00:34,902 --> 00:00:38,539
包括使用了 async/await
模式的 Swift 并发

14
00:00:38,539 --> 00:00:39,573
在服务器端

15
00:00:39,573 --> 00:00:41,608
我们用一组全新
App Store Server 端点

16
00:00:41,608 --> 00:00:45,078
补充了这些新的 StoreKit 功能

17
00:00:45,078 --> 00:00:47,214
这些服务器端点方便您在服务器上

18
00:00:47,214 --> 00:00:49,917
检索交易信息

19
00:00:49,917 --> 00:00:52,219
查看订阅状态

20
00:00:52,219 --> 00:00:55,822
我们还发布了第 2 版
App Store Server Notifications

21
00:00:55,822 --> 00:00:57,691
方便您在服务器上

22
00:00:57,691 --> 00:01:00,227
跟踪订阅周期

23
00:01:00,227 --> 00:01:02,996
以上 API 以及
新版 StoreKit 模型的

24
00:01:02,996 --> 00:01:04,598
增强功能

25
00:01:04,598 --> 00:01:07,467
将由我来为大家介绍

26
00:01:07,467 --> 00:01:09,303
之后 将由 Ian 为大家介绍

27
00:01:09,303 --> 00:01:11,205
一些超赞的服务器更新

28
00:01:11,205 --> 00:01:13,707
包括
App Store Server API 增强功能

29
00:01:13,707 --> 00:01:17,611
以及用于 App Store
Server Notifications 的全新 API

30
00:01:17,611 --> 00:01:20,514
首先 我将介绍用于
验证 App 购买的

31
00:01:20,514 --> 00:01:23,584
全新 App Transaction API

32
00:01:23,584 --> 00:01:26,420
其次 我将深入介绍
StoreKit 模型的

33
00:01:26,420 --> 00:01:28,989
新增属性

34
00:01:28,989 --> 00:01:32,226
即全新 SwiftUI 友好型 API

35
00:01:32,226 --> 00:01:34,127
用于兑换订阅优惠代码

36
00:01:34,127 --> 00:01:37,231
并要求用户评价 App

37
00:01:37,231 --> 00:01:39,967
再次 我将为您
介绍 StoreKit Messages

38
00:01:39,967 --> 00:01:41,735
该 API 用于向用户显示

39
00:01:41,735 --> 00:01:44,171
App Store 的消息

40
00:01:44,171 --> 00:01:46,740
最后 我将介绍
即将新增的增强功能

41
00:01:46,740 --> 00:01:49,343
该功能从旧版
StoreKit API 迁移到新版时

42
00:01:49,343 --> 00:01:52,880
能保留您的 applicationUsername

43
00:01:52,880 --> 00:01:55,949
讲解过程中
我将用我常用的 App

44
00:01:55,949 --> 00:01:57,017
Food Truck 为大家演示

45
00:01:57,017 --> 00:01:59,987
在 Food Truck 这款 App 中
我经营着一个虚拟甜甜圈餐车

46
00:01:59,987 --> 00:02:02,789
走遍各个城市售卖甜甜圈

47
00:02:02,789 --> 00:02:05,392
那我们现在就开始吧！

48
00:02:05,392 --> 00:02:06,960
先来看看 App Transaction

49
00:02:06,960 --> 00:02:09,196
App Transaction
是我们新推出的 API

50
00:02:09,196 --> 00:02:12,432
用于验证 App 购买

51
00:02:12,432 --> 00:02:14,968
App 交易相当于为设备上

52
00:02:14,968 --> 00:02:18,939
运行的 App 购买签名信息

53
00:02:18,939 --> 00:02:21,508
该 API 使用 JWS 签名

54
00:02:21,508 --> 00:02:24,444
取代了原先
StoreKit API 中 App 收据的

55
00:02:24,444 --> 00:02:27,247
App 详情

56
00:02:27,247 --> 00:02:29,416
如交易验证一样

57
00:02:29,416 --> 00:02:31,585
StoreKit 为您的 App 交易

58
00:02:31,585 --> 00:02:34,888
执行自动验证

59
00:02:34,888 --> 00:02:37,457
但如果您愿意 您也可

60
00:02:37,457 --> 00:02:39,326
自行验证

61
00:02:39,326 --> 00:02:43,230
验证 JWS 签名有据可查

62
00:02:43,230 --> 00:02:45,065
您可参考公共文档

63
00:02:45,065 --> 00:02:48,335
执行验证

64
00:02:48,335 --> 00:02:50,370
StoreKit 在必要时可自动更新

65
00:02:50,370 --> 00:02:52,673
App 交易

66
00:02:52,673 --> 00:02:54,775
但在极少数情况下 用户

67
00:02:54,775 --> 00:02:57,978
认为交易出现问题 也可手动刷新

68
00:02:57,978 --> 00:02:59,613
您应在 App 中提供 UI

69
00:02:59,613 --> 00:03:03,417
允许用户刷新 App 交易

70
00:03:03,417 --> 00:03:06,186
该方法仅用于响应用户操作

71
00:03:06,186 --> 00:03:07,988
因为刷新 App 交易

72
00:03:07,988 --> 00:03:11,091
会提示用户进行身份验证

73
00:03:11,091 --> 00:03:15,362
App Transaction
受欢迎的原因并非只有防止诈骗

74
00:03:15,362 --> 00:03:18,599
如果您希望把
商业模式从付费 App 转换成

75
00:03:18,599 --> 00:03:21,368
提供 App 内购买项目的免费 App

76
00:03:21,368 --> 00:03:23,170
如果您好奇哪些客户

77
00:03:23,170 --> 00:03:25,172
预购了您的 App

78
00:03:25,172 --> 00:03:27,875
或想了解您 App 的购买时段

79
00:03:27,875 --> 00:03:31,879
均可在
App Transaction 中实现

80
00:03:31,879 --> 00:03:33,747
在 App 收据中 收据有效负载

81
00:03:33,747 --> 00:03:36,383
结合了您的 App 购买数据

82
00:03:36,383 --> 00:03:39,786
以及所有发起的 App 内购买

83
00:03:39,786 --> 00:03:41,989
这在 StoreKit 中

84
00:03:41,989 --> 00:03:43,290
分为两个独立组件

85
00:03:43,290 --> 00:03:46,393
第一个组件是交易历史

86
00:03:46,393 --> 00:03:48,495
StoreKit 的交易 API
可以让您在设备上

87
00:03:48,495 --> 00:03:51,064
查看用户所有的 App 内购买

88
00:03:51,064 --> 00:03:52,933
历史记录

89
00:03:52,933 --> 00:03:56,270
该 API 可以查找
您所需要的确切信息

90
00:03:56,270 --> 00:03:58,672
包括用户最新交易

91
00:03:58,672 --> 00:04:02,476
未完成的交易和当前授权的交易

92
00:04:02,476 --> 00:04:05,279
如您倾向于
在自己的服务器上执行运算

93
00:04:05,279 --> 00:04:07,347
还可从
App Store Server API 中

94
00:04:07,347 --> 00:04:09,516
获取用户的购买历史记录

95
00:04:09,516 --> 00:04:11,652
Ian 稍后将对该功能的亮点

96
00:04:11,652 --> 00:04:13,687
进行补充

97
00:04:13,687 --> 00:04:16,089
第二个组件是 App Transaction

98
00:04:16,089 --> 00:04:18,058
包含让您的
App 在设备上有效运行

99
00:04:18,058 --> 00:04:20,861
所需的数据

100
00:04:20,861 --> 00:04:23,063
使用 App Transaction 能轻松

101
00:04:23,063 --> 00:04:25,599
验证您的 App 购买

102
00:04:25,599 --> 00:04:28,869
稍后我将举例说明使用方法

103
00:04:28,869 --> 00:04:30,537
但在此之前 我先来向您介绍一下

104
00:04:30,537 --> 00:04:32,239
我常用的这款 App 的背景

105
00:04:32,239 --> 00:04:34,508
在 Food Truck 上
我可以配送甜甜圈

106
00:04:34,508 --> 00:04:36,777
查阅基础社交信息流

107
00:04:36,777 --> 00:04:39,046
查看销售历史

108
00:04:39,046 --> 00:04:41,048
将所有这些信息保存在数据库中

109
00:04:41,048 --> 00:04:45,219
需要持续支付费用
那么为了便于支付

110
00:04:45,219 --> 00:04:47,487
我要一次性购买

111
00:04:47,487 --> 00:04:49,523
年度销售记录表

112
00:04:49,523 --> 00:04:52,793
此外 我还想增强社交信息流推送

113
00:04:52,793 --> 00:04:54,628
这样不仅能看到他人如何评价

114
00:04:54,628 --> 00:04:56,630
我的餐车 我还能提供工具

115
00:04:56,630 --> 00:04:59,299
和客户展开互动

116
00:04:59,299 --> 00:05:00,968
这就涉及到订阅服务

117
00:05:00,968 --> 00:05:04,505
可以按月度或年度订阅

118
00:05:04,505 --> 00:05:07,508
Food Truck 起初是一款付费 App
我打算将其转变为

119
00:05:07,508 --> 00:05:10,310
支持 App 内购买的免费 App

120
00:05:10,310 --> 00:05:11,912
但我又不希望忽略

121
00:05:11,912 --> 00:05:15,782
当前已经购买了 Food Truck 的用户

122
00:05:15,782 --> 00:05:17,751
所以 我会使用 App Transaction

123
00:05:17,751 --> 00:05:20,220
保证已购买 Food Truck 的用户

124
00:05:20,220 --> 00:05:24,157
继续访问其支付的高级内容

125
00:05:24,157 --> 00:05:26,994
这是 Food Truck 的时间线

126
00:05:26,994 --> 00:05:29,263
在最初的版本中

127
00:05:29,263 --> 00:05:31,965
Food Truck 是一款
售价 4.99 美元的付费 App

128
00:05:31,965 --> 00:05:34,401
1.0 版本提供甜甜圈配送

129
00:05:34,401 --> 00:05:37,938
基础社交动态和销售记录表

130
00:05:37,938 --> 00:05:39,907
后来 在发布 8.0 版本时

131
00:05:39,907 --> 00:05:42,009
我改变了商业模式

132
00:05:42,009 --> 00:05:43,810
现在 Food Truck
虽然免费 但包含

133
00:05:43,810 --> 00:05:47,347
各类解锁高级功能
的 App 内购买项目

134
00:05:47,347 --> 00:05:50,284
年度销售记录表现在是一次性购买的

135
00:05:50,284 --> 00:05:52,486
非消耗型订阅项目 现在还有

136
00:05:52,486 --> 00:05:55,255
全新的获取高级
社交动态的订阅服务

137
00:05:55,255 --> 00:05:58,125
为您提供高级体验工具

138
00:05:58,125 --> 00:06:00,761
现在让我们来看看会受此影响的

139
00:06:00,761 --> 00:06:03,263
两类不同的用户

140
00:06:03,263 --> 00:06:06,633
Alice 发现了
Food Truck 2.5 版本的 App

141
00:06:06,633 --> 00:06:09,069
决定在虚拟世界中分享

142
00:06:09,069 --> 00:06:11,138
她对甜甜圈的热情

143
00:06:11,138 --> 00:06:13,507
所以 她以 4.99 美元的
价格购买了这款 App

144
00:06:13,507 --> 00:06:16,476
开启了甜甜圈售卖之旅

145
00:06:16,476 --> 00:06:19,513
第二位用户 Bob
通过朋友知道了 Food Truck

146
00:06:19,513 --> 00:06:21,014
并在 8.2 版的 App Store 中

147
00:06:21,014 --> 00:06:23,684
免费下载了这款 App

148
00:06:23,684 --> 00:06:26,220
在此情况下 在这款 App 免费前

149
00:06:26,220 --> 00:06:28,522
购买了该 App 的 Alice
仍可以访问

150
00:06:28,522 --> 00:06:33,093
其已经支付的所有高级内容

151
00:06:33,093 --> 00:06:35,095
仍可以选择订阅购买

152
00:06:35,095 --> 00:06:37,764
高级的社交动态信息流 但不可否认

153
00:06:37,764 --> 00:06:42,569
年度销售记录表已经包含在
她的付费版 App 中了

154
00:06:42,569 --> 00:06:44,872
而 Bob 则是免费下载了该 App

155
00:06:44,872 --> 00:06:47,307
两位都要完成 App 内购买

156
00:06:47,307 --> 00:06:49,510
才可使用其中的解锁功能和内容

157
00:06:49,510 --> 00:06:51,345
那么 让我们看看如何
通过代码中的 App Transaction

158
00:06:51,345 --> 00:06:53,881
实现这一目标

159
00:06:53,881 --> 00:06:55,816
首先 我将调用
AppTransaction.shared

160
00:06:55,816 --> 00:06:59,353
发起 App 交易

161
00:06:59,353 --> 00:07:01,722
通过该操作得到
一个含有我的 App 交易的

162
00:07:01,722 --> 00:07:03,991
VerificationResult

163
00:07:03,991 --> 00:07:05,993
在结果中 AppTransaction 类型

164
00:07:05,993 --> 00:07:09,296
包含 JWS 有效负载

165
00:07:09,296 --> 00:07:11,865
接下来 我将打开结果

166
00:07:11,865 --> 00:07:14,134
如果结果未经验证 那就要

167
00:07:14,134 --> 00:07:16,136
提醒用户 其 App 购买

168
00:07:16,136 --> 00:07:18,105
可能未经 App Store 验证

169
00:07:18,105 --> 00:07:22,142
然后 我就可以
提示用户刷新 App 交易

170
00:07:22,142 --> 00:07:26,046
与此同时 我将为用户
提供 App 短时体验机会

171
00:07:26,046 --> 00:07:28,282
如果结果已经验证 那我将借此机会

172
00:07:28,282 --> 00:07:31,885
检查用户是否购买了我的 App

173
00:07:31,885 --> 00:07:33,153
购买了我的 App 的用户

174
00:07:33,153 --> 00:07:36,290
有权获取其所支付的服务

175
00:07:36,290 --> 00:07:39,493
为此 我将利用原始
App 版本的属性

176
00:07:39,493 --> 00:07:41,762
该属性可让我了解用户首次下载

177
00:07:41,762 --> 00:07:46,099
该 App 时的版本

178
00:07:46,099 --> 00:07:49,069
8.0 版本是包含了
App 内购买项目选项的

179
00:07:49,069 --> 00:07:51,572
免费版本

180
00:07:51,572 --> 00:07:53,941
我将把用户下载的
原始 App 版本导入函数

181
00:07:53,941 --> 00:07:57,010
检查用户是否在 8.0 版本发行前

182
00:07:57,010 --> 00:07:58,812
就购买了我的 App

183
00:07:58,812 --> 00:08:01,081
以此为依据 我就可以决定

184
00:08:01,081 --> 00:08:05,919
如何为用户提供高级内容

185
00:08:05,919 --> 00:08:08,155
对于像 Alice 这类
购买 App 的用户

186
00:08:08,155 --> 00:08:10,490
我将向其提供购买时

187
00:08:10,490 --> 00:08:13,093
有权获得的内容

188
00:08:13,093 --> 00:08:15,996
为其解锁甜甜圈售卖的

189
00:08:15,996 --> 00:08:18,332
年度销售记录表

190
00:08:18,332 --> 00:08:20,901
我还想查看
两位在 App 内购买中的

191
00:08:20,901 --> 00:08:25,172
其他行为记录
以便为他们提供相关内容

192
00:08:25,172 --> 00:08:27,908
此外我同时也可以确定
某用户 (比如 Bob) 是在

193
00:08:27,908 --> 00:08:31,044
我转变商业模式后
才下载了我的 App

194
00:08:31,044 --> 00:08:32,079
这正好可以

195
00:08:32,079 --> 00:08:33,780
检查用户当前授权的交易

196
00:08:33,780 --> 00:08:37,651
如此我就可以
解锁其付费的功能和内容

197
00:08:37,651 --> 00:08:39,152
只需几行代码

198
00:08:39,152 --> 00:08:41,755
我就能验证我的 App 购买

199
00:08:41,755 --> 00:08:43,323
检查用户是否下载了

200
00:08:43,323 --> 00:08:44,925
该 App 的付费版本

201
00:08:44,925 --> 00:08:47,494
并且不论用户
是否购买了我的 App

202
00:08:47,494 --> 00:08:52,032
我都能立即提供高级内容

203
00:08:52,032 --> 00:08:54,201
使用 App Transaction
您可轻松为用户

204
00:08:54,201 --> 00:08:56,403
提供支持 无论其是老用户

205
00:08:56,403 --> 00:08:59,473
还是刚刚下载 App 的新用户

206
00:08:59,473 --> 00:09:01,441
现在我来为大家讲解

207
00:09:01,441 --> 00:09:04,344
StoreKit 模型中的新增属性

208
00:09:04,344 --> 00:09:07,414
首先是价格区域设置

209
00:09:07,414 --> 00:09:10,684
价格区域设置
如今包含在 StoreKit 产品中

210
00:09:10,684 --> 00:09:12,586
您在使用原先购买的 API 时

211
00:09:12,586 --> 00:09:16,423
可能对此已有所了解

212
00:09:16,423 --> 00:09:19,593
接下来 我将深入
介绍服务器的环境属性

213
00:09:19,593 --> 00:09:21,662
现在 您可以知道交易或续订

214
00:09:21,662 --> 00:09:25,132
发生时处于的服务器环境

215
00:09:25,132 --> 00:09:27,334
然后 我会谈谈

216
00:09:27,334 --> 00:09:28,902
最近订阅开始日期属性

217
00:09:28,902 --> 00:09:31,471
它能帮助您根据用户的订阅模式

218
00:09:31,471 --> 00:09:35,242
明智地决定如何为其提供服务

219
00:09:35,242 --> 00:09:37,845
最后 我将介绍利用上述属性

220
00:09:37,845 --> 00:09:39,546
在 Xcode 中使用
StoreKit Testing 时的

221
00:09:39,546 --> 00:09:41,882
特别注意事项

222
00:09:41,882 --> 00:09:43,650
上述属性在较旧的操作系统中

223
00:09:43,650 --> 00:09:46,520
会返回标记值 对此我来

224
00:09:46,520 --> 00:09:48,522
稍作一点解释

225
00:09:48,522 --> 00:09:51,692
StoreKit API
的设计考虑了灵活性

226
00:09:51,692 --> 00:09:53,026
所以我可以很自豪地说

227
00:09:53,026 --> 00:09:55,295
以上新属性就算是在去年

228
00:09:55,295 --> 00:09:58,432
未曾配备类似属性的操作系统上

229
00:09:58,432 --> 00:10:01,902
也可以使用

230
00:10:01,902 --> 00:10:04,304
要做到这一点 您只需要使用

231
00:10:04,304 --> 00:10:07,074
Xcode 14 来构建
您的 App 您可在

232
00:10:07,074 --> 00:10:10,177
先前的操作系统中
获取上述新增属性

233
00:10:10,177 --> 00:10:12,179
之所以能如此 是因为

234
00:10:12,179 --> 00:10:14,515
上述新增属性
被编译到您的 App 中

235
00:10:14,515 --> 00:10:16,984
因此 用户在更新版本后

236
00:10:16,984 --> 00:10:19,186
就能够使用这些增强功能

237
00:10:19,186 --> 00:10:21,955
无需更新其操作系统

238
00:10:21,955 --> 00:10:23,790
但是 在使用新增属性时

239
00:10:23,790 --> 00:10:26,360
要牢记一件事

240
00:10:26,360 --> 00:10:28,328
当您在旧版操作系统中的

241
00:10:28,328 --> 00:10:30,397
Xcode 中使用
StoreKit 测试时

242
00:10:30,397 --> 00:10:32,533
新增属性会返回标记值

243
00:10:32,533 --> 00:10:33,967
这里说的标记值

244
00:10:33,967 --> 00:10:36,069
指的是占位符值

245
00:10:36,069 --> 00:10:38,539
不是您使用的实际值

246
00:10:38,539 --> 00:10:41,308
我来解释一下原因

247
00:10:41,308 --> 00:10:43,544
沙盒和生产环境

248
00:10:43,544 --> 00:10:45,812
通过提取 App Store
服务器响应的值

249
00:10:45,812 --> 00:10:48,081
来利用这些属性

250
00:10:48,081 --> 00:10:50,083
不过 Xcode 中的
StoreKit 测试

251
00:10:50,083 --> 00:10:52,786
是独立于 App Store 服务器

252
00:10:52,786 --> 00:10:54,821
运行的本地测试环境

253
00:10:54,821 --> 00:10:57,157
这意味着我们无法将这些属性的值

254
00:10:57,157 --> 00:11:00,527
回传到先前的操作系统中

255
00:11:00,527 --> 00:11:02,396
您可将测试设备
更新到新的操作系统中

256
00:11:02,396 --> 00:11:05,232
从而轻松绕过此限制

257
00:11:05,232 --> 00:11:07,100
随后即可在本地环境中

258
00:11:07,100 --> 00:11:08,735
测试上述值

259
00:11:08,735 --> 00:11:10,971
我们来讨论一下几种

260
00:11:10,971 --> 00:11:13,340
利用新增属性的情况

261
00:11:13,340 --> 00:11:15,776
首先是价格区域设置

262
00:11:15,776 --> 00:11:18,478
StoreKit 产品已经
具备了显示价格属性

263
00:11:18,478 --> 00:11:21,281
用以标记购买价格
但利用价格区域设置

264
00:11:21,281 --> 00:11:22,716
您可将产品十进制价格中得出的

265
00:11:22,716 --> 00:11:25,986
数字格式化

266
00:11:25,986 --> 00:11:27,721
如果您有年度订阅功能

267
00:11:27,721 --> 00:11:29,756
即可以此为契机

268
00:11:29,756 --> 00:11:32,726
向用户展示每月的费用

269
00:11:32,726 --> 00:11:35,329
在此示例中
您可以看到年度订阅服务

270
00:11:35,329 --> 00:11:38,599
每月费用为 4.17 美元

271
00:11:38,599 --> 00:11:40,200
或者您想向用户展示

272
00:11:40,200 --> 00:11:42,469
订阅您的年度服务比订阅月度服务

273
00:11:42,469 --> 00:11:44,404
节省了多少开支

274
00:11:44,404 --> 00:11:46,607
利用以上信息 您的用户可以

275
00:11:46,607 --> 00:11:48,475
在考虑您的购买选项时

276
00:11:48,475 --> 00:11:51,144
做出明智的决定

277
00:11:51,144 --> 00:11:54,014
我们继续来讨论环境属性

278
00:11:54,014 --> 00:11:55,516
环境属性可以

279
00:11:55,516 --> 00:11:57,918
在交易和续订信息中找到

280
00:11:57,918 --> 00:11:59,920
该属性能让您了解交易或续订信息

281
00:11:59,920 --> 00:12:02,990
源于哪个服务器环境

282
00:12:02,990 --> 00:12:06,093
例如 Xcode、沙盒或生产环境

283
00:12:06,093 --> 00:12:07,327
您的 App 会在用户购买后

284
00:12:07,327 --> 00:12:09,730
将交易信息发送到您的服务器

285
00:12:09,730 --> 00:12:13,133
以便记账和分析

286
00:12:13,133 --> 00:12:15,302
当您的 App 生成交易时

287
00:12:15,302 --> 00:12:18,172
交易可能来自任何服务器环境

288
00:12:18,172 --> 00:12:19,673
和您一样 我也不想让

289
00:12:19,673 --> 00:12:22,843
不相关的测试数据干扰分析

290
00:12:22,843 --> 00:12:25,045
因此 了解环境可帮助您

291
00:12:25,045 --> 00:12:27,614
过滤掉发送至服务器的

292
00:12:27,614 --> 00:12:29,149
不必要的信息

293
00:12:29,149 --> 00:12:30,350
最后 我们来看看

294
00:12:30,350 --> 00:12:32,786
最近订阅开始日期

295
00:12:32,786 --> 00:12:34,955
最近订阅开始日期可在

296
00:12:34,955 --> 00:12:37,624
产品订阅信息中查看

297
00:12:37,624 --> 00:12:39,326
指的是连续订阅

298
00:12:39,326 --> 00:12:41,595
最近开始的日期

299
00:12:41,595 --> 00:12:44,231
如果任何两个订阅期
之间没有超过 60 天

300
00:12:44,231 --> 00:12:48,235
则视为连续订阅

301
00:12:48,235 --> 00:12:50,270
请记住 该期间可能包含

302
00:12:50,270 --> 00:12:53,240
用户未订阅您产品的时间

303
00:12:53,240 --> 00:12:54,875
因此不可将其作为

304
00:12:54,875 --> 00:12:59,213
用户已订阅天数的指标

305
00:12:59,213 --> 00:13:01,515
最近订阅开始日期可帮助您

306
00:13:01,515 --> 00:13:05,485
确定您和用户之间的粘度

307
00:13:05,485 --> 00:13:07,955
对于忠实用户 您可为其提供奖励

308
00:13:07,955 --> 00:13:10,891
鼓励其继续使用您的产品

309
00:13:10,891 --> 00:13:12,292
或者 若您注意到用户

310
00:13:12,292 --> 00:13:14,194
已取消订阅您的服务

311
00:13:14,194 --> 00:13:16,997
您可以借此机会
激励用户再次使用您的产品

312
00:13:16,997 --> 00:13:21,635
赢回流失的顾客

313
00:13:21,635 --> 00:13:23,704
之前我提到过 我们要仔细查看

314
00:13:23,704 --> 00:13:26,573
新增属性的标记值

315
00:13:26,573 --> 00:13:28,842
请注意 这里说的标记值

316
00:13:28,842 --> 00:13:30,511
指的是占位符值

317
00:13:30,511 --> 00:13:34,781
用于指示缺失的实际值

318
00:13:34,781 --> 00:13:38,252
新增属性的标记值很容易识别

319
00:13:38,252 --> 00:13:39,987
当您处理价格区域设置时

320
00:13:39,987 --> 00:13:45,526
标记值是带有
标识符 xx_XX 的区域设置

321
00:13:45,526 --> 00:13:49,062
对环境属性而言
标记值是一个空字符串

322
00:13:49,062 --> 00:13:51,698
最后 就最近订阅开始日期而言

323
00:13:51,698 --> 00:13:54,301
此值为 Date.distantPast

324
00:13:54,301 --> 00:13:56,503
所幸 标记值的出现

325
00:13:56,503 --> 00:13:58,739
是可预测的——
您只会在较老的操作系统中的

326
00:13:58,739 --> 00:14:00,707
Xcode 中使用 StoreKit 测试时

327
00:14:00,707 --> 00:14:02,442
遇到该值

328
00:14:02,442 --> 00:14:05,879
您可通过更新测试设备解决该问题

329
00:14:05,879 --> 00:14:07,514
现在您已经了解了
我们在 StoreKit 模型中

330
00:14:07,514 --> 00:14:09,650
添加的增强功能

331
00:14:09,650 --> 00:14:11,685
我最喜欢一点是 新增属性

332
00:14:11,685 --> 00:14:13,720
可以一直向后兼容到

333
00:14:13,720 --> 00:14:15,822
推出该模型的操作系统

334
00:14:15,822 --> 00:14:17,824
这样您的用户只需更新 App

335
00:14:17,824 --> 00:14:19,560
就可立即使用新增属性

336
00:14:19,560 --> 00:14:22,196
当您对价格值执行算法时

337
00:14:22,196 --> 00:14:24,431
价格区域设置可帮助您正确格式化

338
00:14:24,431 --> 00:14:26,800
使其与 App Store 的
区域设置相匹配

339
00:14:26,800 --> 00:14:29,269
对于交易和订阅信息

340
00:14:29,269 --> 00:14:30,504
环境会准确告知您

341
00:14:30,504 --> 00:14:32,272
具体来源

342
00:14:32,272 --> 00:14:33,974
因此若您将
这些数据存储在服务器上

343
00:14:33,974 --> 00:14:37,377
您就可以根据环境
对其采取相应措施

344
00:14:37,377 --> 00:14:40,013
最近订阅开始日期可助您了解

345
00:14:40,013 --> 00:14:42,482
用户忠诚度 因此您可为长期用户

346
00:14:42,482 --> 00:14:45,085
定制具体优惠 或者您可以

347
00:14:45,085 --> 00:14:49,423
为已退订的用户提供激励

348
00:14:49,423 --> 00:14:52,693
若您想知道环境

349
00:14:52,693 --> 00:14:55,529
以及最近订阅开始日期

350
00:14:55,529 --> 00:14:59,032
可在 App Store Server API 和
App Store Server Notifications 中查看

351
00:14:59,032 --> 00:15:01,101
这是 Ian 之后要讨论的内容

352
00:15:01,101 --> 00:15:04,471
现在我来介绍一下
我们为兑换优惠代码和请求评价

353
00:15:04,471 --> 00:15:08,108
提供的全新 SwiftUI API

354
00:15:08,108 --> 00:15:11,245
优惠代码可帮助您

355
00:15:11,245 --> 00:15:14,081
通过提供折扣或限时免费订阅

356
00:15:14,081 --> 00:15:16,984
获取、巩固并赢回订阅者

357
00:15:16,984 --> 00:15:19,453
在 App Store Connect 中
您可以创建唯一命名的

358
00:15:19,453 --> 00:15:20,821
自定义代码

359
00:15:20,821 --> 00:15:23,490
然后您可设置最大赎回限额

360
00:15:23,490 --> 00:15:26,527
选择是否设置截止时间

361
00:15:26,527 --> 00:15:28,996
我们来看 SwiftUI 在

362
00:15:28,996 --> 00:15:32,366
您的 App 中呈现
优惠代码兑换表的方式

363
00:15:32,366 --> 00:15:34,034
这是一个 SwiftUI 视图

364
00:15:34,034 --> 00:15:36,837
带有可触发优惠代码兑换表的按钮

365
00:15:36,837 --> 00:15:38,672
优惠代码兑换表

366
00:15:38,672 --> 00:15:42,843
在 SwiftUI 中
有自己的视图修饰符

367
00:15:42,843 --> 00:15:44,645
视图修饰符使用简单

368
00:15:44,645 --> 00:15:47,915
只需绑定布尔值便可启动程序

369
00:15:47,915 --> 00:15:49,883
一旦解除优惠代码表

370
00:15:49,883 --> 00:15:51,051
您就会得到显示

371
00:15:51,051 --> 00:15:54,955
该表是否成功呈现的结果

372
00:15:54,955 --> 00:15:57,558
当用户为您的 App
兑换优惠代码时

373
00:15:57,558 --> 00:15:58,592
最终交易结果

374
00:15:58,592 --> 00:16:02,062
就被发送到事务监听器

375
00:16:02,062 --> 00:16:04,231
因此 一定要在您的 App 启动后

376
00:16:04,231 --> 00:16:06,233
设置一个事务监听器 使其在

377
00:16:06,233 --> 00:16:09,970
App 运行时接收和更新事务

378
00:16:09,970 --> 00:16:14,842
优惠代码视图修饰符
将从 iOS 16 起

379
00:16:14,842 --> 00:16:18,478
接下来 我来介绍一下
对请求评价的更新

380
00:16:18,478 --> 00:16:21,281
获取用户反馈尤为重要

381
00:16:21,281 --> 00:16:23,550
评价可能是潜在新用户

382
00:16:23,550 --> 00:16:27,154
下载 App 的决定性因素

383
00:16:27,154 --> 00:16:29,356
其他用户或许也想通过评价来提供

384
00:16:29,356 --> 00:16:32,159
反馈或建议

385
00:16:32,159 --> 00:16:34,761
无论哪种情况
我们都希望为您提供有利工具

386
00:16:34,761 --> 00:16:37,297
便于您向用户请求评分

387
00:16:37,297 --> 00:16:39,066
让用户知道您在倾听他们的意见

388
00:16:39,066 --> 00:16:41,468
方便您继续与其互动

389
00:16:41,468 --> 00:16:44,071
我们再来看一下代码

390
00:16:44,071 --> 00:16:45,272
这个简单的视图

391
00:16:45,272 --> 00:16:48,275
演示了请求评价的 API

392
00:16:48,275 --> 00:16:50,744
在 SwiftUI 中 有一个环境值

393
00:16:50,744 --> 00:16:52,513
名为 requestReview

394
00:16:52,513 --> 00:16:54,314
您可使用此值来获取

395
00:16:54,314 --> 00:16:56,550
RequestReviewAction 的实例

396
00:16:56,550 --> 00:16:58,418
当您准备好请求评分时

397
00:16:58,418 --> 00:17:00,420
只需将实例作为函数调用

398
00:17:00,420 --> 00:17:03,524
请求显示评价提示

399
00:17:03,524 --> 00:17:05,192
您可选择恰当时机请求用户

400
00:17:05,192 --> 00:17:06,827
对您的 App 进行评价

401
00:17:06,827 --> 00:17:09,429
不过 您需了解 该提示

402
00:17:09,429 --> 00:17:12,032
在 365 天内最多只会

403
00:17:12,032 --> 00:17:14,902
向用户展示 3 次

404
00:17:14,902 --> 00:17:16,503
您也不应请求用户

405
00:17:16,503 --> 00:17:19,740
对同一版本的 App
进行多次评价

406
00:17:19,740 --> 00:17:22,543
避免评价提示打扰用户

407
00:17:22,543 --> 00:17:24,811
请求评价的良好时机应在用户

408
00:17:24,811 --> 00:17:27,814
进行良性互动之后
例如在电子商务 App 上

409
00:17:27,814 --> 00:17:31,118
完成购买 或在游戏中完成关卡

410
00:17:31,118 --> 00:17:33,854
最后 用户可禁止在其设备上

411
00:17:33,854 --> 00:17:35,923
发送请求 因此您不应

412
00:17:35,923 --> 00:17:39,927
再次向用户发送评价请求

413
00:17:39,927 --> 00:17:42,196
以上 API 一定会
让您的 SwiftUI App

414
00:17:42,196 --> 00:17:43,664
使用便捷

415
00:17:43,664 --> 00:17:45,566
接下来 我为大家介绍一下

416
00:17:45,566 --> 00:17:48,468
适用 StoreKit 消息的新 API

417
00:17:48,468 --> 00:17:51,071
StoreKit 消息是在您的 App 上

418
00:17:51,071 --> 00:17:54,808
显示的一张表格
用于向用户展示重要信息

419
00:17:54,808 --> 00:17:57,244
信息由 App Store 出售

420
00:17:57,244 --> 00:17:58,745
每一条消息的出现都有原因

421
00:17:58,745 --> 00:18:01,882
包含在消息元数据中

422
00:18:01,882 --> 00:18:03,717
当您的 App 在前台运行时

423
00:18:03,717 --> 00:18:05,586
就能检索到 StoreKit 消息

424
00:18:05,586 --> 00:18:07,321
举个例子 我们看一下

425
00:18:07,321 --> 00:18:10,858
其中一条消息原因——同意涨价

426
00:18:10,858 --> 00:18:13,227
当您提高订阅价格时

427
00:18:13,227 --> 00:18:15,963
需要经过用户同意
App Store 就会通过

428
00:18:15,963 --> 00:18:19,833
电子邮件、推送通知
和 App 内价格同意书的方式

429
00:18:19,833 --> 00:18:21,869
通知受影响的订阅者

430
00:18:21,869 --> 00:18:23,971
在此情况下 App Store 需要用户

431
00:18:23,971 --> 00:18:25,906
在以更高的价格续订之前

432
00:18:25,906 --> 00:18:28,442
同意您新制定的价格

433
00:18:28,442 --> 00:18:30,978
因此 如果您决定
向用户收取更多订阅费用

434
00:18:30,978 --> 00:18:32,980
且若用户尚未回应涨价

435
00:18:32,980 --> 00:18:36,316
那么当其打开您的 App 时

436
00:18:36,316 --> 00:18:38,285
就会出现涨价同意书

437
00:18:38,285 --> 00:18:40,654
默认情况下 StoreKit 消息

438
00:18:40,654 --> 00:18:42,990
会在用户前台运行
您的 App 时显示

439
00:18:42,990 --> 00:18:44,892
要求用户就您的 App

440
00:18:44,892 --> 00:18:46,693
进行某些操作

441
00:18:46,693 --> 00:18:48,495
我们来回顾一下

442
00:18:48,495 --> 00:18:51,298
以您的 App 为起点

443
00:18:51,298 --> 00:18:53,467
当您的 App 进入前台时

444
00:18:53,467 --> 00:18:54,635
StoreKit 会检查

445
00:18:54,635 --> 00:18:56,904
有无待显示的消息

446
00:18:56,904 --> 00:19:00,007
如果有 StoreKit 会在
App Store 中记录

447
00:19:00,007 --> 00:19:01,909
App Store 会将相关信息

448
00:19:01,909 --> 00:19:03,677
返回到 StoreKit

449
00:19:03,677 --> 00:19:05,579
这时 StoreKit
会检查您的 App 是否

450
00:19:05,579 --> 00:19:07,614
设置为接收消息

451
00:19:07,614 --> 00:19:10,651
您可通过在 App 上
设置消息监听器来实现

452
00:19:10,651 --> 00:19:12,486
这一点我很快就会讲到

453
00:19:12,486 --> 00:19:14,721
如果您的 App
设置了消息监听器

454
00:19:14,721 --> 00:19:17,925
StoreKit 会将
有关信息发送到您的 App

455
00:19:17,925 --> 00:19:20,761
然后由您决定是否

456
00:19:20,761 --> 00:19:22,796
让您的 App 显示消息

457
00:19:22,796 --> 00:19:25,499
或者推迟显示

458
00:19:25,499 --> 00:19:28,135
若您未设置消息监听器

459
00:19:28,135 --> 00:19:29,837
StoreKit 通过在您的 App 上

460
00:19:29,837 --> 00:19:32,339
显示消息表来立即显示消息

461
00:19:32,339 --> 00:19:34,408
我来介绍如何在代码中执行此操作

462
00:19:34,408 --> 00:19:36,410
但在这之前 我先解释一种情况

463
00:19:36,410 --> 00:19:38,779
在这种情况下
控制 App Store 消息的呈现

464
00:19:38,779 --> 00:19:41,148
非常有用

465
00:19:41,148 --> 00:19:43,450
在 Food Truck 这款 App 中
我可以自定义

466
00:19:43,450 --> 00:19:45,485
送往不同城市的甜甜圈

467
00:19:45,485 --> 00:19:48,088
在此期间
若有消息发送到我的 App 上

468
00:19:48,088 --> 00:19:50,290
那么消息表的突然出现 会扰乱用户

469
00:19:50,290 --> 00:19:53,460
所以我要利用消息 API

470
00:19:53,460 --> 00:19:56,129
控制消息出现的时间

471
00:19:56,129 --> 00:19:59,333
来避免此类情况

472
00:19:59,333 --> 00:20:01,535
现在来看代码

473
00:20:01,535 --> 00:20:04,304
这是一个甜甜圈编辑器的简单视图

474
00:20:04,304 --> 00:20:06,607
之前提到过 待处理消息

475
00:20:06,607 --> 00:20:09,142
会在您每次
前台运行 App 时发送

476
00:20:09,142 --> 00:20:12,012
所以 我想在
每个视图中设置一个消息监听器

477
00:20:12,012 --> 00:20:15,782
来推迟消息的呈现

478
00:20:15,782 --> 00:20:17,985
在位于编辑视图时
我将添加一个绑定数组来收集

479
00:20:17,985 --> 00:20:20,921
传送至我 App 的所有消息

480
00:20:20,921 --> 00:20:24,091
这个步骤很重要
因为若不设置消息监听器

481
00:20:24,091 --> 00:20:26,760
StoreKit 将在
我前台运行 App 时

482
00:20:26,760 --> 00:20:28,962
立即显示消息表

483
00:20:28,962 --> 00:20:32,533
视图一出现 我就设置了消息监听器

484
00:20:32,533 --> 00:20:34,668
为此 我将设置一个任务

485
00:20:34,668 --> 00:20:37,504
该任务会在
消息类型上迭代一个静态属性

486
00:20:37,504 --> 00:20:39,540
该属性是一个异步序列

487
00:20:39,540 --> 00:20:42,676
而且我可以在消息进来时立刻接收

488
00:20:42,676 --> 00:20:44,444
就我的用途而言 我将在待处理的

489
00:20:44,444 --> 00:20:46,747
消息数组中保存消息

490
00:20:46,747 --> 00:20:48,649
由于每次在前台运行 App 时

491
00:20:48,649 --> 00:20:50,751
都会发送待处理消息 您的 App

492
00:20:50,751 --> 00:20:53,487
会多次接收同一条消息 因此我可以

493
00:20:53,487 --> 00:20:56,757
避免将重复的消息添加到数组中

494
00:20:56,757 --> 00:20:58,759
然后 一旦该视图消失

495
00:20:58,759 --> 00:21:01,762
父视图中就可显示消息

496
00:21:01,762 --> 00:21:03,730
这是包含甜甜圈编辑器链接的

497
00:21:03,730 --> 00:21:05,499
父视图

498
00:21:05,499 --> 00:21:07,434
在这里 我收集了
需要在待处理消息数组中

499
00:21:07,434 --> 00:21:10,671
显示的所有待处理消息

500
00:21:10,671 --> 00:21:13,507
那么 如何显示以上待处理消息呢？

501
00:21:13,507 --> 00:21:15,175
现在有一个
displayStoreKitMessage

502
00:21:15,175 --> 00:21:17,244
环境值

503
00:21:17,244 --> 00:21:19,880
该值为您提供
DisplayMessageAction 的实例

504
00:21:19,880 --> 00:21:23,383
您可以利用其显示特定消息

505
00:21:23,383 --> 00:21:24,418
视图出现时

506
00:21:24,418 --> 00:21:25,986
我将循环访问待处理消息

507
00:21:25,986 --> 00:21:27,855
并调用 displayStoreKitMessage

508
00:21:27,855 --> 00:21:30,390
传递我要显示的消息

509
00:21:30,390 --> 00:21:34,695
StoreKit 负责呈现消息表

510
00:21:34,695 --> 00:21:36,196
之前 我提到过相同的消息

511
00:21:36,196 --> 00:21:38,799
可能会多次传送到您的 App

512
00:21:38,799 --> 00:21:40,868
那是因为消息在呈现给用户后

513
00:21:40,868 --> 00:21:42,936
才被标记为已读

514
00:21:42,936 --> 00:21:45,639
因此 StoreKit 会确保
每条不同的消息

515
00:21:45,639 --> 00:21:48,442
只呈现一次

516
00:21:48,442 --> 00:21:50,477
这一点是 Messages API 的

517
00:21:50,477 --> 00:21:52,613
快速实现

518
00:21:52,613 --> 00:21:55,849
再次提醒 StoreKit 消息
会在您前台运行 App 时

519
00:21:55,849 --> 00:21:58,352
发送给您 所以您需要

520
00:21:58,352 --> 00:22:01,188
给每一个视图设置
消息侦听器 以便控制

521
00:22:01,188 --> 00:22:04,258
消息显示的时间

522
00:22:04,258 --> 00:22:07,294
您可确保消息在恰当的时机出现

523
00:22:07,294 --> 00:22:10,797
保证用户的良好体验

524
00:22:10,797 --> 00:22:12,566
或者您也可以为某些消息类型

525
00:22:12,566 --> 00:22:14,368
自定义逻辑

526
00:22:14,368 --> 00:22:16,370
在向用户发送涨价同意书前

527
00:22:16,370 --> 00:22:17,804
您可能想利用涨价同意信息

528
00:22:17,804 --> 00:22:19,673
告知用户

529
00:22:19,673 --> 00:22:23,076
您提供的附加价值

530
00:22:23,076 --> 00:22:25,712
最后 我们来看一下用户购买后

531
00:22:25,712 --> 00:22:28,282
StoreKit 将
applicationUsername 保存为

532
00:22:28,282 --> 00:22:31,185
appAccountToken 的方式

533
00:22:31,185 --> 00:22:34,087
如果您的服务器上有用户帐户系统

534
00:22:34,087 --> 00:22:35,889
您可能已经在使用

535
00:22:35,889 --> 00:22:38,425
applicationUsername 属性了

536
00:22:38,425 --> 00:22:41,361
applicationUsername
是您创建的字符串

537
00:22:41,361 --> 00:22:45,832
用于将交易与您服务中的
用户帐户相关联

538
00:22:45,832 --> 00:22:48,235
在 App 内购买的原始 API 中

539
00:22:48,235 --> 00:22:50,938
您在向支付队列添加付款时

540
00:22:50,938 --> 00:22:53,340
会设置 applicationUsername 值

541
00:22:53,340 --> 00:22:56,810
尽管 applicationUsername
接受任何字符串

542
00:22:56,810 --> 00:22:59,213
但我们建议您提供

543
00:22:59,213 --> 00:23:01,815
UUID 的字符串表现形式

544
00:23:01,815 --> 00:23:04,184
在提供 UUID 字符串后

545
00:23:04,184 --> 00:23:06,086
StoreKit 会保留该值 您会在

546
00:23:06,086 --> 00:23:08,522
队列更新的交易中看到它

547
00:23:08,522 --> 00:23:10,457
如果您未向 applicationUsername

548
00:23:10,457 --> 00:23:13,794
提供 UUID 字符串
StoreKit 可能不会保留该值

549
00:23:13,794 --> 00:23:15,896
无法保证在您将支付交易添加到

550
00:23:15,896 --> 00:23:18,699
队列和队列更新交易之间

551
00:23:18,699 --> 00:23:21,935
该值将保持不变

552
00:23:21,935 --> 00:23:25,072
您提供 UUID 字符串表现形式后

553
00:23:25,072 --> 00:23:27,307
就能识别哪些用户帐户

554
00:23:27,307 --> 00:23:30,410
开始并完成了一笔交易

555
00:23:30,410 --> 00:23:33,313
在现代 StoreKit API 中
我们将此概念实现为

556
00:23:33,313 --> 00:23:35,883
appAccountToken 的购买选项

557
00:23:35,883 --> 00:23:39,386
并需要 UUID 格式

558
00:23:39,386 --> 00:23:41,622
现在 当您在付款期间将
applicationUsername

559
00:23:41,622 --> 00:23:44,525
设置为 UUID 字符串时

560
00:23:44,525 --> 00:23:47,761
App Store 服务器就会将其
存储为 appAccountToken

561
00:23:47,761 --> 00:23:51,031
所以您会看到其 UUID 出现在

562
00:23:51,031 --> 00:23:53,267
App Store Server API
返回的签名交易信息

563
00:23:53,267 --> 00:23:57,337
和 V2 App Store
Server Notifications 中

564
00:23:57,337 --> 00:24:00,541
并且其作为 UUID
在现代 StoreKit 交易 API 中

565
00:24:00,541 --> 00:24:03,911
可与 appAccountToken 兼容

566
00:24:03,911 --> 00:24:06,446
因此 您可确定在将代码库

567
00:24:06,446 --> 00:24:08,248
更新到现代 StoreKit API 时

568
00:24:08,248 --> 00:24:11,084
您用于
applicationUsername 的 UUID

569
00:24:11,084 --> 00:24:12,986
在 StoreKit 交易中

570
00:24:12,986 --> 00:24:15,789
保存为 appAccountToken

571
00:24:15,789 --> 00:24:18,125
我们今天接触了很多概念

572
00:24:18,125 --> 00:24:20,427
在讲解服务器更新之前

573
00:24:20,427 --> 00:24:24,264
我们先来回顾一下
今年 StoreKit 的更新内容

574
00:24:24,264 --> 00:24:26,400
我们讨论了用 App Transaction

575
00:24:26,400 --> 00:24:28,035
验证您的 App 购买

576
00:24:28,035 --> 00:24:31,605
在 SwiftUI 中
兑换优惠代码并请求评价

577
00:24:31,605 --> 00:24:35,409
以及控制 StoreKit 的消息呈现

578
00:24:35,409 --> 00:24:38,579
我们谈到价格区域设置、环境

579
00:24:38,579 --> 00:24:41,715
以及最近订阅开始日期等新增属性

580
00:24:41,715 --> 00:24:43,784
还讲述了将 applicationUsername

581
00:24:43,784 --> 00:24:48,088
设置为 UUID 字符串以

582
00:24:48,088 --> 00:24:50,924
将其保留
为 App 帐户令牌的重要性

583
00:24:50,924 --> 00:24:53,660
我强烈推荐您观看接下来的讲解

584
00:24:53,660 --> 00:24:56,063
“StoreKit 测试中的新功能”

585
00:24:56,063 --> 00:24:58,899
如果您需要重新了解
StoreKit 2 API

586
00:24:58,899 --> 00:25:01,935
请查看去年的
“Meet StoreKit 2”一期

587
00:25:01,935 --> 00:25:03,637
接下来就交给 Ian

588
00:25:03,637 --> 00:25:06,673
由他为您介绍
App Store 服务器的更新内容

589
00:25:06,673 --> 00:25:07,975
Ian Zanger ：谢谢 Dani

590
00:25:07,975 --> 00:25:09,776
大家好 我是 Ian

591
00:25:09,776 --> 00:25:12,913
App Store Server
团队的工程师

592
00:25:12,913 --> 00:25:14,181
既然您已经了解了

593
00:25:14,181 --> 00:25:16,416
使用 StoreKit 进行
App 内购买的最新消息

594
00:25:16,416 --> 00:25:19,253
那么我就换个角度来谈谈服务器

595
00:25:19,253 --> 00:25:23,223
首先 我来回顾一下
过去一年的最新进展

596
00:25:23,223 --> 00:25:25,559
然后再介绍
App Store Server API

597
00:25:25,559 --> 00:25:27,861
和 App Store Server Notifications V2 的

598
00:25:27,861 --> 00:25:32,299
新增亮点

599
00:25:32,299 --> 00:25:34,535
我们开始吧

600
00:25:34,535 --> 00:25:36,069
去年收获颇丰

601
00:25:36,069 --> 00:25:39,039
我们为您带来了一整套

602
00:25:39,039 --> 00:25:41,008
搭载 App Store Server API

603
00:25:41,008 --> 00:25:44,344
和 App Store Server Notifications V2
的全新端点

604
00:25:44,344 --> 00:25:46,580
包括支持以上所有新功能的

605
00:25:46,580 --> 00:25:48,815
完整的沙盒测试

606
00:25:48,815 --> 00:25:52,653
我们分享了如何使用
Get Transaction History 端点

607
00:25:52,653 --> 00:25:55,889
获取用户 App 内
购买的完整历史记录

608
00:25:55,889 --> 00:25:59,092
或 Get All
Subscription Statuses 端点

609
00:25:59,092 --> 00:26:01,061
以便随时了解

610
00:26:01,061 --> 00:26:03,497
用户订阅状态

611
00:26:03,497 --> 00:26:05,899
上述两个端点都可便于切断

612
00:26:05,899 --> 00:26:09,169
用户的 originalTransactionId

613
00:26:09,169 --> 00:26:11,605
这样您只需存储这一简单的值

614
00:26:11,605 --> 00:26:14,808
就可以访问数据宝库

615
00:26:14,808 --> 00:26:16,777
我们还涉猎到

616
00:26:16,777 --> 00:26:19,012
App Store Server Notifications V2

617
00:26:19,012 --> 00:26:22,082
简化服务器上​​的事件处理

618
00:26:22,082 --> 00:26:25,385
并补足
App Store Server API 的方式

619
00:26:25,385 --> 00:26:27,387
利用版本 2 通知

620
00:26:27,387 --> 00:26:30,524
App Store 服务器
会直接调用您的服务器

621
00:26:30,524 --> 00:26:33,894
在有新版本时
通知您更新 App 内购买

622
00:26:33,894 --> 00:26:37,264
简化后的通知类型和子类型

623
00:26:37,264 --> 00:26:40,267
便于您理解具体情况

624
00:26:40,267 --> 00:26:42,135
您可借此跟踪 App 内订阅

625
00:26:42,135 --> 00:26:45,939
和其他事件相关的变动

626
00:26:45,939 --> 00:26:47,574
利用所有这些数据源

627
00:26:47,574 --> 00:26:51,411
我们想让数据尽可能便于解析

628
00:26:51,411 --> 00:26:53,680
收据现在已成为历史

629
00:26:53,680 --> 00:26:56,583
因为新增服务以签名的 JSON 格式

630
00:26:56,583 --> 00:27:00,487
提供 App 内数据
您因此可以轻松解析

631
00:27:00,487 --> 00:27:04,091
并相信其来自
App Store 服务器

632
00:27:04,091 --> 00:27:07,628
去年对于 App Store
服务器来说是重要的一年

633
00:27:07,628 --> 00:27:10,063
如果您致力于更新服务器代码

634
00:27:10,063 --> 00:27:12,432
以便使用所有新增功能

635
00:27:12,432 --> 00:27:15,068
那么这一年对您或许同样重要

636
00:27:15,068 --> 00:27:18,238
请放心 努力将继续得到回报

637
00:27:18,238 --> 00:27:21,341
因为我们为
App Store Server API 和

638
00:27:21,341 --> 00:27:27,181
App Store Server Notifications V2
带来了强大的增强功能特性

639
00:27:27,181 --> 00:27:28,749
这就是我们一年的历程

640
00:27:28,749 --> 00:27:30,484
如果您在听完今年的更新后

641
00:27:30,484 --> 00:27:32,519
想复习一下

642
00:27:32,519 --> 00:27:36,990
请务必查看 WWDC21 演讲

643
00:27:36,990 --> 00:27:40,127
“管理服务器上的 App 内购买”、

644
00:27:40,127 --> 00:27:42,262
“认识 StoreKit 2”

645
00:27:42,262 --> 00:27:45,832
以及“支持顾客和处理退款”

646
00:27:45,832 --> 00:27:48,468
现在我们继续讲解为 WWDC22 的

647
00:27:48,468 --> 00:27:53,207
App Store 服务器做的全新升级

648
00:27:53,207 --> 00:27:56,143
首先 我来分享一些关于交易

649
00:27:56,143 --> 00:27:58,378
和续订信息字段的更新

650
00:27:58,378 --> 00:28:01,148
接下来我为您讲述
App Store Server API 中

651
00:28:01,148 --> 00:28:03,917
新的增强功能

652
00:28:03,917 --> 00:28:06,587
最后 我将分享即将用于
App Store Server Notifications V2

653
00:28:06,587 --> 00:28:11,191
的亮点新功能

654
00:28:11,191 --> 00:28:14,461
现在我们来深入探讨第一个话题

655
00:28:14,461 --> 00:28:18,498
交易和续订信息中的新字段

656
00:28:18,498 --> 00:28:21,735
此前 您从 Dani 那里
了解到 App 内购买中

657
00:28:21,735 --> 00:28:24,137
交易和续订信息的

658
00:28:24,137 --> 00:28:26,039
新字段

659
00:28:26,039 --> 00:28:30,077
上述字段 即环境和
recentSubscriptionStartDate

660
00:28:30,077 --> 00:28:32,079
也会出现在您从
App Store Server API

661
00:28:32,079 --> 00:28:33,514
和 V2 App Store Server Notifications 中

662
00:28:33,514 --> 00:28:36,316
收到的交易和续订信息的

663
00:28:36,316 --> 00:28:40,687
有效载荷中

664
00:28:40,687 --> 00:28:44,391
让我们重新审视一下
您希望从包含以上新字段的

665
00:28:44,391 --> 00:28:48,395
App Store 服务器中收到的数据

666
00:28:48,395 --> 00:28:50,931
首先是交易信息有效载荷

667
00:28:50,931 --> 00:28:53,734
解码后我们可以在这里看到

668
00:28:53,734 --> 00:28:57,804
在底部 您可以看到
我们的新字段：环境

669
00:28:57,804 --> 00:28:59,773
您可以清晰地知道

670
00:28:59,773 --> 00:29:01,575
交易是否发生

671
00:29:01,575 --> 00:29:04,878
在生产或沙盒环境中

672
00:29:04,878 --> 00:29:07,247
接下来是续订信息有效载荷

673
00:29:07,247 --> 00:29:10,017
解码后仍可在这里看到

674
00:29:10,017 --> 00:29:13,620
如您所见 环境字段也出现在这里

675
00:29:13,620 --> 00:29:15,656
以供您参考

676
00:29:15,656 --> 00:29:18,192
此外 recentSubscriptionStartDate

677
00:29:18,192 --> 00:29:21,428
现在将出现在
每个续订信息有效载荷中

678
00:29:21,428 --> 00:29:23,797
这是用户在最近的续订字段中

679
00:29:23,797 --> 00:29:27,801
首次订阅购买的开始日期

680
00:29:27,801 --> 00:29:32,105
它会忽略 60 天及以内的时间间隔

681
00:29:32,105 --> 00:29:35,542
recentSubscriptionStartDate 是了解

682
00:29:35,542 --> 00:29:38,512
用户忠诚度的简单方法

683
00:29:38,512 --> 00:29:40,047
但如果您想了解更多细节

684
00:29:40,047 --> 00:29:43,750
包括服务订阅间隙的时间和长度

685
00:29:43,750 --> 00:29:47,020
您可调用
Get Transaction History 端点

686
00:29:47,020 --> 00:29:48,622
并检查用户

687
00:29:48,622 --> 00:29:51,925
续订购买的完整历史记录

688
00:29:51,925 --> 00:29:54,094
若想进一步了解细节

689
00:29:54,094 --> 00:29:56,964
使用 App Store Server Notifications V2

690
00:29:56,964 --> 00:29:59,867
App Store 服务器就会自动

691
00:29:59,867 --> 00:30:03,070
向您的服务器发送用户订阅更新

692
00:30:03,070 --> 00:30:05,939
这些通知可让您最大限度了解

693
00:30:05,939 --> 00:30:09,710
更新偏好变化、优惠代码兑换

694
00:30:09,710 --> 00:30:14,548
计费失败等事件的时间

695
00:30:14,548 --> 00:30:17,351
如您所见
recentSubscriptionStartDate

696
00:30:17,351 --> 00:30:19,152
为确定用户忠诚度

697
00:30:19,152 --> 00:30:21,588
完善了一系列选项

698
00:30:21,588 --> 00:30:23,757
利用这些工具可定制优惠

699
00:30:23,757 --> 00:30:27,060
奖励您最忠实的用户

700
00:30:27,060 --> 00:30:30,497
现在让我们来看
Get Transaction History

701
00:30:30,497 --> 00:30:33,734
端点中便利的增强功能

702
00:30:33,734 --> 00:30:36,003
利用 Get Transaction History 端点

703
00:30:36,003 --> 00:30:39,206
您可以在 App 上获取用户购买的

704
00:30:39,206 --> 00:30:41,008
完整历史记录

705
00:30:41,008 --> 00:30:43,377
端点响应是分页的

706
00:30:43,377 --> 00:30:46,947
因此您可在合理的
区块中处理这些数据

707
00:30:46,947 --> 00:30:49,983
每个响应都包含一个
修订令牌 您在下一个请求中

708
00:30:49,983 --> 00:30:53,921
提供该令牌即可获取下一页

709
00:30:53,921 --> 00:30:56,623
页面按修改日期排序

710
00:30:56,623 --> 00:30:59,693
这就意味着每个后续页面都包含

711
00:30:59,693 --> 00:31:02,930
最近修改的交易

712
00:31:02,930 --> 00:31:05,299
我们看看其工作模式

713
00:31:05,299 --> 00:31:08,268
您调用
Get Transaction History 端点

714
00:31:08,268 --> 00:31:12,105
并提供 originalTransactionId

715
00:31:12,105 --> 00:31:16,410
App Store 服务器
将为该用户返回至多

716
00:31:16,410 --> 00:31:18,045
20 个签名交易

717
00:31:18,045 --> 00:31:21,181
还会返回一个更新的修订值

718
00:31:21,181 --> 00:31:25,519
您将在下一页请求中
为该用户提供此值

719
00:31:25,519 --> 00:31:27,688
您会看到
当响应中的 hasMore 字段

720
00:31:27,688 --> 00:31:31,725
为真时 还有更多可用数据

721
00:31:31,725 --> 00:31:32,926
假设在这种情况下

722
00:31:32,926 --> 00:31:35,863
还有另一页可用数据

723
00:31:35,863 --> 00:31:37,998
您向端点发出另一个请求

724
00:31:37,998 --> 00:31:41,635
其中包含了第一个响应中的修订值

725
00:31:41,635 --> 00:31:43,537
那您收到的下一页数据

726
00:31:43,537 --> 00:31:46,406
其中就包括更新的修订值

727
00:31:46,406 --> 00:31:49,743
hasMore 现在是错误的
因此您就知道了

728
00:31:49,743 --> 00:31:52,513
最新的交易数据

729
00:31:52,513 --> 00:31:54,181
此外 您注意到

730
00:31:54,181 --> 00:31:56,683
响应中的最终交易

731
00:31:56,683 --> 00:31:58,485
好像之前见过

732
00:31:58,485 --> 00:32:01,288
这就是您在第一次请求时收到的

733
00:32:01,288 --> 00:32:03,891
20 个签名交易中的一个

734
00:32:03,891 --> 00:32:06,593
这意味着交易一定已被修改

735
00:32:06,593 --> 00:32:10,497
所以它被放回了排序首位

736
00:32:10,497 --> 00:32:13,467
现在您可以检查该交易的数据

737
00:32:13,467 --> 00:32:15,702
看看发生了什么变化

738
00:32:15,702 --> 00:32:18,639
这时 您会注意到 revocationDate

739
00:32:18,639 --> 00:32:21,808
和 revocationReason 字段已被填充

740
00:32:21,808 --> 00:32:24,211
这意味着交易被撤销

741
00:32:24,211 --> 00:32:26,847
您可以撤消任何与购买相关的内容

742
00:32:26,847 --> 00:32:29,616
来采取行动

743
00:32:29,616 --> 00:32:32,152
最好的办法是将最终响应的修订值

744
00:32:32,152 --> 00:32:34,521
与您用于识别用户的

745
00:32:34,521 --> 00:32:39,326
originalTransactionId 一同存储

746
00:32:39,326 --> 00:32:41,862
这样下一次您为该用户调用端点时

747
00:32:41,862 --> 00:32:44,064
就可以提供该修订并了解

748
00:32:44,064 --> 00:32:47,201
只取回自您上次请求后被修改的

749
00:32:47,201 --> 00:32:50,971
新交易数据

750
00:32:50,971 --> 00:32:54,074
如您所见
Get Transaction History 端点

751
00:32:54,074 --> 00:32:57,811
为您提供了一种检索
一套全面 App 内购买数据的

752
00:32:57,811 --> 00:33:00,013
简单方法

753
00:33:00,013 --> 00:33:03,851
但有时它或许过于全面

754
00:33:03,851 --> 00:33:06,286
某些用户购买历史较长

755
00:33:06,286 --> 00:33:09,056
有好几年

756
00:33:09,056 --> 00:33:12,092
对于这些用户 此端点可能会返回

757
00:33:12,092 --> 00:33:16,897
数百种类型的购买数据

758
00:33:16,897 --> 00:33:20,234
即使有页面 处理起来也较繁琐

759
00:33:20,234 --> 00:33:22,803
这就是今年我们
要用各种新的排序和过滤选项

760
00:33:22,803 --> 00:33:27,307
增强该端点的原因

761
00:33:27,307 --> 00:33:31,111
现在您可以告知我们
您想要的确切初始数据

762
00:33:31,111 --> 00:33:33,514
节省服务器处理时间

763
00:33:33,514 --> 00:33:35,449
并减少所有可用页面

764
00:33:35,449 --> 00:33:39,319
所需的网络调用次数

765
00:33:39,319 --> 00:33:41,889
如果您想在第一页看到

766
00:33:41,889 --> 00:33:43,891
最近修改的购买数据

767
00:33:43,891 --> 00:33:47,794
可按修改日期降序排列

768
00:33:47,794 --> 00:33:50,597
您还可以按几个
有用的字段进行过滤

769
00:33:50,597 --> 00:33:54,201
例如产品类型、产品 ID

770
00:33:54,201 --> 00:33:56,970
家庭共享状态等

771
00:33:56,970 --> 00:33:59,706
要应用上述排序和过滤选项

772
00:33:59,706 --> 00:34:03,143
只需将其作为查询参数附加到您对

773
00:34:03,143 --> 00:34:06,346
Get Transaction History 端点的请求中

774
00:34:06,346 --> 00:34:09,183
我们进一步来看看其工作方式

775
00:34:09,183 --> 00:34:12,686
在这里您可以
看到新增的全部参数选项

776
00:34:12,686 --> 00:34:15,455
可能看起来很熟悉 因为大多数都

777
00:34:15,455 --> 00:34:18,625
来自交易信息有效负载

778
00:34:18,625 --> 00:34:20,394
您可以混合匹配这些参数

779
00:34:20,394 --> 00:34:22,596
以得到具体结果

780
00:34:22,596 --> 00:34:24,865
例如 我们或许只想获取

781
00:34:24,865 --> 00:34:28,335
一位用户自今年年初以来的

782
00:34:28,335 --> 00:34:31,004
非消费性购买数据

783
00:34:31,004 --> 00:34:34,741
并希望排除任何已撤销的购买

784
00:34:34,741 --> 00:34:36,510
那么我们构建自定义请求

785
00:34:36,510 --> 00:34:39,446
将 productType
设置为 NON_CONSUMABLE

786
00:34:39,446 --> 00:34:43,116
并将 startDate
指定为今年年初

787
00:34:43,116 --> 00:34:45,185
以毫秒为单位显示

788
00:34:45,185 --> 00:34:49,189
最后 我们将
excludeRevoked 设置为 true

789
00:34:49,189 --> 00:34:50,891
请求就构建完成了！

790
00:34:50,891 --> 00:34:53,093
由于我们没有选择排序顺序

791
00:34:53,093 --> 00:34:55,095
响应将默认为

792
00:34:55,095 --> 00:34:58,131
按升序修改日期排序

793
00:34:58,131 --> 00:35:00,934
即便请求已十分具体

794
00:35:00,934 --> 00:35:04,338
也可能有多个购买页面需要检索

795
00:35:04,338 --> 00:35:06,673
对于后续请求 我们应该确保

796
00:35:06,673 --> 00:35:09,343
除了先前响应的修订

797
00:35:09,343 --> 00:35:12,980
包含完全相同的查询参数

798
00:35:12,980 --> 00:35:14,781
为了更加灵活

799
00:35:14,781 --> 00:35:18,185
其中有三个过滤器字段支持多个值

800
00:35:18,185 --> 00:35:20,587
因此您可以过滤与所提供值

801
00:35:20,587 --> 00:35:24,691
至少有一个相匹配的购买数据

802
00:35:24,691 --> 00:35:28,962
该字段为
productType、productId

803
00:35:28,962 --> 00:35:32,199
和 subscriptionGroupIdentifier

804
00:35:32,199 --> 00:35:35,369
要为这些参数提供多个值

805
00:35:35,369 --> 00:35:39,173
只需多次对其定义

806
00:35:39,173 --> 00:35:44,378
接下来我们继续讨论
App Store Server Notification 更新

807
00:35:44,378 --> 00:35:47,314
使用 App Store Server Notifications V2

808
00:35:47,314 --> 00:35:50,417
您可将服务器提升至更高水平

809
00:35:50,417 --> 00:35:53,487
V2 通知提供了

810
00:35:53,487 --> 00:35:55,088
关于 App 内购买的详细内容

811
00:35:55,088 --> 00:35:57,824
使其独树一帜

812
00:35:57,824 --> 00:36:01,161
这尤其方便您跟踪 App 中提供的

813
00:36:01,161 --> 00:36:05,032
自动更新订阅生命周期

814
00:36:05,032 --> 00:36:08,569
您可以利用该内容巩固用户

815
00:36:08,569 --> 00:36:10,804
赢回流失用户

816
00:36:10,804 --> 00:36:15,108
解决用户支持请求等

817
00:36:15,108 --> 00:36:19,446
了解了以上妙用
您可能想知道究竟如何开始

818
00:36:19,446 --> 00:36:21,181
与其他新功能一样

819
00:36:21,181 --> 00:36:24,852
最好以沙盒测试环境为起点

820
00:36:24,852 --> 00:36:26,086
这就是为什么去年

821
00:36:26,086 --> 00:36:29,423
我们要在
App Store Connect 中添加

822
00:36:29,423 --> 00:36:31,792
设置单独服务器 URL 的功能

823
00:36:31,792 --> 00:36:35,262
以便在沙盒中接收
App Store Server Notifications

824
00:36:35,262 --> 00:36:37,865
注册您的服务器 URL 后

825
00:36:37,865 --> 00:36:39,600
您需要确认您的服务器

826
00:36:39,600 --> 00:36:43,403
正在接收来自
App Store 服务器的通知

827
00:36:43,403 --> 00:36:45,272
您可以设置一个沙盒帐户

828
00:36:45,272 --> 00:36:49,276
以便通过用户操作触发通知

829
00:36:49,276 --> 00:36:52,779
例如 假设您使用该沙盒帐户

830
00:36:52,779 --> 00:36:56,216
首次购买订阅服务

831
00:36:56,216 --> 00:37:00,687
您会收到
SUBSCRIBED 类型 V2 通知

832
00:37:00,687 --> 00:37:03,257
和 INITIAL_BUY 子类型

833
00:37:03,257 --> 00:37:05,626
若没有收到通知怎么办？

834
00:37:05,626 --> 00:37:08,262
您或许会怀疑是否是服务器

835
00:37:08,262 --> 00:37:12,099
或您为触发通知
而操作的步骤出现了问题

836
00:37:12,099 --> 00:37:15,169
刚开始时 这种情况会产生

837
00:37:15,169 --> 00:37:16,803
很多不确定性

838
00:37:16,803 --> 00:37:19,573
我们希望简化设置 便于您

839
00:37:19,573 --> 00:37:23,043
轻松验证
App Store Server Notifications

840
00:37:23,043 --> 00:37:25,345
是否发送至您的服务器

841
00:37:25,345 --> 00:37:27,981
因此在今年 我们推出新的

842
00:37:27,981 --> 00:37:31,151
Request a Test Notification 端点

843
00:37:31,151 --> 00:37:32,886
通过调用这个简单的端点

844
00:37:32,886 --> 00:37:37,691
您可要求我们发送
TEST 类型的 V2 Notification

845
00:37:37,691 --> 00:37:42,429
至 App Store Connect 中
为您的 App 注册的服务器 URL

846
00:37:42,429 --> 00:37:45,899
新的 TEST 通知类型为

847
00:37:45,899 --> 00:37:47,935
该端点专用

848
00:37:47,935 --> 00:37:51,038
您可以在沙盒或生产环境中调用端点

849
00:37:51,038 --> 00:37:55,342
为任一环境测试您保存的 URL

850
00:37:55,342 --> 00:37:59,346
使用这个新端点
可以快速测试新的服务器 URL

851
00:37:59,346 --> 00:38:01,748
和配置

852
00:38:01,748 --> 00:38:04,918
我们来看看如何简化首次设置

853
00:38:04,918 --> 00:38:08,555
如果您只是想触发第一个通知

854
00:38:08,555 --> 00:38:10,924
那么无需设置沙盒帐户

855
00:38:10,924 --> 00:38:12,960
或执行购买

856
00:38:12,960 --> 00:38:14,328
只需在您要测试的环境中

857
00:38:14,328 --> 00:38:16,964
调用新端点

858
00:38:16,964 --> 00:38:20,634
即可收到一个确认您请求的

859
00:38:20,634 --> 00:38:22,736
HTTP 200 响应

860
00:38:22,736 --> 00:38:25,138
该响应包含一个新字段

861
00:38:25,138 --> 00:38:29,610
testNotificationToken
识别您的服务器

862
00:38:29,610 --> 00:38:31,712
收到的测试通知

863
00:38:31,712 --> 00:38:34,381
我们稍后会再次提到这个新字段

864
00:38:34,381 --> 00:38:38,819
片刻后 您的服务器
就会在 App Store Connect

865
00:38:38,819 --> 00:38:43,624
保存的 URL 中收到
类型为 TEST 的 V2 通知

866
00:38:43,624 --> 00:38:46,493
现在来看如何调用该端点

867
00:38:46,493 --> 00:38:49,530
只需向 App Store
服务器上的这个新路径

868
00:38:49,530 --> 00:38:52,032
发送一个简单的 POST 请求

869
00:38:52,032 --> 00:38:55,235
您就会收到 HTTP 200 响应

870
00:38:55,235 --> 00:38:58,572
并了解您的请求已被提交

871
00:38:58,572 --> 00:39:01,441
响应将包含我提到的新字段

872
00:39:01,441 --> 00:39:03,810
testNotificationToken

873
00:39:03,810 --> 00:39:06,146
请留意这一点以备后用

874
00:39:06,146 --> 00:39:10,317
很快您就会收到一份
签好名的 TEST 通知

875
00:39:10,317 --> 00:39:12,519
这是该通知

876
00:39:12,519 --> 00:39:14,488
解码后的样子

877
00:39:14,488 --> 00:39:17,491
您会注意到它包含 V2 通知中

878
00:39:17,491 --> 00:39:19,526
所有常见的顶级字段

879
00:39:19,526 --> 00:39:23,230
包括新的 notificationType TEST

880
00:39:23,230 --> 00:39:26,099
数据对象的内容

881
00:39:26,099 --> 00:39:27,901
比正常通知稍短

882
00:39:27,901 --> 00:39:29,636
由于这只是一个测试

883
00:39:29,636 --> 00:39:32,840
未包含交易相关数据

884
00:39:32,840 --> 00:39:35,642
因此我们省略了特定于交易的字段

885
00:39:35,642 --> 00:39:40,080
最常见的就是
signedTransactionInfo

886
00:39:40,080 --> 00:39:43,684
调用新的
Request a Test Notification 端点时

887
00:39:43,684 --> 00:39:46,186
请记住
App Store Server Notifications

888
00:39:46,186 --> 00:39:48,655
是异步发送的

889
00:39:48,655 --> 00:39:50,824
您对端点的成功调用

890
00:39:50,824 --> 00:39:55,462
将返回一个 HTTP 200
但实际的测试通知

891
00:39:55,462 --> 00:39:59,466
稍后将单独到达

892
00:39:59,466 --> 00:40:01,368
由于该端点是为

893
00:40:01,368 --> 00:40:03,704
测试您的服务器配置

894
00:40:03,704 --> 00:40:07,107
您或许好奇该测试若失败了该怎么办

895
00:40:07,107 --> 00:40:12,112
换句话说
如果测试通知没有到达怎么办？

896
00:40:12,112 --> 00:40:14,982
为进一步提高您的测试能力

897
00:40:14,982 --> 00:40:18,752
我们将发布
Get Test Notification Status 端点

898
00:40:18,752 --> 00:40:20,521
您将其与

899
00:40:20,521 --> 00:40:24,091
Request a Test Notification 端点结合使用

900
00:40:24,091 --> 00:40:26,793
利用该端点 您可以检查先前请求的

901
00:40:26,793 --> 00:40:30,631
TEST 通知状态

902
00:40:30,631 --> 00:40:33,534
端点响应将告知您
App Store 服务器是否

903
00:40:33,534 --> 00:40:35,369
能够访问您的服务器

904
00:40:35,369 --> 00:40:39,173
并成功发送 TEST 通知

905
00:40:39,173 --> 00:40:42,342
如果发送失败 它也会告诉您原因

906
00:40:42,342 --> 00:40:46,480
这样您就可以更好地
对服务器配置进行故障排除

907
00:40:46,480 --> 00:40:50,284
我们来看使用该端点的方法

908
00:40:50,284 --> 00:40:54,888
向 App Store 服务器上的
此路径发送 GET 请求

909
00:40:54,888 --> 00:40:58,091
在此路径中 包含了您从

910
00:40:58,091 --> 00:41:02,462
Request a Test Notification 端点
收到的 testNotificationToken

911
00:41:02,462 --> 00:41:04,865
这会告诉我们您想检查

912
00:41:04,865 --> 00:41:07,234
哪个测试通知的状态

913
00:41:07,234 --> 00:41:09,169
再来看响应

914
00:41:09,169 --> 00:41:13,073
signedPayload 字段
包含了App Store 服务器

915
00:41:13,073 --> 00:41:15,542
尝试向您的服务器发送的

916
00:41:15,542 --> 00:41:17,377
TEST 通知有效负载

917
00:41:17,377 --> 00:41:21,281
并且
firstSendAttemptResult 字段表明了

918
00:41:21,281 --> 00:41:23,851
发送尝试的结果

919
00:41:23,851 --> 00:41:27,654
这里 SUCCESS 表示发送成功

920
00:41:27,654 --> 00:41:31,725
意味着 App Store 服务器
收到了您的服务器做出的

921
00:41:31,725 --> 00:41:34,127
HTTP 200 响应

922
00:41:34,127 --> 00:41:36,530
如果未发送成功

923
00:41:36,530 --> 00:41:40,667
您将看到以下几个不同的错误值

924
00:41:40,667 --> 00:41:44,505
这些值表示
App Store 服务器在尝试

925
00:41:44,505 --> 00:41:48,008
通过测试通知
访问您的服务器时遇到的错误

926
00:41:48,008 --> 00:41:51,812
有了这些信息
您可以解决服务器问题

927
00:41:51,812 --> 00:41:54,748
根据需要请求新的测试通知

928
00:41:54,748 --> 00:41:58,118
让您的服务器平稳运行

929
00:41:58,118 --> 00:42:00,921
总得来说 以上测试通知端点

930
00:42:00,921 --> 00:42:03,724
使用简单 在设置或重新配置服务器

931
00:42:03,724 --> 00:42:06,593
以接收
V2 App Store 服务器通知时

932
00:42:06,593 --> 00:42:11,698
可以为您省去很多麻烦

933
00:42:11,698 --> 00:42:13,133
在上述端点的帮助下

934
00:42:13,133 --> 00:42:17,004
您可以设置
您的服务器确保其顺利运行

935
00:42:17,004 --> 00:42:20,207
但服务器并不完美 有时还会中断

936
00:42:20,207 --> 00:42:23,043
那当您的服务器
出现故障 导致您错过

937
00:42:23,043 --> 00:42:26,914
App Store Server Notifications 时
您如何恢复？

938
00:42:26,914 --> 00:42:30,484
目前的解决方案就是重试系统

939
00:42:30,484 --> 00:42:33,453
当 App Store 服务器
无法访问您的服务器时

940
00:42:33,453 --> 00:42:36,089
它会启动重试程序

941
00:42:36,089 --> 00:42:40,360
最多重试发送五次相同通知

942
00:42:40,360 --> 00:42:43,363
每次尝试间隔递增

943
00:42:43,363 --> 00:42:47,701
重试仅发生在生产环境中

944
00:42:47,701 --> 00:42:50,637
可帮助您最终从中断中恢复

945
00:42:50,637 --> 00:42:53,740
但并非适合所有情况

946
00:42:53,740 --> 00:42:57,110
例如 有些中断可能范围较大

947
00:42:57,110 --> 00:42:58,979
如果您的服务器停机时间长到

948
00:42:58,979 --> 00:43:02,482
错过了 App Store
服务器发送的最终重试尝试

949
00:43:02,482 --> 00:43:05,319
那该通知将丢失

950
00:43:05,319 --> 00:43:06,587
或者还有更常见的情况

951
00:43:06,587 --> 00:43:09,590
您的服务器可能遇到了
一个非常简短的问题

952
00:43:09,590 --> 00:43:13,560
而在此期间它只错过了少量通知

953
00:43:13,560 --> 00:43:16,196
但错过哪怕一个通知

954
00:43:16,196 --> 00:43:18,832
都意味着您的客户记录

955
00:43:18,832 --> 00:43:20,567
至少有一个小时未更新

956
00:43:20,567 --> 00:43:23,437
而您却不知道未更新的是哪些记录！

957
00:43:23,437 --> 00:43:26,240
显然 服务器中断压力很大

958
00:43:26,240 --> 00:43:29,309
从中恢复是一项复杂的任务

959
00:43:29,309 --> 00:43:31,845
所以我们才想尽可能简单地

960
00:43:31,845 --> 00:43:35,182
恢复错过的
App Store Server Notifications

961
00:43:35,182 --> 00:43:39,887
以便您的服务器尽快重回正轨

962
00:43:39,887 --> 00:43:42,689
这也是今年我们推出新的

963
00:43:42,689 --> 00:43:45,325
Get Notification History 端点的原因

964
00:43:45,325 --> 00:43:46,994
有了该端点

965
00:43:46,994 --> 00:43:51,331
您可以获取您的 App 生成的

966
00:43:51,331 --> 00:43:53,767
V2 App Store Server Notifications

967
00:43:53,767 --> 00:43:58,238
无论您的服务器是否成功收到通知

968
00:43:58,238 --> 00:44:02,743
该通知都会出现在该端点的响应中

969
00:44:02,743 --> 00:44:04,111
调用该端点时

970
00:44:04,111 --> 00:44:08,515
您要指定获取通知的日期范围

971
00:44:08,515 --> 00:44:11,919
通过 WWDC
我们已经开始记录这些数据

972
00:44:11,919 --> 00:44:15,422
累积最近六个月的

973
00:44:15,422 --> 00:44:18,192
滚动历史上线

974
00:44:18,192 --> 00:44:22,296
您可以选择
按类型和子类型过滤您的请求

975
00:44:22,296 --> 00:44:25,699
或通过提供 originalTransactionId

976
00:44:25,699 --> 00:44:29,036
仅获取单个用户的通知

977
00:44:29,036 --> 00:44:31,905
现有的重试系统仍然可用

978
00:44:31,905 --> 00:44:35,843
因此您可以将其与该新端点结合使用

979
00:44:35,843 --> 00:44:39,046
我们来看一下如何调用该端点

980
00:44:39,046 --> 00:44:41,849
您向 App Store
服务器上的这个新路径

981
00:44:41,849 --> 00:44:43,684
发送一个简单的 POST 请求

982
00:44:43,684 --> 00:44:48,822
在请求正文中包含
startDate 和 endDate

983
00:44:48,822 --> 00:44:51,425
响应将仅包含我们首次尝试

984
00:44:51,425 --> 00:44:54,795
在此窗口中发送的通知

985
00:44:54,795 --> 00:44:58,065
请记住 最早可用的通知

986
00:44:58,065 --> 00:45:02,970
是在您提出请求前
六个月发送的通知

987
00:45:02,970 --> 00:45:06,473
或者 您可指定一个
notificationType

988
00:45:06,473 --> 00:45:08,609
和 notificationSubtype

989
00:45:08,609 --> 00:45:12,513
若采用此方法
历史记录将被过滤为仅

990
00:45:12,513 --> 00:45:15,148
匹配这两个值的通知

991
00:45:15,148 --> 00:45:19,486
请记住 某些通知没有子类型

992
00:45:19,486 --> 00:45:21,321
又或者 您可提供

993
00:45:21,321 --> 00:45:23,991
某个用户的
originalTransactionId

994
00:45:23,991 --> 00:45:28,662
仅获取该用户的通知历史记录

995
00:45:28,662 --> 00:45:31,632
最后 您要提供
一个 paginationToken

996
00:45:31,632 --> 00:45:34,768
作为每个后续请求的查询参数

997
00:45:34,768 --> 00:45:37,171
以便获取下一页

998
00:45:37,171 --> 00:45:39,740
确保您在后续请求中

999
00:45:39,740 --> 00:45:41,341
使用相同的请求正文

1000
00:45:41,341 --> 00:45:44,511
仅更改此 paginationToken

1001
00:45:44,511 --> 00:45:47,447
现在让我们来看响应

1002
00:45:47,447 --> 00:45:51,752
notificationHistory 数组
最多包含 20 个通知

1003
00:45:51,752 --> 00:45:55,622
首先是最久远的通知

1004
00:45:55,622 --> 00:45:59,860
该数组中的每个条目代表一个通知

1005
00:45:59,860 --> 00:46:02,930
在其中您会找到 signedPayload

1006
00:46:02,930 --> 00:46:07,434
您可像往常一样
对其解码以查看交易数据

1007
00:46:07,434 --> 00:46:10,337
其中的数据与 App Store 服务器

1008
00:46:10,337 --> 00:46:14,575
在原始通知中发送的有效负载相同

1009
00:46:14,575 --> 00:46:16,610
您会看到我们
为该还端点响应带来了新的

1010
00:46:16,610 --> 00:46:20,848
firstSendAttemptResult 字段

1011
00:46:20,848 --> 00:46:24,151
使用此字段您可查找超时序列

1012
00:46:24,151 --> 00:46:27,487
以及其他错误
以更好了解您的服务器

1013
00:46:27,487 --> 00:46:30,858
错过历史通知的原因

1014
00:46:30,858 --> 00:46:33,627
若有更多页面需要检索

1015
00:46:33,627 --> 00:46:36,196
响应还包含一个 paginationToken

1016
00:46:36,196 --> 00:46:38,265
您应该在下一个请求中提供此信息

1017
00:46:38,265 --> 00:46:41,802
以获得下一页通知

1018
00:46:41,802 --> 00:46:43,937
只要 hasMore 字段为 true

1019
00:46:43,937 --> 00:46:47,708
您就有更多页面需要检索

1020
00:46:47,708 --> 00:46:49,243
以上就是该新端点的

1021
00:46:49,243 --> 00:46:52,546
所有介绍

1022
00:46:52,546 --> 00:46:56,116
今天我们的 App Store
服务器更新讲座就到此结束了

1023
00:46:56,116 --> 00:46:59,152
讲座中提及的服务器功能现在均可

1024
00:46:59,152 --> 00:47:02,389
在沙盒和生产中使用

1025
00:47:02,389 --> 00:47:04,758
我们希望您能利用以上新功能

1026
00:47:04,758 --> 00:47:07,761
让您的服务器达到最佳状态

1027
00:47:07,761 --> 00:47:11,465
有关针对 App 内购买使用服务器
的更多精彩内容

1028
00:47:11,465 --> 00:47:13,700
包括如何在支持旧版客户端的同时

1029
00:47:13,700 --> 00:47:15,802
使用最新功能

1030
00:47:15,802 --> 00:47:20,374
建议您观看 WWDC22 的另一场讲座

1031
00:47:20,374 --> 00:47:24,211
“探索 App 内购买集成和迁移”

1032
00:47:24,211 --> 00:47:27,548
两位：感谢您加入 WWDC22！

1033
00:47:27,548 --> 00:47:31,585
♪

