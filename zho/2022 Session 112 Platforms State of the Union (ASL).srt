1
00:00:00,334 --> 00:00:07,574
♪ ♪

2
00:00:09,243 --> 00:00:17,251
♪ ♪

3
00:00:22,356 --> 00:00:27,861
欢迎来到 WWDC 2022
State of the Union

4
00:00:27,895 --> 00:00:31,498
我们总是兴奋地迎接 WWDC
因为它提供了非常好的契机

5
00:00:31,532 --> 00:00:33,600
让我们可以与你们所有人沟通

6
00:00:33,634 --> 00:00:35,602
分享我们最近的工作进展

7
00:00:35,636 --> 00:00:39,940
以及更好地理解
你们需要我们的开发者平台提供什么

8
00:00:39,973 --> 00:00:43,477
你们作为开发者所做的工作太了不起了

9
00:00:43,510 --> 00:00:48,015
你们将奇思妙想变成现实

10
00:00:48,048 --> 00:00:51,585
将用户体验推向新高度

11
00:00:51,618 --> 00:00:55,455
而我们想帮助大家
让你们的想法走得更远

12
00:00:55,489 --> 00:00:58,592
我们已经在 Keynote 主题演讲中涵盖了

13
00:00:58,625 --> 00:01:02,296
iPhone、iPad、Mac、Apple Watch
和 Apple TV 上的一些新功能

14
00:01:02,329 --> 00:01:05,265
还有 Apple 芯片令人难以置信的强大性能

15
00:01:05,299 --> 00:01:09,069
助力大家把最有雄心的想法变为现实

16
00:01:09,102 --> 00:01:13,240
我们今天要讲的内容很多
首先来讲一些更新

17
00:01:13,273 --> 00:01:17,678
今年早些时候 我们开启了全新的
Apple Developer Center

18
00:01:17,711 --> 00:01:20,981
让大家和 Apple 的工程师和设计师

19
00:01:21,014 --> 00:01:24,484
一起沟通与协作
且就在 Apple Park

20
00:01:24,518 --> 00:01:28,455
去年秋天
有成千上万跟你们一样的开发者在世界各地

21
00:01:28,488 --> 00:01:30,657
参加了我们全新的线上 Tech Talks

22
00:01:30,691 --> 00:01:36,463
我们用 5 种语言在线直播了
来自 11 个国家的数百场现场活动

23
00:01:36,496 --> 00:01:38,899
对我们来说
Tech Talks 系列最棒的地方之一

24
00:01:38,932 --> 00:01:40,300
就是一对一会面

25
00:01:40,334 --> 00:01:43,871
这给我们提供了绝佳的机会
了解大家的工作

26
00:01:43,904 --> 00:01:46,773
分享一些建议和指导

27
00:01:46,807 --> 00:01:49,343
去年秋季我们推出了
Swift Playgrounds 4

28
00:01:49,376 --> 00:01:53,247
让大家有能力可以构建 app
并直接提交至 App Store

29
00:01:53,280 --> 00:01:55,148
还提供了对 SwiftUI 的支持

30
00:01:55,182 --> 00:01:59,653
使其成为用于测试
和 UI 原型设计的绝佳工具

31
00:01:59,686 --> 00:02:02,489
当然还有 Xcode Cloud

32
00:02:02,523 --> 00:02:04,124
我们打造 Xcode Cloud 是为了帮助大家

33
00:02:04,157 --> 00:02:07,294
更快更容易地打造更好的 app

34
00:02:07,327 --> 00:02:09,630
它是一项持续集成与交付服务

35
00:02:09,663 --> 00:02:14,234
且内置于 Xcode 采用云托管

36
00:02:14,268 --> 00:02:18,205
Xcode Cloud 支持所有 Apple 平台的开发

37
00:02:18,238 --> 00:02:21,141
它集成了 TestFlight 和
App Store Connect

38
00:02:21,175 --> 00:02:24,545
以及所有主要基于 Git 的源代码提供程序

39
00:02:24,578 --> 00:02:30,150
它甚至拥有各种 REST API
协助联结开发过程中的其他方面

40
00:02:30,184 --> 00:02:34,121
并保有高度的安全性
来保护着你和你的项目

41
00:02:34,154 --> 00:02:36,523
我非常高兴地宣布

42
00:02:36,557 --> 00:02:41,595
Xcode Cloud 从今天起正式推出

43
00:02:41,628 --> 00:02:43,997
我们认为几乎每个开发团队

44
00:02:44,031 --> 00:02:45,699
都能从 Xcode Cloud 获益

45
00:02:45,732 --> 00:02:49,937
因此我们将其定价置在
所有规模的开发者都可以使用的水平

46
00:02:49,970 --> 00:02:53,340
我们将提供每月 25 小时的订阅

47
00:02:53,373 --> 00:02:56,610
给所有 Apple Developer
Program 用户免费使用

48
00:02:56,643 --> 00:02:59,179
持续到 2023 年底

49
00:02:59,213 --> 00:03:04,885
大家还可以从 Developer app 中
订阅任意一级 Xcode Cloud 服务

50
00:03:04,918 --> 00:03:06,353
今夏晚些时候推出

51
00:03:06,386 --> 00:03:10,791
今天 我们要来谈三大主题

52
00:03:10,824 --> 00:03:15,829
首先 我们想分享一下
我们对 Apple 平台开发的愿景

53
00:03:15,863 --> 00:03:19,666
我们平台目前现状
以及我们未来前进的方向

54
00:03:19,700 --> 00:03:22,135
然后 我们会分享一些激动人心的新方式

55
00:03:22,169 --> 00:03:26,507
让你开发的各种 app 与 Apple 平台的系统体验
相互整合

56
00:03:26,540 --> 00:03:30,310
最后 我们要讨论各种强大的全新 API

57
00:03:30,344 --> 00:03:34,882
并向大家展示它们可以如何
帮助你的 app 实现更强大的功能

58
00:03:34,915 --> 00:03:37,851
首先看看我们对开发者平台的愿景

59
00:03:37,885 --> 00:03:39,419
以及它是如何持续进化的

60
00:03:39,453 --> 00:03:42,456
下面请 Josh 为你介绍

61
00:03:43,323 --> 00:03:46,560
优秀的开发者平台可以提供

62
00:03:46,593 --> 00:03:49,696
不同编程语言、框架和工具间的深度整合

63
00:03:49,730 --> 00:03:52,232
当三者完全相辅相成时

64
00:03:52,266 --> 00:03:54,868
我们就可以确保
常见的任务可以轻松完成

65
00:03:54,902 --> 00:03:57,137
并且将实现不常见的任务也变为可能

66
00:03:57,738 --> 00:04:01,175
把这点做好
可以缩短开发一款优质 app 要走的路

67
00:04:01,208 --> 00:04:03,210
并造福所有人

68
00:04:03,243 --> 00:04:05,946
用户可以获得一致的体验

69
00:04:05,979 --> 00:04:08,715
就像总是感觉到顺滑的滚动浏览

70
00:04:08,749 --> 00:04:13,420
而你也可以把时间和精力
专注在构建你的 app 与众不同的地方

71
00:04:13,453 --> 00:04:16,456
随着设计的演变
以及硬件的持续发展

72
00:04:16,490 --> 00:04:20,360
过去的前沿技术在今天变成了基础

73
00:04:20,394 --> 00:04:23,864
Objective-C 语言
AppKit 和 UIKit 框架

74
00:04:23,897 --> 00:04:27,801
以及 Interface Builder
已经赋能多代开发者

75
00:04:27,835 --> 00:04:30,370
这些技术是为彼此而构建的

76
00:04:30,404 --> 00:04:33,707
并将在未来很长的一段时间内
继续为我们提供良好的服务

77
00:04:33,740 --> 00:04:37,411
但随着时间推移
新的抽象成为了必要

78
00:04:37,444 --> 00:04:40,581
过去一段时间
大家已经看到我们在很努力地定义

79
00:04:40,614 --> 00:04:44,985
下一代紧密集成的语言、框架和工具

80
00:04:45,018 --> 00:04:48,889
这就是 Swift、SwiftUI 和
Xcode Previews

81
00:04:49,857 --> 00:04:52,459
在这样的开发平台上紧密集成

82
00:04:52,492 --> 00:04:56,363
需要这三部分一同设计和演变

83
00:04:56,396 --> 00:04:59,466
并相互驱动、带动

84
00:04:59,499 --> 00:05:04,771
Swift Result Builder 的灵感
来自于 SwiftUI 的组成结构

85
00:05:04,805 --> 00:05:09,910
SwiftUI 的声明式视图
背靠 Swift 值类型

86
00:05:09,943 --> 00:05:15,716
而 Xcode Previews 是专门为这两者而设计
也是依靠这两者运行的

87
00:05:15,749 --> 00:05:19,920
他们之间相辅相成
带来了我们迄今最优秀的开发平台

88
00:05:19,953 --> 00:05:25,425
今年 Swift、SwiftUI 和 Xcode
都有精彩的更新

89
00:05:25,459 --> 00:05:27,461
进一步实现我们的愿景

90
00:05:27,494 --> 00:05:31,765
让大家更容易地开发出色的 app
并适用于我们所有的软件平台

91
00:05:31,798 --> 00:05:33,934
而这一切都要从 Swift 开始

92
00:05:33,967 --> 00:05:37,738
现在请 Swift 团队的 Ben 为大家介绍

93
00:05:39,907 --> 00:05:47,915
♪ ♪

94
00:05:49,650 --> 00:05:52,920
Swift 具备了快速、现代与安全的特性

95
00:05:52,953 --> 00:05:55,956
它结合了强类型语言的速度

96
00:05:55,989 --> 00:05:58,992
以及易于阅读和编写的表达式语法

97
00:05:59,026 --> 00:06:02,963
它的设计消除了多种类别的编程错误

98
00:06:02,996 --> 00:06:07,067
Swift 绝对是在我们各个设备上
开发 app 的最佳语言

99
00:06:07,901 --> 00:06:09,536
Swift 以开源形式在 Swift.org 上开发而成

100
00:06:09,570 --> 00:06:13,407
Swift.org 上有很棒的贡献者

101
00:06:13,440 --> 00:06:15,209
他们通过 Diversity in Swift

102
00:06:15,242 --> 00:06:18,212
和 Swift Mentorship Program
等倡议互相支持

103
00:06:18,245 --> 00:06:21,515
并推动 Swift 的发展
通过相关主题工作小组

104
00:06:21,548 --> 00:06:24,384
如 Swift on Server
和 C++ 互操作性等

105
00:06:25,352 --> 00:06:27,921
在过去一年 Swift 变得更加优秀

106
00:06:27,955 --> 00:06:30,224
包括增强了并发功能

107
00:06:30,257 --> 00:06:33,260
还推出了让 Swift 更易于读写的升级

108
00:06:33,293 --> 00:06:35,329
帮你定制工作流的工具

109
00:06:35,362 --> 00:06:37,931
以及惊人的后台性能提升

110
00:06:37,965 --> 00:06:39,466
这一切始于去年

111
00:06:39,499 --> 00:06:41,535
我们推出 Swift 并发功能的时候

112
00:06:42,169 --> 00:06:47,307
Swift 并发功能
极大地简化了并行运行代码的读写

113
00:06:47,341 --> 00:06:50,777
仅第一年就在 App Store 中获得
超过 40000 个 app 采用

114
00:06:50,811 --> 00:06:52,779
这可说是一项巨大的成就

115
00:06:53,247 --> 00:06:57,918
因为这对你的 app 代码库来说
是一项根本且重要的提升

116
00:06:57,951 --> 00:07:00,420
所以现在可以将具有 Swift 并发的代码

117
00:07:00,454 --> 00:07:04,424
部署到过去三年内发布的
所有操作系统上

118
00:07:04,458 --> 00:07:08,529
Swift 并发功能还带来了异步序列

119
00:07:08,562 --> 00:07:11,231
今年更为大家带来了全新的开源包

120
00:07:11,265 --> 00:07:15,569
将为 Swift 丰富的现有序列算法
带来并发支持

121
00:07:15,602 --> 00:07:17,938
这称为异步算法

122
00:07:17,971 --> 00:07:23,410
例如 Swift 的序列协议支持 zip 算法
可将两个序列组合在一起

123
00:07:23,443 --> 00:07:28,081
而异步算法则可以
将两个异步序列组合在一起

124
00:07:28,115 --> 00:07:31,885
因为异步序列是直接集成在 Swift 语言中

125
00:07:31,919 --> 00:07:34,755
所以它们使用的是如“for”循环
为大家所熟悉的结构

126
00:07:34,788 --> 00:07:36,823
而由于有 async/await 语法

127
00:07:36,857 --> 00:07:38,825
这看起来就像普通的直线代码

128
00:07:38,859 --> 00:07:42,496
你还可以使用熟悉的 try/catch 匹配符
处理问题

129
00:07:42,529 --> 00:07:46,633
如网络上异步数据流的网络故障

130
00:07:46,667 --> 00:07:49,369
异步序列的一个关键之处在于

131
00:07:49,403 --> 00:07:52,206
它们是如何随着时间的推移传递数据值

132
00:07:52,739 --> 00:07:57,311
Swift 现在包含一套新的时钟类型
用于表示时间单位

133
00:07:57,344 --> 00:08:01,682
而异步算法则在此基础上
提供多种基于时间的算法

134
00:08:01,715 --> 00:08:03,183
就像这里的 throttle

135
00:08:03,217 --> 00:08:06,787
可以减慢序列的更新

136
00:08:06,820 --> 00:08:11,191
Swift 的并发模型旨在让异步代码

137
00:08:11,225 --> 00:08:13,961
像同步代码一样简便且安全地进行编写

138
00:08:13,994 --> 00:08:16,864
其中很重要的一部分是
Swift 的 actor 模型

139
00:08:16,897 --> 00:08:19,800
actor 让你可以使用线程安全

140
00:08:19,833 --> 00:08:23,337
并发执行的代码隔离数据

141
00:08:23,370 --> 00:08:27,741
Swift 可防止你意外于并行线程之间分享该状态

142
00:08:27,774 --> 00:08:30,310
定义一个主要的错误来源

143
00:08:31,211 --> 00:08:35,649
通过 async/await 即可简单高效地
在不同 actors 之间传递信息

144
00:08:35,682 --> 00:08:39,453
现在 Swift 通过
distributed actors

145
00:08:39,486 --> 00:08:41,221
让 actor 隔离更进一步

146
00:08:41,255 --> 00:08:45,859
distributed actors 可在多个进程
或设备间通信

147
00:08:45,893 --> 00:08:48,929
用“distributed”关键词标记

148
00:08:48,962 --> 00:08:51,431
那些可以远程访问的 actors 和方法

149
00:08:51,465 --> 00:08:54,535
无论是在你 Mac 上的独立进程之间

150
00:08:54,568 --> 00:08:56,904
还是不同设备间的点对点通信

151
00:08:56,937 --> 00:09:00,541
亦或者是从一个设备
与你用 Swift on Server 编写的后端对话

152
00:09:01,909 --> 00:09:06,079
就像 actor 可以帮助 Swift
按照指定顺序访问你的数据来访问它们

153
00:09:06,113 --> 00:09:09,349
distributed actors
使用一种可插拔运输机制

154
00:09:09,383 --> 00:09:12,553
帮助 Swift 让数据在跨进程的场景可用

155
00:09:12,819 --> 00:09:15,622
Swift 编译器随后可以执行检查

156
00:09:15,656 --> 00:09:19,159
确保 distributed 环境中的行为是正确的

157
00:09:19,193 --> 00:09:22,863
让你可以继续开发你想要的功能

158
00:09:23,297 --> 00:09:26,400
distributed actors
和其他并发功能显示出

159
00:09:26,433 --> 00:09:29,870
Swift 代码的读写可以多么容易

160
00:09:29,903 --> 00:09:33,106
当增强功能被深度整合在语法中时

161
00:09:33,140 --> 00:09:38,645
下面由 Ken 来给大家介绍
Swift 易用性的增强

162
00:09:38,679 --> 00:09:42,316
字符串是任何编程语言中
最重要的功能之一

163
00:09:42,349 --> 00:09:45,652
但处理字符串可能会
常常让人感到沮丧

164
00:09:46,453 --> 00:09:48,322
在开发者的工作中

165
00:09:48,355 --> 00:09:53,260
可能会碰到需要从类似这样的字符串中
提取信息的时候

166
00:09:53,293 --> 00:09:56,797
编写解析字符串的代码很容易出错

167
00:09:56,830 --> 00:09:58,799
需要追踪很多细节

168
00:09:58,832 --> 00:10:01,935
而且最后生成的代码
很难读懂及修改

169
00:10:02,803 --> 00:10:06,473
正则表达式是应对这一挑战的
强大解决方式

170
00:10:06,507 --> 00:10:09,810
让你可以描述你期望在字符串中
看到的匹配符

171
00:10:09,843 --> 00:10:13,914
并说明你想抓取哪些信息

172
00:10:13,947 --> 00:10:20,387
今年 Swift 将大幅提升
有关正则表达式的开发者体验

173
00:10:20,420 --> 00:10:23,390
首先是推出一个
全新的正则表达式字面值

174
00:10:24,558 --> 00:10:26,393
它们直接内置于语言当中

175
00:10:26,426 --> 00:10:28,862
Swift 编译器可以检查其是否正确

176
00:10:28,896 --> 00:10:31,665
在你用正则表达式提取信息时

177
00:10:31,698 --> 00:10:34,134
它们会解锁 Swift 类型系统的力量

178
00:10:34,168 --> 00:10:39,206
并且它们充分利用了 Swift
一流的 Unicode 支持

179
00:10:39,239 --> 00:10:40,908
我们一起来看一看

180
00:10:40,941 --> 00:10:42,609
我在开发一款叫 Food Truck 的 app

181
00:10:42,643 --> 00:10:46,413
它可以管理从接单到追踪销售的所有环节

182
00:10:46,446 --> 00:10:49,383
有些订单是以字符串的形式出现的
充满了数据

183
00:10:49,416 --> 00:10:53,120
正则表达式特别适合
从中提取我想要的信息

184
00:10:53,153 --> 00:10:56,857
而在 Playground 中进行实验
再合适不过了

185
00:10:56,890 --> 00:10:58,926
我先创建一个正则表达式字面值

186
00:11:00,227 --> 00:11:02,229
现在输入表达式

187
00:11:02,262 --> 00:11:04,298
提取下单人信息

188
00:11:04,331 --> 00:11:05,866
甜甜圈类型

189
00:11:05,899 --> 00:11:07,968
以及甜甜圈数量

190
00:11:08,001 --> 00:11:10,771
在我输入时
正则表达式被语法高亮显示

191
00:11:10,804 --> 00:11:14,041
这有助于我确认表达式是正确的

192
00:11:14,074 --> 00:11:14,942
现在我来试试看

193
00:11:16,109 --> 00:11:17,978
使用上面的订单字符串

194
00:11:18,011 --> 00:11:20,347
并寻找正则表达式的第一个匹配项

195
00:11:21,481 --> 00:11:24,318
当我运行 Playground 时
就可以通过内联结果

196
00:11:24,351 --> 00:11:28,288
看到正则表达式具体匹配到了
字符串的哪些部分

197
00:11:28,322 --> 00:11:31,258
这里它就找到了我想要的信息

198
00:11:31,291 --> 00:11:34,661
Swift 的全新正则表达式支持
并不止这些

199
00:11:34,695 --> 00:11:36,396
随着字面值变得越来越复杂

200
00:11:36,430 --> 00:11:39,633
就像这里
它匹配的是日志文件的一部分

201
00:11:39,666 --> 00:11:43,670
Swift 提供了一种更好的方式
来处理这些匹配符

202
00:11:43,704 --> 00:11:45,305
即正则表达式生成器

203
00:11:46,773 --> 00:11:49,576
可以很容易地用它把字面值转换为生成器

204
00:11:50,377 --> 00:11:52,179
现在我得到了代码

205
00:11:52,212 --> 00:11:55,616
这些代码更易读懂和修改

206
00:11:55,649 --> 00:11:58,418
我甚至还可以进一步简化它

207
00:11:58,452 --> 00:12:00,854
这里我在找的是一个十六进制的数字

208
00:12:00,888 --> 00:12:03,390
我可以用新的
hexDigitCharacterClass

209
00:12:03,423 --> 00:12:06,493
让我的意图更加明确

210
00:12:06,527 --> 00:12:11,865
这个生成器语法让我可以
轻松创建和扩展表达式

211
00:12:11,899 --> 00:12:14,601
得到我想要的结果

212
00:12:15,102 --> 00:12:19,606
这就是强大的 Swift 中
正则表达式所带来的全新开发者体验

213
00:12:20,174 --> 00:12:21,742
除了字符串语法

214
00:12:21,775 --> 00:12:27,614
Swift 也在透过对泛型语言特性的改进
使其变得更加易于读写

215
00:12:27,915 --> 00:12:30,984
泛型为你每天使用的 Swift 功能提供支持

216
00:12:31,018 --> 00:12:32,152
比如数组类型

217
00:12:32,186 --> 00:12:35,789
它可以容纳任何类型的元素
从字符串到你自定义的类型

218
00:12:35,822 --> 00:12:42,563
泛型代码使用占位符的概念来代替另一种类型
可待之后再确定

219
00:12:42,596 --> 00:12:45,432
通过清除对类型的假设

220
00:12:45,465 --> 00:12:48,068
你可以更清楚地表达代码的意图

221
00:12:48,101 --> 00:12:50,604
并使其容易重复使用

222
00:12:50,637 --> 00:12:53,307
但这也可能使你的代码更难以阅读

223
00:12:53,841 --> 00:12:58,779
举例来说 如果你想以函数参数的形式
处理一个宽泛的歌曲集合

224
00:12:58,812 --> 00:13:02,216
你就需要写出相当多的代码来表达这个意图

225
00:13:03,050 --> 00:13:07,054
如今在 Swift 中
编写接受一些歌曲集合的函数

226
00:13:07,087 --> 00:13:12,025
就像使用关键词 some
告诉 Swift 参数是什么一样简单

227
00:13:12,059 --> 00:13:15,562
可以用更少的代码表达同样的意思

228
00:13:15,596 --> 00:13:19,166
在其它情况下
你可能需要更多的动态行为

229
00:13:19,199 --> 00:13:22,202
比如这个音乐库的播放列表阵列

230
00:13:22,236 --> 00:13:25,739
它可能需要包含不同类型的歌曲集合

231
00:13:25,772 --> 00:13:28,509
譬如说歌曲集或歌曲阵列

232
00:13:28,542 --> 00:13:31,278
新的关键词 any
就可以在这种情况下帮上大忙了

233
00:13:31,311 --> 00:13:33,547
关键词 any 内置于 Swift 当中

234
00:13:33,580 --> 00:13:38,018
让你可以表达
一个可以容纳任何歌曲集合的类型

235
00:13:38,051 --> 00:13:41,355
它也与通用函数无缝衔接

236
00:13:41,388 --> 00:13:45,325
透过采用熟悉的语法和更自然的关键词

237
00:13:45,359 --> 00:13:48,662
使用 Swift 编写泛型代码将更加轻而易举

238
00:13:48,695 --> 00:13:52,466
与 Swift 语言内置功能同等重要的

239
00:13:52,499 --> 00:13:54,868
就是为它而构建的相关工具了

240
00:13:54,902 --> 00:13:58,772
Swift Package Manager
让你可以轻松处理 app 的依赖项

241
00:13:58,805 --> 00:14:01,074
并可利用来自世界各地开发者

242
00:14:01,108 --> 00:14:03,710
所发布的优秀软件包

243
00:14:03,744 --> 00:14:07,948
迄今为止 这些开发者们
已经发布了数以千计的 Swift 软件包

244
00:14:07,981 --> 00:14:11,652
提供代码来解决从验证到网络服务
再到数据管理

245
00:14:11,685 --> 00:14:14,955
专业图形和可重复使用的 UI 组件
各种疑难杂症

246
00:14:14,988 --> 00:14:17,457
今年 Swift Package Manager

247
00:14:17,491 --> 00:14:22,896
将新增全新的 Package Plugins
来扩充你创建和构建代码的方式

248
00:14:22,930 --> 00:14:26,400
Plugins 是可以如同任何其他依赖项

249
00:14:26,433 --> 00:14:28,902
轻易地添加进项目的 Swift 软件包

250
00:14:28,936 --> 00:14:32,339
它们在运行新的 checkout 时
自动下载并构建

251
00:14:32,372 --> 00:14:35,008
不过它们不是你 app 中的代码

252
00:14:35,042 --> 00:14:36,743
而是帮助你构建 app 的代码

253
00:14:37,678 --> 00:14:41,281
Package Plugins 可从命令行
或 Xcode 中调用

254
00:14:41,315 --> 00:14:44,585
可以是构建阶段的一部分
也可按需调用

255
00:14:44,618 --> 00:14:46,653
它们在沙盒环境中运行

256
00:14:46,687 --> 00:14:50,157
在读取或修改代码前会请求你的许可

257
00:14:50,858 --> 00:14:54,428
使用 Package Plugins 扩展你的工作流
将可拥有无限的可能性

258
00:14:54,461 --> 00:14:57,064
你可以用它们检查和格式化你的代码

259
00:14:57,097 --> 00:14:58,498
并使用像 SwiftLint 和 SwiftFormat
这样的软件包

260
00:14:58,532 --> 00:15:00,901
来确保你的代码符合团队的风格指南

261
00:15:00,934 --> 00:15:04,938
或者用 Sourcery 等工具在构建时
自动生成源代码

262
00:15:04,972 --> 00:15:07,174
或者做任何其他有助于你完成工作的事

263
00:15:07,808 --> 00:15:10,677
Package Plugins 可以
很好地扩展 Xcode

264
00:15:10,711 --> 00:15:12,913
仅需写一点 Swift 代码

265
00:15:12,946 --> 00:15:14,548
你可以透过以下两种方式来实现

266
00:15:14,581 --> 00:15:17,484
有按需使用的命令插件

267
00:15:17,518 --> 00:15:20,654
还有构建插件
供你随时需进行项目构建时使用

268
00:15:20,687 --> 00:15:22,689
回到我们的 Food Truck app

269
00:15:22,723 --> 00:15:24,992
这里是我创建的一个命令插件的代码

270
00:15:26,627 --> 00:15:29,897
我的团队对代码有种独特的审美

271
00:15:29,930 --> 00:15:32,733
我们喜欢让导入的语句按字符串长度排序

272
00:15:32,766 --> 00:15:34,768
由短到长

273
00:15:34,801 --> 00:15:38,639
由于 Package Plugins
就是用于定制和控制的

274
00:15:38,672 --> 00:15:42,075
我们创建了一个命令插件
采用 SwiftFormat 来处理这个需求

275
00:15:43,110 --> 00:15:45,812
它可以找到所有本地修改的文件

276
00:15:45,846 --> 00:15:48,148
然后对导入进行排序

277
00:15:48,182 --> 00:15:52,252
这是一个我正在编辑的文件
最上面的导入是尚未排序的

278
00:15:52,286 --> 00:15:54,988
我在整个项目中运行命令插件

279
00:15:55,022 --> 00:15:58,525
我可以选择任何数量的运行目标
这里我就在全部目标上运行

280
00:15:59,059 --> 00:16:01,295
如果我愿意
甚至还可以审查命令插件的代码

281
00:16:01,328 --> 00:16:02,796
我准备好了
直接来运行这个命令

282
00:16:03,564 --> 00:16:06,466
就这么简单
插件就会在我的文件上运行

283
00:16:07,100 --> 00:16:10,070
它找到了所有本地修改的文件

284
00:16:10,103 --> 00:16:12,506
然后以长度排序

285
00:16:12,539 --> 00:16:15,542
使用插件 能做的可不止是格式化

286
00:16:15,576 --> 00:16:18,412
你可以生成源代码、使用 git

287
00:16:18,445 --> 00:16:21,648
甚至是使用自己的自定义错误和警告提示

288
00:16:21,682 --> 00:16:25,052
我还有另一个插件
可以确保把我的代码很好被记录管理

289
00:16:25,085 --> 00:16:29,122
这是一个构建插件
基于开源的 SwiftLint 软件包

290
00:16:29,890 --> 00:16:33,727
所以当我在构建的时候
就可以轻松看到代码中

291
00:16:33,760 --> 00:16:36,196
所有需要添加文档的地方

292
00:16:36,230 --> 00:16:40,000
而且构建插件将一直延伸到 Xcode Cloud

293
00:16:40,033 --> 00:16:42,503
可以作为每个构建的一部分运行

294
00:16:42,536 --> 00:16:44,271
有了 Swift Package Plugins

295
00:16:44,304 --> 00:16:46,607
我和我的团队可以在本地和 Xcode Cloud

296
00:16:46,640 --> 00:16:49,576
创建我们的命令 以及自定义我们的构建

297
00:16:49,610 --> 00:16:51,945
并与他人分享这些插件

298
00:16:51,979 --> 00:16:55,182
这仅需透过几行强大的 Swift 代码即可完成

299
00:16:55,215 --> 00:16:57,618
这就是 Package Plugins 的简要介绍

300
00:16:57,651 --> 00:17:00,220
它有各种方式来大幅提升你的开发工作流

301
00:17:00,254 --> 00:17:04,324
最后 Swift 还迎来了一些惊人的后台改进

302
00:17:04,358 --> 00:17:06,293
现在能以前所未有的速度构建 Swift 项目

303
00:17:06,326 --> 00:17:10,864
依靠新的并行化大幅提升链接时间可快达两倍

304
00:17:10,898 --> 00:17:12,733
并且 Swift 并发运行时间

305
00:17:12,766 --> 00:17:15,502
现在更紧密地与软件系统整合

306
00:17:15,536 --> 00:17:18,672
更好地确保异步任务的优先级

307
00:17:18,705 --> 00:17:21,175
帮助你的 app 保持高效和及时响应

308
00:17:21,208 --> 00:17:26,413
最后 用 Swift 编写的 app
在 iOS 16 上启动时间大大缩短

309
00:17:26,446 --> 00:17:30,918
像是 Lyft 和 Airbnb 等 app 的启动速度提升
可仅为过去的一半

310
00:17:30,951 --> 00:17:33,053
这得益于动态链接器的改进

311
00:17:33,086 --> 00:17:35,055
有了这些后台的提升

312
00:17:35,088 --> 00:17:36,723
工具的新能力

313
00:17:36,757 --> 00:17:39,760
更加易于读写的演进版语法

314
00:17:39,793 --> 00:17:41,628
以及对并发功能的改进

315
00:17:41,662 --> 00:17:44,665
现在正是用 Swift 开发的最佳时机

316
00:17:44,698 --> 00:17:49,636
Swift 绝对是最佳语言用来
开发跨我们所有设备的 app

317
00:17:49,670 --> 00:17:53,473
但语言只是你构建优质 app 所需的一部分

318
00:17:53,507 --> 00:17:57,477
你必须把语言和强大的
用户界面框架搭配起来

319
00:17:57,511 --> 00:17:59,646
下面由 Eliza 来给大家进一步说明

320
00:17:59,680 --> 00:18:02,649
强大的 UI 框架可以提供抽象

321
00:18:02,683 --> 00:18:05,152
让你更轻松地描述界面

322
00:18:05,185 --> 00:18:08,188
填充数据 以及保持更新

323
00:18:08,222 --> 00:18:10,490
它应该具有很好的扩展性
适用于不同的复杂环境

324
00:18:10,524 --> 00:18:13,060
而且 它应该是为你的目标平台设计的

325
00:18:13,093 --> 00:18:15,829
让你可以充分利用设备的能力

326
00:18:15,863 --> 00:18:20,868
UI 框架应该助你一臂之力
使你的 app 感到亲切且直观

327
00:18:20,901 --> 00:18:23,704
它应该让你可以轻松创建标准控制件

328
00:18:23,737 --> 00:18:25,472
和本地交互匹配模式

329
00:18:25,506 --> 00:18:28,075
并支持高级定制功能

330
00:18:28,108 --> 00:18:30,477
它还需要有富有表现力的 API

331
00:18:30,511 --> 00:18:33,413
让你可以快速建立你的想法的原型

332
00:18:33,447 --> 00:18:35,849
并在一系列设备上看到结果

333
00:18:36,416 --> 00:18:38,986
SwiftUI 就可以提供这一切 且不止于此

334
00:18:39,019 --> 00:18:42,456
与 Swift 一样  SwiftUI 的设计旨在

335
00:18:42,489 --> 00:18:44,491
提供开发 app 的最佳方式

336
00:18:44,525 --> 00:18:48,295
它采用声明式语法 易于读写

337
00:18:48,328 --> 00:18:52,766
你只需描述界面的样子 而不是如何构建界面

338
00:18:53,767 --> 00:18:56,336
而这就是 SwiftUI 可发挥的空间

339
00:18:56,370 --> 00:18:59,439
为每个平台提供智能默认值

340
00:18:59,473 --> 00:19:02,776
SwiftUI 会自动保持界面的更新

341
00:19:02,809 --> 00:19:05,412
确保界面随底层数据模型的改动而变化

342
00:19:05,445 --> 00:19:08,749
因此你的 app 的 UI
永远不会陷入不一致的状态

343
00:19:09,583 --> 00:19:13,153
SwiftUI 为你处理所有这些细节

344
00:19:13,187 --> 00:19:17,224
这样你就可以把时间和精力专注在
构建你的 app 与众不同的地方

345
00:19:17,257 --> 00:19:20,861
编写新的 UI 框架是一项巨大的工程

346
00:19:20,894 --> 00:19:25,432
自从推出 SwiftUI 以来
我们持续扩大 SwiftUI 的 API 类型

347
00:19:25,465 --> 00:19:27,000
且都是基于大家的反馈

348
00:19:27,668 --> 00:19:33,006
今年 我们将让你在现有的各种 app 中
逐步采用 SwiftUI 变得更容易

349
00:19:33,040 --> 00:19:37,211
同时我们还对它的性能和灵活性
带来可观的提升

350
00:19:37,244 --> 00:19:39,613
首先是 app 导航

351
00:19:39,646 --> 00:19:41,949
一直以来 使用 SwiftUI

352
00:19:41,982 --> 00:19:46,286
即可轻松创建许多 app 中
常见的导航层次结构

353
00:19:46,320 --> 00:19:49,523
SwiftUI 在今年将会扩展这方面的支持

354
00:19:49,556 --> 00:19:52,125
推出全新的导航 API

355
00:19:52,693 --> 00:19:56,730
新的导航 API 可以让你更容易地创建

356
00:19:56,763 --> 00:19:59,466
最适合你 app 需求的导航风格

357
00:19:59,499 --> 00:20:03,604
通过对 app 视图呈现的强大编程控制

358
00:20:03,637 --> 00:20:06,373
你可以轻松保存或选择恢复

359
00:20:06,406 --> 00:20:10,177
甚至替换导航栏的全部内容

360
00:20:10,210 --> 00:20:13,313
这在处理重要行为时十分有用

361
00:20:13,347 --> 00:20:15,549
如设置 app 的启动状态

362
00:20:15,582 --> 00:20:18,385
管理尺寸类别间的过渡

363
00:20:18,418 --> 00:20:20,053
以及对深度链接的响应

364
00:20:20,988 --> 00:20:23,724
SwiftUI 的另一项巨大改进

365
00:20:23,757 --> 00:20:26,927
是可以让你更好地控制 app 界面的布局

366
00:20:27,661 --> 00:20:31,899
许多 app 的界面可以用 SwiftUI 的

367
00:20:31,932 --> 00:20:34,701
水平或垂直元素堆栈模型来描述

368
00:20:34,735 --> 00:20:37,404
虽然这个模型可以处理很多常见布局

369
00:20:37,437 --> 00:20:40,174
但有时你需要更加灵活的工具

370
00:20:40,207 --> 00:20:43,076
今年 我们将加入全新的 grid API

371
00:20:43,110 --> 00:20:48,415
让你轻松设置多行与多列排列的网格布局

372
00:20:48,448 --> 00:20:50,951
透过全新的自定义布局 API

373
00:20:50,984 --> 00:20:53,987
将可让你的布局更上层楼

374
00:20:54,021 --> 00:20:56,990
自定义布局 API 带来了灵活性

375
00:20:57,024 --> 00:20:59,593
让你可以随心所欲设置你想要的布局

376
00:20:59,626 --> 00:21:01,862
例如 你可以创建流动式布局

377
00:21:01,895 --> 00:21:05,299
让视图像报纸内容一样排列

378
00:21:05,332 --> 00:21:08,402
当需要更多空间时
将内容自动延伸至下一栏

379
00:21:08,435 --> 00:21:12,406
或者你可以创建放射式布局
把视图做成圆环

380
00:21:12,439 --> 00:21:13,941
就像手表表盘的数字一样

381
00:21:14,675 --> 00:21:19,379
自定义布局 API 让你可以
轻松重复使用你的布局逻辑

382
00:21:19,413 --> 00:21:22,182
使你的视图代码更简单 更易读

383
00:21:22,216 --> 00:21:25,185
SwiftUI 还在不断发展

384
00:21:25,219 --> 00:21:27,521
为你提供更多类型的界面元素

385
00:21:27,554 --> 00:21:30,591
比如通过半屏表单来展示二级页面

386
00:21:30,624 --> 00:21:32,593
并可以上下滑动

387
00:21:32,626 --> 00:21:37,397
有助于在较小的屏幕快速获取信息

388
00:21:37,431 --> 00:21:39,933
例如 SwiftUI 现在支持共享表单

389
00:21:39,967 --> 00:21:41,668
让你的 app 可以轻松利用

390
00:21:41,702 --> 00:21:44,838
用户设备上的所有共享扩展

391
00:21:44,872 --> 00:21:49,009
全新的 Transferable 协议支持共享表单

392
00:21:49,042 --> 00:21:52,746
并为传输 app 数据引入了一个安全类型的 API

393
00:21:53,747 --> 00:21:58,485
为了让你更轻松地在现有 app 中
逐步采用 SwiftUI

394
00:21:58,519 --> 00:22:03,390
我们还推出了一个可以托管 SwiftUI 视图的
特殊集合视图单元格

395
00:22:03,423 --> 00:22:06,493
如果你在 UIKit app 中已有一个集合视图

396
00:22:06,527 --> 00:22:10,597
那你现在就可以使用 SwiftUI 的声明式语法
编写自定义单元格

397
00:22:10,631 --> 00:22:15,102
这些单元格与 UIKit 紧密集成
支持轻扫动作

398
00:22:15,135 --> 00:22:19,072
单元格背景
以及 UICollectionView 的其他功能

399
00:22:19,106 --> 00:22:21,942
今天 我们还要推出一个全新的框架

400
00:22:21,975 --> 00:22:23,510
更好地补充 SwiftUI

401
00:22:23,544 --> 00:22:26,880
来让你能够呈现更多的界面

402
00:22:26,914 --> 00:22:28,882
下面请 Jo 给大家介绍

403
00:22:28,916 --> 00:22:31,051
数据在当今的世界随处可见

404
00:22:31,084 --> 00:22:33,287
数据可以帮助我们理解并做出决策

405
00:22:33,320 --> 00:22:34,888
以及发现新的视角

406
00:22:34,922 --> 00:22:37,558
一个精心设计、容易获取的数据可视化呈现

407
00:22:37,591 --> 00:22:39,893
能够以清晰自然的方式

408
00:22:39,927 --> 00:22:42,462
向用户传达复杂的信息

409
00:22:42,496 --> 00:22:44,631
赋能于他们的日常生活

410
00:22:45,465 --> 00:22:48,535
比如帮助显示他们健康的变化趋势

411
00:22:48,569 --> 00:22:51,672
强调他们个人目标的进度

412
00:22:51,705 --> 00:22:53,640
以及协助他们为未来做好准备

413
00:22:54,308 --> 00:22:57,144
今天 我们要推出一个新的框架

414
00:22:57,177 --> 00:23:00,414
帮助你的用户来解读 app 中的数据

415
00:23:00,447 --> 00:23:03,717
这就是 Swift Charts

416
00:23:03,750 --> 00:23:07,187
Swift Charts 是一个可高度自定义的图表框架

417
00:23:07,221 --> 00:23:08,889
它基于 SwiftUI

418
00:23:08,922 --> 00:23:12,626
可以轻松创建精美的可视化图表

419
00:23:12,659 --> 00:23:15,762
它使用与 SwiftUI 相同的声明式语法

420
00:23:15,796 --> 00:23:19,433
可轻松读写传达视觉信息的代码

421
00:23:20,400 --> 00:23:23,170
Swift Charts 让你可以自定义信息的呈现方式

422
00:23:23,203 --> 00:23:25,439
最大程度地符合你 app 的需求

423
00:23:25,472 --> 00:23:28,008
创建各种图表 从线图和柱状图

424
00:23:28,041 --> 00:23:32,279
到更复杂的热力图和流线图

425
00:23:32,312 --> 00:23:34,147
以及很多其他类型的图表

426
00:23:35,182 --> 00:23:38,118
由于 Swift Charts
是在 SwiftUI 的基础上所建立

427
00:23:38,151 --> 00:23:40,654
所以图表提供了非常好的辅助功能支持

428
00:23:40,687 --> 00:23:43,924
例如绝佳的、开箱即用的旁白体验

429
00:23:43,957 --> 00:23:46,059
并可轻松自定义

430
00:23:46,093 --> 00:23:49,997
以 SwiftUI 为基础也意味着
你可以对图表进行动画处理

431
00:23:50,030 --> 00:23:53,367
给 app 提供你想要的外观和感觉

432
00:23:53,400 --> 00:23:57,704
当然 Swift Charts 支持我们所有的设备

433
00:23:57,738 --> 00:23:59,806
回到我们的 Food Truck app

434
00:23:59,840 --> 00:24:01,875
这里就是在全面重新设计过的 Xcode 预览区中

435
00:24:01,909 --> 00:24:05,312
呈现美观的全新 Swift Charts 图表

436
00:24:05,345 --> 00:24:09,349
同时我还用了新的多列 SwiftUI 表格视图

437
00:24:09,383 --> 00:24:12,719
我来给大家展示一下
创建这个图表有多么容易

438
00:24:12,753 --> 00:24:14,087
在我滚动页面时

439
00:24:14,121 --> 00:24:17,357
你可以在源代码编辑器中
看到这个很棒的全新结构化标题

440
00:24:17,391 --> 00:24:20,227
这让我可以很容易看到我正在编辑的地方

441
00:24:21,261 --> 00:24:22,696
这里是图表的代码

442
00:24:22,729 --> 00:24:26,600
这其实是一个堆叠的柱状图
但真的是看不出来差别

443
00:24:26,633 --> 00:24:29,503
我们来给每种甜甜圈一个不同的颜色

444
00:24:30,871 --> 00:24:34,341
如果我们把每种甜甜圈的条柱
并排放在一起

445
00:24:34,374 --> 00:24:36,677
可能会更容易比较各种甜甜圈

446
00:24:37,945 --> 00:24:40,681
我非常喜欢的是 进行这些大的改动

447
00:24:40,714 --> 00:24:43,050
仅需几个简单的 modifier

448
00:24:43,083 --> 00:24:45,552
我们还可以自定义样式

449
00:24:45,586 --> 00:24:48,522
让这些条柱对应甜甜圈的颜色

450
00:24:48,555 --> 00:24:52,125
我们甚至可以用另一个 modifier
给条柱添加注解

451
00:24:53,327 --> 00:24:54,795
看起来很棒

452
00:24:54,828 --> 00:24:56,730
预览现在默认是实时的

453
00:24:56,763 --> 00:24:59,533
所以我可以立即与视图进行互动

454
00:24:59,566 --> 00:25:01,268
我来更改一下排序

455
00:25:01,301 --> 00:25:04,204
看看条柱精美的动画

456
00:25:04,238 --> 00:25:07,074
而所有繁重的工作
都是由 Swift Charts 来完成的

457
00:25:07,107 --> 00:25:08,976
我们来抓取更多数据

458
00:25:09,009 --> 00:25:12,980
图和表都会自动随模型的变化更新

459
00:25:13,013 --> 00:25:17,184
图甚至会重新计算 Y 轴
反映出新的总计值

460
00:25:17,217 --> 00:25:19,019
让我再给大家看一张图

461
00:25:19,052 --> 00:25:22,556
我在这里做了一个线图
我们把它添加到视图里

462
00:25:22,589 --> 00:25:25,025
我直接跳到实施

463
00:25:25,058 --> 00:25:29,096
Swift Charts 的线图有些很酷的选项

464
00:25:29,129 --> 00:25:31,865
我们可以为每种甜甜圈添加符号

465
00:25:31,899 --> 00:25:34,134
可以为线添加注解

466
00:25:34,168 --> 00:25:38,672
甚至可以采用各种差值策略平滑曲线

467
00:25:38,705 --> 00:25:40,941
我们这里用 catmullRom

468
00:25:40,974 --> 00:25:43,443
最后 通过提供我自己的映射

469
00:25:43,477 --> 00:25:45,579
覆盖图表比例样式

470
00:25:45,612 --> 00:25:49,082
这样会使图表与 app 的配色方案更吻合

471
00:25:49,116 --> 00:25:50,584
非常棒

472
00:25:50,617 --> 00:25:53,320
重新设计的预览区使我比以往更容易看到

473
00:25:53,353 --> 00:25:56,056
我的视图在不同环境中的样子

474
00:25:56,089 --> 00:25:58,292
通过点击画布上的按钮

475
00:25:58,325 --> 00:26:01,094
我可以看到深色和浅色模式下的视图

476
00:26:01,128 --> 00:26:04,631
甚至可以看到所有的屏幕方向中的布局

477
00:26:04,665 --> 00:26:07,367
一个额外的预览都不用添加

478
00:26:07,401 --> 00:26:09,870
我们来放大看看横向模式

479
00:26:09,903 --> 00:26:13,040
看起来我的 UI 有点问题

480
00:26:13,073 --> 00:26:14,441
有几个控制按钮在屏幕之外

481
00:26:14,474 --> 00:26:17,578
而且图表的长宽比也很别扭

482
00:26:17,611 --> 00:26:20,881
我们来看看这个布局是在哪里描述的

483
00:26:20,914 --> 00:26:24,218
这里这些视图在一个隐含的 VStack 里

484
00:26:25,352 --> 00:26:28,922
今年 SwiftUI 中有些强大的全新 API

485
00:26:28,956 --> 00:26:31,391
可以创建更多的灵活布局

486
00:26:31,425 --> 00:26:34,027
这里我来用 ViewThatFits

487
00:26:34,061 --> 00:26:36,263
这会根据可用空间

488
00:26:36,296 --> 00:26:39,266
在垂直和水平堆栈之间切换

489
00:26:40,667 --> 00:26:42,302
这样看起来好多了

490
00:26:42,336 --> 00:26:43,670
现在把这个视图连接起来

491
00:26:43,704 --> 00:26:45,639
从主屏幕导航到这里

492
00:26:46,673 --> 00:26:49,810
我用的是 SwiftUI 全新的导航分屏浏览

493
00:26:49,843 --> 00:26:51,612
操作起来非常方便

494
00:26:51,645 --> 00:26:55,082
分屏浏览有一个侧边栏 可以追踪选择

495
00:26:55,115 --> 00:27:00,521
它还有个 NavigationStack
其内容随着侧边栏选择的变化进而调整

496
00:27:00,554 --> 00:27:01,922
我来跳到侧边栏

497
00:27:01,955 --> 00:27:04,992
为我们的甜甜圈冠军视图
添加导航链接

498
00:27:05,025 --> 00:27:07,494
然后 就可以在这个互动预览中试试看

499
00:27:08,262 --> 00:27:10,664
我想在横向模式中看一下分屏浏览

500
00:27:10,697 --> 00:27:12,933
那我就用新的画布设置

501
00:27:12,966 --> 00:27:15,202
来旋转实时预览

502
00:27:15,235 --> 00:27:16,837
很棒

503
00:27:16,870 --> 00:27:19,406
我对它在 iPad 上的效果很满意

504
00:27:19,439 --> 00:27:21,675
但我现在想把它也带到 Mac 上

505
00:27:21,708 --> 00:27:24,978
而这只需点击几下即可做到

506
00:27:25,012 --> 00:27:27,481
我想充分利用 Mac SDK

507
00:27:27,514 --> 00:27:28,949
所以我在这里使用原生

508
00:27:31,218 --> 00:27:33,554
因为我的 app 背后只有一个目标

509
00:27:33,587 --> 00:27:35,589
我可以共用几乎所有的代码

510
00:27:35,622 --> 00:27:39,026
而 SwiftUI 会让我的 app
在每个平台上看起来都很棒

511
00:27:39,059 --> 00:27:42,429
我也可以轻松添加针对不同设备的功能

512
00:27:42,462 --> 00:27:45,299
对 Mac app 我们来添加
一个 menuBarExtra

513
00:27:45,332 --> 00:27:47,267
这就是你屏幕右上角那些

514
00:27:47,301 --> 00:27:49,002
有用的小图标

515
00:27:49,036 --> 00:27:52,072
比如 Wi-Fi 和聚焦

516
00:27:52,105 --> 00:27:55,142
SwiftUI 为此提供了新的 API

517
00:27:55,175 --> 00:27:57,244
我只需把它添加到我 app 的主体

518
00:27:57,277 --> 00:27:59,146
现在我们来为 Mac 运行试试看

519
00:28:02,683 --> 00:28:06,553
我们的甜甜圈冠军视图在 Mac 上
看起来很棒

520
00:28:06,587 --> 00:28:08,589
这里就是那个 menuBarExtra

521
00:28:08,622 --> 00:28:09,990
很方便

522
00:28:10,023 --> 00:28:12,292
这就是对 Swift Charts 的简要介绍

523
00:28:12,326 --> 00:28:15,762
以及 SwiftUI 和 Xcode 即将带来
部分增强功能的说明

524
00:28:15,796 --> 00:28:17,631
现在交回给 Josh

525
00:28:17,664 --> 00:28:20,834
我们正越来越多地使用 SwiftUI

526
00:28:20,868 --> 00:28:23,403
并覆盖了我们的各个 app 和系统界面

527
00:28:23,437 --> 00:28:25,973
例如 iOS 新的锁定屏幕小组件

528
00:28:26,006 --> 00:28:29,243
就是由 SwiftUI 全新设计的

529
00:28:29,276 --> 00:28:32,179
而新的 Font Book app 也是用它
完全重写的

530
00:28:32,212 --> 00:28:36,283
还有看起来很现代、超前的
全新 macOS 系统设置 app

531
00:28:36,316 --> 00:28:37,818
也是用它构建的

532
00:28:37,851 --> 00:28:40,988
Swift 和 SwiftUI 从一开始的设计目的

533
00:28:41,021 --> 00:28:45,759
就是用统一的原生语言和 API
适用于 Apple 的各个平台

534
00:28:45,792 --> 00:28:48,629
只需学习一次 即可用在所有地方

535
00:28:48,662 --> 00:28:51,798
无论你的愿景是在 Apple Watch 上

536
00:28:51,832 --> 00:28:53,834
提供一目了然的快速信息访问

537
00:28:53,867 --> 00:28:57,104
为 MacBook Pro 和 iPad 提供生产力工具

538
00:28:57,137 --> 00:28:59,006
在 iPhone 上提供新的体验

539
00:28:59,039 --> 00:29:01,408
还是为 Apple TV 提供新的放松方式

540
00:29:01,441 --> 00:29:03,911
Swift、SwiftUI 和 Xcode

541
00:29:03,944 --> 00:29:07,614
提供了新一代的整合开发平台

542
00:29:07,648 --> 00:29:10,884
帮你开发的 app 适用于我们所有的产品

543
00:29:10,918 --> 00:29:12,519
如果你先前已开发的 app

544
00:29:12,553 --> 00:29:15,989
同样也可以轻松地逐步采用这些新技术

545
00:29:16,023 --> 00:29:19,526
如果你是我们平台的新手
或者要开始开发新的 app

546
00:29:19,560 --> 00:29:23,664
最好的构建方式就是直接使用
Swift 和 SwiftUI

547
00:29:23,697 --> 00:29:25,899
当然 这只是个开始

548
00:29:25,933 --> 00:29:29,870
我们也在不断改进平台的用户体验

549
00:29:29,903 --> 00:29:32,706
为你们提供更多与用户互动的方式

550
00:29:32,739 --> 00:29:35,075
下面请 Sebastien 给你们来详细介绍

551
00:29:36,376 --> 00:29:38,412
开发 app 就是将各种想法

552
00:29:38,445 --> 00:29:41,148
代码和 API 转变为用户体验

553
00:29:41,181 --> 00:29:42,482
而最好的 app

554
00:29:42,516 --> 00:29:45,752
就是能满足用户当下需求的 app

555
00:29:45,786 --> 00:29:49,456
我们创建了各种方式
让用户体验不仅限于你的 app 里

556
00:29:49,489 --> 00:29:53,126
更整合到不同 Apple 设备的系统体验中

557
00:29:53,927 --> 00:29:57,664
这段旅程从各种扩展方式开始
以及与共享表单的整合

558
00:29:57,698 --> 00:29:59,399
还有自定义键盘

559
00:29:59,433 --> 00:30:02,736
最近 还增加了让你的 app 使用小组件

560
00:30:02,769 --> 00:30:06,039
在主屏幕显示关键信息的能力

561
00:30:06,073 --> 00:30:07,875
今年将有众多新的方式

562
00:30:07,908 --> 00:30:10,978
将你的 app 与我们各平台的系统体验相整合

563
00:30:11,011 --> 00:30:15,482
这要从锁定屏幕开始
锁定屏幕得到了有史以来最大的更新

564
00:30:15,516 --> 00:30:19,019
我们重新设计了锁定屏幕的外观和运作方式

565
00:30:19,052 --> 00:30:23,390
为你的创意和各种 app
提供另一个与用户互动的地方

566
00:30:23,423 --> 00:30:25,792
让 Robert 来给大家介绍详情

567
00:30:34,268 --> 00:30:35,802
重新设计锁定屏幕的目的

568
00:30:35,836 --> 00:30:38,805
是让它更加个性化、更美观

569
00:30:38,839 --> 00:30:40,674
同时提高日常实用性

570
00:30:40,707 --> 00:30:43,443
在这个过程中 我们知道我们需要

571
00:30:43,477 --> 00:30:46,413
把小组件的强大功能 带到全新的锁定屏幕上

572
00:30:46,446 --> 00:30:50,484
小组件带来了出色的方式
突出你 app 里的关键信息

573
00:30:50,517 --> 00:30:53,487
让用户一目了然

574
00:30:53,520 --> 00:30:57,157
它们让用户能够直接从主屏幕轻松获取

575
00:30:57,191 --> 00:30:58,559
丰富、及时的信息

576
00:30:59,226 --> 00:31:02,796
每当举起 iPhone 最先看到的就是锁定屏幕

577
00:31:02,829 --> 00:31:05,432
这里一直是查看日期时间

578
00:31:05,465 --> 00:31:07,334
了解重要信息的地方

579
00:31:07,367 --> 00:31:11,038
在思考如何以最佳的形式
在这里显示更多信息时

580
00:31:11,071 --> 00:31:13,574
我们不用绞尽脑汁去寻找设计灵感

581
00:31:14,208 --> 00:31:18,078
Apple Watch 上的复杂功能已经提供了
一目了然、相关

582
00:31:18,111 --> 00:31:19,546
最即时的信息

583
00:31:19,580 --> 00:31:22,349
并在用户需要时美观呈现这些内容

584
00:31:23,016 --> 00:31:25,719
这种设计语言自然地延伸到 iOS

585
00:31:25,752 --> 00:31:28,622
恰如其分地出现在新的锁定屏幕上

586
00:31:28,655 --> 00:31:31,825
因此 利用 WidgetKit 我们将一些相同的设计

587
00:31:31,859 --> 00:31:34,962
带来锁定屏幕上的小组件 包括 Circular

588
00:31:34,995 --> 00:31:39,666
可以展示一张小图、仪表或几个字符的文字

589
00:31:39,700 --> 00:31:43,370
Circular 小组件非常适合展示出
你今天活动量是否已经足够

590
00:31:43,403 --> 00:31:45,506
还是需要出去跑跑步

591
00:31:45,539 --> 00:31:48,175
Rectangular 提供一个大画布

592
00:31:48,208 --> 00:31:51,578
可显示像天气预报这样的内容

593
00:31:51,612 --> 00:31:54,515
Inline 是一种强大的展示信息的方式

594
00:31:54,548 --> 00:31:58,919
可在 iPhone 的时钟上方
显示少量文本和 SF 符号

595
00:31:58,952 --> 00:32:02,990
旁边是系统提供的日期字符串
如 6 日星期一

596
00:32:03,023 --> 00:32:08,328
对了 所有这些小组件都可在
iOS 和 watchOS 上使用

597
00:32:08,362 --> 00:32:10,330
因为从 watchOS 9 开始

598
00:32:10,364 --> 00:32:13,567
复杂功能也由 WidgetKit 提供支持

599
00:32:13,600 --> 00:32:16,170
这是首次可以在两个平台上

600
00:32:16,203 --> 00:32:20,107
使用相同的代码生成一目了然的数据

601
00:32:20,140 --> 00:32:23,177
WidgetKit 为你自动管理平台差异

602
00:32:23,210 --> 00:32:25,479
默认使用适合的系统字体

603
00:32:25,512 --> 00:32:29,283
并为锁定屏幕上的小组件上色
提供最大的可读性

604
00:32:29,316 --> 00:32:32,786
具体如何使用 WidgetKit 以相同的代码
为 iPhone 锁定屏幕

605
00:32:32,819 --> 00:32:35,589
和 Apple Watch 复杂功能创建小组件

606
00:32:35,622 --> 00:32:37,524
将由 Michael 为大家介绍

607
00:32:39,793 --> 00:32:41,495
无论是在 iPhone 锁定屏幕上创建小组件

608
00:32:41,528 --> 00:32:44,798
还是打造 Apple Watch 上的复杂功能
都可以用 WidgetKit 轻松实现

609
00:32:44,831 --> 00:32:47,401
如果你已经做了主屏幕小组件
那你就已经完成了大部分工作

610
00:32:47,434 --> 00:32:49,870
包括数据和时间线的更新方式

611
00:32:49,903 --> 00:32:52,406
在我们的 Food Truck app 中
我们已经有了 systemSmall 小组件

612
00:32:52,439 --> 00:32:54,107
用户可以添加到主屏幕上

613
00:32:54,141 --> 00:32:56,977
查看他们今天已经完成了多少订单配额

614
00:32:57,010 --> 00:32:59,513
这类信息就非常适合显示在锁定屏幕

615
00:32:59,546 --> 00:33:01,748
或是手表表盘的复杂功能中

616
00:33:01,782 --> 00:33:03,984
我们先来建立 Circular 系列

617
00:33:05,485 --> 00:33:08,255
首先要在 Supported Families 阵列中
声明对它的支持

618
00:33:09,389 --> 00:33:12,025
你可以看到我们在这里用了一些平台条件

619
00:33:12,059 --> 00:33:15,762
这是因为我们希望这个小组件能继续
利用 systemSmall

620
00:33:15,796 --> 00:33:19,366
支持 macOS 和 iOS
但 watchOS 无法使用这个系列

621
00:33:20,200 --> 00:33:22,336
于是我们增加了一个枚举值来定义这个视图

622
00:33:24,004 --> 00:33:28,041
我们使用仪表来显示
从 0 到每日配额的订单量

623
00:33:28,075 --> 00:33:30,844
这样用户就能快速并且一目了然地看到进展

624
00:33:31,678 --> 00:33:34,648
我们在中间以文本形式显示当前订单量

625
00:33:34,681 --> 00:33:37,217
并显示一个甜甜圈符号
好了

626
00:33:37,251 --> 00:33:39,152
我们在 Xcode Previews 中看看效果

627
00:33:40,721 --> 00:33:41,755
很棒

628
00:33:41,788 --> 00:33:42,956
在锁定屏幕上看起来很自然

629
00:33:43,924 --> 00:33:45,826
如果想一目了然地显示更多细节

630
00:33:45,859 --> 00:33:48,328
我们还可以添加对 Rectangular 系列的支持

631
00:33:51,932 --> 00:33:54,735
我们建一个 VStack 来实现这个视图

632
00:33:54,768 --> 00:33:57,104
首先给所展示的数据一个标题

633
00:33:57,137 --> 00:33:58,805
还有同样的甜甜圈符号

634
00:33:59,506 --> 00:34:01,775
将字体设置为标题样式

635
00:34:01,808 --> 00:34:04,278
这样在两个平台上都有很美观的效果

636
00:34:04,311 --> 00:34:07,414
然后用 widgetAccentable
modifier 确保它着重显示

637
00:34:07,447 --> 00:34:10,784
由于 Rectangular 系列提供了更多空间

638
00:34:10,817 --> 00:34:13,554
我们可以显示一个很酷的
自定义分段式仪表

639
00:34:13,587 --> 00:34:18,592
同时让仪表标签显示
当前订单数和每日配额

640
00:34:18,625 --> 00:34:20,160
回到画布

641
00:34:20,194 --> 00:34:22,796
我们也可以在预览中看到
Rectangular 小组件

642
00:34:22,829 --> 00:34:25,132
我真的非常喜欢这个仪表

643
00:34:25,165 --> 00:34:26,934
现在我们来看看这个小组件

644
00:34:26,967 --> 00:34:30,437
在手表表盘以 Circular
复杂功能显示是什么效果

645
00:34:32,573 --> 00:34:34,341
相当好 所有信息都显示了

646
00:34:34,374 --> 00:34:36,844
但对复杂功能来说 我们还需考虑

647
00:34:36,877 --> 00:34:38,145
全彩渲染模式

648
00:34:38,178 --> 00:34:41,248
这是 Xcode Previews 中的默认模式

649
00:34:41,281 --> 00:34:45,419
我们来调整一下
给每个仪表添加一点色调

650
00:34:46,687 --> 00:34:49,756
再给 Rectangular 标题添加一个前景色

651
00:34:51,592 --> 00:34:53,093
要在全彩中强调显示

652
00:34:53,126 --> 00:34:56,697
我们可以用环境属性检查渲染模式

653
00:34:56,730 --> 00:35:00,133
并在 Circular 和
Rectangular 视图中

654
00:35:00,167 --> 00:35:04,872
用甜甜圈表情符号替换甜甜圈符号

655
00:35:04,905 --> 00:35:06,139
看起来很棒

656
00:35:06,173 --> 00:35:08,041
利用预览中的新变体 UI

657
00:35:08,075 --> 00:35:11,078
完全无需创建任何代码
我们可以改变预览颜色

658
00:35:12,179 --> 00:35:14,181
甚至同时预览多个颜色

659
00:35:14,948 --> 00:35:18,018
由于我们使用了默认的间距
系统字体样式

660
00:35:18,051 --> 00:35:19,620
并适应了渲染模式

661
00:35:19,653 --> 00:35:23,123
同样的视图在锁定屏幕和手表表盘上
看起来都相当自然

662
00:35:23,156 --> 00:35:26,793
如刚所示都是使用同样的代码
就可以轻松制作

663
00:35:26,827 --> 00:35:30,564
iOS 16 全新锁定屏幕的小组件
以及 watchOS 9 的复杂功能

664
00:35:30,597 --> 00:35:33,800
但这并不是唯一一种把 WidgetKit 的能力
带到锁定屏幕的方式

665
00:35:33,834 --> 00:35:35,435
下面请 Matt 给大家介绍

666
00:35:36,003 --> 00:35:37,070
利用 WidgetKit

667
00:35:37,104 --> 00:35:39,806
你可以让用户获取一目了然的信息

668
00:35:39,840 --> 00:35:42,309
但他们有时需要实时更新的信息

669
00:35:42,342 --> 00:35:44,945
或是与他们当前关心的活动或事件有关的信息

670
00:35:44,978 --> 00:35:46,446
这时该怎么做呢

671
00:35:46,480 --> 00:35:51,118
为此 我们正在探索一个新的功能
称为实时活动

672
00:35:51,151 --> 00:35:53,320
实时活动让你更容易实时获取

673
00:35:53,353 --> 00:35:55,122
与正在发生的事情相关的信息

674
00:35:55,155 --> 00:35:56,723
直接显示在锁定屏幕上

675
00:35:56,757 --> 00:36:00,027
比如比赛的最新得分

676
00:36:00,060 --> 00:36:03,497
叫车进程或体能训练进度

677
00:36:03,530 --> 00:36:06,066
直接显示在锁定屏幕上并且实时更新

678
00:36:06,099 --> 00:36:09,703
就像小组件一样 你可以用
WidgetKit 创建实时活动

679
00:36:09,736 --> 00:36:12,406
差别在于实时活动所呈现的信息和状态

680
00:36:12,439 --> 00:36:14,208
是实时更新的

681
00:36:14,241 --> 00:36:16,210
由于它们是用 SwiftUI 构建的

682
00:36:16,243 --> 00:36:19,580
你甚至可以将状态间的更新做成动画

683
00:36:19,613 --> 00:36:21,615
这些更新确保你的实时活动

684
00:36:21,648 --> 00:36:25,452
在用户浏览时显示最新的信息

685
00:36:25,485 --> 00:36:30,490
实时活动将于今年晚些时候
在 iOS 16 更新中开始提供

686
00:36:30,524 --> 00:36:32,993
这就是全新锁定屏幕的最新进展

687
00:36:33,026 --> 00:36:34,094
这些超棒的更新

688
00:36:34,127 --> 00:36:38,398
可以让你在用户最需要的时候
为他们提供一目了然的信息

689
00:36:39,132 --> 00:36:42,603
接下来 我们来谈一谈增强协作体验的全新方式

690
00:36:42,636 --> 00:36:44,938
由 Pierre 来给大家介绍

691
00:36:44,972 --> 00:36:46,974
协作同步是非常重要的 无论是在

692
00:36:47,007 --> 00:36:50,511
iOS、iPadOS 还是 macOS 上

693
00:36:50,544 --> 00:36:53,380
这在很大程度上是得益于大量丰富的 app

694
00:36:53,413 --> 00:36:55,015
很多正是由你们来开发的

695
00:36:55,048 --> 00:36:57,885
来支持所有远距离协作的团队们

696
00:36:57,918 --> 00:37:01,588
工作上的协作 例如 Airtable 中的产品路线图

697
00:37:01,622 --> 00:37:06,226
还有娱乐上的协作
例如在 Redfin 上寻找你的梦想家园

698
00:37:06,260 --> 00:37:08,095
无论是工作还是娱乐

699
00:37:08,128 --> 00:37:11,265
协作通常从对话开始

700
00:37:11,298 --> 00:37:13,800
通过全新的 Messages
Collaboration API

701
00:37:13,834 --> 00:37:16,970
你可以把 app 的现有协作体验

702
00:37:17,004 --> 00:37:18,772
融入信息 app 和 FaceTime 通话

703
00:37:18,805 --> 00:37:21,708
当用户在你的 app 中分享内容链接时

704
00:37:21,742 --> 00:37:25,412
这个 API 可以让你更轻松地
将连接标记为协作性的

705
00:37:25,445 --> 00:37:27,514
以实现无缝的体验

706
00:37:27,548 --> 00:37:29,650
我们提供你所需的标识符

707
00:37:29,683 --> 00:37:32,152
这样你可以在接收方轻点链接加入时

708
00:37:32,186 --> 00:37:33,987
立即提供访问权

709
00:37:34,021 --> 00:37:36,924
当然 这都是在不影响隐私的前提下进行的

710
00:37:36,957 --> 00:37:40,994
信息身份和 app 身份将保持私密 不会被分享

711
00:37:41,028 --> 00:37:44,831
最棒的是 你可以用你的 app 很可能已经在用的

712
00:37:44,865 --> 00:37:47,301
现有技术来实现这一点

713
00:37:47,334 --> 00:37:51,471
只需一个对象 用户就可以发起协作

714
00:37:51,505 --> 00:37:54,575
有两种他们已经很熟悉的方式来进行操作

715
00:37:54,608 --> 00:37:57,277
一是共享表单 我们已经提供更新

716
00:37:57,311 --> 00:37:59,446
将协作放在非常重要的位置

717
00:37:59,479 --> 00:38:01,014
二是通过拖放

718
00:38:01,048 --> 00:38:03,750
分享你想协作的内容

719
00:38:03,784 --> 00:38:06,954
仅需直接将内容拖到信息 app 的对话中

720
00:38:06,987 --> 00:38:10,557
一旦协作开始 你甚至可以把内容更新通知

721
00:38:10,591 --> 00:38:14,061
直接发布在信息 app 的对话中

722
00:38:14,094 --> 00:38:17,798
只需几行代码 用户就可以回到
你的 app 中进行协作

723
00:38:17,831 --> 00:38:21,034
仅需在信息 app 中轻点一下

724
00:38:21,068 --> 00:38:22,703
利用协作弹窗

725
00:38:22,736 --> 00:38:27,908
用户可以从你的 app 里
直接回到信息 app 或 FaceTime 通话中

726
00:38:27,941 --> 00:38:29,943
利用 Messages
Collaboration API

727
00:38:29,977 --> 00:38:33,780
你的 app 可以深度整合到信息 app
和 FaceTime 通话的架构中

728
00:38:33,814 --> 00:38:37,684
我们给你的用户提供强大的通信工具

729
00:38:37,718 --> 00:38:40,754
这样你就可以专注于你的 app

730
00:38:40,787 --> 00:38:42,422
提供强大的协作工具

731
00:38:42,456 --> 00:38:46,860
这将提升 iOS、iPadOS
和 macOS 上的协作功能

732
00:38:46,894 --> 00:38:48,695
创造一致的体验

733
00:38:48,729 --> 00:38:52,399
它深深扎根于协作者之间的联系

734
00:38:52,432 --> 00:38:53,934
无论是用于工作还是娱乐

735
00:38:53,967 --> 00:38:56,470
接下来 Ari 将给大家介绍

736
00:38:56,503 --> 00:38:59,072
一个新的框架 App Intents

737
00:38:59,106 --> 00:39:02,609
我非常高兴可以给各位介绍 App Intents 框架

738
00:39:02,643 --> 00:39:05,245
它把你的 app 的功能开放给系统

739
00:39:05,279 --> 00:39:09,183
这样用户就可以通过 Siri 和快捷指令
自动使用这些功能

740
00:39:09,216 --> 00:39:11,552
人们喜欢在使用 app 时使用快捷指令

741
00:39:11,585 --> 00:39:15,022
快捷指令让用户可以快速完成任务
仅需询问 Siri

742
00:39:15,055 --> 00:39:18,325
或快速轻点主屏幕上的快捷指令

743
00:39:18,358 --> 00:39:21,428
让我们惊叹的是用户组合使用 app 的能力

744
00:39:21,461 --> 00:39:25,299
用自定义快捷指令
把它们组合成新的功能

745
00:39:25,332 --> 00:39:29,703
目前 用户必须先手动添加快捷指令
之后才能使用它们

746
00:39:29,736 --> 00:39:34,041
我们在 iOS 16 中将通过新的
App Intents 框架 把这个过程自动化

747
00:39:35,075 --> 00:39:39,112
App Intents 与快捷指令一起
形成 app 快捷指令

748
00:39:39,146 --> 00:39:41,281
供用户直接通过 Siri 使用

749
00:39:41,315 --> 00:39:43,116
无需预先设置

750
00:39:43,150 --> 00:39:46,386
可以说 “嘿 Siri 用 Roomba 打扫厨房”

751
00:39:46,420 --> 00:39:47,988
而且不只是 Siri

752
00:39:48,021 --> 00:39:49,990
app 快捷指令让你的用户

753
00:39:50,023 --> 00:39:52,693
可以在整个系统中使用你的 app 的功能

754
00:39:52,726 --> 00:39:56,330
像是在聚焦中 当用户搜索你的 app 时

755
00:39:56,363 --> 00:39:58,532
你的快捷指令也会显示出来

756
00:39:58,565 --> 00:40:02,302
并且你的快捷指令会被
直接推荐在 app 推荐下面

757
00:40:02,336 --> 00:40:06,306
无需采用任何额外 API 如 donations

758
00:40:06,340 --> 00:40:09,409
你的快捷指令还会立即出现在
快捷指令 app 中

759
00:40:09,443 --> 00:40:11,512
用户可以轻点运行

760
00:40:12,179 --> 00:40:17,584
App Intents 是我们在 iOS 10 中引入的
SiriKit Intents 框架的下一步

761
00:40:17,618 --> 00:40:21,021
如果你用各种 intent
来整合小组件或是 domain

762
00:40:21,054 --> 00:40:22,389
比如媒体或信息

763
00:40:22,422 --> 00:40:25,626
你应该继续使用 SiriKit Intents 框架

764
00:40:25,659 --> 00:40:29,062
但对为 Siri 和快捷指令
构建自定义 intent 的开发者

765
00:40:29,096 --> 00:40:31,298
你应该升级至 App Intents

766
00:40:31,331 --> 00:40:34,501
你可以在 Xcode 中轻松
升级到 App Intents

767
00:40:34,535 --> 00:40:37,804
仅需点击 intent 定
义文件中的 Convert 按钮

768
00:40:37,838 --> 00:40:40,841
Xcode 会生成对等的 App Intents 源代码

769
00:40:40,874 --> 00:40:43,310
然后你用你的 intent 处理代码来填补空白

770
00:40:43,343 --> 00:40:46,580
用 App Intents 进行开发真的非常容易

771
00:40:46,613 --> 00:40:49,716
因为它是为 Swift 特意设计的

772
00:40:49,750 --> 00:40:52,085
所以需要的代码要少得多

773
00:40:52,119 --> 00:40:55,455
你所写的 Swift 代码 就是唯一的数据源

774
00:40:55,489 --> 00:40:57,758
也没有需要同步保留 额外的 intent 定义文件

775
00:40:57,791 --> 00:41:00,060
或代码生成

776
00:41:00,093 --> 00:41:02,696
并且这些代码很容易添加到你的项目中

777
00:41:02,729 --> 00:41:05,232
你不需要重新设计你的代码库

778
00:41:05,265 --> 00:41:08,335
哪怕你有 Objective-C 代码
你仍然可以在 App Intents 中使用它们

779
00:41:08,368 --> 00:41:09,970
只要用 Swift 代码封装一下

780
00:41:10,003 --> 00:41:13,373
一个 app intent 表示用户在你的 app 中
可以做的事情

781
00:41:13,407 --> 00:41:16,610
并且使从你的 app 外完成该操作成为可能

782
00:41:16,643 --> 00:41:19,346
你可以定义 intent 并添加 app 快捷指令

783
00:41:19,379 --> 00:41:21,048
仅需几行代码

784
00:41:21,081 --> 00:41:23,250
我们来一起试一试

785
00:41:23,283 --> 00:41:25,953
回到 Food Truck app
我这里有个很棒的图表视图

786
00:41:25,986 --> 00:41:30,557
可以让我看到不同时间段内
最畅销的五种甜甜圈

787
00:41:30,591 --> 00:41:32,459
比如今天或本周

788
00:41:32,492 --> 00:41:34,628
我想把它显示给 Siri 和快捷指令

789
00:41:34,661 --> 00:41:37,397
这样用户就可以飞快地调出它

790
00:41:37,431 --> 00:41:40,834
首先 在 Xcode 中 我进入
一个新的 Swift 文件

791
00:41:40,868 --> 00:41:44,171
导入 App Intents 和 SwiftUI 框架

792
00:41:45,672 --> 00:41:47,541
然后给这个 intent 下定义

793
00:41:47,574 --> 00:41:50,878
要通过定义一个符合 AppIntent 协议的结构

794
00:41:50,911 --> 00:41:53,247
我来给它加一个 title

795
00:41:53,280 --> 00:41:57,251
再添加一个 parameter
来定义具体哪个时间段的趋势

796
00:41:57,284 --> 00:42:01,221
它使用的是已经在我的代码库中
定义的时间框架枚举

797
00:42:01,255 --> 00:42:04,925
我需要扩展它 以符合 AppEnum 协议

798
00:42:04,958 --> 00:42:08,662
这样我们就可以为每个枚举情况
提取人类可读的名称

799
00:42:08,695 --> 00:42:11,064
如 “今天” 和 “本周”

800
00:42:11,098 --> 00:42:15,569
接下来 在 intent 这里
加上 perform 方法

801
00:42:15,602 --> 00:42:19,640
这里 返回的是一个包含 SwiftUI 视图的结果

802
00:42:19,673 --> 00:42:22,643
我还可以加入一个对话或输出值

803
00:42:22,676 --> 00:42:26,380
我希望用户可以自动使用这个 intent
而不用设置

804
00:42:26,413 --> 00:42:28,115
所以我要定义一个 app 快捷指令

805
00:42:30,017 --> 00:42:32,719
这包括用户可以对 Siri 说的短语

806
00:42:32,753 --> 00:42:34,488
好调用这个 intent

807
00:42:34,521 --> 00:42:38,258
这个短语必须包括 app 的名称作为变量

808
00:42:38,292 --> 00:42:40,894
我还包括了时间段参数

809
00:42:40,928 --> 00:42:43,964
所以用户可以说 “Food Truck 今日趋势”

810
00:42:43,997 --> 00:42:46,967
或 “Food Truck 本周趋势”

811
00:42:47,000 --> 00:42:50,470
我需要做的最后一件事
就是让用户可以发现这个快捷指令

812
00:42:50,504 --> 00:42:52,673
用户需要在某个时候看到这个短语

813
00:42:52,706 --> 00:42:54,474
以便知道他们可以对 Siri 说什么

814
00:42:54,508 --> 00:42:57,778
所以我就切换到前五甜甜圈视图文件

815
00:42:57,811 --> 00:42:59,546
就是我们刚刚看的那个

816
00:42:59,580 --> 00:43:01,648
我在这里添加一个 SiriTip

817
00:43:03,217 --> 00:43:07,387
现在我就可以构建并运行这个 app
然后在我的手机上试试看

818
00:43:07,421 --> 00:43:08,455
我们来试一试

819
00:43:10,958 --> 00:43:13,594
我可以看到快捷指令出现在了快捷指令 app 中

820
00:43:13,627 --> 00:43:15,863
每个参数值都有变量

821
00:43:15,896 --> 00:43:19,433
我可以轻点运行一个

822
00:43:19,466 --> 00:43:22,769
也可通过说那句短语 从 Siri 运行

823
00:43:22,803 --> 00:43:24,838
“Food Truck 今日趋势”

824
00:43:26,640 --> 00:43:30,010
我还可以说 “Food Truck 本周趋势”

825
00:43:32,279 --> 00:43:34,681
当用户进到 app 的前五视图时

826
00:43:34,715 --> 00:43:36,783
他们会看到我们在底部添加的这个提示

827
00:43:36,817 --> 00:43:40,320
从而了解对 Siri 说什么可以使用该功能

828
00:43:40,354 --> 00:43:43,657
最后 用户在聚焦中搜索该 app 时

829
00:43:43,690 --> 00:43:45,759
可以访问这些功能 就像这样

830
00:43:47,995 --> 00:43:50,130
非常有用

831
00:43:50,163 --> 00:43:53,100
App Intents 让你前所未有地轻松打造

832
00:43:53,133 --> 00:43:58,772
各种 app 功能 整合于系统体验中
并跨越各个平台

833
00:43:58,805 --> 00:44:01,275
下面 Ricky 将给大家带来一些

834
00:44:01,308 --> 00:44:03,210
关于认证技术的重大进展

835
00:44:03,877 --> 00:44:05,445
从我们记事开始

836
00:44:05,479 --> 00:44:08,048
我们就一直在创建和使用密码

837
00:44:08,081 --> 00:44:10,250
但密码有着严重的问题

838
00:44:10,284 --> 00:44:14,421
如网络钓鱼、多账号使用同一密码、网站泄露

839
00:44:14,454 --> 00:44:18,091
好消息是 我们可以携起手来解决这一问题

840
00:44:18,125 --> 00:44:21,161
现在 我们用通行密钥就可以了

841
00:44:21,195 --> 00:44:24,131
通行密钥将简化你的认证流程

842
00:44:24,164 --> 00:44:27,434
解决密码的首要安全问题

843
00:44:27,467 --> 00:44:30,737
通行密钥的设计理念让它无比易用

844
00:44:30,771 --> 00:44:34,274
通行密钥复用了之前的自动填充信息界面

845
00:44:34,308 --> 00:44:37,778
并使用面容 ID 和触控 ID 进行生物识别验证

846
00:44:37,811 --> 00:44:41,448
这些元素创造了从密码的无缝过渡

847
00:44:41,481 --> 00:44:44,985
同时大大提升了安全性

848
00:44:45,018 --> 00:44:47,187
让我们来看看通行密钥的实际应用

849
00:44:47,988 --> 00:44:50,090
用通行密钥设置账户的话

850
00:44:50,123 --> 00:44:52,359
我就不需要创建密码了

851
00:44:52,392 --> 00:44:57,497
我在这里输入用户名
并将通行密钥保存到我的 iCloud 钥匙串中

852
00:44:57,531 --> 00:45:01,969
这个通行密钥就安全同步到
我所有其他 Apple 设备上了

853
00:45:02,002 --> 00:45:06,106
重新登录是一件轻而易举的事

854
00:45:06,139 --> 00:45:09,309
面容 ID 验证 就搞定

855
00:45:09,343 --> 00:45:12,546
通行密钥建立在开放的行业标准上

856
00:45:12,579 --> 00:45:14,281
且各个平台都在持续采用

857
00:45:14,314 --> 00:45:17,584
我可以用我刚刚在 iPhone 上创建的通行密钥

858
00:45:17,618 --> 00:45:21,088
在我朋友的 PC 上登录 Food Truck 网站

859
00:45:21,121 --> 00:45:25,192
在网站上 输入我的用户名
点击提交

860
00:45:25,225 --> 00:45:28,896
选择用手机登陆

861
00:45:28,929 --> 00:45:31,331
扫描二维码

862
00:45:31,365 --> 00:45:36,570
让 PC 和 iPhone 建立安全连接

863
00:45:36,603 --> 00:45:39,139
登录成功

864
00:45:39,173 --> 00:45:42,543
在我自己 Mac 的 Safari 浏览器上
登录更加简单

865
00:45:42,576 --> 00:45:45,612
我的通行密钥已经在这里了
得益于 iCloud 钥匙串

866
00:45:45,646 --> 00:45:49,283
所以我可以直接从网站的用户名栏登录

867
00:45:49,316 --> 00:45:53,120
将通行密钥整合到现有登录流程中非常容易

868
00:45:53,153 --> 00:45:57,424
例如 这个网站的用户名栏允许我用通行密钥登录

869
00:45:57,457 --> 00:45:59,092
也可用密码登录

870
00:45:59,126 --> 00:46:03,864
如果我输入一个有密码的账号的用户名

871
00:46:03,897 --> 00:46:05,432
我也可以快速登录

872
00:46:05,465 --> 00:46:08,235
使用通行密钥 出力的是设备

873
00:46:08,268 --> 00:46:10,604
而且每次都是安全的

874
00:46:10,637 --> 00:46:12,139
创建通行密钥时

875
00:46:12,172 --> 00:46:16,977
设备会生成一个独特密钥
专用于创建它的网站或 app

876
00:46:17,010 --> 00:46:19,713
并且这个密钥会受到生物识别的保护

877
00:46:19,746 --> 00:46:22,282
不可能有弱通行密钥

878
00:46:22,316 --> 00:46:25,219
这些密钥不会被遗忘、无法重新使用
或者被猜出来

879
00:46:25,252 --> 00:46:28,388
通行密钥的基础是公钥加密技术

880
00:46:28,422 --> 00:46:32,092
这让服务器端的凭证泄露成为历史

881
00:46:32,125 --> 00:46:35,429
不同于之前 在服务器上存储加盐哈希密码

882
00:46:35,462 --> 00:46:40,567
存在泄漏和被破解的风险
现在只需要将对应的公钥保存在上面

883
00:46:40,601 --> 00:46:43,103
公钥被设计为真正公开的

884
00:46:43,136 --> 00:46:45,405
对黑客完全没有价值

885
00:46:45,439 --> 00:46:49,209
这极大地降低了你作为网站所有者的风险

886
00:46:49,243 --> 00:46:52,179
还有非常重要的一点

887
00:46:52,212 --> 00:46:55,215
有了通行密钥
我们今天所知的凭证钓鱼将不复存在

888
00:46:55,249 --> 00:46:59,453
消除了用户面临的头号安全漏洞

889
00:46:59,486 --> 00:47:03,524
通行密钥与设置它们的网站或 app 有内在联系

890
00:47:03,557 --> 00:47:07,828
因此 用户永远不会被骗在错误的网站上
使用他们的通行密钥

891
00:47:07,861 --> 00:47:09,530
而且 与密码不同的是

892
00:47:09,563 --> 00:47:12,366
将通行密钥输入或复制到

893
00:47:12,399 --> 00:47:14,501
看上去非常逼真的假网站是不可能的

894
00:47:14,535 --> 00:47:18,238
甚至不可能将任何信息泄露给偷看到你密码的人

895
00:47:18,272 --> 00:47:21,141
把这一切放在一起时
我们看到的就是

896
00:47:21,175 --> 00:47:23,644
账户安全的崭新时代

897
00:47:23,677 --> 00:47:27,748
在你的 app 和网站里支持 通行密钥仅需几步

898
00:47:27,781 --> 00:47:31,084
首先 教你的帐户后端存储公钥

899
00:47:31,118 --> 00:47:33,687
并发出身份验证挑战

900
00:47:33,720 --> 00:47:36,190
然后 在网站和 app 中

901
00:47:36,223 --> 00:47:38,058
给用户提供通行密钥

902
00:47:38,091 --> 00:47:42,329
并采用 API 来创建新的通行密钥以及用它登录

903
00:47:42,362 --> 00:47:46,934
通行密钥基于 Web 认证标准

904
00:47:46,967 --> 00:47:49,870
这个标准是跨行业的平台供应商和服务所有者

905
00:47:49,903 --> 00:47:53,407
共同努力的结果

906
00:47:53,440 --> 00:47:56,610
这标准本身非常成熟
并且有详细的对应文档

907
00:47:56,643 --> 00:47:59,112
通行密钥非常适合它

908
00:47:59,146 --> 00:48:02,683
所有这一切已经准备就绪
你现在就可开始构建

909
00:48:02,716 --> 00:48:06,453
新一代的安全保护 流畅的用户体验

910
00:48:06,486 --> 00:48:10,824
并能在转换过渡期与密码顺畅地使用

911
00:48:10,858 --> 00:48:12,459
交回给你 Sebastien

912
00:48:12,492 --> 00:48:15,195
大家刚刚看到的是一些最新的方式

913
00:48:15,229 --> 00:48:19,733
能让你的 app 整合到
跨我们所有平台的系统体验中

914
00:48:19,766 --> 00:48:24,137
除了这些可以整合的特性
还有大量新的 API 和框架

915
00:48:24,171 --> 00:48:25,672
跨我们所有的平台

916
00:48:25,706 --> 00:48:29,476
能在今年为你和你的 app 带来更多的可能性

917
00:48:30,310 --> 00:48:32,312
我想先给大家介绍一些

918
00:48:32,346 --> 00:48:35,782
然后再更深入讲解另外几个

919
00:48:35,816 --> 00:48:38,418
我们先来看 iPadOS

920
00:48:38,452 --> 00:48:42,923
有了 iPadOS 16 你可以打造出
iPad 上各类前所未有的强大 app

921
00:48:42,956 --> 00:48:46,326
并且带来和桌面级 app 一致的体验

922
00:48:46,360 --> 00:48:49,930
例如流畅的查找和替换体验用于 UI 文本视图

923
00:48:49,963 --> 00:48:52,132
让你打造的 app 可以直接调用

924
00:48:52,165 --> 00:48:54,434
以及对导航栏、工具栏

925
00:48:54,468 --> 00:48:56,403
文档菜单的更新

926
00:48:56,436 --> 00:48:59,339
它们会让你的用户能更轻松地管理文档

927
00:48:59,373 --> 00:49:01,575
以及自定义他们的体验

928
00:49:01,608 --> 00:49:05,746
为了让 iPad 更好地与其他硬件搭配使用

929
00:49:05,779 --> 00:49:07,748
我们为 iPad 推出了 DriverKit

930
00:49:07,781 --> 00:49:11,285
解锁 M1 芯片的惊人性能

931
00:49:11,318 --> 00:49:13,987
它与目前在 Mac 上可用的 API 相同

932
00:49:14,021 --> 00:49:18,358
让你可以轻松地向更多用户提供对

933
00:49:18,392 --> 00:49:21,261
USB、音频和 PCI 设备的支持

934
00:49:22,596 --> 00:49:25,532
此外 watchOS 也正在为各类 app 创造新的机会

935
00:49:25,566 --> 00:49:28,702
通过与各类系统服务 更深层度的整合

936
00:49:28,735 --> 00:49:31,238
watchOS 9 的 CallKit 框架

937
00:49:31,271 --> 00:49:33,740
包括一个新的 VoIP 背景模式

938
00:49:33,774 --> 00:49:37,211
让 app 可以直接从 Apple Watch 上
发起语音通话

939
00:49:37,244 --> 00:49:41,882
带来熟悉的用户体验
正如 FaceTime 音频通话和打电话那样

940
00:49:41,915 --> 00:49:46,687
通过蓝牙连接的医疗设备获得了
更强大的连接能力和数据传输

941
00:49:46,720 --> 00:49:50,290
能在检测到危急情况时及时发出提示

942
00:49:51,692 --> 00:49:55,629
tvOS 16 为你提供了新的方法
来创造连接性的体验

943
00:49:55,662 --> 00:49:57,397
让你把 Apple TV 上的 app

944
00:49:57,431 --> 00:50:01,902
与附近设备上的 iPhone、iPad
或 Apple Watch app 相连

945
00:50:01,935 --> 00:50:05,072
这样 锻炼可以使用 Apple Watch 的运动数据

946
00:50:05,105 --> 00:50:06,740
或者你可以把 iPhone 或 iPad

947
00:50:06,773 --> 00:50:10,177
用作回合制游戏的自定义手柄

948
00:50:10,210 --> 00:50:14,147
tvOS 负责管理设备的发现和连接

949
00:50:14,181 --> 00:50:16,450
所以你的 app 甚至无需在另一部设备上运行

950
00:50:16,483 --> 00:50:18,719
事实上 如果你的 app 还没被安装

951
00:50:18,752 --> 00:50:23,757
用户会被自动提示从 App Store下载它

952
00:50:23,790 --> 00:50:27,694
对于手机和 iPad
还有提供给广告商的新工具

953
00:50:27,728 --> 00:50:31,465
我们知道 有效的广告对大家的很多业务很重要

954
00:50:31,498 --> 00:50:34,401
这就是为什么我们创建了 SKAdNetwork

955
00:50:34,434 --> 00:50:37,204
这是一个帮助广告网络和广告商的 API

956
00:50:37,237 --> 00:50:40,574
可在不追踪用户的前提下衡量广告活动的指标

957
00:50:40,607 --> 00:50:44,945
我们很高兴看到许多第三方广告网络都采用了它

958
00:50:44,978 --> 00:50:47,681
我们听到了广告网络和开发者的反馈

959
00:50:47,714 --> 00:50:51,151
并在今年对 SKAdNetwork 进行了一些改进

960
00:50:51,185 --> 00:50:53,020
回应了许多强烈要求的功能

961
00:50:53,053 --> 00:50:55,489
为大家提供极大的灵活性

962
00:50:55,522 --> 00:50:58,659
同时不影响隐私

963
00:50:59,793 --> 00:51:02,362
在 iPhone 和 iPad 上 有些很酷的新功能

964
00:51:02,396 --> 00:51:07,034
基于增强现实和激光雷达扫描仪
用到了 ScanKit 与 RoomPlan

965
00:51:07,067 --> 00:51:13,607
这些 API 让你的 app 以 USD 和 USDZ
格式创建信息丰富的 3D 参数化房间模型

966
00:51:13,640 --> 00:51:16,743
你可以创建各种工作流和体验

967
00:51:16,777 --> 00:51:20,347
从建筑和设计 到零售、酒店行业

968
00:51:20,380 --> 00:51:23,951
这些模型包括了家具分类

969
00:51:23,984 --> 00:51:29,423
包括沙发、橱柜、电视等类别
没错 甚至还有厨房水槽

970
00:51:29,456 --> 00:51:31,225
去年 我们推出了专注模式

971
00:51:31,258 --> 00:51:33,927
适用于 iPhone、iPad
Mac 和 Apple Watch

972
00:51:33,961 --> 00:51:39,633
让你的 app 根据用户的专注模式去管理通知

973
00:51:39,666 --> 00:51:43,170
今年 我们将通过专注模式过滤条件
进一步加强这项功能

974
00:51:43,203 --> 00:51:46,773
专注模式过滤条件建立在 App Intents 之上

975
00:51:46,807 --> 00:51:50,377
让你根据用户当前的专注模式调整 app 的内容

976
00:51:50,410 --> 00:51:53,213
例如 app 可以创建专注模式过滤条件

977
00:51:53,247 --> 00:51:57,818
在用户设置为工作模式时 仅显示工作账号

978
00:51:57,851 --> 00:52:01,388
而这些例子仅是冰山一角

979
00:52:01,421 --> 00:52:04,458
在各个层面都有新的工具和 API

980
00:52:04,491 --> 00:52:06,093
为你提供所需要的功能

981
00:52:06,126 --> 00:52:08,362
让你的 app 更进一步

982
00:52:08,395 --> 00:52:11,098
以及创造全新的 app 和体验

983
00:52:11,131 --> 00:52:13,534
下面 我们来深入讲解一下

984
00:52:13,567 --> 00:52:14,902
首先就是 Metal

985
00:52:14,935 --> 00:52:18,038
这项技术将各种体验带入全新境界

986
00:52:18,071 --> 00:52:20,941
更多详情 请 Sarah 来介绍

987
00:52:20,974 --> 00:52:27,981
♪ ♪

988
00:52:29,249 --> 00:52:32,286
Metal 是个强大的图形处理和计算 API

989
00:52:32,319 --> 00:52:34,888
帮助你打造出令人惊叹的各类游戏和专业级 app

990
00:52:34,922 --> 00:52:36,423
覆盖 Apple 的各个平台

991
00:52:36,456 --> 00:52:38,325
Metal 让你可以充分利用 Apple 打造的

992
00:52:38,358 --> 00:52:41,895
带来突破性能的图形处理器和统一内存系统

993
00:52:41,929 --> 00:52:46,700
覆盖搭载了 Apple 芯片的最新
iPhone、iPad、Mac 产品线

994
00:52:46,733 --> 00:52:50,771
今年 我们将推出 Metal 3

995
00:52:50,804 --> 00:52:52,506
带来强大的新功能

996
00:52:52,539 --> 00:52:55,275
助你以更高的帧率渲染沉浸式画面

997
00:52:55,309 --> 00:52:58,312
并将计算性能推向新高

998
00:52:58,345 --> 00:53:01,014
例如 机器学习框架 Pytorch

999
00:53:01,048 --> 00:53:03,183
将迎来巨大的性能提升

1000
00:53:03,217 --> 00:53:05,085
它现在使用新的 Metal 后端

1001
00:53:05,118 --> 00:53:07,554
使用图形处理器来进行机器学习训练

1002
00:53:07,588 --> 00:53:10,257
当然最受关注的领域就是游戏

1003
00:53:10,290 --> 00:53:12,192
首先是游戏加载

1004
00:53:12,226 --> 00:53:14,494
这是游戏体验的一个关键因素

1005
00:53:14,528 --> 00:53:17,197
会影响启动时间和新关卡加载

1006
00:53:17,231 --> 00:53:19,900
现在的游戏带来细节丰富的游戏体验

1007
00:53:19,933 --> 00:53:22,269
基于高画质的素材

1008
00:53:22,302 --> 00:53:26,273
将这些素材快速地从硬盘加载到图形处理器
是件有挑战的事

1009
00:53:26,306 --> 00:53:30,177
通常 游戏会在加载画面时进行素材加载

1010
00:53:30,210 --> 00:53:32,679
一种加快游戏启动的方式

1011
00:53:32,713 --> 00:53:34,815
是加载并绘制一个较低质量的版本

1012
00:53:34,848 --> 00:53:37,484
直到高质量的视觉画面加载完毕

1013
00:53:37,518 --> 00:53:39,620
这并不是理想的游戏体验

1014
00:53:39,653 --> 00:53:43,156
因为用户会更长时间看到低画质

1015
00:53:43,190 --> 00:53:46,260
Metal 3 带来了快速资源加载

1016
00:53:46,293 --> 00:53:47,628
基于 Metal IO API

1017
00:53:47,661 --> 00:53:51,431
利用 Apple 图形处理器的统一内存架构

1018
00:53:51,465 --> 00:53:53,100
减少加载开销

1019
00:53:53,133 --> 00:53:57,871
确保每台 Apple 芯片
Mac 所配的高速 SSD 存储

1020
00:53:57,905 --> 00:54:01,575
在队列中有足够的请求 从而最大限度地提高通量

1021
00:54:01,608 --> 00:54:04,878
这个新的 API 会提供更快更一致的性能

1022
00:54:04,912 --> 00:54:07,814
从而把更多的时间留给理想画质的绘制

1023
00:54:09,149 --> 00:54:12,152
除了将资源从硬盘加载到内存以外

1024
00:54:12,186 --> 00:54:14,955
着色器编译也会影响游戏加载

1025
00:54:14,988 --> 00:54:19,193
着色器总是需要根据用户的
独特硬件配置进行编译

1026
00:54:19,226 --> 00:54:22,129
由于 PC 硬件种类繁多

1027
00:54:22,162 --> 00:54:24,464
这通常需要在运行时完成

1028
00:54:24,498 --> 00:54:27,734
这种游戏中的编译会影响玩家体验

1029
00:54:27,768 --> 00:54:31,338
导致掉帧、帧率下降、加载时间延长

1030
00:54:31,371 --> 00:54:35,375
相比之下 Apple 芯片和
Metal 3 的设计相辅相成

1031
00:54:35,409 --> 00:54:37,144
支持所有 Apple 设备

1032
00:54:37,177 --> 00:54:39,546
现在 有了离线着色器编译

1033
00:54:39,580 --> 00:54:43,183
你可以在项目构建时
生成图形处理器着色器二进制文件

1034
00:54:43,217 --> 00:54:46,153
让你能够消除游戏中的着色器编译

1035
00:54:46,186 --> 00:54:49,389
减少加载时间 提升渲染性能

1036
00:54:49,423 --> 00:54:54,127
游戏的另一个重点是提供丰富
充满细节的素材

1037
00:54:54,161 --> 00:54:57,331
提高游戏图形视觉保真度的一个方法是

1038
00:54:57,364 --> 00:55:01,335
生成更复杂的几何网格

1039
00:55:01,368 --> 00:55:03,871
之前是在中央处理器上进行界面评估

1040
00:55:03,904 --> 00:55:06,340
生成几何图形

1041
00:55:06,373 --> 00:55:08,442
再提交给图形处理器进行渲染

1042
00:55:08,475 --> 00:55:11,078
挑战在于 这可能会带来延迟

1043
00:55:11,111 --> 00:55:13,447
并占用不可预测的内存空间

1044
00:55:13,480 --> 00:55:16,483
Metal 3 引入了新的
Mesh Shading API

1045
00:55:16,517 --> 00:55:22,289
让你能够从一个渲染通道中
精确控制优化的几何处理管线

1046
00:55:22,322 --> 00:55:25,192
对象着色器决定生成多少网格

1047
00:55:25,225 --> 00:55:27,461
网格着色器生成实际的几何图像

1048
00:55:27,494 --> 00:55:29,897
然后直接发给光栅化渲染器

1049
00:55:29,930 --> 00:55:33,267
避免了多次内存访问 提高了性能

1050
00:55:33,300 --> 00:55:36,069
玩家也希望以最高的帧率

1051
00:55:36,103 --> 00:55:37,838
看到这些令人惊叹的视觉效果

1052
00:55:37,871 --> 00:55:41,074
但以超高分辨率渲染高级图像

1053
00:55:41,108 --> 00:55:42,809
可能会耗费宝贵的毫秒

1054
00:55:42,843 --> 00:55:46,079
MetalFX 上采样功能帮你以每帧更短的时间

1055
00:55:46,113 --> 00:55:47,781
来渲染沉浸式画面

1056
00:55:47,814 --> 00:55:49,349
它是这样运作的

1057
00:55:49,383 --> 00:55:52,819
以前 你会以原始分辨率渲染全帧

1058
00:55:52,853 --> 00:55:56,256
但图形处理器的渲染时间可能无法达到目标帧时间

1059
00:55:56,290 --> 00:56:00,093
现在 你能以较低的分辨率
渲染同样的复杂场景

1060
00:56:00,127 --> 00:56:03,197
从而满足目标帧时间
然后利用 MetalFX 框架

1061
00:56:03,230 --> 00:56:07,668
执行时间抗锯齿 并上采样至目标分辨率

1062
00:56:07,701 --> 00:56:10,637
有了 Apple 芯片和 Metal 3 优化的功能

1063
00:56:10,671 --> 00:56:13,106
游戏将在 Mac 上前所未有地大放异彩

1064
00:56:13,140 --> 00:56:14,808
游戏开发者也表示赞同

1065
00:56:14,842 --> 00:56:18,245
许多顶尖的游戏工作室正在着手
将他们的游戏带到 Mac 上

1066
00:56:18,278 --> 00:56:21,281
比如 Grid Legends 利用 Apple 芯片

1067
00:56:21,315 --> 00:56:23,617
助你全速前进

1068
00:56:23,650 --> 00:56:27,387
而 Resident Evil Village
使用 MetalFX 上采样等功能

1069
00:56:27,421 --> 00:56:31,358
以最高分辨率提供美到惊心动魄的画面

1070
00:56:31,391 --> 00:56:33,961
还有 No Man's Sky
利用 Metal 3 的优势

1071
00:56:33,994 --> 00:56:37,564
在 Mac 和 iPad 上探索丰富、广阔的世界

1072
00:56:37,598 --> 00:56:42,336
Metal 3 令人难以置信
它将提升你的 app 的性能

1073
00:56:42,369 --> 00:56:44,605
以及提供惊艳的游戏体验

1074
00:56:44,638 --> 00:56:49,109
现在 我们来看看 MapKit 的发展方向
请 Kathy 给大家介绍

1075
00:56:49,142 --> 00:56:51,278
无论你是要导航前往你最喜欢的餐厅

1076
00:56:51,311 --> 00:56:52,980
计划下一个假期

1077
00:56:53,013 --> 00:56:55,849
还是只是在地图上查看
你最喜欢的美食车停在哪里

1078
00:56:55,883 --> 00:57:00,487
我们都无比依赖我们的设备
帮我们探索周边的世界

1079
00:57:00,521 --> 00:57:04,391
MapKit 是帮助用户探索和导航的好方法

1080
00:57:04,424 --> 00:57:07,361
它提供了丰富而灵活的地图和位置服务

1081
00:57:07,394 --> 00:57:11,465
由 Apple 地图驱动 开发者可免费使用

1082
00:57:11,498 --> 00:57:15,669
利用 MapKit 你可以在你的 app 中
显示地图或卫星图像

1083
00:57:15,702 --> 00:57:17,604
找到并调出兴趣点

1084
00:57:17,638 --> 00:57:19,239
添加注释和覆盖物

1085
00:57:19,273 --> 00:57:21,408
获取路线等等

1086
00:57:21,441 --> 00:57:23,844
MapKit 由我们的全新地图提供支持

1087
00:57:23,877 --> 00:57:26,246
经过 Apple 彻底重新设计

1088
00:57:26,280 --> 00:57:28,248
它提供了更好的细节和准确性

1089
00:57:28,282 --> 00:57:31,952
并能为你的 app 带来有用的地图和位置服务

1090
00:57:31,985 --> 00:57:34,421
在 iOS 16 中 我们将在新地图的基础上

1091
00:57:34,454 --> 00:57:37,191
推出有史以来对 MapKit 最大的更新

1092
00:57:37,224 --> 00:57:42,029
首先是向所有开发者提供
3D City Experience

1093
00:57:42,062 --> 00:57:45,032
你的 app 用户将能看到令人难以置信的细节

1094
00:57:45,065 --> 00:57:47,801
包括 3D 高度信息、转弯车道

1095
00:57:47,835 --> 00:57:49,269
人行横道、自行车道等

1096
00:57:49,303 --> 00:57:52,039
还有惊人的手工打造的 3D 地标

1097
00:57:52,072 --> 00:57:54,508
如金门大桥或渡轮大厦

1098
00:57:54,541 --> 00:57:57,411
地图的新增细节让你可以提供

1099
00:57:57,444 --> 00:58:01,181
前所未有的背景和精确度

1100
00:58:01,215 --> 00:58:06,887
例如 你可以在人行横道和自行车道起始点间
显示一个兴趣点

1101
00:58:06,920 --> 00:58:09,156
没有其他数字地图能让你做到这一点

1102
00:58:09,189 --> 00:58:12,359
而我们可以让你非常轻松地实现它

1103
00:58:12,392 --> 00:58:14,261
为了给大家展示 我们来创造一个体验

1104
00:58:14,294 --> 00:58:20,400
让用户利用新地图的细节
轻松找到他们最喜欢的美食车停在哪里

1105
00:58:20,434 --> 00:58:25,038
像这样的地图视图会在可用时
自动获得 3D City Experience

1106
00:58:25,072 --> 00:58:28,242
只需将部署目标设置为 iOS 16 即可

1107
00:58:28,275 --> 00:58:31,578
接下来 我可以用非常详细的地图

1108
00:58:31,612 --> 00:58:35,315
来显示美食车的确切位置

1109
00:58:35,349 --> 00:58:39,353
MapKit 拥有强大的控件
让我们在 3D 空间中定位相机

1110
00:58:39,386 --> 00:58:42,122
以创建精确的地图视图

1111
00:58:42,155 --> 00:58:44,658
这里 我可以选择我们希望被放大的距离

1112
00:58:44,691 --> 00:58:48,762
通过将相机的中心坐标距离设置为 600 米即可

1113
00:58:48,795 --> 00:58:51,999
通过调整俯仰和朝向 倾斜相机查看 3D 视图

1114
00:58:52,032 --> 00:58:55,002
你可以看到令人惊叹的有用细节
如转弯车道

1115
00:58:55,035 --> 00:58:57,771
人行横道 甚至还有树木

1116
00:58:57,804 --> 00:59:00,474
默认情况下 高度信息将被压平

1117
00:59:00,507 --> 00:59:03,410
为了帮助用户了解他们将遇到的地形

1118
00:59:03,443 --> 00:59:07,814
我可以用 preferredConfiguration
将 elevationStyle 设置为 ‘realistic’

1119
00:59:07,848 --> 00:59:09,783
以包含 3D 高度信息

1120
00:59:10,851 --> 00:59:15,255
从 MapKit 的路线规划 API 中
添加注释或路线源时

1121
00:59:15,289 --> 00:59:17,457
MapKit 会自动处理高度信息

1122
00:59:17,491 --> 00:59:19,927
并会通过将其置于 3D 地形之上

1123
00:59:19,960 --> 00:59:23,830
调整注释或路线

1124
00:59:23,864 --> 00:59:26,466
通过添加慢速平移 为相机朝向进行动画处理

1125
00:59:26,500 --> 00:59:29,736
可以让地图视图变得生动

1126
00:59:29,770 --> 00:59:31,438
当用户切换到深色模式时

1127
00:59:31,471 --> 00:59:34,241
地图也会与 UI 的其他部分一同调整

1128
00:59:34,274 --> 00:59:39,646
我们非常高兴能通过 iOS 16
向开发者提供这项沉浸式的体验

1129
00:59:39,680 --> 00:59:43,817
此外 我们还将另一个很受欢迎的
Apple 地图功能带到了 MapKit

1130
00:59:43,851 --> 00:59:45,452
那就是 四处看看

1131
00:59:45,485 --> 00:59:48,956
这是一种从视平线角度探索世界的好方法

1132
00:59:48,989 --> 00:59:52,392
提供了高分辨率的 3D 图像和流畅的动画

1133
00:59:52,426 --> 00:59:55,295
用户只需轻点就可在街道上移动

1134
00:59:56,997 --> 00:59:59,900
我可以在地图下面添加一个静态的
四处看看预览

1135
00:59:59,933 --> 01:00:03,604
仅需放入一个 View Controller
并指定 MapItem

1136
01:00:03,637 --> 01:00:07,241
四处看看视图会自动插入正确的位置

1137
01:00:07,274 --> 01:00:09,610
用户轻点预览时 我可以选择提供

1138
01:00:09,643 --> 01:00:11,512
全屏的四处看看视图

1139
01:00:11,545 --> 01:00:13,480
用户可以看到地址

1140
01:00:13,514 --> 01:00:15,349
图像采集日期

1141
01:00:15,382 --> 01:00:17,584
还能通过轻点自由移动

1142
01:00:17,618 --> 01:00:20,420
更好地了解周边环境

1143
01:00:20,454 --> 01:00:23,223
还有一项新的、呼声很高的功能

1144
01:00:23,257 --> 01:00:26,026
将在 iOS 16 中登陆 MapKit

1145
01:00:26,059 --> 01:00:28,295
Apple Maps Server API

1146
01:00:28,328 --> 01:00:30,163
Maps Server API 是 REST 接口

1147
01:00:30,197 --> 01:00:33,367
支持 MapKit 最常用功能中的四项

1148
01:00:33,400 --> 01:00:36,537
地理编码 可将经纬度转换为地址

1149
01:00:36,570 --> 01:00:38,872
逆地理编码 实现的是相反的功能

1150
01:00:38,906 --> 01:00:41,608
将地址转换为 GPS 坐标

1151
01:00:41,642 --> 01:00:44,111
搜索 以及到达时间

1152
01:00:44,144 --> 01:00:46,914
我们新的 Maps Server API

1153
01:00:46,947 --> 01:00:51,385
能让你自己的后端服务更丰富 性能更强

1154
01:00:51,418 --> 01:00:55,989
当然 MapKit 建立在与 Apple 地图相同的
隐私保护基础上

1155
01:00:56,023 --> 01:00:59,226
不会将用户的数据与他们的身份关联起来

1156
01:00:59,259 --> 01:01:01,895
也不会保留用户去过的地方的历史

1157
01:01:01,929 --> 01:01:05,499
这就是对 iOS 16 中
MapKit 新功能的简单介绍

1158
01:01:05,532 --> 01:01:08,936
现在轮到介绍天气了
至少是如何将天气建入你的 app

1159
01:01:08,969 --> 01:01:10,637
交给 Novall

1160
01:01:10,671 --> 01:01:14,975
我们今天宣布了要把天气 app
带到 iPad 和 Mac 上

1161
01:01:15,008 --> 01:01:17,377
并推出强大的新功能

1162
01:01:17,411 --> 01:01:21,081
包括恶劣天气通知、丰富的细节视图

1163
01:01:21,114 --> 01:01:25,018
以及未来十天的每小时温度和降水预报

1164
01:01:25,052 --> 01:01:29,256
等各种各样的体验 跨各个 Apple 设备和平台

1165
01:01:29,289 --> 01:01:32,659
这些体验也将因我们提供的天气数据而优化提升

1166
01:01:32,693 --> 01:01:35,295
无论是向 Siri 询问今天的天气预报

1167
01:01:35,329 --> 01:01:38,232
还是绕过水灾区域重新规划导航路线

1168
01:01:38,265 --> 01:01:42,035
所有这一切都内置于我们的 Apple 天气服务中

1169
01:01:42,069 --> 01:01:45,372
Apple 天气提供了世界级的全球天气预报

1170
01:01:45,405 --> 01:01:48,041
利用高分辨率气象模型

1171
01:01:48,075 --> 01:01:50,911
结合机器学习和预测算法

1172
01:01:50,944 --> 01:01:53,447
Apple 天气提供当前天气

1173
01:01:53,480 --> 01:01:56,517
10 天内的每小时预报、每日预报

1174
01:01:56,550 --> 01:02:00,354
以及历史天气 方便你评估数据趋势

1175
01:02:00,387 --> 01:02:03,090
在一些国家和地区还提供

1176
01:02:03,123 --> 01:02:06,860
恶劣天气警报和每分钟降水信息

1177
01:02:06,894 --> 01:02:10,330
预报功能包括未来 10 天的每小时温度

1178
01:02:10,364 --> 01:02:15,068
降水、紫外线指数预报 以及更多信息

1179
01:02:15,102 --> 01:02:19,173
所有这些数据都可通过 WeatherKit 获取到

1180
01:02:19,206 --> 01:02:23,210
WeatherKit 是原生的 Swift API
适用于所有 Apple 平台

1181
01:02:23,243 --> 01:02:25,612
并且是一个可以从任何地方使用的 REST API

1182
01:02:25,646 --> 01:02:29,449
这些 API 可以提供准确、超本地化的天气预报

1183
01:02:29,483 --> 01:02:33,787
为你的用户提供信息
帮助他们保持安全 做好准备

1184
01:02:33,820 --> 01:02:36,190
我来通过一个简短的演示向你介绍

1185
01:02:36,223 --> 01:02:39,593
通过 WeatherKit 很棒的 Swift API
获取天气信息多么容易

1186
01:02:39,626 --> 01:02:41,862
我们再回到 Food Truck app

1187
01:02:41,895 --> 01:02:44,231
为了确保我的顾客不被雨淋

1188
01:02:44,264 --> 01:02:47,968
我设置的 app 能推荐一个天空晴朗的停车点

1189
01:02:48,001 --> 01:02:50,470
我来展示一下我是如何获得天气信息的

1190
01:02:50,504 --> 01:02:53,240
我这里有一份安全停车点的清单

1191
01:02:53,273 --> 01:02:56,109
我已在 Xcode 中添加了 WeatherKit 功能

1192
01:02:56,143 --> 01:02:58,545
仅需几行代码即可

1193
01:02:58,579 --> 01:03:01,648
利用 Swift 并发功能 请求天气信息非常简单

1194
01:03:01,682 --> 01:03:06,019
我们调用 weather(for:) on WeatherService
并传入位置

1195
01:03:06,053 --> 01:03:11,391
然后我就可以获得我的 app 所需的相关数据
如天气状况

1196
01:03:11,425 --> 01:03:17,898
降水、云层覆盖

1197
01:03:17,931 --> 01:03:21,068
现在我有了每个停车位所需的数据

1198
01:03:21,101 --> 01:03:22,369
在我运行 app 时

1199
01:03:22,402 --> 01:03:26,740
我的自定义视图就已经更新为
推荐一个天空晴朗的位置

1200
01:03:28,509 --> 01:03:30,777
你可以通过各种方式使用天气数据

1201
01:03:30,811 --> 01:03:33,714
让你的 app 提供更好的体验

1202
01:03:33,747 --> 01:03:36,617
你可能会用天气预报帮你管理库存

1203
01:03:36,650 --> 01:03:40,587
预测冰淇淋馅甜甜圈在大热天会很受欢迎

1204
01:03:40,621 --> 01:03:43,123
所以你该多备一些冰淇淋

1205
01:03:43,156 --> 01:03:45,292
为我们的美食车获取天气数据仅需这样简单的操作

1206
01:03:45,325 --> 01:03:48,595
大家可以用 WeatherKit 做的事还有更多

1207
01:03:48,629 --> 01:03:50,964
与 Apple 对隐私保护的承诺一致

1208
01:03:50,998 --> 01:03:54,201
位置信息仅用于提供天气预报

1209
01:03:54,234 --> 01:03:57,504
不会与任何个人身份信息相关联

1210
01:03:57,538 --> 01:04:00,374
并且永不分享或出售

1211
01:04:00,407 --> 01:04:02,509
保护隐私是我们共同的责任

1212
01:04:02,543 --> 01:04:05,279
通过 WeatherKit 你可以获得准确的天气数据

1213
01:04:05,312 --> 01:04:08,081
同时保护用户隐私

1214
01:04:08,115 --> 01:04:11,251
因为我们想让大家很容易就能
开始使用 WeatherKit

1215
01:04:11,285 --> 01:04:15,722
所以我们将每月 50 万次
weather(for:location) API 调用

1216
01:04:15,756 --> 01:04:18,358
包含在你们的 Apple
Developer Program 订阅中

1217
01:04:18,392 --> 01:04:22,095
需求量更大的开发者
将可购买额外的服务级别

1218
01:04:22,129 --> 01:04:24,665
今年秋天起即可从开发者 app 中购买

1219
01:04:24,698 --> 01:04:26,800
这就是 WeatherKit

1220
01:04:26,834 --> 01:04:30,904
由 Apple 天气服务提供的准确、超本地化的天气预报

1221
01:04:30,938 --> 01:04:35,642
我们将从 Beta 测试版开始
现在就可以在所有平台上使用

1222
01:04:35,676 --> 01:04:39,913
你可以有很多有创意的方法
将 WeatherKit 用在你的 app 中

1223
01:04:39,947 --> 01:04:41,715
现在交给 Ryan 来给我们介绍

1224
01:04:41,748 --> 01:04:44,351
你的 app 可以通过实况文本看到什么

1225
01:04:44,384 --> 01:04:47,054
我们的用户非常喜欢实况文本

1226
01:04:47,087 --> 01:04:48,522
我们也听到你们中的很多人

1227
01:04:48,555 --> 01:04:50,757
都想把它加入到你们的 app 中

1228
01:04:50,791 --> 01:04:54,127
因此 今年我们将通过两个新的 API
扩展 VisionKit

1229
01:04:54,161 --> 01:04:56,330
让你们可以做到这一点

1230
01:04:57,631 --> 01:05:01,702
实况文本 API 解锁了分析图像内容的能力

1231
01:05:01,735 --> 01:05:04,371
让用户可以与照片和暂停视频帧中的

1232
01:05:04,404 --> 01:05:07,374
文字和二维码互动

1233
01:05:07,407 --> 01:05:08,775
并提供快速操作

1234
01:05:08,809 --> 01:05:10,844
这样你的用户仅需轻点

1235
01:05:10,878 --> 01:05:13,380
即可根据相关数据完成操作

1236
01:05:13,413 --> 01:05:15,749
它非常适合任何显示视觉媒体的 app

1237
01:05:15,782 --> 01:05:19,386
如 Apollo for Reddit 或 Vimeo

1238
01:05:19,419 --> 01:05:23,757
而 Data Scanner API 则解锁了
分析实时摄像头画面的能力

1239
01:05:23,790 --> 01:05:27,694
它极大地简化了扫描文本和条码的流程

1240
01:05:27,728 --> 01:05:31,331
你所需要做的就是添加覆盖物或自定义控件

1241
01:05:31,365 --> 01:05:35,169
使实况摄像头体验符合你 app 的需求

1242
01:05:35,202 --> 01:05:39,139
这特别适合依赖二维码的消费类 app

1243
01:05:39,173 --> 01:05:42,543
或者是企业 app 如仓库后区库存管理

1244
01:05:42,576 --> 01:05:44,211
取货和包装送货服务

1245
01:05:44,244 --> 01:05:45,679
以及自助结账机

1246
01:05:46,547 --> 01:05:48,982
实况文本 API 和数据扫描 API

1247
01:05:49,016 --> 01:05:51,652
支持自动检测 9 种语言

1248
01:05:51,685 --> 01:05:54,655
包括今年新增的日文和韩文

1249
01:05:55,656 --> 01:05:59,293
这些 VisionKit API 将多年的计算机视觉创新

1250
01:05:59,326 --> 01:06:02,396
带给你的 app  且仅需几行代码

1251
01:06:02,429 --> 01:06:04,431
下面交给 Jenny 来为各位展示

1252
01:06:04,464 --> 01:06:07,935
给大家快速展示一下
回到我们超棒的快闪 Food Truck app

1253
01:06:07,968 --> 01:06:11,471
我们正在做一个促销活动
如果用户在社交频道发布一张照片

1254
01:06:11,505 --> 01:06:15,209
手持带有 #freedonut 标签
和他们在 app 上的地址的牌子

1255
01:06:15,242 --> 01:06:18,212
我们就会把车开到他们的地址
赠送一个免费甜甜圈

1256
01:06:18,245 --> 01:06:20,147
我们来看看我们甜甜圈的社交频道

1257
01:06:20,180 --> 01:06:22,416
我们想把实况文本功能添加到图片上

1258
01:06:22,449 --> 01:06:25,652
这样司机就可以提取文本 获得送餐地址

1259
01:06:26,453 --> 01:06:29,223
这就到新的实况文本 API 派上用场的时候了

1260
01:06:29,256 --> 01:06:32,326
我可以很容易地在我的视图上面
添加一个 ImageInteraction

1261
01:06:32,359 --> 01:06:35,896
这将会添加一个实况文本按钮
并且支持快速操作

1262
01:06:35,929 --> 01:06:39,132
实况文本按钮通常位于右下角

1263
01:06:39,166 --> 01:06:41,401
但我的 app 中已经有个爱心按钮了

1264
01:06:41,435 --> 01:06:44,238
所以我可以使用自定义嵌入物调整它的位置

1265
01:06:44,271 --> 01:06:48,275
我还可以设置按钮的配置
自定义按钮风格

1266
01:06:48,308 --> 01:06:50,577
让它与我的 app 更匹配

1267
01:06:50,611 --> 01:06:54,848
现在我已经添加好了 我可以轻点实况文本按钮

1268
01:06:54,882 --> 01:06:56,316
选择文本

1269
01:06:56,350 --> 01:06:58,919
或者用快速操作轻松抓取地址

1270
01:07:00,487 --> 01:07:03,657
我很喜欢的是用户不用学习新的交互模式

1271
01:07:03,690 --> 01:07:08,295
因为它提供了与实况文本相同的易用性

1272
01:07:08,328 --> 01:07:10,430
UI 都是一致且熟悉的

1273
01:07:10,464 --> 01:07:12,499
与操作系统充分整合

1274
01:07:12,533 --> 01:07:16,503
但我还是可以调整位置
哪怕我已经有了自己的自定义 UI

1275
01:07:17,237 --> 01:07:19,273
当然 就像任何优秀送餐 app 一样

1276
01:07:19,306 --> 01:07:22,476
我们也希望为顾客提供最好的服务

1277
01:07:22,509 --> 01:07:25,479
确保他们得到正确的甜甜圈

1278
01:07:25,512 --> 01:07:28,982
所以 我们通过二维码追踪甜甜圈订单

1279
01:07:29,016 --> 01:07:33,420
使用新的数据扫描 API
我可以轻松添加该功能

1280
01:07:33,453 --> 01:07:35,923
让它成为与顾客互动的第一步

1281
01:07:35,956 --> 01:07:38,025
现在这个按钮什么都做不了

1282
01:07:38,058 --> 01:07:41,094
但我可以很容易地实例化一个
新的数据扫描对象

1283
01:07:41,128 --> 01:07:44,231
它可以寻找文本、二维码或条码

1284
01:07:44,264 --> 01:07:46,466
然后我可以将其导入我的 app

1285
01:07:46,500 --> 01:07:49,169
仅需几行代码 我就可以调出相机

1286
01:07:49,203 --> 01:07:53,373
指明我想要二维码 然后开始扫描

1287
01:07:53,407 --> 01:07:55,542
当司机轻点二维码时

1288
01:07:55,576 --> 01:07:58,011
我想显示出扫描成功

1289
01:07:58,045 --> 01:08:00,147
我可以在 Xcode 中添加委托处理程序

1290
01:08:03,517 --> 01:08:07,354
并在轻点时向用户显示扫描成功的提示

1291
01:08:07,387 --> 01:08:10,257
这样我就可以开始处理订单了

1292
01:08:10,290 --> 01:08:15,562
现在我运行 app 时
会调出带有相机视图的视图控制器

1293
01:08:15,596 --> 01:08:16,930
我可以看到引导信息

1294
01:08:16,964 --> 01:08:20,200
以及高亮显示二维码的标线视图

1295
01:08:20,234 --> 01:08:23,570
我轻点二维码时 就可以看到扫描成功了

1296
01:08:23,604 --> 01:08:25,973
甜甜圈订单已确认

1297
01:08:26,006 --> 01:08:30,444
就这样简单 我的 #freedonut 已经上路了

1298
01:08:30,477 --> 01:08:31,512
利用 VisionKit

1299
01:08:31,545 --> 01:08:34,448
全新的实况文本 API
和数据扫描 API

1300
01:08:34,481 --> 01:08:38,919
你可以轻松将这些强大的视觉功能
带给你的 app

1301
01:08:38,952 --> 01:08:41,288
好 现在交回给 Susan

1302
01:08:41,321 --> 01:08:44,725
对 app 开发来说 这真是个激动人心的时代

1303
01:08:44,758 --> 01:08:49,229
Xcode Cloud 现在已经准备就绪
帮你更快地构建更优秀的 app

1304
01:08:49,263 --> 01:08:51,265
Swift 和 SwiftUI

1305
01:08:51,298 --> 01:08:57,571
更便于你讲奇思妙想融入 app 中
并且适用于 Apple 的各个平台

1306
01:08:57,604 --> 01:09:00,307
还有很酷的新方法 帮你把你的想法

1307
01:09:00,340 --> 01:09:02,776
并和系统体验相整合

1308
01:09:02,809 --> 01:09:04,878
锁定屏幕小组件和实时活动

1309
01:09:04,912 --> 01:09:07,481
把你的 app 带到锁定屏幕上

1310
01:09:07,514 --> 01:09:10,250
Messages Collaboration 让你的用户

1311
01:09:10,284 --> 01:09:13,353
可以无比轻松地联络和协作

1312
01:09:13,387 --> 01:09:17,791
而 App Intents 可以帮你把 app
和 Siri 整合在一起

1313
01:09:17,824 --> 01:09:19,826
还有各种全新的 API

1314
01:09:19,860 --> 01:09:22,362
以及对现有 API 的重大更新

1315
01:09:22,396 --> 01:09:27,000
如 WeatherKit、MapKit
实况文本和 Metal

1316
01:09:27,034 --> 01:09:28,869
而这还不是全部

1317
01:09:28,902 --> 01:09:32,072
今年的 WWDC 又是一大盛事

1318
01:09:32,105 --> 01:09:34,241
175 场讲座

1319
01:09:34,274 --> 01:09:39,012
数百个实验室以及数字聊天室活动
贯穿整个星期

1320
01:09:39,046 --> 01:09:41,315
我们迫不及待在这周与大家见面

1321
01:09:41,348 --> 01:09:44,518
更重要的是 这周的主角是你们

1322
01:09:44,551 --> 01:09:47,421
我们迫不及待地想看到你们的下一个大作

1323
01:09:47,454 --> 01:09:49,256
谢谢大家！

1324
01:09:49,289 --> 01:09:57,297
♪ ♪

1325
01:10:06,340 --> 01:10:14,348
.

