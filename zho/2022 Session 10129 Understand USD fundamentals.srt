1
00:00:00,000 --> 00:00:03,003
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,003 --> 00:00:09,510
♪

3
00:00:09,510 --> 00:00:12,145
您好 欢迎来到 WWDC

4
00:00:12,145 --> 00:00:14,047
我是 Kacey

5
00:00:14,047 --> 00:00:16,617
您可能已经见到过“通用场景描述”

6
00:00:16,617 --> 00:00:18,218
或者简称为 USD

7
00:00:18,218 --> 00:00:21,555
您可能已经在增强现实中
与 USD 文件进行了交互

8
00:00:21,555 --> 00:00:25,058
您也可能已经有将资产
从其他格式转换为 USD 的经验

9
00:00:25,058 --> 00:00:28,195
但是 USD 文件里究竟有什么呢？

10
00:00:28,195 --> 00:00:31,365
USD 是一项
具有独特功能的重要技术

11
00:00:31,365 --> 00:00:32,933
就让我们一起揭开它的神秘面纱

12
00:00:32,933 --> 00:00:36,370
来探讨 USD 的基本原理吧

13
00:00:36,370 --> 00:00:39,139
我们将了解 USD 是什么

14
00:00:39,139 --> 00:00:42,843
介绍一些基础的 USD 概念

15
00:00:42,843 --> 00:00:46,113
学习如何用 USD 构建场景

16
00:00:46,113 --> 00:00:50,684
并了解 USD 的文件格式

17
00:00:50,684 --> 00:00:53,921
首先 什么是 USD？

18
00:00:53,921 --> 00:00:56,924
USD 由 Pixar 动画工作室开发

19
00:00:56,924 --> 00:00:59,693
帮助工作室创作出
那些深受我们喜爱的精彩电影

20
00:00:59,693 --> 00:01:02,696
它也在影视、娱乐

21
00:01:02,696 --> 00:01:04,665
和其他行业中有着广泛应用

22
00:01:04,665 --> 00:01:07,201
它被设计为可扩展的
并且正在迅速作为一种

23
00:01:07,201 --> 00:01:10,370
具备协作性的关键工作流技术崛起

24
00:01:10,370 --> 00:01:12,506
它是一个建立在数十年

25
00:01:12,506 --> 00:01:14,908
电影行业制作经验基础上的开源项目

26
00:01:14,908 --> 00:01:17,211
并且越来越多地被用于游戏

27
00:01:17,211 --> 00:01:22,416
模拟、增强现实、制造业和电子商务

28
00:01:22,416 --> 00:01:24,818
USD 有三个核心要素

29
00:01:24,818 --> 00:01:27,921
场景描述规范、API

30
00:01:27,921 --> 00:01:30,824
和渲染系统

31
00:01:30,824 --> 00:01:35,529
您的 App 使用 API 与 USD 进行交互

32
00:01:35,529 --> 00:01:36,964
渲染系统为使用不同

33
00:01:36,964 --> 00:01:41,468
渲染器进行场景可视化提供支持

34
00:01:41,468 --> 00:01:44,605
Apple 有多种多样的 USD 渲染系统

35
00:01:44,605 --> 00:01:47,341
请查看“探讨 USD 工具与渲染”讲座

36
00:01:47,341 --> 00:01:50,677
了解更多信息

37
00:01:50,677 --> 00:01:51,879
在今天的讲座中

38
00:01:51,879 --> 00:01:54,381
我们将集中了解场景描述规范

39
00:01:54,381 --> 00:01:56,617
它说明了如何描述场景数据

40
00:01:56,617 --> 00:01:58,018
如何组织这些数据

41
00:01:58,018 --> 00:02:02,155
以及如何用文件格式来对其进行表述

42
00:02:02,155 --> 00:02:04,958
究其本质
这些 USD 文件中包含了

43
00:02:04,958 --> 00:02:07,628
描述场景应有外观的数据

44
00:02:07,628 --> 00:02:09,763
渲染 App 解译这些数据

45
00:02:09,763 --> 00:02:12,633
并在屏幕上生成图像

46
00:02:12,633 --> 00:02:15,936
比如说 在去年的 WWDC 讲座中

47
00:02:15,936 --> 00:02:19,940
我们创建了这个 USD 场景
并用 Octane 对它进行了渲染

48
00:02:19,940 --> 00:02:22,242
现在让我们深入探讨基本概念

49
00:02:22,242 --> 00:02:24,811
并了解渲染背后的数据

50
00:02:24,811 --> 00:02:26,246
为了简单起见

51
00:02:26,246 --> 00:02:29,550
我们将使用文本 USD 表述

52
00:02:29,550 --> 00:02:32,386
USD 有很多很酷的功能
我们都想一一谈到

53
00:02:32,386 --> 00:02:33,787
但因为时间有限

54
00:02:33,787 --> 00:02:35,255
我们将集中讲解您在使用 USD 时

55
00:02:35,255 --> 00:02:36,723
可能最常遇到的必要功能

56
00:02:36,723 --> 00:02:41,361
比如舞台、基元和层级

57
00:02:41,361 --> 00:02:43,297
它们只是其中的几个例子

58
00:02:43,297 --> 00:02:45,832
让我们从舞台开始

59
00:02:45,832 --> 00:02:48,969
想象一下 我们正在剧院观看戏剧

60
00:02:48,969 --> 00:02:51,371
作为观众 我们观察着舞台上

61
00:02:51,371 --> 00:02:54,341
演员的表演 留意环境

62
00:02:54,341 --> 00:02:56,877
灯光和道具

63
00:02:56,877 --> 00:03:01,281
这很好地类比了舞台
在 USD 中运作的方式

64
00:03:01,281 --> 00:03:04,051
一个舞台就是一个场景图表
或者数据结构

65
00:03:04,051 --> 00:03:06,086
用于以分等级的方式

66
00:03:06,086 --> 00:03:07,487
在所有场景元素集中之处

67
00:03:07,487 --> 00:03:10,624
对图像信息进行组织

68
00:03:10,624 --> 00:03:13,293
一个舞台是单个或多个层级的组合

69
00:03:13,293 --> 00:03:18,298
它们通常是包含场景信息的文件

70
00:03:18,298 --> 00:03:20,767
一般来说舞台是由基元组成的

71
00:03:20,767 --> 00:03:24,104
基元是场景的主要容器对象

72
00:03:24,104 --> 00:03:25,606
基元可以通过包含其他基元

73
00:03:25,606 --> 00:03:28,108
来创建场景元素的层级结构

74
00:03:28,108 --> 00:03:30,844
我们来看一个例子

75
00:03:30,844 --> 00:03:33,780
左侧是一个示例 USD 分层

76
00:03:33,780 --> 00:03:36,650
在右侧 我们可以看到舞台的

77
00:03:36,650 --> 00:03:38,352
预览视觉表述

78
00:03:38,352 --> 00:03:43,624
我们可以看到两个基元
一个球体和一个立方体

79
00:03:43,624 --> 00:03:45,526
每个基元都有特定的类型

80
00:03:45,526 --> 00:03:48,662
来定义它在舞台中代表什么

81
00:03:48,662 --> 00:03:50,230
构成一个舞台的基元类型有很多

82
00:03:50,230 --> 00:03:55,068
比如网格、灯光和材质

83
00:03:55,068 --> 00:03:56,303
在这个例子当中

84
00:03:56,303 --> 00:03:59,406
球体基元有一个
名为 Sphere 的类型

85
00:03:59,406 --> 00:04:03,710
立方体基元有一个
名为 Cube 的类型

86
00:04:03,710 --> 00:04:06,280
这提出了一个很好的问题

87
00:04:06,280 --> 00:04:10,017
USD 怎么知道这些
基元类型代表的含义呢？

88
00:04:10,017 --> 00:04:12,419
USD 是通过使用模式来了解的

89
00:04:12,419 --> 00:04:14,021
模式是用于定义基元

90
00:04:14,021 --> 00:04:16,957
在舞台上角色的结构化数据

91
00:04:16,957 --> 00:04:19,293
它们为常见的场景概念提供意义

92
00:04:19,293 --> 00:04:22,529
比如几何、材料等等

93
00:04:22,529 --> 00:04:23,797
在这个例子中

94
00:04:23,797 --> 00:04:26,466
这就是一个球体的模式定义

95
00:04:26,466 --> 00:04:28,435
它定义了每个球体都有半径

96
00:04:28,435 --> 00:04:31,104
和边界框范围

97
00:04:31,104 --> 00:04:34,174
使用现有的模式
USD 为您提供了丰富的

98
00:04:34,174 --> 00:04:38,011
内置类型基础 用于描述您的场景

99
00:04:38,011 --> 00:04:41,849
自定义模式使您
能够进一步扩展 USD

100
00:04:41,849 --> 00:04:44,852
您可以提供自己的模式
来表述您的自定义数据

101
00:04:44,852 --> 00:04:47,421
用于您自己的案例和工作流程中

102
00:04:47,421 --> 00:04:49,890
模式不需要具备视觉表述

103
00:04:49,890 --> 00:04:52,125
它们可以只是您想在舞台上

104
00:04:52,125 --> 00:04:54,428
以结构化且有意义的方式
保有的数据

105
00:04:54,428 --> 00:04:55,529
举例来说

106
00:04:55,529 --> 00:04:59,433
我在这里创建了一个
名为“WWDC”的新模式

107
00:04:59,433 --> 00:05:01,268
它定义了一个含有标题和

108
00:05:01,268 --> 00:05:03,370
相关年份的基元

109
00:05:03,370 --> 00:05:06,373
这个名为“WWDC22”的基元

110
00:05:06,373 --> 00:05:07,908
就使用了该模式

111
00:05:07,908 --> 00:05:09,877
它已将年份设定为 2022 年

112
00:05:09,877 --> 00:05:12,613
并将标题设为“调用代码”

113
00:05:12,613 --> 00:05:14,982
年份和标题被称作

114
00:05:14,982 --> 00:05:16,183
基元的“属性”

115
00:05:16,183 --> 00:05:18,519
基元可以有各种各样的属性

116
00:05:18,519 --> 00:05:21,622
每种属性都由类型和值构成

117
00:05:21,622 --> 00:05:24,024
属性也可以带有创建的默认值

118
00:05:24,024 --> 00:05:25,826
这样它们就不必在使用此

119
00:05:25,826 --> 00:05:28,395
模式的基元中进行明确定义

120
00:05:28,395 --> 00:05:30,163
回到我们的 Sphere 模式

121
00:05:30,163 --> 00:05:31,899
您可以看到我们是如何为

122
00:05:31,899 --> 00:05:34,902
半径和范围属性定义默认值的

123
00:05:34,902 --> 00:05:37,638
这一层级中有一个
单独的 Sphere 基元

124
00:05:37,638 --> 00:05:39,840
由于未设置 Radius 属性

125
00:05:39,840 --> 00:05:42,042
它就从 Sphere 模式中衍生出值

126
00:05:42,042 --> 00:05:43,911
默认半径为 1

127
00:05:43,911 --> 00:05:47,281
我们当然也可以明确地设置半径属性

128
00:05:47,281 --> 00:05:48,749
球体看起来和之前一样

129
00:05:48,749 --> 00:05:50,951
因为设置值与模式中

130
00:05:50,951 --> 00:05:52,686
默认设置的值“1”匹配

131
00:05:52,686 --> 00:05:57,124
现在让我们添加第二个球体
并将半径设置为 0.5

132
00:05:57,124 --> 00:05:58,825
我们可以看到
它确实只有另一个球体的

133
00:05:58,825 --> 00:06:00,694
一半那么大

134
00:06:00,694 --> 00:06:04,865
属性、基元和舞台也可以包含元数据

135
00:06:04,865 --> 00:06:07,234
元数据是可以为场景中某些部分

136
00:06:07,234 --> 00:06:10,604
提供辅助数据的信息的键值对

137
00:06:10,604 --> 00:06:13,807
元数据在它适用的级别中设置

138
00:06:13,807 --> 00:06:15,809
影响整个舞台的元数据

139
00:06:15,809 --> 00:06:19,246
和其中的所有基元
都设置在舞台这一级

140
00:06:19,246 --> 00:06:21,215
特定于单个基元的元数据

141
00:06:21,215 --> 00:06:23,584
则设置在基元上

142
00:06:23,584 --> 00:06:26,019
属性也可以含有元数据

143
00:06:26,019 --> 00:06:30,224
比如说 这是典型的舞台元数据

144
00:06:30,224 --> 00:06:33,760
metersPerUnit
定义场景的比例单位

145
00:06:33,760 --> 00:06:36,830
upAxis 定义 X、 Y 或 Z 轴中哪一个

146
00:06:36,830 --> 00:06:41,168
是对场景中相机而言朝上的方向

147
00:06:41,168 --> 00:06:43,170
doc 字符串存储有用的文档

148
00:06:43,170 --> 00:06:46,807
用于工作流的跟踪

149
00:06:46,807 --> 00:06:48,742
现在我们已经定义了基础信息

150
00:06:48,742 --> 00:06:51,545
就可以开始使用 USD 了

151
00:06:51,545 --> 00:06:53,347
让我们看看仅使用这些概念

152
00:06:53,347 --> 00:06:55,849
是怎么做出煎饼的场景的

153
00:06:55,849 --> 00:06:56,917
在这个层级中

154
00:06:56,917 --> 00:07:00,654
我们创建了名为
Pancakes 的转换基元

155
00:07:00,654 --> 00:07:03,690
再添加一个名为
Blueberry_01 的转换基元

156
00:07:03,690 --> 00:07:06,894
它是 Pancakes 基元的子基元

157
00:07:06,894 --> 00:07:11,632
在 Blueberry_01 基元中
我们加入了 Mesh 基元

158
00:07:11,632 --> 00:07:14,001
Mesh 基元中保存着蓝莓的几何形状

159
00:07:14,001 --> 00:07:17,037
并将其与材料绑定

160
00:07:17,037 --> 00:07:18,539
让我们通过添加其他基元

161
00:07:18,539 --> 00:07:21,275
完成剩余资产的构建

162
00:07:21,275 --> 00:07:23,243
这是我们仅使用基本概念

163
00:07:23,243 --> 00:07:25,245
完成的煎饼场景

164
00:07:28,849 --> 00:07:30,684
基础知识可以让您走得很远

165
00:07:30,684 --> 00:07:32,386
但在以生产为中心的项目中

166
00:07:32,386 --> 00:07:34,388
我们需要与许多不同的团队成员

167
00:07:34,388 --> 00:07:36,290
和组织进行协作

168
00:07:36,290 --> 00:07:38,425
USD 有很多可以满足这一需求的功能

169
00:07:38,425 --> 00:07:41,662
通过“组合”来实现

170
00:07:41,662 --> 00:07:43,697
组合使通过不同场景描述单元

171
00:07:43,697 --> 00:07:46,733
创建舞台成为可能

172
00:07:46,733 --> 00:07:48,836
它允许在实现协作和

173
00:07:48,836 --> 00:07:51,138
快速迭代的场景中

174
00:07:51,138 --> 00:07:53,574
有效地重复使用 3D 元素

175
00:07:53,574 --> 00:07:56,510
我们将讨论最常见的组合类型

176
00:07:56,510 --> 00:08:01,181
分层、引用、有效负载和变体集

177
00:08:01,181 --> 00:08:03,217
不过 让我们用有趣
一点的方式来探讨吧

178
00:08:03,217 --> 00:08:05,586
想玩国际象棋吗？

179
00:08:05,586 --> 00:08:07,788
就让我们来构建
一套国际象棋的场景吧

180
00:08:07,788 --> 00:08:09,089
在场景中

181
00:08:09,089 --> 00:08:12,159
我们将在目录层级中使用资产目录

182
00:08:12,159 --> 00:08:14,695
它指的是我们的棋子

183
00:08:14,695 --> 00:08:16,864
然后我们将这些棋子在布局层中

184
00:08:16,864 --> 00:08:19,399
排列在棋盘上 得到最终结果

185
00:08:19,399 --> 00:08:22,536
结果可以通过
ChessSet 层级查看

186
00:08:22,536 --> 00:08:25,572
首先要制作我们的棋子

187
00:08:25,572 --> 00:08:28,442
在国际象棋中 有六类主要的棋子

188
00:08:28,442 --> 00:08:35,015
士兵、城堡、主教
骑士、王后和国王

189
00:08:35,015 --> 00:08:37,584
我们将使用这些
通过 Object Capture 创建的资产

190
00:08:37,584 --> 00:08:40,487
来构建一套完整的国际象棋

191
00:08:40,487 --> 00:08:42,656
让我们先使用一个 USD 概念

192
00:08:42,656 --> 00:08:45,893
来把棋子带入舞台 这就是引用

193
00:08:45,893 --> 00:08:49,463
引用是指一个舞台
中的基元引用另一个

194
00:08:49,463 --> 00:08:51,932
在同一舞台或不同层级的基元

195
00:08:51,932 --> 00:08:54,535
而无需复制数据

196
00:08:54,535 --> 00:08:56,904
这有助于最大限度地减少数据重复

197
00:08:56,904 --> 00:08:58,872
并允许不同的人和 App

198
00:08:58,872 --> 00:09:01,675
分别更新数据

199
00:09:01,675 --> 00:09:06,380
让我们将士兵棋子资产引用到场景中

200
00:09:06,380 --> 00:09:10,150
在目录层级中
我们定义了一个名为 Pawn 的基元

201
00:09:10,150 --> 00:09:15,556
到目前为止它还没有任何数据
所以我们的舞台仍然是空的

202
00:09:15,556 --> 00:09:19,459
接下来 我们要添加
对 Pawn.usda 层级的引用

203
00:09:19,459 --> 00:09:20,994
这会将士兵棋子资产引入

204
00:09:20,994 --> 00:09:24,097
我们可以在目录层级看到它

205
00:09:24,097 --> 00:09:26,166
但 USD 是怎么知道
应该从您引用的

206
00:09:26,166 --> 00:09:28,368
文件中带入哪个基元呢？

207
00:09:28,368 --> 00:09:32,439
我们可以使用 defaultPrim
元数据指定这个基元

208
00:09:32,439 --> 00:09:35,409
defaultPrim 元数据在舞台上定义

209
00:09:35,409 --> 00:09:37,477
并指定在另一舞台使用此场景时

210
00:09:37,477 --> 00:09:40,280
应该引用哪个基元

211
00:09:40,280 --> 00:09:44,418
我们建议始终
为 USD 资产创建 defaultPrim

212
00:09:44,418 --> 00:09:45,719
让我们检查一下士兵棋子资产

213
00:09:45,719 --> 00:09:48,422
确保创建了 defaultPrim

214
00:09:48,422 --> 00:09:50,691
我们可以在资产的舞台这一级

215
00:09:50,691 --> 00:09:51,892
看到 defaultPrim 元数据

216
00:09:51,892 --> 00:09:53,894
很好

217
00:09:53,894 --> 00:09:57,097
在其他情况下
如果没有创建 defaultPrim

218
00:09:57,097 --> 00:09:58,699
或者您想引用一个

219
00:09:58,699 --> 00:10:00,767
与 defaultPrim 不同的基元

220
00:10:00,767 --> 00:10:02,436
您可以在引用层级明确指定

221
00:10:02,436 --> 00:10:04,338
基元的路径

222
00:10:04,338 --> 00:10:08,342
在等级结构中的任何位置均可

223
00:10:08,342 --> 00:10:12,579
USD 中的路径
用于标识舞台上的元素

224
00:10:12,579 --> 00:10:16,049
基元路径是基元的唯一标识符

225
00:10:16,049 --> 00:10:19,820
举例来说 在这个舞台中
我们可以看到三个基元

226
00:10:19,820 --> 00:10:23,323
“世界”基元的基元路径为 /World

227
00:10:23,323 --> 00:10:24,691
“士兵”和“骑士”基元

228
00:10:24,691 --> 00:10:27,361
被认为是“世界”的子基元

229
00:10:27,361 --> 00:10:31,131
因此 通往“士兵” 的
路径将是 /World/Pawn

230
00:10:31,131 --> 00:10:36,737
而通往“骑士”的路径
则是 /World/Knight

231
00:10:36,737 --> 00:10:39,806
有了这个概念后 我们可以明确

232
00:10:39,806 --> 00:10:44,211
基元路径设置到
我们引用中的 Pawn 基元

233
00:10:44,211 --> 00:10:46,180
对于较大的场景 一次性加载

234
00:10:46,180 --> 00:10:49,049
所有场景信息可能代价过高

235
00:10:49,049 --> 00:10:51,251
因此 USD 允许使用一种

236
00:10:51,251 --> 00:10:52,953
名为“有效负载”的引用类型

237
00:10:52,953 --> 00:10:56,290
对将场景描述搬上舞台的
动作进行延迟加载

238
00:10:56,290 --> 00:10:58,258
在引用大型数据集时推荐使用

239
00:10:58,258 --> 00:11:00,827
有效负载 例如复杂的几何图形

240
00:11:00,827 --> 00:11:02,162
或其他表示道具和角色的

241
00:11:02,162 --> 00:11:04,164
大型场景图

242
00:11:07,434 --> 00:11:10,003
由于我们会将这些
资产引用转换为有效负载

243
00:11:10,003 --> 00:11:14,541
所以可以选择延迟加载棋子

244
00:11:14,541 --> 00:11:16,577
如果我们选择不加载有效负载

245
00:11:16,577 --> 00:11:20,247
则场景在最初打开时显示为空

246
00:11:20,247 --> 00:11:22,182
一旦启用了加载有效负载

247
00:11:22,182 --> 00:11:24,518
就可以重新看到我们的棋子

248
00:11:24,518 --> 00:11:26,453
现在我们的场景中有了棋子

249
00:11:26,453 --> 00:11:28,889
现在可以开始把它们排列在棋盘上

250
00:11:28,889 --> 00:11:30,424
我们可以使用 USD 的

251
00:11:30,424 --> 00:11:33,260
分层概念 在另一个层级上完成

252
00:11:33,260 --> 00:11:35,929
通过分层 层级可以堆叠起来

253
00:11:35,929 --> 00:11:38,265
原理类似于流行的图像编辑软件

254
00:11:38,265 --> 00:11:41,535
例如 Photoshop 和 Affinity Photo

255
00:11:41,535 --> 00:11:43,537
位于一个层级上方
另一个层级中的基元

256
00:11:43,537 --> 00:11:46,540
被视为更强 可以添加或覆盖

257
00:11:46,540 --> 00:11:49,076
较低层级中的数据

258
00:11:49,076 --> 00:11:50,377
正如您所看到的

259
00:11:50,377 --> 00:11:53,180
棋子目前的位置都是错误的

260
00:11:53,180 --> 00:11:55,082
但是不用担心 我们可以使用分层

261
00:11:55,082 --> 00:11:58,719
对其他层级进行非破坏性修改

262
00:11:58,719 --> 00:12:00,454
这非常适合在无需编辑

263
00:12:00,454 --> 00:12:04,091
目录层级的情况下
将棋子移动到正确的位置

264
00:12:04,091 --> 00:12:06,660
让我们来看看这应该如何完成

265
00:12:06,660 --> 00:12:09,596
首先创建一个
名为 ChessSet 的新舞台

266
00:12:09,596 --> 00:12:12,132
它将是我们最后的场景

267
00:12:12,132 --> 00:12:13,834
在层级的顶部 它包含了一个

268
00:12:13,834 --> 00:12:15,802
名为“子层级”的元数据

269
00:12:15,802 --> 00:12:20,574
现在我们将棋子与目录层级一起引入

270
00:12:20,574 --> 00:12:23,777
接下来 我们新建一个层级
Layout.usda

271
00:12:23,777 --> 00:12:27,781
用来移动棋子

272
00:12:27,781 --> 00:12:29,983
这个布局层级将包含

273
00:12:29,983 --> 00:12:31,818
棋子的位置信息

274
00:12:31,818 --> 00:12:34,922
让我们开始覆盖棋子在场景中的位置

275
00:12:34,922 --> 00:12:37,858
我们先从 Pawn_01 开始

276
00:12:37,858 --> 00:12:39,860
我们通过更改士兵棋子资产的

277
00:12:39,860 --> 00:12:42,663
平移属性 来修改它的位置

278
00:12:42,663 --> 00:12:46,767
让我们来看看这将如何更新场景

279
00:12:46,767 --> 00:12:50,003
这是没有布局层级的国际象棋盘

280
00:12:50,003 --> 00:12:53,407
所以士兵棋子仍在它原来的位置上

281
00:12:53,407 --> 00:12:55,976
一旦我们添加了布局层级
士兵棋子就被移动到了

282
00:12:55,976 --> 00:12:59,213
它在棋盘上的预期位置

283
00:12:59,213 --> 00:13:00,948
让我们对其他棋子进行同样的操作

284
00:13:00,948 --> 00:13:03,250
将它们移动到正确的位置上

285
00:13:04,952 --> 00:13:06,286
我们摆放其他棋子的方法

286
00:13:06,286 --> 00:13:09,056
和摆放士兵棋子一样

287
00:13:09,056 --> 00:13:12,226
这里我们移动了 Pawn_02

288
00:13:12,226 --> 00:13:16,530
然后是 Pawn_03 以此类推

289
00:13:16,530 --> 00:13:18,398
我们完成了对布局层级的更改

290
00:13:18,398 --> 00:13:21,535
将棋子放置在了正确的位置上

291
00:13:23,904 --> 00:13:26,206
我们的国际象棋已经完成了半套

292
00:13:26,206 --> 00:13:29,676
我们使用层级将
资产与目录层级一起引入

293
00:13:29,676 --> 00:13:32,045
并通过布局层级的覆盖将它们

294
00:13:32,045 --> 00:13:33,680
放置在棋盘上

295
00:13:35,716 --> 00:13:37,451
剩下的就是为对手方

296
00:13:37,451 --> 00:13:39,520
设置棋子

297
00:13:39,520 --> 00:13:41,622
需要注意的是对手的棋子

298
00:13:41,622 --> 00:13:43,557
颜色不同

299
00:13:43,557 --> 00:13:45,526
无需重新制作一套新的资产

300
00:13:45,526 --> 00:13:47,227
我们可以使用另一个 USD 概念

301
00:13:47,227 --> 00:13:50,864
“变体集”来更新我们的棋子资产

302
00:13:50,864 --> 00:13:53,233
变体集允许舞台上的

303
00:13:53,233 --> 00:13:56,170
离散替代物进行动态交换

304
00:13:56,170 --> 00:13:57,871
变体集中包含的变体

305
00:13:57,871 --> 00:14:00,440
可以是不同的材料、几何形状、

306
00:14:00,440 --> 00:14:03,944
以及一切
可以用 USD 表述的东西

307
00:14:03,944 --> 00:14:06,079
在舞台上进行不同变体之间的切换

308
00:14:06,079 --> 00:14:08,348
是非破坏性的

309
00:14:08,348 --> 00:14:10,217
我们将设置变体集

310
00:14:10,217 --> 00:14:14,321
在棋子的不同材料之间进行切换

311
00:14:14,321 --> 00:14:17,658
在“士兵”资产中
我们添加名为“color”的变量集

312
00:14:17,658 --> 00:14:21,195
这样就可以在士兵棋子的
不同颜色之间进行切换

313
00:14:21,195 --> 00:14:24,198
现在我们将两个变体添加到变体集

314
00:14:24,198 --> 00:14:30,571
Dark 使用深色材质
Light 使用浅色材质

315
00:14:30,571 --> 00:14:33,473
最后 我们设置默认变体来指定

316
00:14:33,473 --> 00:14:38,245
将士兵棋子加载到
舞台上时具体使用哪一个

317
00:14:38,245 --> 00:14:40,914
现在 我们回到目录层级

318
00:14:40,914 --> 00:14:42,850
所有的棋子都已经摆好了

319
00:14:42,850 --> 00:14:45,652
但它们都使用了浅色材料

320
00:14:45,652 --> 00:14:47,154
那是因为默认变体

321
00:14:47,154 --> 00:14:49,690
设置为浅色材质

322
00:14:49,690 --> 00:14:51,558
让我们将其中一个棋子的变体

323
00:14:51,558 --> 00:14:54,561
更改为深色材料

324
00:14:54,561 --> 00:14:56,363
我们将变体设置为 Dark

325
00:14:56,363 --> 00:14:58,532
我们可以看到对方阵营中的一个棋子

326
00:14:58,532 --> 00:15:00,634
现在变成了深色

327
00:15:00,634 --> 00:15:04,872
让我们也将更改应用于其他棋子

328
00:15:04,872 --> 00:15:07,608
我们的这套国际象棋终于完成了

329
00:15:09,209 --> 00:15:13,013
我们还可以使用另一个
USD 概念来优化我们的场景

330
00:15:13,013 --> 00:15:15,415
场景图实例化

331
00:15:15,415 --> 00:15:17,017
场景图实例化允许我们

332
00:15:17,017 --> 00:15:20,020
在舞台上多次重复使用场景图的局部

333
00:15:20,020 --> 00:15:21,221
用于表述任何包含

334
00:15:21,221 --> 00:15:24,691
不止一种元素的物件
例如树叶、家具

335
00:15:24,691 --> 00:15:27,661
还有我们案例中的棋子

336
00:15:27,661 --> 00:15:29,863
使用场景图实例化
将同时为您的 App

337
00:15:29,863 --> 00:15:33,267
提供内存和性能的提升

338
00:15:33,267 --> 00:15:35,102
要使用场景图实例化

339
00:15:35,102 --> 00:15:37,571
我们可以在基元或场景图的局部

340
00:15:37,571 --> 00:15:40,140
指定实例元数据

341
00:15:40,140 --> 00:15:42,176
所有实例化的基元都可以

342
00:15:42,176 --> 00:15:44,578
共享同一个场景图

343
00:15:44,578 --> 00:15:48,348
让我们在场景中
添加对基元实例化的支持

344
00:15:48,348 --> 00:15:51,385
在目录文件中 我们将
元数据 instanceable

345
00:15:51,385 --> 00:15:55,022
添加到棋子基元 并将值设置为真

346
00:15:55,022 --> 00:15:57,925
通过添加此元数据
USD 现在将把这些资产

347
00:15:57,925 --> 00:16:01,495
看作共享相同数据的
潜在可实例化基元

348
00:16:01,495 --> 00:16:05,199
而不再去为每个基元复制数据

349
00:16:05,199 --> 00:16:07,000
我们的国际象棋盘看起来还是一样

350
00:16:07,000 --> 00:16:10,070
但现在 它的性能和
内存效率都提高了

351
00:16:10,070 --> 00:16:12,573
这样一来 我们的
这套国际象棋就完成了！

352
00:16:12,573 --> 00:16:16,009
它看起来很棒 我们也练习了
各种 USD 功能的使用

353
00:16:17,311 --> 00:16:21,215
分层、引用、有效负载和变体集

354
00:16:21,215 --> 00:16:25,452
只是 USD 定义的几个组合类型

355
00:16:25,452 --> 00:16:26,854
USD 对场景图的创建

356
00:16:26,854 --> 00:16:28,822
有特定的强度顺序

357
00:16:28,822 --> 00:16:32,292
以确保一致的场景表述

358
00:16:32,292 --> 00:16:34,127
有关组合的更多信息

359
00:16:34,127 --> 00:16:36,363
和首字母缩写为 LIVRPS 的命令

360
00:16:36,363 --> 00:16:40,467
您都可以在 Pixar 的
USD 文档中进一步了解

361
00:16:40,467 --> 00:16:41,768
在今天的讲座中

362
00:16:41,768 --> 00:16:44,238
我们探讨了 USD 文件中的内容

363
00:16:44,238 --> 00:16:46,340
现在让我们来谈谈文件本身

364
00:16:46,340 --> 00:16:48,909
以及它们出现在磁盘上的方式

365
00:16:48,909 --> 00:16:51,745
USD 文件的类型有以下几种

366
00:16:51,745 --> 00:16:53,947
包含可读 ASCII 文本的 USD 文件

367
00:16:53,947 --> 00:16:56,283
使用 .usda 扩展名

368
00:16:56,283 --> 00:16:59,953
在今天的讲座中
我们一直在使用这些文件

369
00:16:59,953 --> 00:17:02,789
更紧凑、更高效的二进制表述

370
00:17:02,789 --> 00:17:07,227
是箱格式 扩展名为 .usdc

371
00:17:07,227 --> 00:17:10,497
您可能还会看到
使用 .usd 扩展名的文件

372
00:17:10,497 --> 00:17:15,035
它们既可以是 ASCII 文本
也可能是二进制箱文件

373
00:17:15,035 --> 00:17:18,539
最后 USD 还有一个打包格式

374
00:17:18,539 --> 00:17:21,542
可以将多个 USD 文件
和相关的辅助文件

375
00:17:21,542 --> 00:17:24,111
比如纹理 囊括在
一个未压缩的 zip 存档中

376
00:17:24,111 --> 00:17:27,681
使用 .usdz 扩展名

377
00:17:27,681 --> 00:17:31,318
今天我们了解了 USD 的基本概念

378
00:17:31,318 --> 00:17:38,358
舞台、层级、基元
模式、属性和元数据

379
00:17:38,358 --> 00:17:40,427
我们使用这些概念
来构建了一套国际象棋

380
00:17:40,427 --> 00:17:44,264
并使用了引用、有效负载、默认基元

381
00:17:44,264 --> 00:17:48,202
基元路径、分层和实例化

382
00:17:48,202 --> 00:17:51,905
最后 我们讨论了
不同的 USD 文件格式

383
00:17:51,905 --> 00:17:57,344
.usda, .usdc
.usd 和 .usdz

384
00:17:57,344 --> 00:17:59,646
我们鼓励您
通过 Pixar 的 USD 文档

385
00:17:59,646 --> 00:18:02,749
更深入地了解这些概念
并在您的 App 中

386
00:18:02,749 --> 00:18:05,919
充分利用 USD 的功能

387
00:18:05,919 --> 00:18:07,387
谢谢！

388
00:18:07,387 --> 00:18:11,391
♪

