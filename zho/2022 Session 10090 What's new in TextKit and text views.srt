1
00:00:00,334 --> 00:00:06,340
[欢快的音乐]

2
00:00:09,309 --> 00:00:13,714
大家好 欢迎收看
“TextKit 和文本视图的新功能”

3
00:00:14,681 --> 00:00:17,384
我叫 Donna Tom
是一名 TextKit 工程师

4
00:00:18,752 --> 00:00:23,924
在 iOS 15 和 macOS Monterey 中
我们引入了 TextKit 2

5
00:00:23,957 --> 00:00:27,094
这是一个功能强大的新文本引擎
具有更高的性能

6
00:00:27,127 --> 00:00:29,263
正确性和安全性

7
00:00:30,264 --> 00:00:33,100
TextKit 2 基于视口的布局架构

8
00:00:33,133 --> 00:00:35,469
提供了高性能的文本布局

9
00:00:35,502 --> 00:00:38,705
尤其是对于包含大量内容的文档

10
00:00:40,174 --> 00:00:44,711
TextKit 2 通过消除使用字形
不必要的复杂性

11
00:00:44,745 --> 00:00:49,049
为全球的用户提供了
更好的文本体验

12
00:00:49,082 --> 00:00:52,219
并且它完全支持 OpenType

13
00:00:52,252 --> 00:00:54,621
和可变字体等现代字体技术

14
00:00:56,356 --> 00:00:59,359
TextKit 2 专注于使用更高级的对象

15
00:00:59,393 --> 00:01:01,261
来控制文本布局

16
00:01:01,295 --> 00:01:04,665
使您可以更轻松地自定义文本的布局

17
00:01:04,698 --> 00:01:07,768
从而可以用更少的代码
来构建更酷的东西

18
00:01:10,504 --> 00:01:12,773
接下来 TextKit 2 引擎构成了

19
00:01:12,806 --> 00:01:18,145
所有 Apple 平台上
文本布局和渲染的基础

20
00:01:19,713 --> 00:01:24,051
未来的性能增强 更新和改进

21
00:01:24,084 --> 00:01:27,387
都将集中在 TextKit 2 引擎上

22
00:01:28,188 --> 00:01:31,258
更新到 TextKit 2 后
您的 App 将可以

23
00:01:31,291 --> 00:01:33,560
在我们推出这些改进后
从中受益

24
00:01:34,394 --> 00:01:36,563
有关 TextKit2 的深入介绍

25
00:01:36,597 --> 00:01:39,900
请观看 Meet TextKit2 视频

26
00:01:39,933 --> 00:01:42,669
该视频涵盖了基础知识

27
00:01:42,703 --> 00:01:46,807
以及如何使用 TextKit 2
构建自己的文本布局组件

28
00:01:47,641 --> 00:01:52,579
另一方面 本视频则会介绍
TextKit 2 的最新进展

29
00:01:52,613 --> 00:01:56,683
以及如何充分利用
TextKit 2 支持的多个文本视图

30
00:01:56,717 --> 00:02:02,155
没错 我说的是多个文本视图 复数形式

31
00:02:02,189 --> 00:02:05,626
因为现在
截至 iOS 16 和 macOS Ventura

32
00:02:05,659 --> 00:02:09,963
UIKit 和 AppKit 中的
所有文本控件都使用 TextKit 2

33
00:02:09,997 --> 00:02:12,766
包括 UITextView

34
00:02:12,799 --> 00:02:17,938
所以我们在整个系统中使用 TextKit 2
进行布局和渲染

35
00:02:17,971 --> 00:02:22,876
让所有 App 尽快过渡到 TextKit 2
非常重要

36
00:02:22,910 --> 00:02:27,481
我们添加了许多工具
来帮您更轻松地过渡

37
00:02:27,514 --> 00:02:31,251
对于许多 App 来说
这可能是零代码转换

38
00:02:31,285 --> 00:02:33,153
我们预计 对于那些没有对文本视图

39
00:02:33,187 --> 00:02:36,890
进行任何特殊修改的 App 来说
情况也是如此

40
00:02:36,924 --> 00:02:39,092
稍后我会告诉您更多这方面的信息

41
00:02:40,294 --> 00:02:44,031
但首先 我将介绍
TextKit 2 中的新增功能

42
00:02:44,064 --> 00:02:46,700
包括我刚才提到的一些工具

43
00:02:48,001 --> 00:02:50,270
之后 我将深入讲解文本视图的

44
00:02:50,304 --> 00:02:53,774
TextKit 1 兼容模式的细节

45
00:02:54,942 --> 00:02:58,979
然后我将讨论在准备将代码

46
00:02:59,012 --> 00:03:02,182
转换到 TextKit 2 时
可以使用的现代化策略

47
00:03:03,550 --> 00:03:07,187
首先是 TextKit 2 中的新功能

48
00:03:08,322 --> 00:03:12,059
TextKit 2 最早出现在
iOS 15 中的 UIKit

49
00:03:12,092 --> 00:03:14,928
为了使用 TextKit 2
UITextField 进行了升级

50
00:03:15,529 --> 00:03:20,234
在 iOS 16 中
UIKit 向 TextKit 2 的过渡已经完成

51
00:03:20,267 --> 00:03:26,340
所有文本控件默认使用 TextKit 2
包括 UITextView

52
00:03:26,373 --> 00:03:30,010
大多数文本视图
将自动选择加入 TextKit 2

53
00:03:30,043 --> 00:03:32,846
而无需您的任何操作

54
00:03:32,880 --> 00:03:36,884
只有少数情况下
文本视图可能无法选择

55
00:03:36,917 --> 00:03:40,521
我将在本视频的兼容性部分进行介绍

56
00:03:42,155 --> 00:03:44,458
AppKit 也有类似的情况

57
00:03:44,491 --> 00:03:49,329
TextKit 2 最早出现在
macOS Big Sur 中的 AppKit

58
00:03:49,363 --> 00:03:53,867
在 macOS Monterey 中
NSTextField 已升级为默认使用它

59
00:03:53,901 --> 00:03:57,671
通过选择加入
它可用于 NSTextView

60
00:03:58,939 --> 00:04:03,944
在 macOS Ventura 中
所有文本控件默认使用 TextKit 2

61
00:04:03,977 --> 00:04:09,583
就像 UITextView 大多数 NSTextViews
自动选择加入TextKit 2

62
00:04:09,616 --> 00:04:11,985
而不需要您的任何操作

63
00:04:14,221 --> 00:04:17,858
TextEdit 是 NSTextView 的
一个薄包装器

64
00:04:17,891 --> 00:04:22,029
它在 macOS Ventura 的任何地方
都使用 TextKit 2

65
00:04:22,062 --> 00:04:27,768
自 macOS Big Sur 以来 TextEdit
一直在纯文本模式下使用 TextKit 2

66
00:04:27,801 --> 00:04:32,272
在 macOS Ventura 中
富文本模式也使用 TextKit 2

67
00:04:34,708 --> 00:04:37,277
由于 TextKit 2 是新标准

68
00:04:37,311 --> 00:04:42,683
我们为 UITextView 和 NSTextView
添加了一些方便的构造函数

69
00:04:42,716 --> 00:04:46,453
使用这些新的构造函数在初始化时

70
00:04:46,486 --> 00:04:48,689
选择使用哪个文本引擎

71
00:04:49,957 --> 00:04:52,326
要创建使用 TextKit 2 的文本视图

72
00:04:52,359 --> 00:04:55,095
请使用新的构造函数

73
00:04:55,128 --> 00:04:58,332
并为 UsingTextLayoutManager
参数传递 true

74
00:04:58,365 --> 00:05:04,371
如果文本视图需要使用 TextKit 1
以实现兼容性 则改为传递 false

75
00:05:07,207 --> 00:05:12,045
在 Interface Builder 中创建的
文本视图有一个新的文本布局选项

76
00:05:12,079 --> 00:05:16,149
通过此新选项
您可以控制在每个实例上

77
00:05:16,183 --> 00:05:18,519
使用哪种布局系统

78
00:05:18,552 --> 00:05:22,756
默认设置是系统默认值 即 TextKit 2

79
00:05:23,757 --> 00:05:28,762
还可以选择显式使用
TextKit 2 或 TextKit 1

80
00:05:30,664 --> 00:05:34,468
TextKit 2 现在支持非简单文本容器

81
00:05:34,501 --> 00:05:39,606
非简单文本容器中可能有漏洞或缺口

82
00:05:39,640 --> 00:05:43,810
这允许文本环绕图像或其他内联内容

83
00:05:45,145 --> 00:05:47,414
若要创建非简单文本容器

84
00:05:47,447 --> 00:05:51,552
请使用 NSTextContainer 上的

85
00:05:51,585 --> 00:05:55,656
exclusionPaths 属性来定义
不应放置文本的区域

86
00:05:55,689 --> 00:06:00,460
关于如何做到这一点的示例
请查看与此视频相关的参考资料中的

87
00:06:00,494 --> 00:06:03,497
TextKitAndTextView 示例代码

88
00:06:03,530 --> 00:06:07,534
您可以在排除路径选项卡上
找到相关示例

89
00:06:10,137 --> 00:06:13,207
我们增强了 TextKit 2 中的
换行符引擎

90
00:06:13,240 --> 00:06:17,477
为两端对齐的段落选择
更均匀的换行符

91
00:06:17,511 --> 00:06:22,382
这是一个微妙的变化
在较长的文本段落中更容易注意到

92
00:06:23,684 --> 00:06:27,688
在这里我们有两个版本的同一文本
放在同一个区域

93
00:06:28,689 --> 00:06:32,526
请注意 使用传统的换行符时

94
00:06:32,559 --> 00:06:34,528
线条会拉伸 字间距也会变大

95
00:06:36,029 --> 00:06:37,698
在新的偶数换行中

96
00:06:37,731 --> 00:06:40,033
这种情况要少得多

97
00:06:40,067 --> 00:06:42,503
这使得文本更容易阅读

98
00:06:42,536 --> 00:06:45,272
并且您可以通过 TextKit 2 免费获得

99
00:06:45,305 --> 00:06:47,107
无需采用

100
00:06:48,642 --> 00:06:53,680
最后 我们在 TextKit 2 中
为所有平台添加了文本列表支持

101
00:06:53,714 --> 00:06:56,750
使用文本列表 您可以通过编程方式

102
00:06:56,783 --> 00:07:00,387
创建编号或项目符号列表
以便在文本视图中显示

103
00:07:00,420 --> 00:07:06,994
TextKit 2 使用 NSTextList
来表示文本列表 就像 TextKit 1 一样

104
00:07:07,027 --> 00:07:10,197
NSTextList 过去仅在 AppKit 中可用

105
00:07:10,230 --> 00:07:13,767
但在iOS 16 中 它在 UIKit 中也可用

106
00:07:15,669 --> 00:07:20,774
将 NSTextList 与
NSmutableParagraphStyle 一起使用

107
00:07:20,807 --> 00:07:25,712
可以指定文本存储中的段落
格式化为列表以供显示

108
00:07:25,746 --> 00:07:29,283
文本视图负责从文本存储中
提取这些属性

109
00:07:29,316 --> 00:07:34,221
并将段落内容重新格式化为列表

110
00:07:35,856 --> 00:07:41,795
虽然 NSTextList 本身并不是新的
但有一些新增的 TextKit 2

111
00:07:41,828 --> 00:07:44,164
由于列表有嵌套项

112
00:07:44,198 --> 00:07:47,267
所以很自然地将它们表示为树结构

113
00:07:47,301 --> 00:07:52,973
在 TextKit 2 中
我们增强了 NSTextElement

114
00:07:53,006 --> 00:07:56,443
以支持将它们结构化为具有
访问子元素和父元素属性的树

115
00:07:58,011 --> 00:08:02,616
我们还添加了一个新的
元素子类 叫做NSTextListElement

116
00:08:02,649 --> 00:08:07,487
当内容管理器在文本内容中
遇到 NSTextList 时

117
00:08:07,521 --> 00:08:12,192
它将生成 NSTextListElements
来表示列表中的项目

118
00:08:14,394 --> 00:08:18,565
要更深入地了解
如何创建文本列表和添加项目

119
00:08:18,599 --> 00:08:22,302
请参阅
TextKitAndTextView 示例代码

120
00:08:22,336 --> 00:08:25,205
您可以在列表选项卡上找到相关示例

121
00:08:27,474 --> 00:08:29,443
在探索示例代码时

122
00:08:29,476 --> 00:08:31,879
请不要错过文本附件示例

123
00:08:31,912 --> 00:08:37,084
该示例演示了如何使用 TextKit 2 中的
文本附件视图提供程序 API

124
00:08:38,852 --> 00:08:43,223
这些 API 允许您使用
UI 或 NSView 作为文本附件

125
00:08:43,257 --> 00:08:47,294
并且事件可以由附件视图直接处理

126
00:08:47,327 --> 00:08:50,998
因此使用文本附件处理事件
就变得更加容易了

127
00:08:51,031 --> 00:08:54,268
而且只有使用 TextKit 2
才有可能做到这点

128
00:08:54,301 --> 00:08:57,838
好了 这就是 TextKit 2 中新增的功能

129
00:08:57,871 --> 00:09:03,443
接下来 我将详细介绍
TextKit 1 兼容性模式

130
00:09:03,477 --> 00:09:08,015
由于 TextKit 2 与 TextKit 1 的设计
截然不同

131
00:09:08,048 --> 00:09:12,553
我们理解 对于大量投资于
TextKit 1 架构的 App 来说

132
00:09:12,586 --> 00:09:17,157
全面采用 TextKit 2
可能需要一些时间

133
00:09:17,191 --> 00:09:21,662
我们希望这些 App 能够继续工作
直到实现过渡

134
00:09:21,695 --> 00:09:25,399
这就是为什么我们为
UITextView 和 NSTextView

135
00:09:25,432 --> 00:09:28,468
添加了一个特殊的 TextKit 1
兼容模式

136
00:09:28,502 --> 00:09:32,172
当您显式调用
NSLayoutManager API 时

137
00:09:32,206 --> 00:09:35,943
文本视图将用 NSTextLayoutManager
替换其 NSLayoutManager

138
00:09:35,976 --> 00:09:41,215
并将自身重新配置为使用 TextKit 1

139
00:09:41,248 --> 00:09:45,052
如果文本视图遇到 TextKit 2
尚不支持的属性

140
00:09:45,085 --> 00:09:50,557
例如表格 或者在打印时
也会发生这种情况

141
00:09:52,826 --> 00:09:57,865
如果在 UITextView 中
遇到意外运行时回退到 TextKit 1

142
00:09:57,898 --> 00:10:01,802
请检查日志中有关开关的警告消息

143
00:10:01,835 --> 00:10:07,274
在符号下划线上设置断点

144
00:10:07,307 --> 00:10:11,044
以捕获堆栈跟踪
和其他有用的调试信息

145
00:10:13,046 --> 00:10:15,549
对于 NSTextView
您可以通过订阅 willSwitch

146
00:10:15,582 --> 00:10:19,953
或 didSwitchToNSLayoutManager 通知

147
00:10:19,987 --> 00:10:23,223
来获取有关意外运行时回退的
更多信息

148
00:10:25,292 --> 00:10:27,694
如果您必须退回到 TextKit 1

149
00:10:27,728 --> 00:10:31,064
最好在初始化时退出

150
00:10:31,098 --> 00:10:34,501
以编程方式初始化的文本视图

151
00:10:34,535 --> 00:10:39,039
通过使用自己的文本容器和
TextKit 1 布局管理器来实现这一点

152
00:10:40,707 --> 00:10:43,610
另一种选择是使用新的便利构造函数

153
00:10:43,644 --> 00:10:49,316
来初始化 TextKit 1 文本视图
并将 false 作为参数传递

154
00:10:49,349 --> 00:10:52,152
这将使您的文本视图使用 TextKit 1

155
00:10:54,354 --> 00:10:57,057
第三个选项是使用 Interface Builder

156
00:10:57,090 --> 00:11:01,862
并在文本视图中
将新的文本布局选项设置为 TextKit 1

157
00:11:03,230 --> 00:11:05,432
这里有一点是需要注意的

158
00:11:05,465 --> 00:11:08,836
如果要在初始化期间或之后

159
00:11:08,869 --> 00:11:11,672
调出文本容器的布局管理器

160
00:11:11,705 --> 00:11:16,643
则文本视图将返回到设计的 TextKit 1

161
00:11:16,677 --> 00:11:21,381
在初始化期间创建
所有的 TextKit 2 对象

162
00:11:21,415 --> 00:11:24,351
稍后将其丢弃 这是非常低效的

163
00:11:24,384 --> 00:11:28,922
根据时间的不同
还有潜在的用户副作用

164
00:11:28,956 --> 00:11:32,559
如果它发生在键入过程中
文本视图可能会失去焦点

165
00:11:32,593 --> 00:11:38,899
并中断输入
需要再次选择文本视图才能恢复

166
00:11:38,932 --> 00:11:44,705
可以通过在初始化时选择文本视图
来避免这种情况

167
00:11:44,738 --> 00:11:47,708
既然您已经了解了所有的兼容性模式

168
00:11:47,741 --> 00:11:52,212
现在是时候谈谈如何通过更新 App
和采用 TextKit 2

169
00:11:52,246 --> 00:11:54,281
来完全避免它了

170
00:11:54,314 --> 00:11:57,718
我想让您记住一件非常重要的事

171
00:11:59,553 --> 00:12:03,023
每个文本视图只能有一个布局管理器

172
00:12:03,056 --> 00:12:06,393
文本视图不能
同时拥有 NSTextLayoutManager

173
00:12:06,426 --> 00:12:10,030
和 NSLayoutManager

174
00:12:11,698 --> 00:12:17,004
一旦文本视图切换到 TextKit 1
就无法自动返回

175
00:12:17,037 --> 00:12:20,073
切换布局系统的过程代价很高

176
00:12:20,107 --> 00:12:25,345
并且您会丢失切换时
存在的任何 UI 状态

177
00:12:25,379 --> 00:12:28,348
因此为了优化性能和可用性

178
00:12:28,382 --> 00:12:33,554
系统不会将文本视图
从 TextKit 1 切换回 TextKit 2

179
00:12:33,587 --> 00:12:35,389
这是单向操作

180
00:12:36,790 --> 00:12:42,429
这意味着避免兼容模式非常重要

181
00:12:42,462 --> 00:12:46,934
文本视图进入兼容模式
有几个不同的原因

182
00:12:46,967 --> 00:12:50,838
文本视图进入兼容模式的第一个原因

183
00:12:50,871 --> 00:12:55,342
是访问文本视图的
layoutManager 属性

184
00:12:55,375 --> 00:12:57,778
其他原因则不太常见

185
00:12:59,746 --> 00:13:01,181
因此一个重要的策略是

186
00:13:01,215 --> 00:13:05,219
避免访问文本视图的布局管理器属性

187
00:13:05,252 --> 00:13:10,991
还应避免通过文本视图的
文本容器访问布局管理器

188
00:13:11,024 --> 00:13:14,194
检查代码中这些属性的使用情况

189
00:13:14,228 --> 00:13:18,432
并将其删除或替换为
与 TextKit 2 等效的属性

190
00:13:20,334 --> 00:13:24,705
如果您将 App 部署到
没有 TextKit 2 的旧操作系统版本

191
00:13:24,738 --> 00:13:28,809
您可能无法
完全删除 layoutManager 代码

192
00:13:29,977 --> 00:13:35,048
在这种情况下 应首先检查
文本视图的 NSTextLayoutManager

193
00:13:36,216 --> 00:13:39,086
将 TextKit 2 代码放在 if 子句中

194
00:13:39,119 --> 00:13:42,389
将 TextKit 1 代码放在 else 子句中

195
00:13:42,422 --> 00:13:45,392
包括 layoutManager 访问权限

196
00:13:45,425 --> 00:13:50,531
这样 TextKit 1 代码
仅在 TextKit 2 不可用时运行

197
00:13:50,564 --> 00:13:55,469
并且 layoutManager 查询不会导致
意外回退到 TextKit 1

198
00:13:57,771 --> 00:14:00,641
如果您遵循了所有这些建议
但仍然遇到了

199
00:14:00,674 --> 00:14:04,411
来自系统的
对 TextKit 1 的意外回退

200
00:14:04,444 --> 00:14:09,483
那就是我们的问题了
请向“反馈助手”报告此问题

201
00:14:09,516 --> 00:14:12,519
在回退时包含堆栈跟踪的捕获

202
00:14:12,553 --> 00:14:13,921
您可以通过在 UIKit 中的下划线

203
00:14:13,954 --> 00:14:17,791
UITextViewEnableingCompatibilityMode 上
断开获取

204
00:14:17,824 --> 00:14:22,229
也可以通过 AppKit 中的

205
00:14:22,262 --> 00:14:24,231
willSwitchToNSLayoutManagerNotification
来获取

206
00:14:25,632 --> 00:14:29,336
好的 现在我将从
NSLayoutManager 开始

207
00:14:29,369 --> 00:14:33,974
详细介绍与 TextKit 1 类型
相关的更新代码

208
00:14:34,007 --> 00:14:37,444
审核了 NSLayoutManager
查询的代码后

209
00:14:37,477 --> 00:14:41,982
您需要找出与 NSTextLayoutManager
等价的 TextKit 2

210
00:14:44,418 --> 00:14:49,122
一些布局管理器 API
在 TextKit 1 和 2 之间有相似的名称

211
00:14:49,156 --> 00:14:51,892
替换很简单

212
00:14:51,925 --> 00:14:53,894
这里有几个例子

213
00:14:53,927 --> 00:14:59,032
在 TextKit 1 中
在 NSLayoutManager 上调用

214
00:14:59,066 --> 00:15:04,805
usedRect (for: textContainer)
来获取文本容器内文本的边框

215
00:15:04,838 --> 00:15:09,643
在 TextKit 2 中 您可以从
NSTextLayoutManager 上的

216
00:15:09,676 --> 00:15:11,712
usageBoundsForTextContainer
属性中获得此信息

217
00:15:12,779 --> 00:15:16,316
在 TextKit 1 中 我们使用临时属性

218
00:15:16,350 --> 00:15:21,455
来表示只影响渲染
而不影响布局的属性

219
00:15:21,488 --> 00:15:25,792
在 TextKit 2 中
我们更准确地将这些称为渲染属性

220
00:15:27,861 --> 00:15:30,030
但是有一些 TextKit 1 API

221
00:15:30,063 --> 00:15:33,634
在 TextKit 2 中没有直接的对应 API

222
00:15:33,667 --> 00:15:36,436
要了解原因 您需要了解

223
00:15:36,470 --> 00:15:39,640
印度文 (如卡纳达语) 脚本中
有些单词没有

224
00:15:39,673 --> 00:15:42,743
正确的字符来进行字形映射

225
00:15:43,644 --> 00:15:46,079
在这些脚本中 字形可以被分割

226
00:15:46,113 --> 00:15:49,349
重新排序 重组 甚至删除

227
00:15:50,751 --> 00:15:53,787
NSLayoutManager 上
基于字形的 API

228
00:15:53,820 --> 00:15:58,392
假设您可以直接
将连续的字符范围

229
00:15:58,425 --> 00:16:03,630
与连续的字形范围相关联
但这并不适用于所有脚本

230
00:16:03,664 --> 00:16:07,134
使用这些 API 可能会导致
用卡纳达语等脚本编写的

231
00:16:07,167 --> 00:16:09,937
文本的布局和呈现中断

232
00:16:09,970 --> 00:16:14,508
这就是为什么 TextKit 2 中的
字形 API 为零的原因

233
00:16:14,541 --> 00:16:19,413
您不能仅仅用单个 TextKit 2 API
替换 TextKit 1 glyph API

234
00:16:19,446 --> 00:16:23,016
替换这些 API 需要不同的方法

235
00:16:24,818 --> 00:16:28,422
这里是如何更新基于字形的代码

236
00:16:28,455 --> 00:16:33,060
第一步是识别您正在使用的字形 API

237
00:16:33,093 --> 00:16:36,597
接下来 看看您要如何使用这些 API

238
00:16:36,630 --> 00:16:40,701
并从高级别上定义您想做什么

239
00:16:40,734 --> 00:16:44,171
基于字形的代码是非常低级的

240
00:16:44,204 --> 00:16:47,107
并且有许多细节与您的高级任务无关

241
00:16:48,342 --> 00:16:50,110
定义了高级任务后

242
00:16:50,143 --> 00:16:54,448
请检查 TextKit 2 中可用的结构

243
00:16:54,481 --> 00:16:58,952
例如布局片段 行片段和文本选择

244
00:16:58,986 --> 00:17:02,155
这些可以帮助您完成任务

245
00:17:02,189 --> 00:17:06,126
例如 考虑下面的 TextKit 1 代码

246
00:17:06,159 --> 00:17:09,296
这里使用了两个字形 API

247
00:17:09,329 --> 00:17:10,964
numberOfGlyphs

248
00:17:10,998 --> 00:17:15,836
和 lineFragmentRect
(for glyphat:index)

249
00:17:15,869 --> 00:17:19,973
这段 TextKit 1 代码
历遍了文档中的所有字形

250
00:17:20,007 --> 00:17:22,743
并计算行片段的长度

251
00:17:22,776 --> 00:17:27,581
高级任务是计算文本视图中

252
00:17:27,614 --> 00:17:29,816
已包装文本的行数

253
00:17:29,850 --> 00:17:32,953
由于此代码使用的是行片段 rect

254
00:17:32,986 --> 00:17:37,124
因此要使用的 TextKit 2 结构
是 NSTextLineFragment

255
00:17:37,157 --> 00:17:39,693
和 NSTextLayoutFragment

256
00:17:40,594 --> 00:17:43,964
这是为使用 TextKit 2 而重写的代码

257
00:17:43,997 --> 00:17:46,400
它没有历遍字形

258
00:17:46,433 --> 00:17:49,837
而是枚举文档中的文本布局片段

259
00:17:49,870 --> 00:17:53,740
并提供一个闭包来计算

260
00:17:53,774 --> 00:17:55,909
每个布局片段中的所有文本行片段

261
00:17:57,578 --> 00:18:01,648
在为 TextKit 2 更新自己的代码时
请记住这个示例

262
00:18:01,682 --> 00:18:06,587
现在我将换个方向
讨论如何更新基于 NSRange 的代码

263
00:18:09,756 --> 00:18:14,561
TextKit 1 使用 NSRange
索引文本内容

264
00:18:14,595 --> 00:18:19,099
NSRange 是字符串的线性索引

265
00:18:19,132 --> 00:18:22,703
对于文本 Hello TextKit 2！
感叹号表示

266
00:18:22,736 --> 00:18:27,674
代表“TextKit 2 exclamation point” 的
NSRange 的

267
00:18:27,708 --> 00:18:31,278
位置是 6 长度是 10

268
00:18:31,311 --> 00:18:36,016
因为它从第 6 个字符开始
长度是 10 个字符

269
00:18:36,049 --> 00:18:38,785
这种线性模型很容易理解

270
00:18:38,819 --> 00:18:41,755
对于字符串的索引非常有效

271
00:18:43,557 --> 00:18:47,394
但是线性模型不适用于索引

272
00:18:47,427 --> 00:18:50,297
任何比字符串更具结构的内容

273
00:18:50,330 --> 00:18:52,833
举一个例子

274
00:18:52,866 --> 00:18:56,336
HTML 文档被表示为一个树形结构

275
00:18:56,370 --> 00:18:58,872
其中每个标签是树中的一个节点

276
00:18:58,906 --> 00:19:01,341
如果我们的 Hello TextKit 2！文本

277
00:19:01,375 --> 00:19:03,710
是 HTML 文档的一部分

278
00:19:03,744 --> 00:19:08,215
我们的 NSRange 无法告诉我们
文本在 span 标签内

279
00:19:08,248 --> 00:19:10,851
嵌套了 3 层

280
00:19:10,884 --> 00:19:14,488
线性模型的表达能力
不足以存储该信息

281
00:19:14,521 --> 00:19:19,426
所以我们不能用它来索引
像这样的嵌套结构

282
00:19:19,459 --> 00:19:26,466
这就是为什么 TextKit 2 添加了
新类型来表示文本内容中的范围

283
00:19:26,500 --> 00:19:31,271
NSTextLocation 是一个
能够表示文本内容中

284
00:19:31,305 --> 00:19:33,574
单个位置的对象

285
00:19:33,607 --> 00:19:38,245
NSTextRange 由开始和结束位置组成

286
00:19:38,278 --> 00:19:42,449
结束位置不在该范围内

287
00:19:42,482 --> 00:19:46,954
这些新类型可以通过
将位置定义为 DOM 节点

288
00:19:46,987 --> 00:19:52,426
加上字符偏移量
来表示这个 HTML 文档的嵌套结构

289
00:19:53,594 --> 00:19:58,532
既然 NSTextLocation 是一个协议
那任何自定义对象都可以是一个位置

290
00:19:58,565 --> 00:20:03,437
只要它实现了
NSTextLocation 协议方法

291
00:20:03,470 --> 00:20:07,407
这对于处理不同类型的支持模型中
结构化数据的后备存储来说

292
00:20:07,441 --> 00:20:10,344
是至关重要的基础设施

293
00:20:11,912 --> 00:20:15,983
但是文本视图是建立在
没有这种结构的

294
00:20:16,016 --> 00:20:19,019
NSAttributedString 后台存储上的
我们无法在不破坏

295
00:20:19,052 --> 00:20:23,123
许多 App 的情况下改变这一点
包括您的 App

296
00:20:23,156 --> 00:20:26,994
因此 在使用 selectedRange
或 scrollRangeToVisible 等

297
00:20:27,027 --> 00:20:30,731
文本视图 API 时 您将继续使用
NSRange 布局管理器或内容管理器

298
00:20:30,764 --> 00:20:34,968
当与 TextKit 2 通信时

299
00:20:35,002 --> 00:20:39,473
您需要在 NSRange
和 NSTextRange 之间进行转换

300
00:20:40,941 --> 00:20:44,778
要将文本视图的 NSRange
转换为 NSTextRange

301
00:20:44,811 --> 00:20:49,716
请将位置定义为
属性化字符串的整数索引

302
00:20:50,851 --> 00:20:55,589
使用 NSRange 位置
作为 NSTextRange 的起始位置

303
00:20:56,790 --> 00:21:02,596
使用 NSRange 位置加上长度
作为 NSTextRange 的结束位置

304
00:21:02,629 --> 00:21:07,234
从概念上讲 这就是从 NSRange
映射到 NSTextRange 的方法

305
00:21:09,069 --> 00:21:11,705
实际上 代码看起来有点不同

306
00:21:11,738 --> 00:21:15,442
因为 NSTextLocations 必须是对象

307
00:21:17,110 --> 00:21:20,547
您需要通过内容管理器来计算位置

308
00:21:21,815 --> 00:21:24,785
对于开始位置
请向内容管理员询问

309
00:21:24,818 --> 00:21:27,354
文档开始的位置

310
00:21:27,387 --> 00:21:31,091
然后根据 NSRange 的位置
对其进行偏移

311
00:21:31,124 --> 00:21:36,530
然后将起始位置偏移
NSRange 的长度以获得结束位置

312
00:21:38,899 --> 00:21:42,369
要朝另一个方向发展
请使用文本内容管理器

313
00:21:42,402 --> 00:21:44,204
以获取两个不同的偏移量

314
00:21:45,772 --> 00:21:49,676
NSRange 的位置是文档开头

315
00:21:49,710 --> 00:21:53,347
和 NSTextRange 位置之间的偏移量

316
00:21:53,380 --> 00:21:57,651
NSRange 的长度是 NSTextRange 的
开始和结束位置

317
00:21:57,684 --> 00:21:59,686
之间的偏移量

318
00:22:01,455 --> 00:22:06,193
UITextViews 和 UITextFields
符合 UITextInput 协议

319
00:22:06,226 --> 00:22:09,963
该协议使用 UITextPosition 和 range

320
00:22:09,997 --> 00:22:12,399
大多数时候 在使用

321
00:22:12,432 --> 00:22:16,003
UITextView 或 UITextField 时

322
00:22:16,036 --> 00:22:19,540
您不需要将 UITextRange
直接转换为 NSTextRange

323
00:22:19,573 --> 00:22:22,009
如果您想这样做 使用整数偏移量

324
00:22:22,042 --> 00:22:24,611
作为两个范围类型之间的媒介

325
00:22:26,713 --> 00:22:30,851
另一方面 如果您使用
带有 UITextInput 的自定义视图

326
00:22:30,884 --> 00:22:34,288
您可以直接控制视图中

327
00:22:34,321 --> 00:22:38,592
使用的 UITextPosition
和 UITextRange 子类

328
00:22:38,625 --> 00:22:41,495
您可以使您的 UITextPosition 子类

329
00:22:41,528 --> 00:22:45,399
符合 NSTextLocation 实现所需的方法

330
00:22:45,432 --> 00:22:49,703
并使用您的子类直接创建
NSTextRanges

331
00:22:51,138 --> 00:22:56,076
最后 这里提醒您避免
跨不同视图重用

332
00:22:56,109 --> 00:23:02,416
UITextPosition 对象
即使两个视图中的内容相似

333
00:23:02,449 --> 00:23:07,721
UITextPosition 仅对
用于创建它的视图有效

334
00:23:09,223 --> 00:23:12,526
好了 现在您已经有了很多

335
00:23:12,559 --> 00:23:14,561
让代码现代化的策略

336
00:23:14,595 --> 00:23:17,297
应用这些策略 您的 App 就可以

337
00:23:17,331 --> 00:23:19,666
享受到 TextKit 2 的好处

338
00:23:21,568 --> 00:23:24,805
这就是 TextKit 和文本视图的
新增功能

339
00:23:24,838 --> 00:23:27,875
我介绍了 TextKit 2 中的
许多重大改进

340
00:23:27,908 --> 00:23:30,344
并分享了一些更新 App 的策略

341
00:23:30,377 --> 00:23:33,814
同时保持与旧操作系统版本的兼容性

342
00:23:33,847 --> 00:23:39,052
今天就在您的 App 中使用 TextKit 2
充分利用新的改进吧

343
00:23:39,086 --> 00:23:40,954
检查您的文本视图 以确保

344
00:23:40,988 --> 00:23:44,391
它们不会无意中退回到 TextKit 1

345
00:23:44,424 --> 00:23:47,127
最后 采用现代化策略

346
00:23:47,160 --> 00:23:50,464
让您的 App 在 TextKit 2 上运行

347
00:23:50,497 --> 00:23:55,169
我们迫不及待地想阅读您使用
TextKit 2 和文本视图创建的内容了

348
00:23:55,202 --> 00:23:57,171
感谢收看

