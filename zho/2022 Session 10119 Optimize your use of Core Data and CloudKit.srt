1
00:00:01,401 --> 00:00:07,407
[古怪的音乐]

2
00:00:09,309 --> 00:00:13,580
Nick: 大家好 我叫 Gillett
是 Apple Core Data 团队的一名工程师

3
00:00:14,147 --> 00:00:18,218
在本期讲座中 我将向你展示如何
使用开发者工具了解更多关于使用

4
00:00:18,252 --> 00:00:21,722
NSPersistentCloudKitContainer 的
App 信息

5
00:00:21,755 --> 00:00:25,492
首先 我们将详细介绍
如何以一种富有成效

6
00:00:25,526 --> 00:00:27,761
和具有教育意义的方式
来探索应用程序

7
00:00:28,795 --> 00:00:33,800
然后 我们将使用一些我最喜欢的
工具来分析应用程序的行为

8
00:00:33,834 --> 00:00:37,037
最后 我们将研究如何就使用
NSPersistentCloudKitContainer 的

9
00:00:37,070 --> 00:00:41,408
体验提供详细的 可操作的反馈

10
00:00:42,509 --> 00:00:46,313
我喜欢把工程学想象成水循环

11
00:00:46,346 --> 00:00:49,983
通常 我从探索功能所在的空间

12
00:00:50,017 --> 00:00:51,852
开始研究其功能

13
00:00:51,885 --> 00:00:57,057
然后 根据我学到的东西
我会使用工具和测试的组合

14
00:00:57,090 --> 00:00:59,993
在可复制的环境中分析我的工作

15
00:01:00,794 --> 00:01:05,098
最后 我会与同事和合作者
一起回顾结果

16
00:01:05,132 --> 00:01:06,400
并收集他们的反馈

17
00:01:07,134 --> 00:01:10,938
这个循环的目标是持久地捕捉到
我在工作中

18
00:01:10,971 --> 00:01:12,506
学到的东西

19
00:01:12,539 --> 00:01:16,877
Apple 平台包括很多工具 比如 Xcode

20
00:01:16,910 --> 00:01:21,949
Instruments 和 XCTest
我用它们来获取我所学的内容

21
00:01:21,982 --> 00:01:24,885
这些工具还可以收集大量的诊断信息

22
00:01:24,918 --> 00:01:28,989
我可以用这些信息
来提供可操作的反馈

23
00:01:30,858 --> 00:01:34,628
本讲座参考了过去几年的许多知识

24
00:01:34,661 --> 00:01:37,731
我已经讨论过
NSPersisentCloudKitContainer

25
00:01:37,764 --> 00:01:41,168
和 Core Data CloudKit 示例应用程序
我今天将在

26
00:01:41,201 --> 00:01:46,840
“Build Apps that
share data through CloudKit and Core Data”

27
00:01:46,874 --> 00:01:51,211
和 “Using Core Data with CloudKit.”
这两个讲座中详细介绍这两个应用程序

28
00:01:51,245 --> 00:01:56,483
我还将演示如何使用
Xcode 和 Instruments 来运行测试

29
00:01:56,517 --> 00:02:00,254
以及如何使用 Device Organizer
从设备中捕获数据

30
00:02:00,287 --> 00:02:03,490
如果需要 我建议你查看讲座

31
00:02:03,524 --> 00:02:05,392
“Getting Started With Instruments”

32
00:02:05,425 --> 00:02:09,763
和 “Diagnose performance issues
with the Xcode Organizer”

33
00:02:09,796 --> 00:02:14,735
以更多地了解工具链的
这两个重要部分

34
00:02:14,768 --> 00:02:19,873
好了 让我们开始本循环的
第一部分 探索

35
00:02:19,907 --> 00:02:24,178
对我来说 探索的首要目标是学习

36
00:02:24,211 --> 00:02:27,814
我想挑战并验证

37
00:02:27,848 --> 00:02:29,816
应用程序工作原理的所有假设

38
00:02:30,617 --> 00:02:34,087
我可能会问
如果我点击这个按钮会发生什么

39
00:02:34,121 --> 00:02:39,493
当我将数据保存到永久存储时
NSPersistentCloudKitContainer 是否同步

40
00:02:39,526 --> 00:02:43,630
在处理大型数据集时
应用程序是否会耗尽内存

41
00:02:44,498 --> 00:02:48,669
从 Core Data 的角度来看
所有这些问题都受到

42
00:02:48,702 --> 00:02:51,038
应用程序处理的数据的影响

43
00:02:51,071 --> 00:02:56,743
例如 Core Data CloudKit
示例应用程序使用这个数据模型

44
00:02:58,245 --> 00:03:03,383
它管理一组帖子 其中包含
一些标题和内容的文本字段

45
00:03:04,284 --> 00:03:07,688
帖子可以与附件 通常是图像 相关

46
00:03:07,721 --> 00:03:08,889
这些附件可能非常大

47
00:03:10,324 --> 00:03:14,728
因此 ImageData 存储在
一组对一关系中

48
00:03:14,761 --> 00:03:17,698
以便按需加载

49
00:03:17,731 --> 00:03:21,768
我将重点研究该数据集

50
00:03:21,802 --> 00:03:24,872
特别是当我改变该数据的形状

51
00:03:24,905 --> 00:03:29,443
结构和变化时
该示例应用程序会发生什么

52
00:03:30,677 --> 00:03:36,216
自从发布以来 该示例应用程序
已经包含了一个内置的方法来探索它

53
00:03:36,250 --> 00:03:40,487
Generate 1000 Posts 按钮
完全按照标签上的内容执行

54
00:03:41,355 --> 00:03:44,157
点击后 它会生成一个
包含 1000 篇短文标题的

55
00:03:44,191 --> 00:03:47,060
样本数据集

56
00:03:47,094 --> 00:03:50,931
帖子的表格视图可以轻松处理
这种级别的数据

57
00:03:50,964 --> 00:03:54,835
因此 我要问的下一个问题是
如何在这个应用程序中

58
00:03:54,868 --> 00:03:58,138
探索不同形状或大小的数据集

59
00:03:59,006 --> 00:04:02,376
Generate 1000 Posts 按钮运行的是

60
00:04:02,409 --> 00:04:05,078
我所说的算法数据生成器

61
00:04:05,112 --> 00:04:08,982
算法数据生成器遵循
一组预先确定的规则

62
00:04:09,016 --> 00:04:11,852
如 “插入 1000 个对象”

63
00:04:11,885 --> 00:04:17,224
或“确保每个字段都有值
或者没有字段有值”

64
00:04:17,858 --> 00:04:21,395
事实证明 我们也是数据生成者

65
00:04:21,428 --> 00:04:25,499
我们可以在代码中 在 SQL 中

66
00:04:25,532 --> 00:04:28,869
或通过直接与应用程序交互
来手工创建特定的数据集

67
00:04:28,902 --> 00:04:31,705
这些生成的数据集可以被保留

68
00:04:31,738 --> 00:04:33,740
以供以后使用或分析

69
00:04:34,508 --> 00:04:39,213
为了探索更大的数据集
我可以定义一个新的数据生成器

70
00:04:39,246 --> 00:04:42,850
LargeDataGenerator
并提供一个方法

71
00:04:42,883 --> 00:04:46,086
来构建我的新数据集
即 generateData

72
00:04:46,119 --> 00:04:49,890
只需两个 for 循环
我就可以生成一组 60 个帖子

73
00:04:49,923 --> 00:04:54,094
每个帖子都有 11 个关联的图片附件

74
00:04:54,127 --> 00:04:57,231
总共有 660 张图片

75
00:04:57,264 --> 00:05:00,601
每个图像的平均大小为 10 到 15 MB

76
00:05:00,634 --> 00:05:06,073
生成的数据集消耗了近 10 GB 的数据

77
00:05:06,106 --> 00:05:10,143
通过这样一个简单的接口
数据生成器很容易

78
00:05:10,177 --> 00:05:12,246
在这样的测试中调用

79
00:05:12,279 --> 00:05:17,184
这一行代码生成了超过 10 GB 的
代表性数据

80
00:05:17,217 --> 00:05:18,685
供该测试使用

81
00:05:20,721 --> 00:05:24,391
此外 我们可以在测试中
构建验证方法

82
00:05:24,424 --> 00:05:27,828
以验证数据生成器的行为是否正确

83
00:05:27,861 --> 00:05:31,899
比如断言每个帖子确实有
11 个图像附件

84
00:05:33,433 --> 00:05:37,604
当然 如果我们不同步这些数据

85
00:05:37,638 --> 00:05:39,673
这就不是
NSPersistentCloudKitContainer

86
00:05:39,706 --> 00:05:42,409
所以让我们设计一个新的测试
来完成这个任务

87
00:05:43,911 --> 00:05:49,183
我首先需要使用
NSPersistentCloudKitContainer 的一个实例

88
00:05:49,216 --> 00:05:52,753
我已经创建了一个助手方法
来简化这一过程

89
00:05:52,786 --> 00:05:55,422
接下来
我使用 LargeDataGenerator

90
00:05:55,455 --> 00:05:58,559
用所需的数据集填充容器

91
00:05:59,526 --> 00:06:03,997
最后 我等待容器完成数据导出

92
00:06:04,031 --> 00:06:07,467
在这个特定的测试中
我最多等待 20 分钟

93
00:06:07,501 --> 00:06:09,736
以便为大数据集提供上传时间

94
00:06:11,338 --> 00:06:15,108
你们当中目光敏锐的人
可能已经注意到

95
00:06:15,142 --> 00:06:18,378
这个测试似乎在等待不同类型的事件

96
00:06:18,412 --> 00:06:21,381
在这里 当我创建容器时

97
00:06:21,415 --> 00:06:23,750
我等待容器完成设置

98
00:06:24,551 --> 00:06:29,323
在这里 我使用我编写的助手方法

99
00:06:29,356 --> 00:06:31,558
为容器中的导出事件
创建 XctestExpections

100
00:06:32,159 --> 00:06:33,493
我们来详细了解一下

101
00:06:34,494 --> 00:06:38,165
此方法将所需的事件类型和

102
00:06:38,198 --> 00:06:41,568
NSPersistentCloudKitContainer 的
实例作为参数

103
00:06:41,602 --> 00:06:45,939
它使用 XCTestCase 的
expectationForNotification 方法

104
00:06:45,973 --> 00:06:50,511
来观察 NSPersistentCloudKitContainer 的
eventChanged 通知

105
00:06:50,544 --> 00:06:55,749
从而为容器中的每个持久性存储
创建一个预期

106
00:06:55,782 --> 00:06:57,951
在通知处理程序模块中

107
00:06:57,985 --> 00:06:59,953
我验证传入事件的类型

108
00:06:59,987 --> 00:07:01,388
是否与这个预期所针对的

109
00:07:01,421 --> 00:07:04,358
特定存储的类型一致

110
00:07:04,391 --> 00:07:06,727
并通过检查 endDate

111
00:07:06,760 --> 00:07:08,195
不等于 nil 来完成

112
00:07:08,962 --> 00:07:10,731
通过使用这种技术

113
00:07:10,764 --> 00:07:14,501
我们可以将测试中的控制点与来自

114
00:07:14,535 --> 00:07:17,471
NSPersistentCloudKitContainer 的
事件紧密关联起来

115
00:07:17,504 --> 00:07:24,011
回到测试中 我添加了一个新容器
来导入刚刚导出的数据

116
00:07:24,044 --> 00:07:26,446
这项技术使用了一种技巧

117
00:07:26,480 --> 00:07:27,848
它使用空存储文件创建

118
00:07:27,881 --> 00:07:31,919
NSPersistentCloudKitContainer 的
新实例

119
00:07:31,952 --> 00:07:33,954
这使得测试可以利用

120
00:07:33,987 --> 00:07:37,157
NSPersisentCloudKitContainer 的
第一次导入

121
00:07:37,191 --> 00:07:42,296
来探索当设备下载
所有这些数据时会发生什么

122
00:07:42,329 --> 00:07:45,966
现在 测试很顺利 但有时我想知道

123
00:07:45,999 --> 00:07:48,702
数据集在应用程序中是如何工作的

124
00:07:48,735 --> 00:07:52,806
为此 我可以将数据生成器
绑定到用户界面

125
00:07:52,840 --> 00:07:55,375
就像我们在示例应用程序中
所做的那样

126
00:07:56,076 --> 00:07:59,479
当我点击 Generate Large Data
按钮时 我可以看到

127
00:07:59,513 --> 00:08:02,482
数据生成器填充数据集

128
00:08:02,516 --> 00:08:06,186
在另一个设备上
当 NSPersistentCloudKitContainer

129
00:08:06,220 --> 00:08:12,226
下载生成的数据时
我可以看到表视图被填充

130
00:08:12,259 --> 00:08:16,697
点击单个帖子 我可以看到附件下载

131
00:08:16,730 --> 00:08:18,799
和增量填充

132
00:08:18,832 --> 00:08:22,102
就像该应用程序用户所做的那样

133
00:08:22,669 --> 00:08:26,440
此特定用户界面由警报控制器驱动

134
00:08:27,107 --> 00:08:30,644
LargeDataGenerator 的简单接口
使得仅使用这两行代码

135
00:08:30,677 --> 00:08:34,781
就可以轻松地添加新的警报操作

136
00:08:34,815 --> 00:08:38,018
清晰 简洁 易理解

137
00:08:39,753 --> 00:08:43,290
在这个部分
我们使用数据生成器的概念

138
00:08:43,323 --> 00:08:45,726
探索了应用程序的行为

139
00:08:46,593 --> 00:08:51,098
数据生成器可在我们的应用程序中
以我们选择的任何方式驱动

140
00:08:51,131 --> 00:08:55,102
无论是通过测试或自定义 UI
如我所演示的那样

141
00:08:55,135 --> 00:08:57,571
或是通过命令行参数之类的东西

142
00:08:57,604 --> 00:09:01,375
或任何针对特定用例的东西

143
00:09:01,408 --> 00:09:05,112
现在我们已经知道
如何用数据填充应用程序

144
00:09:05,145 --> 00:09:08,849
那么我们就可以分析
数据如何改变应用程序的行为了

145
00:09:08,882 --> 00:09:12,586
在这个部分
我们将了解一些工具和技术

146
00:09:12,619 --> 00:09:14,555
来分析应用程序如何处理

147
00:09:14,588 --> 00:09:15,822
大型数据集

148
00:09:16,890 --> 00:09:21,562
具体来说 我们将使用工具
分析 LargeDataGenerator 创建的

149
00:09:21,595 --> 00:09:24,665
数据集的时间和内存复杂性

150
00:09:25,465 --> 00:09:29,069
然后 我们将查看系统日志中

151
00:09:29,102 --> 00:09:30,571
丰富的可用信息

152
00:09:30,604 --> 00:09:35,075
这样 我们就可以从
NSPersistentCloudKitContainer

153
00:09:35,108 --> 00:09:39,713
CloudKit 系统调度器和推送通知中
找到活动记录

154
00:09:39,746 --> 00:09:42,449
我们先从 Instruments 开始

155
00:09:42,482 --> 00:09:46,420
我喜欢测试的一个原因是

156
00:09:46,453 --> 00:09:49,156
Xcode 使分析测试行为变得很容易

157
00:09:49,189 --> 00:09:52,860
在我的测试用例中
我可以在 gutter 区域点击右键

158
00:09:52,893 --> 00:09:55,229
显示并选择 Profile

159
00:09:55,262 --> 00:09:59,433
Xcode 将构建测试
然后自动启动工具

160
00:10:00,234 --> 00:10:02,769
我可以双击 Time Profiler 工具

161
00:10:02,803 --> 00:10:05,939
来检查我的测试在哪里花费了时间

162
00:10:07,508 --> 00:10:11,612
当我点击记录按钮时
Instruments 将启动应用程序

163
00:10:11,645 --> 00:10:14,681
并执行所选的测试

164
00:10:14,715 --> 00:10:18,785
这个测试似乎要花很长时间来运行

165
00:10:18,819 --> 00:10:20,787
我们跳过这一步 看看为什么

166
00:10:21,688 --> 00:10:24,758
Instruments 已经选择了主线程

167
00:10:24,791 --> 00:10:28,795
在右边 我可以看到测试运行中
最重的堆栈轨迹

168
00:10:30,063 --> 00:10:31,865
我们让它更易阅读

169
00:10:36,203 --> 00:10:38,172
好了

170
00:10:38,205 --> 00:10:42,876
现在 如果我滚动到底部
可以看到 LargeDataGenerator

171
00:10:42,910 --> 00:10:45,546
正在花费大量时间来生成缩略图

172
00:10:45,579 --> 00:10:48,582
我们如何判断这是一个漏洞
还是一个功能呢

173
00:10:50,050 --> 00:10:53,687
在 LargeDataGenerator 中
我用这行代码

174
00:10:53,720 --> 00:10:56,623
为每个附件生成一个新的缩略图

175
00:10:56,657 --> 00:11:01,361
但我从应用程序的数据模型中知道
缩略图是特殊的

176
00:11:01,395 --> 00:11:05,432
它们是根据相关的 imageData
按需计算的

177
00:11:05,465 --> 00:11:09,803
这意味着这一行代码不是必要的
我的数据生成器在这上面

178
00:11:09,837 --> 00:11:11,605
浪费了很多时间

179
00:11:11,638 --> 00:11:14,074
所以我可以把它删除掉

180
00:11:14,107 --> 00:11:16,643
我们来看看这会如何改变测试的性能

181
00:11:17,578 --> 00:11:20,781
在使用更新的数据生成器
重新构建应用程序后

182
00:11:20,814 --> 00:11:23,617
我可以在 Instruments 中
重新运行测试

183
00:11:23,650 --> 00:11:29,223
老实说 我看不出有什么变化

184
00:11:29,256 --> 00:11:32,326
但再过几秒钟 测试就完成了

185
00:11:32,359 --> 00:11:35,195
这比上一次运行快得多

186
00:11:35,229 --> 00:11:37,998
我们看看测试大部分时间花在哪里

187
00:11:43,504 --> 00:11:46,907
在右侧的边栏抽屉型菜单中
我现在看到最重的堆栈轨迹

188
00:11:46,940 --> 00:11:49,977
是将图像保存到持久存储中

189
00:11:50,010 --> 00:11:54,081
这正是我对管理这么多
数据的测试所期望的

190
00:11:55,582 --> 00:11:59,720
这一改变将 generateData 测试的
运行时间从这么多

191
00:11:59,753 --> 00:12:02,322
减少到这么多

192
00:12:02,356 --> 00:12:05,959
它的执行时间只有十分之一

193
00:12:05,993 --> 00:12:09,496
以这种方式分析测试
并不总能发现漏洞

194
00:12:09,530 --> 00:12:11,198
有时 我们只是进一步了解了

195
00:12:11,231 --> 00:12:13,400
应用程序在处理特定数据集时

196
00:12:13,433 --> 00:12:16,003
将时间花在哪里

197
00:12:16,036 --> 00:12:18,472
但不管怎样 这都是有价值的学习

198
00:12:19,473 --> 00:12:23,043
这就是 Time Profiler 工具
如何帮助探索

199
00:12:23,076 --> 00:12:26,413
应用程序在数据集上花费的时间

200
00:12:26,446 --> 00:12:31,618
现在 由于这个数据集的大小
我也很好奇这个测试

201
00:12:31,652 --> 00:12:33,720
使用了多少内存

202
00:12:33,754 --> 00:12:37,558
让我们使用 Allocations 工具
来试一试

203
00:12:37,591 --> 00:12:41,328
我将使用 Xcode 启动 Instruments
来分析我的测试

204
00:12:42,062 --> 00:12:44,765
我将双击 Allocations 而不是选择

205
00:12:44,798 --> 00:12:47,301
Time Profiler 工具

206
00:12:51,205 --> 00:12:52,873
然后点击 Record

207
00:13:02,916 --> 00:13:05,719
尽管此测试执行速度很快

208
00:13:05,752 --> 00:13:10,057
但它使用了大量内存
实际上超过 10 GB

209
00:13:10,090 --> 00:13:13,026
这告诉我 在测试运行期间

210
00:13:13,060 --> 00:13:15,495
几乎整个数据集都保存在内存中

211
00:13:15,529 --> 00:13:17,264
让我们来找出原因

212
00:13:19,199 --> 00:13:22,102
我可以选择要查看的分配范围

213
00:13:22,135 --> 00:13:26,573
在底部窗格中
我可以看到有许多大的分配

214
00:13:27,407 --> 00:13:31,211
我可以通过单击这个公开信息
来深入研究这些内容

215
00:13:31,245 --> 00:13:33,647
然后单击分配给测试的

216
00:13:33,680 --> 00:13:36,250
一个大数据团

217
00:13:36,283 --> 00:13:41,288
此特定 blob 已分配
但在将近两秒钟内未释放

218
00:13:41,321 --> 00:13:45,292
这是一个永恒的测试时间
为什么它能存在这么久呢

219
00:13:46,894 --> 00:13:49,930
我可以通过展开右边的
堆栈轨迹来探究这一点

220
00:13:53,834 --> 00:13:57,404
根据经验
分配和解除堆栈轨迹告诉我

221
00:13:57,437 --> 00:14:00,807
此对象是由于 CoreData
而出现了故障

222
00:14:00,841 --> 00:14:05,145
然后在托管对象上下文
完成其工作时释放

223
00:14:05,179 --> 00:14:09,283
这通常表示对象是由提取
autoreleasepool

224
00:14:09,316 --> 00:14:12,486
或测试中的对象保留的

225
00:14:15,155 --> 00:14:19,126
代码中有问题的部分在我的验证器中

226
00:14:19,159 --> 00:14:22,563
我从附件中加载图像并进行验证

227
00:14:22,596 --> 00:14:26,600
但这会将附件和关联的图像数据

228
00:14:26,633 --> 00:14:28,969
注册到托管对象上下文中

229
00:14:29,736 --> 00:14:33,106
我们可以通过多种方式
来解决这个问题

230
00:14:33,140 --> 00:14:37,177
例如 在表格视图中
当表格滚动到帖子上时

231
00:14:37,211 --> 00:14:41,615
我们可以使用批处理提取
来释放图像

232
00:14:41,648 --> 00:14:46,286
然而 此测试执行得太快
无法有效执行

233
00:14:46,320 --> 00:14:48,922
我需要改变方法

234
00:14:48,956 --> 00:14:54,228
我可以提取附件
而不是通过提取帖子来验证

235
00:14:54,261 --> 00:14:57,931
如果我也只提取 objectID
那么托管对象上下文

236
00:14:57,965 --> 00:15:01,368
将不会捕获任何加载的对象
除非我要求它这样做

237
00:15:03,237 --> 00:15:07,040
在进行验证时 我可以使用
NSManagedObjectContext 的

238
00:15:07,074 --> 00:15:11,178
objectWithID 方法提取附件

239
00:15:11,211 --> 00:15:16,250
最后 对于我验证的每 10 个附件
我会重置上下文

240
00:15:16,283 --> 00:15:19,653
释放所有缓存状态和相关内存

241
00:15:21,555 --> 00:15:25,459
如果我用这个变化重新运行测试
我可以看到它将引起

242
00:15:25,492 --> 00:15:29,229
更可预测和更可调的内存消耗水平

243
00:15:30,063 --> 00:15:32,900
事实上 在插入这些对象时

244
00:15:32,933 --> 00:15:34,868
验证器使用的内存

245
00:15:34,902 --> 00:15:36,770
甚至比 LargeDataGenerator 更少

246
00:15:38,272 --> 00:15:41,141
让我们深入了解特定的分配

247
00:15:41,175 --> 00:15:42,976
以了解修复的工作方式

248
00:15:44,344 --> 00:15:47,681
首先 我将选择一系列要使用的分配

249
00:15:47,714 --> 00:15:50,951
然后 我将选择一个
特定的大小进行检查

250
00:15:54,755 --> 00:16:00,227
我需要启用已销毁的对象
来查找在此期间释放的对象

251
00:16:00,260 --> 00:16:03,530
然后我可以选择一个
特定的分配进行检查

252
00:16:05,732 --> 00:16:10,237
在右侧 Instruments 向我显示了
一个分配堆栈轨迹

253
00:16:10,270 --> 00:16:15,742
但我想知道它在哪里被释放
所以我将选择 deallocation 事件

254
00:16:15,776 --> 00:16:18,011
我碰巧知道这个堆栈轨迹意味着

255
00:16:18,045 --> 00:16:21,849
NSManagedObjectContext
正在异步释放

256
00:16:21,882 --> 00:16:26,320
保留此 blob 的对象
从而释放已使用的内存

257
00:16:27,054 --> 00:16:31,191
这种技术使我能够为测试
建立一个高水位线

258
00:16:31,225 --> 00:16:33,994
使其能够在内存较少的系统上运行

259
00:16:35,028 --> 00:16:38,932
通过将测试
与 Instruments 相结合

260
00:16:38,966 --> 00:16:43,637
我发现这个特定的测试有一些
不太理想的行为

261
00:16:43,670 --> 00:16:46,940
我做了有针对性的改变
来直接解决这种行为

262
00:16:46,974 --> 00:16:49,610
然后验证结果

263
00:16:49,643 --> 00:16:52,713
此外 系统日志还包含

264
00:16:52,746 --> 00:16:55,682
大量关于应用程序及其依赖的

265
00:16:55,716 --> 00:16:57,918
系统服务的信息

266
00:16:57,951 --> 00:17:01,922
如 CloudKit 进程表 和推送通知

267
00:17:02,890 --> 00:17:08,295
我将在我的 MacBook Pro
和 iPhone 之间同步一篇帖子

268
00:17:08,328 --> 00:17:12,399
当我在 Mac 上插入一篇新帖子
给它一个简短的标题

269
00:17:12,432 --> 00:17:14,801
并将其上传到 iCloud 时

270
00:17:14,835 --> 00:17:17,237
系统日志会捕获一些事件

271
00:17:18,338 --> 00:17:21,375
当它与我的 iPhone 同步时
有时甚至会捕获

272
00:17:21,408 --> 00:17:23,076
中间状态

273
00:17:23,110 --> 00:17:27,181
系统日志会捕获相应的一组事件

274
00:17:27,214 --> 00:17:31,618
在 MacBook Pro上
NSPersistentCloudKitContainer

275
00:17:31,652 --> 00:17:37,357
在应用程序进程内部工作 在本例中
它是 CoreDataCloudKitDemo

276
00:17:37,391 --> 00:17:39,826
当数据被写入持久存储时

277
00:17:39,860 --> 00:17:43,330
它会询问名为 DASD 的系统服务

278
00:17:43,363 --> 00:17:47,234
现在是否适合将数据导出到 CloudKit

279
00:17:47,267 --> 00:17:51,605
如果是 那么DASD 将通知
NSPersistentCloudKitContainer

280
00:17:51,638 --> 00:17:53,607
运行任务

281
00:17:53,640 --> 00:17:57,044
然后 NSPersistentCloudKitContainer
将使用一个

282
00:17:57,077 --> 00:17:59,046
名为 cloudd 的进程来调度工作

283
00:17:59,079 --> 00:18:02,216
以将更改后的对象导出到 CloudKit

284
00:18:02,249 --> 00:18:07,020
我们可以使用 Console app
观察每个进程的日志

285
00:18:07,721 --> 00:18:11,792
对于应用程序日志
我们只需查找应用程序进程

286
00:18:11,825 --> 00:18:13,994
CoreDataCloudKitDemo

287
00:18:14,027 --> 00:18:18,131
在这里 我选择了一个
显示导出完成的选项

288
00:18:18,165 --> 00:18:23,237
对于调度日志
我们希望查看来自进程 dasd

289
00:18:23,270 --> 00:18:26,707
和来自应用程序特定存储的日志

290
00:18:26,740 --> 00:18:29,977
在这里 我为应用程序的私有存储

291
00:18:30,010 --> 00:18:32,613
选择了导出任务开始

292
00:18:32,646 --> 00:18:35,215
让我们更详细地检查一下这个日志

293
00:18:36,116 --> 00:18:39,653
NSPersistentCloudKitContainer
使用 dasd 创建的任务

294
00:18:39,686 --> 00:18:43,257
遵循特定的格式

295
00:18:43,290 --> 00:18:47,127
任务标识符由
NSPersistentCloudKitContainer

296
00:18:47,160 --> 00:18:52,266
使用的特定前缀以及任务所属存储的

297
00:18:52,299 --> 00:18:55,369
存储标识符组成

298
00:18:55,402 --> 00:18:59,506
dasd 日志包含有关服务如何决定

299
00:18:59,540 --> 00:19:01,675
任务是否可以运行的信息

300
00:19:01,708 --> 00:19:05,312
影响应用程序工作能力的策略

301
00:19:05,345 --> 00:19:08,949
将与最终决策一起列在日志中

302
00:19:10,017 --> 00:19:14,555
最后 流程 cloudd 记录
来自 CloudKit 的信息

303
00:19:14,588 --> 00:19:16,757
我喜欢根据正在处理的

304
00:19:16,790 --> 00:19:19,860
容器标识符过滤这些日志

305
00:19:19,893 --> 00:19:23,463
在这里 我为前面提到的导出内容

306
00:19:23,497 --> 00:19:25,499
选择了相应的修改记录操作

307
00:19:26,633 --> 00:19:29,937
当在接收设备上导入更改时

308
00:19:29,970 --> 00:19:33,440
还有一个额外的过程需要观察

309
00:19:33,473 --> 00:19:38,278
apsd 进程负责接收推送通知

310
00:19:38,312 --> 00:19:40,614
并将其转发给应用程序

311
00:19:41,248 --> 00:19:44,017
这会导致
NSPersistentCloudKitContainer

312
00:19:44,051 --> 00:19:48,856
启动一系列类似于导出过程的任务

313
00:19:48,889 --> 00:19:52,392
它询问 dasd 执行导入的时间

314
00:19:52,426 --> 00:19:56,530
然后使用 cloudd 从 CloudKit 提取

315
00:19:56,563 --> 00:19:59,299
所有更新的对象
并将它们导入本地存储

316
00:20:00,601 --> 00:20:05,739
Apsd 在收到应用程序的推送通知时

317
00:20:05,772 --> 00:20:09,142
会进行日志记录
该日志记录了许多重要的细节

318
00:20:10,010 --> 00:20:13,680
日志消息包括这里的容器标识符

319
00:20:13,714 --> 00:20:16,884
以及触发推送通知的

320
00:20:16,917 --> 00:20:19,319
订阅名称和区域标识符

321
00:20:19,353 --> 00:20:22,422
这些由
NSPersistentCloudKitContainer 管理

322
00:20:22,456 --> 00:20:27,728
并将始终以前缀
com.apple.coredata.cloudkit 开头

323
00:20:29,296 --> 00:20:31,498
现在 console app 很棒

324
00:20:31,532 --> 00:20:35,235
但当我在 Mac 上开发时 我喜欢
使用终端中的 log stream 命令

325
00:20:35,269 --> 00:20:38,672
将这些日志显示在我的 App 旁边

326
00:20:40,007 --> 00:20:44,478
我为以下每个 predicate
打开一个终端窗口或选项卡

327
00:20:44,511 --> 00:20:46,947
首先是应用程序

328
00:20:46,980 --> 00:20:52,519
接下来是 cloudd 中的日志 这样我就
可以看到 CloudKit 服务器发生了什么

329
00:20:52,553 --> 00:20:56,657
接下来 是用于推送通知日志的 apsd

330
00:20:56,690 --> 00:21:00,661
最后是 dasd 这样我就可以看到
NSPersistentCloudKitContainer

331
00:21:00,694 --> 00:21:04,898
为我安排的任务发生了什么

332
00:21:04,932 --> 00:21:09,469
这些 predicate 还可以用于
指导 console app 中的查询

333
00:21:11,205 --> 00:21:15,475
在我们使用的设备上
有很多信息可供我们使用

334
00:21:15,509 --> 00:21:19,646
真正的挑战是知道使用什么工具
来发现和分析信息

335
00:21:19,680 --> 00:21:24,318
仅使用 Instruments
我们就可以了解许多主题

336
00:21:24,351 --> 00:21:27,054
如运行时间和内存性能等

337
00:21:27,087 --> 00:21:31,325
系统日志捕获事件
这些事件描述应用程序所做的工作

338
00:21:31,358 --> 00:21:33,861
以及系统在幕后为它所做的工作

339
00:21:34,828 --> 00:21:37,531
开发周期的最后阶段

340
00:21:37,564 --> 00:21:40,868
是收集和提供可操作的反馈

341
00:21:40,901 --> 00:21:44,671
在这个部分 我将演示如何从设备收集

342
00:21:44,705 --> 00:21:45,939
诊断信息

343
00:21:45,973 --> 00:21:48,275
我们的目标是利用这些信息

344
00:21:48,308 --> 00:21:52,846
来产生可行的反馈
并与特定的目标保持一致

345
00:21:52,880 --> 00:21:55,115
这些技术可以帮助你
从任何设备收集反馈

346
00:21:55,148 --> 00:21:59,253
无论是你自己的设备还是客户的设备

347
00:21:59,286 --> 00:22:04,391
从设备收集诊断信息有三个步骤

348
00:22:04,424 --> 00:22:07,661
首先 我们需要安装 CloudKit
日志记录配置文件

349
00:22:07,694 --> 00:22:10,764
该文件允许使用日志来识别问题

350
00:22:10,797 --> 00:22:13,000
并对其进行有效分类

351
00:22:13,033 --> 00:22:17,404
接下来 我们将从受影响的设备
收集 sysdiagnose

352
00:22:17,437 --> 00:22:21,141
最后 如果我们对设备有物理访问权

353
00:22:21,175 --> 00:22:24,611
我们还可以从 Xcode
收集持久存储文件

354
00:22:25,145 --> 00:22:29,716
要安装日志配置文件 我们只需访问

355
00:22:29,750 --> 00:22:31,818
开发人员网站上的
Profile and Logs 页面

356
00:22:31,852 --> 00:22:36,790
我可以搜索 CloudKit 配置文件
然后点击配置文件链接进行下载

357
00:22:36,823 --> 00:22:41,328
在某些设备上
会显示安装配置文件的通知

358
00:22:41,361 --> 00:22:44,498
然而 在 iOS 上 我们需要通过

359
00:22:44,531 --> 00:22:45,465
Settings app 手动安装

360
00:22:47,267 --> 00:22:52,639
在 Settings 中 我可以导航到
点击 Profile Downloaded 单元格

361
00:22:52,673 --> 00:22:56,610
然后我可以点击下载的
配置文件进行安装

362
00:22:56,643 --> 00:23:00,514
按照步骤完成安装

363
00:23:00,547 --> 00:23:02,516
配置文件安装完成后

364
00:23:02,549 --> 00:23:05,619
重启设备即可生效

365
00:23:09,022 --> 00:23:12,459
一旦设备重新启动 我们就可以重现

366
00:23:12,492 --> 00:23:15,395
我们想要捕获的行为
然后进行系统诊断

367
00:23:16,096 --> 00:23:21,702
进行系统诊断是通过 keychord
即一系列特殊的按钮来完成的

368
00:23:21,735 --> 00:23:25,506
这些在配置文件的说明页面中
进行了描述

369
00:23:25,539 --> 00:23:29,076
我碰巧知道 在 iPhone 中
我们按住音量键

370
00:23:29,109 --> 00:23:31,645
和侧边按钮几秒钟

371
00:23:31,678 --> 00:23:33,480
然后松开

372
00:23:33,514 --> 00:23:37,784
稍后 sysdiagnose 便在
Settings 中可用

373
00:23:37,818 --> 00:23:41,255
查找它的说明包含在概要文件的

374
00:23:41,288 --> 00:23:42,256
说明文件中

375
00:23:43,190 --> 00:23:48,562
在 Settings 中
我导航到 Privacy & Security

376
00:23:48,595 --> 00:23:50,564
Analytics and Improvements

377
00:23:50,597 --> 00:23:52,833
然后选择 Analytics Data

378
00:23:52,866 --> 00:23:56,170
在日志中滚动
直到找到 sysdiagnose

379
00:23:57,437 --> 00:24:01,308
如果我点击 sysdiagnose
然后点击 Share 按钮

380
00:24:01,341 --> 00:24:03,310
我可以选择多种方式来分享它

381
00:24:04,077 --> 00:24:08,081
例如 我喜欢将它们隔空投送到
我的 Mac 上进行分析

382
00:24:08,715 --> 00:24:11,752
最后 如果可能的话
我可以使用 Device Organizer

383
00:24:11,785 --> 00:24:13,921
从 Xcode 收集存储文件

384
00:24:14,721 --> 00:24:16,924
我可以从这台 iPhone 上收集文件

385
00:24:16,957 --> 00:24:18,792
方法是单击已安装 App 列表中的

386
00:24:18,825 --> 00:24:20,394
示例应用程序

387
00:24:20,427 --> 00:24:22,262
单击公开信息按钮

388
00:24:22,296 --> 00:24:24,164
选择 Download Container

389
00:24:24,198 --> 00:24:26,733
并将其保存到我的
Downloads 目录中

390
00:24:30,470 --> 00:24:34,174
完成所有这些操作后
现在可以对系统日志

391
00:24:34,208 --> 00:24:36,343
和存储文件进行分析了

392
00:24:36,376 --> 00:24:38,946
我们已经讨论了 log stream 命令

393
00:24:38,979 --> 00:24:40,047
但使用 sysdiagnose 时

394
00:24:40,080 --> 00:24:44,985
我可以使用 log show 命令
打印出系统诊断中的日志

395
00:24:45,018 --> 00:24:49,389
在这里 我复制了我们前面谈到的
apsd 日志的 predicate

396
00:24:51,925 --> 00:24:56,530
log show 命令的最后一个参数
是要使用的 logarchive

397
00:24:56,563 --> 00:24:59,466
如果未指定任何内容 它将显示

398
00:24:59,499 --> 00:25:01,502
其运行所在机器的系统日志

399
00:25:01,535 --> 00:25:05,105
这里 我指定了 system_logs.logarchive

400
00:25:05,138 --> 00:25:08,308
以便读取我从
sysdiagnose 中获取的日志

401
00:25:08,342 --> 00:25:11,912
例如 我可以指定一个精确的
时间范围

402
00:25:11,945 --> 00:25:15,382
以关注我感兴趣的事件发生的时间

403
00:25:16,884 --> 00:25:20,120
我还可以将我们前面讨论的
许多 predicate 组合起来

404
00:25:20,153 --> 00:25:25,492
形成一个与应用程序相关的
所有任务的统一日志

405
00:25:25,526 --> 00:25:28,562
首先是这里的应用程序日志

406
00:25:28,595 --> 00:25:33,200
这里的 cloudd 日志
这里的 apsd 日志

407
00:25:33,233 --> 00:25:35,869
最后是这里的 dasd 日志

408
00:25:36,703 --> 00:25:40,073
这个强大的命令可以包含在
反馈报告中

409
00:25:40,107 --> 00:25:41,408
也可以与队友共享

410
00:25:41,441 --> 00:25:45,445
让每个人都可以专注于一组
特定的日志进行分析

411
00:25:46,947 --> 00:25:50,918
在本讲座中
我们讨论了如何使用数据生成器

412
00:25:50,951 --> 00:25:52,920
来探索应用程序的行为

413
00:25:52,953 --> 00:25:56,690
如何使用工具和系统日志
来分析应用程序

414
00:25:56,723 --> 00:25:59,193
以及如何从使用
NSPersistentCloudKitContainer 的

415
00:25:59,226 --> 00:26:02,663
应用程序中提供或收集可操作的反馈

416
00:26:03,964 --> 00:26:04,932
我是 Nick Gillett

417
00:26:04,965 --> 00:26:08,101
很高兴为大家带来这个演讲

418
00:26:08,135 --> 00:26:13,106
感谢收看 保持活跃 双手合十
祝你余下的 WWDC 之旅一切顺利

419
00:26:14,408 --> 00:26:16,476
[古怪的音乐]

