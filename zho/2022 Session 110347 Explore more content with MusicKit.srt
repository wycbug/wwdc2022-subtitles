1
00:00:00,334 --> 00:00:07,341
♪ ♪

2
00:00:10,177 --> 00:00:13,180
David Ho: 大家好 欢迎来到 WWDC

3
00:00:13,213 --> 00:00:15,415
我是 David
今天我想向您介绍的是

4
00:00:15,449 --> 00:00:18,685
如何用 MusicKit 探索更多内容

5
00:00:18,719 --> 00:00:21,288
MusicKit 框架于 2021 年推出

6
00:00:21,321 --> 00:00:25,659
提供了一组 API 用于在 Swift 中
访问和播放本机音乐

7
00:00:25,692 --> 00:00:28,996
此框架使您的 App 能够
轻松地与 Apple Music 整合

8
00:00:29,029 --> 00:00:32,299
并提供对整个 Apple Music
目录的访问

9
00:00:32,332 --> 00:00:34,968
今天 我要介绍的是
我们对 MusicKit 所做的

10
00:00:35,002 --> 00:00:36,937
一些主要改进

11
00:00:36,970 --> 00:00:40,641
我将从一些附加内容开始
通过新的音乐项目类型

12
00:00:40,674 --> 00:00:45,012
新的请求和新的元数据
从 Apple Music 目录中获得更多信息

13
00:00:46,046 --> 00:00:49,283
之后 我将讨论如何获取个性化内容

14
00:00:49,316 --> 00:00:53,187
以便为每个用户提供定制的体验

15
00:00:53,220 --> 00:00:56,223
接下来 我将介绍
Apple Music 目录以外的内容

16
00:00:56,256 --> 00:00:59,092
今年 通过加入用户曲库中的音乐

17
00:00:59,126 --> 00:01:02,596
您可以将 App 提升到
一个全新的水平

18
00:01:02,629 --> 00:01:06,133
最后 我将讨论如何主动与曲库交互

19
00:01:06,166 --> 00:01:09,036
例如向曲库或播放列表中添加项目

20
00:01:09,069 --> 00:01:12,072
以及创建和编辑播放列表

21
00:01:12,105 --> 00:01:14,842
让我们深入研究添加的目录内容

22
00:01:14,875 --> 00:01:18,579
最初发布的 MusicKit
引入了一个新的音乐模型层

23
00:01:18,612 --> 00:01:22,616
包括歌曲 专辑
和播放列表等核心类型

24
00:01:22,649 --> 00:01:25,252
今年 我们增加了两种新类型

25
00:01:25,285 --> 00:01:28,722
让 MusicKit 更容易发现新音乐

26
00:01:28,755 --> 00:01:30,824
Curator 和 Radio Show

27
00:01:32,092 --> 00:01:34,561
除此之外 MusicKit 现在还可以让您

28
00:01:34,595 --> 00:01:37,831
构建出色的 UI 来搜索目录

29
00:01:37,865 --> 00:01:41,134
访问排行榜以获取
最受欢迎的歌曲 专辑等

30
00:01:41,168 --> 00:01:44,204
并获取新的属性

31
00:01:44,238 --> 00:01:48,809
例如更高质量的音频元数据
如支持 Dolby Atmos 的 Spatial Audio

32
00:01:49,610 --> 00:01:53,213
让我们从 curator 和广播节目开始
这是发现音乐的

33
00:01:53,247 --> 00:01:54,882
极好资源

34
00:01:54,915 --> 00:01:58,385
在这里 我们来看一个
Curator 的例子 Nike

35
00:01:58,418 --> 00:02:02,756
其他 curator 的例子还有
Shazam 和 Dr. Dre 的 Beats

36
00:02:02,789 --> 00:02:07,127
在这里 我们可以很容易找到
这位 curator 生成的所有播放列表

37
00:02:07,160 --> 00:02:11,231
此功能允许人们快速访问
他们喜欢的播放列表

38
00:02:11,265 --> 00:02:14,434
查找新歌或重新访问旧的个人收藏

39
00:02:14,468 --> 00:02:17,304
现在 让我们深入了解
更多的技术细节

40
00:02:18,238 --> 00:02:20,641
Curators 拥有多种属性

41
00:02:20,674 --> 00:02:24,244
这个新的 Curator 类型的
一些主要属性包括名称

42
00:02:24,278 --> 00:02:28,348
URL 插图和种类

43
00:02:28,382 --> 00:02:32,719
种类属性是一个 enum
可以是“编辑”或“外部”

44
00:02:32,753 --> 00:02:37,291
指示给定的 curator 是
Apple curator 还是第三方 curator

45
00:02:38,258 --> 00:02:40,761
curator 也有一个播放列表关系

46
00:02:40,794 --> 00:02:42,896
展示 curator 制作的播放列表

47
00:02:42,930 --> 00:02:46,133
真正服务于我们刚才看到的
音乐发现概念

48
00:02:47,835 --> 00:02:50,304
接下来 我们来看看广播节目类型

49
00:02:50,337 --> 00:02:52,940
像 Zane Lowe 的 New Music Daily

50
00:02:52,973 --> 00:02:56,343
和 Brooke Reese 的 Pop Hits Radio
这样的广播节目

51
00:02:56,376 --> 00:02:59,046
是通过经验丰富的专业人士
发现新音乐的另一种方式

52
00:02:59,079 --> 00:03:00,647
与 Curator 类型非常相似

53
00:03:00,681 --> 00:03:03,317
广播节目也有播放列表关系

54
00:03:03,350 --> 00:03:06,320
以查找广播节目的音乐功能

55
00:03:06,353 --> 00:03:09,623
正如这两种新类型
与播放列表的关系一样

56
00:03:09,656 --> 00:03:13,260
我们也公开了 Playlist 类型上的
两种新关系

57
00:03:13,293 --> 00:03:17,698
即反向逻辑的“Curator”
和“RadioShow”  给定一个播放列表

58
00:03:17,731 --> 00:03:21,702
我们可以很容易地获得
生成所述播放列表的实体的结构

59
00:03:23,203 --> 00:03:26,840
MusicKit 允许在目录中
搜索多种类型的内容

60
00:03:26,874 --> 00:03:31,645
我们添加了对新项目类型的支持
比如 curator 和广播节目

61
00:03:31,678 --> 00:03:34,481
列表还在继续增长 因此

62
00:03:34,515 --> 00:03:37,651
构建良好的 UI
变得越来越具有挑战性

63
00:03:37,684 --> 00:03:40,621
所以今年我们通过最匹配结果和建议

64
00:03:40,654 --> 00:03:43,857
让您的搜索变得更容易

65
00:03:43,891 --> 00:03:47,694
让我们来看看这些增强
给 UI 带来的效用

66
00:03:47,728 --> 00:03:51,164
当键入搜索内容时
您可能会得到强大的

67
00:03:51,198 --> 00:03:53,834
与音乐相关的
以及自动完成的相关支持

68
00:03:53,867 --> 00:03:56,170
这就是建议发挥作用的地方

69
00:03:56,203 --> 00:03:59,239
提供人们可能试图达到的条件

70
00:03:59,273 --> 00:04:02,309
您甚至可以更进一步显示最匹配结果

71
00:04:02,342 --> 00:04:06,380
以便快速访问人们正在搜索的内容

72
00:04:06,413 --> 00:04:09,650
为了获得最好的结果
您可能并不关心项目的类型

73
00:04:09,683 --> 00:04:12,653
而是想要专注于相关性

74
00:04:12,686 --> 00:04:15,355
这就是最匹配结果的力量

75
00:04:15,389 --> 00:04:18,659
现在 让我们从 Top Results 开始

76
00:04:18,692 --> 00:04:20,227
看一下实施起来会是什么样子

77
00:04:20,260 --> 00:04:23,864
这里是我们创建
目录搜索请求的现有方法

78
00:04:23,897 --> 00:04:25,499
需要一个搜索词

79
00:04:25,532 --> 00:04:28,001
和您想要表示的项目类型

80
00:04:28,035 --> 00:04:31,805
响应包括按请求的类型分类的集合

81
00:04:31,839 --> 00:04:35,175
这意味着有多个
特定于类型的结果列表

82
00:04:35,209 --> 00:04:38,078
尽管这很好 但我们还是想公开一个

83
00:04:38,111 --> 00:04:41,081
与类型无关的最相关的结果列表

84
00:04:41,114 --> 00:04:45,652
请求这些信息就像
添加一行代码一样简单

85
00:04:45,686 --> 00:04:49,790
这里 我们将请求的
includeTopResults 属性设置为 true

86
00:04:49,823 --> 00:04:53,060
并在响应中填充一个新属性

87
00:04:53,093 --> 00:04:55,796
这个新属性被命名为 topResults

88
00:04:55,829 --> 00:04:58,866
它包含任何请求类型的项目

89
00:04:58,899 --> 00:05:02,202
下面是 print statement 的输出

90
00:05:02,236 --> 00:05:06,073
我们可以看到 返回的最匹配结果
是一个合集中的

91
00:05:06,106 --> 00:05:11,011
歌曲 艺术家和专辑的混合
并根据相关性排序

92
00:05:11,044 --> 00:05:14,047
现在 我将向您展示
如何用 Suggestions

93
00:05:14,081 --> 00:05:16,683
帮助人们更快地到达
他们的搜索目的地

94
00:05:16,717 --> 00:05:20,687
只需创建一个带有字符串项的
建议请求

95
00:05:20,721 --> 00:05:25,192
调用响应后 您将得到建议响应

96
00:05:25,225 --> 00:05:27,961
响应中包含了一系列 Suggestions

97
00:05:27,995 --> 00:05:32,232
每个建议都包括一个
适合您的 UI 的显示词

98
00:05:32,266 --> 00:05:34,067
以及一个搜索词

99
00:05:34,101 --> 00:05:37,538
当人们选择一个建议时
您可以通过使用搜索词

100
00:05:37,571 --> 00:05:40,240
执行搜索请求来获取相应的结果

101
00:05:41,508 --> 00:05:46,280
目录排行榜是了解
最新最流行歌曲的好方法

102
00:05:46,313 --> 00:05:50,584
MusicKit 提供各种类型的图表
来查看流行趋势

103
00:05:50,617 --> 00:05:53,053
所提供的图表类型是排行榜

104
00:05:53,086 --> 00:05:57,824
例如热门歌曲或热门专辑
它们对应于最常播放的音乐

105
00:05:57,858 --> 00:06:01,528
城市排行榜和每日前 100 名

106
00:06:01,562 --> 00:06:06,633
您还可以指定所请求的排行榜
按特定的类型进行筛选

107
00:06:06,667 --> 00:06:09,870
通过代码检索这些排行榜非常简单

108
00:06:09,903 --> 00:06:12,539
目录排行榜请求遵循目录搜索请求中

109
00:06:12,573 --> 00:06:15,709
已经使用的既定模式

110
00:06:15,742 --> 00:06:18,879
首先 初始化排行榜请求

111
00:06:18,912 --> 00:06:22,182
然后 您可以指定
您喜欢的排行榜类型

112
00:06:22,216 --> 00:06:25,252
默认情况下
这将获取播放次数最多的内容

113
00:06:25,285 --> 00:06:30,157
但也可以获得
每日全球排行榜和城市排行榜

114
00:06:30,190 --> 00:06:33,560
最后 您只需指定
您希望排行榜包含的类型

115
00:06:33,594 --> 00:06:35,896
就是这样了

116
00:06:35,929 --> 00:06:38,699
当我们访问响应中的第一个
播放列表排行榜时

117
00:06:38,732 --> 00:06:43,270
我们会得到 MusicCatalogChart
它代表每天的全球排行榜

118
00:06:43,303 --> 00:06:48,775
其播放列表包括 “TOP 100：Global”
和 “Top 100: USA”

119
00:06:48,809 --> 00:06:52,279
如果您过去一直用
MusicDataRequest 获取目录排行榜

120
00:06:52,312 --> 00:06:55,482
那么现在您不需要这样做了
因为 MusicKit 将为您完成这项工作

121
00:06:55,516 --> 00:06:58,752
它在项目集合中内置了分页支持

122
00:06:58,785 --> 00:07:00,320
在 2021 年

123
00:07:00,354 --> 00:07:02,789
我们推出了具有真正多维声音

124
00:07:02,823 --> 00:07:05,959
和清晰度的突破性音频体验

125
00:07:05,993 --> 00:07:09,396
支持 Dolby Atmos 的 Spatial Audio

126
00:07:09,429 --> 00:07:13,166
这种身临其境的体验
已经可用于数千首歌曲

127
00:07:13,200 --> 00:07:15,702
现在您可以访问这些数据

128
00:07:15,736 --> 00:07:20,674
MusicKit 通过 Audio Variants
公开歌曲或专辑的可用音频资源

129
00:07:20,707 --> 00:07:25,646
因此现在
您可以将此信息转发给其他人

130
00:07:25,679 --> 00:07:28,315
Audio Variants 的示例包括
前面提到的

131
00:07:28,348 --> 00:07:33,387
支持 Dolby Atmos 和 Lossless Audio的
Spatial Audio 等

132
00:07:34,755 --> 00:07:38,492
除了 Audio Variants 之外 我们还
公开了一个新的 boolean 属性

133
00:07:38,525 --> 00:07:43,297
即 Apple Digital Master
它是受支持的最高质量的 master

134
00:07:43,330 --> 00:07:46,099
由于这些元数据是在项目级别公开的

135
00:07:46,133 --> 00:07:48,368
Audio Variants 非常适合细节视图

136
00:07:48,402 --> 00:07:51,471
允许您实现这样的 UI

137
00:07:51,505 --> 00:07:54,341
我们这里有一张专辑的详细视图

138
00:07:54,374 --> 00:07:56,743
在这里 我们可以看到
基于前面提到的

139
00:07:56,777 --> 00:07:59,580
Audio Variants 属性的相应徽章

140
00:07:59,613 --> 00:08:02,950
让用户知道他们将获得
怎样的音频质量

141
00:08:02,983 --> 00:08:05,819
在这种情况下 空间⾳频和无损音频

142
00:08:05,853 --> 00:08:08,088
可用于该特定专辑

143
00:08:08,121 --> 00:08:11,325
现在让我们看看
如何编写代码来实现这一点

144
00:08:11,358 --> 00:08:14,928
加载 Audio Variants
就像加载任何其他扩展属性一样

145
00:08:14,962 --> 00:08:18,732
使用加载
audioVariants 扩展属性的方法

146
00:08:18,765 --> 00:08:22,803
获取现有的专辑或歌曲
在本例中是专辑

147
00:08:22,836 --> 00:08:27,441
现在 detailedAlbum
已经填充了 audioVariants 属性

148
00:08:27,474 --> 00:08:29,510
这里我们可以看到
Audio Variants 属性

149
00:08:29,543 --> 00:08:32,913
它是一个数组
其元素是 AudioVariant

150
00:08:32,946 --> 00:08:36,884
使用这些值 您可以在 UI 中指定
该特定元素的

151
00:08:36,917 --> 00:08:40,153
可用音频资源
就像我们前面看到的那样

152
00:08:40,187 --> 00:08:42,256
现在 效果很好 但您可能不仅仅希望

153
00:08:42,289 --> 00:08:45,959
在顶层或细节视图上
显示这些音频徽章

154
00:08:45,993 --> 00:08:48,562
这就是为什么我们还要更进一步

155
00:08:48,595 --> 00:08:52,099
为音乐播放器提供动态音频版本

156
00:08:52,132 --> 00:08:55,469
访问活动的 audioVariant 允许对

157
00:08:55,502 --> 00:08:58,772
当前播放项的音频质量
进行可视化指示

158
00:08:58,805 --> 00:09:01,542
例如此视图中的 Dolby Atmos

159
00:09:01,575 --> 00:09:04,511
MusicKit 播放器 API
会根据用户设置

160
00:09:04,545 --> 00:09:08,382
和网络条件自动选择正确的音频质量

161
00:09:09,216 --> 00:09:11,518
要从播放器访问活动特征

162
00:09:11,552 --> 00:09:15,122
首先 我们访问观察对象中

163
00:09:15,155 --> 00:09:17,157
ApplicationMusicPlayer 的播放状态

164
00:09:17,191 --> 00:09:21,728
然后 我们可以直接从播放状态
访问活动的 audioVariant

165
00:09:21,762 --> 00:09:24,031
现在 我们只需检查
audioVariant 属性

166
00:09:24,064 --> 00:09:27,734
看看它是否是 dolbyAtmos
如果是 则添加额外的 UI

167
00:09:27,768 --> 00:09:30,204
因为播放状态是观察到的对象

168
00:09:30,237 --> 00:09:32,272
所以只要当前播放的项目发生更改

169
00:09:32,306 --> 00:09:34,274
此视图就会自动更新

170
00:09:34,308 --> 00:09:37,311
从而确保您的视图始终是最新的

171
00:09:37,344 --> 00:09:39,680
现在我们已经了解了一些目录添加

172
00:09:39,713 --> 00:09:42,282
让我们深入了解个性化内容

173
00:09:42,316 --> 00:09:45,285
个性化内容是特定于订阅者的数据

174
00:09:45,319 --> 00:09:49,423
为 App 中的每个用户
提供独特的定制体验

175
00:09:49,456 --> 00:09:52,526
通常 个性化内容需要
特殊的身份验证

176
00:09:52,559 --> 00:09:55,395
和用户令牌 但在 MusicKit 框架中

177
00:09:55,429 --> 00:09:59,132
我们已将其全部自动化
因此您无需处理任何麻烦

178
00:09:59,166 --> 00:10:01,502
我们为开发人员提供的个性化内容是

179
00:10:01,535 --> 00:10:03,770
访问最近播放的项目

180
00:10:03,804 --> 00:10:06,907
和个人推荐

181
00:10:06,940 --> 00:10:09,443
最近播放的内容

182
00:10:09,476 --> 00:10:12,279
是个人音乐消费体验的宝贵数据

183
00:10:12,312 --> 00:10:16,917
它可以使您快速方便地访问
他们喜欢的音乐项目

184
00:10:16,950 --> 00:10:20,354
当听新音乐时 它允许人们回头

185
00:10:20,387 --> 00:10:22,489
去查阅他们的听歌历史

186
00:10:22,523 --> 00:10:25,526
要获取最近播放的容器
如专辑 播放列表

187
00:10:25,559 --> 00:10:29,730
和电台 您可以创建
最近播放的容器请求

188
00:10:29,763 --> 00:10:32,432
请注意 如果您要播放
播放列表或专辑中的歌曲

189
00:10:32,466 --> 00:10:34,635
就需要检索容器类型

190
00:10:34,668 --> 00:10:38,138
在响应中
您会发现最近播放的音乐项目

191
00:10:38,172 --> 00:10:43,443
您可以轻松地访问标题
副标题和插图

192
00:10:43,477 --> 00:10:46,947
您还可以获取最近播放的
更具体类型的项目

193
00:10:46,980 --> 00:10:48,882
如歌曲或电台

194
00:10:48,916 --> 00:10:52,653
这里 我们创建一个最近播放的请求

195
00:10:52,686 --> 00:10:56,490
通过由尖括号指示的
泛型参数指定歌曲类型

196
00:10:56,523 --> 00:10:59,693
我们的响应现在只包含
我们播放的歌曲

197
00:10:59,726 --> 00:11:02,596
现在 谈谈个人推荐

198
00:11:02,629 --> 00:11:07,067
个人推荐可以让您的 App 体验
更加亲密和吸引人

199
00:11:07,100 --> 00:11:11,905
因为它们是基于用户的曲库
和听歌历史产生的

200
00:11:11,939 --> 00:11:14,575
推荐会按照主题整齐排列

201
00:11:14,608 --> 00:11:20,147
按照流派 艺术家 收藏
如“为您而做”等进行分组

202
00:11:20,180 --> 00:11:22,683
要获取个人推荐

203
00:11:22,716 --> 00:11:25,552
只需创建个人推荐请求即可

204
00:11:25,586 --> 00:11:28,388
响应是一系列推荐

205
00:11:28,422 --> 00:11:32,092
当我们记录第一个推荐时
我们可以看到这个特定的元素

206
00:11:32,125 --> 00:11:34,595
代表“为您而做”的推荐

207
00:11:34,628 --> 00:11:38,632
推荐包含 ID 标题和 nextRefreshDate

208
00:11:38,665 --> 00:11:42,135
nextRefreshDate 表示刷新此推荐

209
00:11:42,169 --> 00:11:45,372
以获得最新建议的日期和时间

210
00:11:45,405 --> 00:11:49,109
播放列表属性包含
“为我而做”的所有播放列表

211
00:11:49,142 --> 00:11:52,446
让我们看看另一个推荐的例子

212
00:11:52,479 --> 00:11:56,250
在这里 我们将打印
推荐响应的第二个元素

213
00:11:56,283 --> 00:11:59,820
我听了一大堆另类音乐
这个推荐包含了

214
00:11:59,853 --> 00:12:04,391
不同类型的混合
在这个例子中为专辑和播放列表

215
00:12:04,424 --> 00:12:06,994
它们被分组在一个单独的项目集合中

216
00:12:07,027 --> 00:12:11,131
这些项目是按照相关性排序的
类似于目录搜索的最匹配结果

217
00:12:11,164 --> 00:12:14,868
现在 让我们更进一步谈谈如何通过

218
00:12:14,902 --> 00:12:17,371
将用户曲库中的内容整合到 App 中

219
00:12:17,404 --> 00:12:21,175
来创造更多与音乐相关的体验

220
00:12:21,208 --> 00:12:25,312
今年 MusicKit 允许 App
通过两种请求

221
00:12:25,345 --> 00:12:28,749
从曲库中提取项目 曲库请求

222
00:12:28,782 --> 00:12:31,485
和曲库分段请求

223
00:12:31,518 --> 00:12:34,588
搜索用户曲库中的内容

224
00:12:34,621 --> 00:12:37,524
并专门从曲库中

225
00:12:37,558 --> 00:12:39,927
加载扩展属性和关系

226
00:12:39,960 --> 00:12:42,296
在我们看到技术细节之前

227
00:12:42,329 --> 00:12:45,566
让我们看看如何使用曲库内容
来增强 App

228
00:12:45,599 --> 00:12:48,435
我一直在开发一款名为
Music Marathon 的健身 App

229
00:12:48,468 --> 00:12:50,704
它将跟踪您的户外跑步情况

230
00:12:50,737 --> 00:12:52,906
通过在项目中加入 MusicKit

231
00:12:52,940 --> 00:12:55,509
人们可以直接通过该 App 播放音乐

232
00:12:55,542 --> 00:12:59,546
而无需在  Apple Music App
和这个 App 之间切换

233
00:12:59,580 --> 00:13:03,016
我们开始一次新的训练
寻找音乐内容

234
00:13:04,818 --> 00:13:07,154
我们在这里看到一些
从个人推荐请求中

235
00:13:07,187 --> 00:13:09,122
检索到的推荐播放列表

236
00:13:09,156 --> 00:13:12,860
以便人们快速访问我们认为
他们会喜欢的播放列表

237
00:13:12,893 --> 00:13:17,531
转到“曲库”选项卡
我们可以看到它是一个空视图

238
00:13:17,564 --> 00:13:20,267
如果能看到我所有的
个人播放列表就太好了

239
00:13:20,300 --> 00:13:21,835
所以让我们来写这个特性吧

240
00:13:21,869 --> 00:13:25,439
我已经设置了一些 UI 来处理
这个视图的基本内容

241
00:13:25,472 --> 00:13:29,109
现在我想从曲库中加载播放列表

242
00:13:29,142 --> 00:13:30,777
首先 我会向曲库申请

243
00:13:33,647 --> 00:13:35,749
在泛型参数中指定播放列表

244
00:13:35,782 --> 00:13:38,785
以表明我们需要用户曲库中的
播放列表

245
00:13:42,256 --> 00:13:44,958
我把它存储在一个局部变量里
将其命名为“请求”

246
00:13:47,928 --> 00:13:51,098
接下来 我将接受这个请求
并调用响应函数

247
00:13:53,867 --> 00:13:56,403
此方法为异步抛出方法

248
00:13:56,436 --> 00:13:58,572
让我们添加尝试和等待的关键字

249
00:13:58,605 --> 00:14:01,441
并再次将其存储在响应变量中

250
00:14:04,311 --> 00:14:07,614
然后 我将更新状态对象
以接收此响应

251
00:14:11,752 --> 00:14:14,555
现在要做的就是更新列表

252
00:14:14,588 --> 00:14:17,457
这样我们就可以在 UI 中
看到播放列表了

253
00:14:17,491 --> 00:14:21,228
我将使用 ForEach 迭代响应中的项

254
00:14:25,432 --> 00:14:28,669
并检索 MusicItemCollection 中的
每个播放列表

255
00:14:30,404 --> 00:14:31,638
现在我们已经有了播放列表

256
00:14:31,672 --> 00:14:33,941
我将把它们传递到
我已经制作的 PlaylistCell 中

257
00:14:35,642 --> 00:14:37,644
现在如果我们重新运行

258
00:14:44,017 --> 00:14:46,753
然后导航回到 App

259
00:14:46,787 --> 00:14:50,057
我们可以在曲库里看到
我所有的个人播放列表

260
00:14:50,090 --> 00:14:52,826
现在 我可以选择听个人推荐

261
00:14:52,860 --> 00:14:57,097
Apple Music 目录中的内容
以及我自己的个人曲库

262
00:14:57,130 --> 00:15:00,467
现在我们已经了解了
访问曲库内容有多么容易

263
00:15:00,501 --> 00:15:02,569
让我们看看曲库请求还能做些什么

264
00:15:02,603 --> 00:15:05,239
音乐曲库请求是一个强大的 API

265
00:15:05,272 --> 00:15:07,741
可以从用户的曲库中获取项目

266
00:15:07,774 --> 00:15:11,845
在 iOS 上 与其他从音乐目录中
获取内容的请求不同

267
00:15:11,879 --> 00:15:15,682
MusicLibraryRequest 实际上
不会从网络加载数据

268
00:15:15,716 --> 00:15:19,152
相反 它将从存储在设备上的

269
00:15:19,186 --> 00:15:21,622
用户曲库副本中加载项目

270
00:15:21,655 --> 00:15:24,591
这个请求的基本内容只要求您指定

271
00:15:24,625 --> 00:15:27,027
想要的音乐项目类型

272
00:15:27,060 --> 00:15:29,429
此项目类型通过
MusicLibraryRequest 的

273
00:15:29,463 --> 00:15:32,332
泛型参数传递

274
00:15:32,366 --> 00:15:36,003
您可以对请求应用各种
过滤器和排序选项

275
00:15:36,036 --> 00:15:39,873
以便对调用进行微调
使其与您的需求相匹配

276
00:15:39,907 --> 00:15:43,710
此请求还能够获取已经下载的内容

277
00:15:43,744 --> 00:15:46,947
支持完全脱机体验

278
00:15:46,980 --> 00:15:50,450
让我们从简单的基本请求开始
就像我们在

279
00:15:50,484 --> 00:15:55,322
Music Marathon App 中写的那样
但这次我们请求的是曲库中的专辑

280
00:15:55,355 --> 00:15:58,625
专辑类型通过泛型参数来指定

281
00:15:58,659 --> 00:16:01,695
要执行请求 请调用响应函数

282
00:16:01,728 --> 00:16:04,898
看看输出 我们有一个
MusicLibraryResponse

283
00:16:04,932 --> 00:16:07,334
其中的项目是用户音乐曲库中

284
00:16:07,367 --> 00:16:11,104
找到的所有专辑的 MusicItemCollection

285
00:16:11,138 --> 00:16:14,541
在这里 我们注意到
这些专辑与您从我们的

286
00:16:14,575 --> 00:16:19,346
各种目录请求中得到的专辑结构相同
并且具有相同的功能

287
00:16:19,379 --> 00:16:22,649
而在本例中
我们将获取曲库中的每个专辑

288
00:16:22,683 --> 00:16:27,221
我们知道在某些情况下
您只需要专辑的一个特定子集

289
00:16:27,254 --> 00:16:31,458
这就是为什么 MusicLibraryRequest
还可以让您更具体地

290
00:16:31,491 --> 00:16:34,595
说明要从曲库中提取哪些项目

291
00:16:34,628 --> 00:16:38,665
我们以之前写的同样的请求为例
并添加一个过滤器

292
00:16:38,699 --> 00:16:42,369
这里 我们希望加载
isCompilation 属性为 true 的

293
00:16:42,402 --> 00:16:43,971
所有专辑

294
00:16:44,004 --> 00:16:47,941
当您调用过滤器方法时
Xcode 的自动完成功能

295
00:16:47,975 --> 00:16:52,212
只会为您请求的项目类型
提供特定的关键路径

296
00:16:52,246 --> 00:16:56,283
现在 响应中只有编译过的专辑

297
00:16:56,316 --> 00:16:59,653
但这并不是 MusicLibraryRequest
所能提供的全部功能

298
00:16:59,686 --> 00:17:01,655
您可以链接多个过滤器

299
00:17:01,688 --> 00:17:04,958
为您提供更精确的请求

300
00:17:04,992 --> 00:17:08,862
如果我们想要
某一特定流派的所有汇编呢

301
00:17:08,896 --> 00:17:11,331
我们可以向请求添加另一个过滤器

302
00:17:11,365 --> 00:17:15,002
例如 这里有一个名为
“Dance”的流派实例

303
00:17:15,035 --> 00:17:18,305
您可以根据流派的关系进行过滤

304
00:17:18,338 --> 00:17:22,309
以将结果限制为仅显示
包含此特定流派的编辑

305
00:17:22,342 --> 00:17:25,746
现在我们的响应只包含舞蹈汇编

306
00:17:25,779 --> 00:17:29,283
如果只包括已经下载的舞蹈汇编如何

307
00:17:29,316 --> 00:17:32,252
为此 只需将请求中的
includeOnlyDownloadedContent

308
00:17:32,286 --> 00:17:33,787
设置为 true

309
00:17:33,820 --> 00:17:34,955
就是这样了

310
00:17:34,988 --> 00:17:37,891
响应是相同的 MusicLibraryResponse

311
00:17:37,925 --> 00:17:41,662
但项目现在只包含下载的元素

312
00:17:41,695 --> 00:17:45,165
正如您所看到的
音乐曲库请求功能非常强大

313
00:17:45,199 --> 00:17:50,204
并解锁了定制 MusicDataRequest
无法实现的新功能

314
00:17:50,237 --> 00:17:54,842
但 MusicKit 提供了更多
从用户曲库中获取数据的选项

315
00:17:54,875 --> 00:17:57,611
来看看 Library Sectioned Request

316
00:17:57,644 --> 00:18:02,082
分段请求能够获取按段分组的项目

317
00:18:02,115 --> 00:18:06,987
因此 分段请求接受
两个不同的泛型参数

318
00:18:07,020 --> 00:18:11,758
第一个表示段类型
第二个表示项类型

319
00:18:11,792 --> 00:18:14,661
曲库分段请求支持
与常规曲库请求相同的功能

320
00:18:14,695 --> 00:18:18,098
例如您可以应用于段或项的

321
00:18:18,131 --> 00:18:23,470
各种过滤和排序方法

322
00:18:23,504 --> 00:18:26,874
以下是如何使用曲库分段请求

323
00:18:26,907 --> 00:18:29,743
来获取所有按其流派分段的专辑

324
00:18:29,776 --> 00:18:33,647
分段响应包含一个名为
“段”的属性 其中每个元素

325
00:18:33,680 --> 00:18:38,318
对应于请求的第一个泛型参数
在本例中为 Genre

326
00:18:38,352 --> 00:18:42,456
每个流派不仅公开了自己的属性
而且还包含一个

327
00:18:42,489 --> 00:18:46,660
专辑集合 可通过项属性访问

328
00:18:46,693 --> 00:18:50,030
这些项目对应于第二个泛型参数

329
00:18:50,063 --> 00:18:53,367
在这里突出显示
专辑的类型是 Alternative

330
00:18:53,400 --> 00:18:56,937
正如前面提到的 过滤和排序功能

331
00:18:56,970 --> 00:18:59,706
也可以用于这个分段请求

332
00:18:59,740 --> 00:19:02,643
假设我们想要相同的专辑
按流派进行分类

333
00:19:02,676 --> 00:19:05,979
但这些专辑是按艺术家的名字排序的

334
00:19:06,013 --> 00:19:07,681
我们添加一个排序过滤器

335
00:19:07,714 --> 00:19:11,585
通过在专辑上指定
artistName keyPath 并说明

336
00:19:11,618 --> 00:19:15,055
我们希望这些是升序的
对响应进行排序

337
00:19:15,088 --> 00:19:18,592
请注意 该方法是排序项
因为我们指定了

338
00:19:18,625 --> 00:19:21,662
要应用于项目而不是段的排序

339
00:19:21,695 --> 00:19:23,564
如果我们想要指定段

340
00:19:23,597 --> 00:19:27,668
可以使用一组
filterSections 和 sortSection 方法

341
00:19:27,701 --> 00:19:29,670
让我们来看看新的响应结果

342
00:19:32,139 --> 00:19:35,776
我们现在可以看到我们的专辑
是按艺术家名字的字母顺序排列的

343
00:19:35,809 --> 00:19:37,811
而不是按标题

344
00:19:37,845 --> 00:19:42,516
曲库请求和曲库分段请求都非常强大

345
00:19:42,549 --> 00:19:45,485
但是您可能还想通过
添加用户曲库中的

346
00:19:45,519 --> 00:19:48,655
搜索结果来补充您的音乐搜索 UI

347
00:19:48,689 --> 00:19:52,593
我们添加了一个新的结构化请求
它的操作与目录搜索几乎相同

348
00:19:52,626 --> 00:19:54,962
但它不是从目录中加载结果

349
00:19:54,995 --> 00:19:59,666
而是在用户的曲库中找到相关的项目

350
00:19:59,700 --> 00:20:02,669
与对应的目录一样 曲库搜索请求

351
00:20:02,703 --> 00:20:06,773
只需要一个搜索词和一个类型数组

352
00:20:06,807 --> 00:20:10,244
现在我们已经了解了
从用户曲库中检索项目的不同方法

353
00:20:10,277 --> 00:20:13,814
那么加载扩展属性和关系怎么样

354
00:20:13,847 --> 00:20:17,784
您可能知道 MusicKit 的初始版本
引入了 with 方法

355
00:20:17,818 --> 00:20:22,189
以一种简单的方式从
Apple Music API 加载这些属性

356
00:20:22,222 --> 00:20:24,658
今年 我们增加了 Current with 方法

357
00:20:24,691 --> 00:20:28,195
还引入了一个首选源参数

358
00:20:28,228 --> 00:20:32,299
对于 Apple Music 目录
和用户曲库中均可用的

359
00:20:32,332 --> 00:20:36,170
扩展属性和关系
此首选源指示从何处

360
00:20:36,203 --> 00:20:38,438
加载数据

361
00:20:38,472 --> 00:20:41,942
对于只存在于目录或曲库中的属性

362
00:20:41,975 --> 00:20:44,711
无论首选源是什么 它们都将被提取

363
00:20:44,745 --> 00:20:47,581
以确保不会忽略任何内容

364
00:20:47,614 --> 00:20:49,950
此外 无论初始项目来自何处

365
00:20:49,983 --> 00:20:52,419
无论是目录请求 曲库请求

366
00:20:52,452 --> 00:20:56,390
还是其他地方 都可以使用此功能

367
00:20:56,423 --> 00:20:57,958
它都很管用

368
00:20:58,959 --> 00:21:02,963
这里我们了解了已知的
接收音乐项关系的方法

369
00:21:02,996 --> 00:21:06,700
我们正在加载一张专辑的曲目
当我们显示输出时

370
00:21:06,733 --> 00:21:09,269
可以看到该专辑的所有曲目

371
00:21:09,303 --> 00:21:13,574
但是 通过新添加的
preferredSource 属性

372
00:21:13,607 --> 00:21:15,242
我们可以指定希望从曲库中

373
00:21:15,275 --> 00:21:17,578
获取这种关系

374
00:21:17,611 --> 00:21:22,349
现在 我们的输出只包含
在曲库中找到的专辑的曲目

375
00:21:22,382 --> 00:21:25,886
现在 您可以通过各种方式
从用户的曲库中获取项目

376
00:21:25,919 --> 00:21:28,655
但只有允许用户通过 MusicKit

377
00:21:28,689 --> 00:21:31,358
直接与曲库交互才有意义

378
00:21:31,391 --> 00:21:34,228
让我们回到我的示例 App
Music Marathon

379
00:21:34,261 --> 00:21:37,164
看看这个曲库提供的一些功能

380
00:21:37,197 --> 00:21:39,333
在我训练的时候 我想浏览一下

381
00:21:39,366 --> 00:21:40,834
我的个人推荐

382
00:21:43,270 --> 00:21:45,839
当我浏览这些曲目时
发现这些歌曲中

383
00:21:45,873 --> 00:21:47,975
有一首非常适合我的训练播放列表

384
00:21:48,008 --> 00:21:51,311
如果按住其中一个单元格
就会弹出一个快捷菜单

385
00:21:51,345 --> 00:21:53,881
允许我将这首歌添加到播放列表中

386
00:21:53,914 --> 00:21:57,851
当我们按下它时
我所有的播放列表再次弹出

387
00:21:57,885 --> 00:22:01,555
我们来编写代码 将选定的曲目
添加到我选择的播放列表中

388
00:22:01,588 --> 00:22:05,025
我已经将所选项目通过管道
传输到 AddToPlaylistCell 单元

389
00:22:05,058 --> 00:22:09,229
所以我们所要做的就是
通过共享实例访问 MusicLibrary

390
00:22:13,534 --> 00:22:16,703
我们将调用“add”方法

391
00:22:16,737 --> 00:22:18,972
指定我们选择的曲目

392
00:22:19,006 --> 00:22:21,275
和要添加到哪个播放列表

393
00:22:23,343 --> 00:22:25,812
这个方法也是一个异步抛出函数

394
00:22:25,846 --> 00:22:28,815
所以我们再次添加
尝试和等待的关键字

395
00:22:31,084 --> 00:22:33,053
最后 我们通过将

396
00:22:33,086 --> 00:22:36,490
isShowingPlaylistPicker 绑定变量
设置为 false 来关闭选取器

397
00:22:38,225 --> 00:22:40,827
现在 如果我们重新运行

398
00:22:40,861 --> 00:22:44,598
并向播放列表中添加一首曲目
并选择其中一个播放列表

399
00:22:44,631 --> 00:22:47,901
我们应该会看到添加了此项目

400
00:22:47,935 --> 00:22:50,704
导航回 App 中的曲库选项卡

401
00:22:50,737 --> 00:22:53,607
我们可以看到歌曲现在已添加到
我们的训练播放列表中

402
00:22:53,640 --> 00:22:56,443
向播放列表中添加项目就是这么简单

403
00:22:56,476 --> 00:22:59,913
让我们看看这个曲库提供的
其他一些功能

404
00:22:59,947 --> 00:23:03,317
与曲库交互的各种其他方式包括

405
00:23:03,350 --> 00:23:06,420
向曲库添加内容 创建播放列表

406
00:23:06,453 --> 00:23:10,524
以及编辑播放列表的元数据
和曲目列表

407
00:23:10,557 --> 00:23:14,728
向用户的音乐库添加内容
可以让人们在 Apple Music App 的

408
00:23:14,761 --> 00:23:18,532
曲库选项卡中找到
特定的歌曲或专辑

409
00:23:18,565 --> 00:23:21,134
以及在设置中打开 Sync Library 时

410
00:23:21,168 --> 00:23:24,338
在所有设备之间进行同步

411
00:23:24,371 --> 00:23:27,474
在您的 App 中直接
提供此功能可以避免人们

412
00:23:27,508 --> 00:23:30,878
在 Apple Music App
和您的 App 之间切换

413
00:23:30,911 --> 00:23:34,515
这样他们就可以
继续关注您提供的内容

414
00:23:34,548 --> 00:23:36,917
此外 通过将添加

415
00:23:36,950 --> 00:23:39,586
和新引入的曲库请求集成在一起

416
00:23:39,620 --> 00:23:42,322
您的 App 可以立即
从这些结果中受益

417
00:23:42,356 --> 00:23:46,026
让用户轻松访问他们喜欢的内容

418
00:23:46,059 --> 00:23:47,928
即使有了这种强大的服务

419
00:23:47,961 --> 00:23:51,331
您可能还是想创造特殊的音乐体验

420
00:23:51,365 --> 00:23:56,236
因此今年 我们将播放列表的
创建和编辑引入 MusicKit

421
00:23:56,270 --> 00:23:59,806
现在 您可以代表用户创建播放列表

422
00:23:59,840 --> 00:24:03,277
我们还可以将歌曲
甚至整个专辑等项目

423
00:24:03,310 --> 00:24:07,447
添加到用户曲库中的
任何符合条件的播放列表中

424
00:24:07,481 --> 00:24:11,151
创建播放列表非常适合
将人们喜欢的内容分组

425
00:24:11,185 --> 00:24:14,188
或者根据情绪设置 App

426
00:24:14,221 --> 00:24:16,557
通过向现有的播放列表添加内容

427
00:24:16,590 --> 00:24:19,860
您可以使用 MusicKit 提供的
各种音乐发现工具

428
00:24:19,893 --> 00:24:22,629
来直接影响用户

429
00:24:22,663 --> 00:24:24,898
您现在还可以编辑已创建的播放列表

430
00:24:24,932 --> 00:24:28,402
可以编辑曲目列表和元数据
以确保

431
00:24:28,435 --> 00:24:30,504
一切都符合您的需要

432
00:24:30,537 --> 00:24:33,507
这些就是您可以在 App 中

433
00:24:33,540 --> 00:24:35,776
与用户曲库交互的方式

434
00:24:35,809 --> 00:24:39,713
总而言之 MusicKit 今年
进行了一些重大升级

435
00:24:39,746 --> 00:24:43,750
轻松将我们针对新类型属性的
目录增强功能

436
00:24:43,784 --> 00:24:47,988
和搜索增强功能整合到现有 App 中
以获得更好的体验

437
00:24:49,256 --> 00:24:51,458
集成曲库内容和功能

438
00:24:51,491 --> 00:24:53,260
以解锁全新的功能

439
00:24:53,293 --> 00:24:55,596
并让用户控制自己的体验

440
00:24:57,130 --> 00:25:00,367
使用 MusicKit 可以增强
多种不同类型的 App

441
00:25:00,400 --> 00:25:03,637
健身 App 游戏 社交媒体 App
地图 App 等

442
00:25:03,670 --> 00:25:07,975
都可以从播放或分享音乐中受益

443
00:25:08,008 --> 00:25:12,012
欲了解更多信息
请查看更多相关讲座

444
00:25:12,045 --> 00:25:14,681
深入研究 Swift
了解该语言的新增功能

445
00:25:14,715 --> 00:25:19,620
以充分利用 MusicKit
和其他 Apple 框架

446
00:25:19,653 --> 00:25:23,257
查看2021年的 MusicKit 讲座
学习如何设置 App

447
00:25:23,290 --> 00:25:28,662
来使用框架 启动回放
并提供订阅优惠

448
00:25:28,695 --> 00:25:32,432
如果您有兴趣在 Android 或 web 上
与 Apple Music 集成

449
00:25:32,466 --> 00:25:36,370
我们还有一个讲座
讨论了如何直接使用 Apple Music API

450
00:25:37,538 --> 00:25:40,207
希望您喜欢我们的讲座
并通过我们的开发者论坛

451
00:25:40,240 --> 00:25:42,442
保持更新和参与

452
00:25:42,476 --> 00:25:46,847
感谢观看
请享受您的 WWDC 2022 之旅吧

