1
00:00:00,033 --> 00:00:03,003
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,003 --> 00:00:09,376
♪

3
00:00:09,376 --> 00:00:12,079
大家好
我是 John Crowson

4
00:00:12,079 --> 00:00:14,414
我是 Apple 性能工具团队的

5
00:00:14,414 --> 00:00:15,682
软件工程师

6
00:00:15,682 --> 00:00:17,451
在本次讲座中
我将向您介绍几个新工具

7
00:00:17,451 --> 00:00:20,554
它们可以用 Xcode
和设备上的卡顿检测

8
00:00:20,554 --> 00:00:24,258
来跟踪 App 中的卡顿

9
00:00:24,258 --> 00:00:26,360
我将作为您的向导 带领您参观
App 开发过程的不同阶段

10
00:00:26,360 --> 00:00:29,363
并考虑在每个阶段

11
00:00:29,363 --> 00:00:32,266
最适合提供帮助的工具是什么

12
00:00:32,266 --> 00:00:35,235
本次讲座分为四个部分

13
00:00:35,235 --> 00:00:38,405
首先 我将介绍 什么是卡顿

14
00:00:38,405 --> 00:00:40,774
然后 我将介绍一些工具 帮助您在

15
00:00:40,774 --> 00:00:44,912
开发 App

16
00:00:44,912 --> 00:00:49,716
测试 App 时以及发布 App 后
发现和诊断卡顿

17
00:00:49,716 --> 00:00:52,619
让我们现在开始吧

18
00:00:52,619 --> 00:00:55,455
我想分享我团队
正在开发的一个新 App

19
00:00:55,455 --> 00:00:58,025
“食品车”它将有助于管理

20
00:00:58,025 --> 00:01:00,694
专门销售甜甜圈的食品车

21
00:01:00,694 --> 00:01:04,398
来看看我创建的甜甜圈类型

22
00:01:07,868 --> 00:01:09,837
滚动浏览我的甜甜圈列表

23
00:01:09,837 --> 00:01:11,839
确实要花不少时间

24
00:01:11,839 --> 00:01:15,809
该 App 运行缓慢
没有响应我的任何触碰

25
00:01:15,809 --> 00:01:20,047
在 Apple 我们将这段
无响应的时间称为“卡顿”

26
00:01:20,047 --> 00:01:22,616
App 的主线程负责处理

27
00:01:22,616 --> 00:01:26,119
用户交互和更新视图内容

28
00:01:26,119 --> 00:01:29,556
当主线程忙于工作

29
00:01:29,556 --> 00:01:32,759
或等待另一个线程或系统资源

30
00:01:32,759 --> 00:01:35,295
导致更新视图内容

31
00:01:35,295 --> 00:01:39,233
至少延迟 250 毫秒时
会报告卡顿

32
00:01:39,233 --> 00:01:41,068
在卡顿解决之前

33
00:01:41,068 --> 00:01:46,006
主线程也无法处理新的用户交互

34
00:01:46,006 --> 00:01:51,378
在用户看来
App 看上去完全卡死了

35
00:01:51,378 --> 00:01:52,880
创建响应灵敏的 App

36
00:01:52,880 --> 00:01:56,717
对于提高用户体验至关重要

37
00:01:56,717 --> 00:01:59,520
持续无响应的 App
可能会导致用户

38
00:01:59,520 --> 00:02:03,123
强制退出 App
切换到其他 App

39
00:02:03,123 --> 00:02:05,559
在某些情况下
甚至删除您的 App

40
00:02:05,559 --> 00:02:08,061
并写负面评价

41
00:02:08,061 --> 00:02:10,697
因此 跟踪您的 App 中的卡顿

42
00:02:10,697 --> 00:02:15,202
对于积累和维护您的用户群体
至关重要

43
00:02:15,202 --> 00:02:17,504
提供即时响应的体验可让用户

44
00:02:17,504 --> 00:02:19,973
会更愿意使用您的 App

45
00:02:21,975 --> 00:02:24,778
有关卡顿及其原因的更多信息

46
00:02:24,778 --> 00:02:27,514
以及从代码中消除它们的方法

47
00:02:27,514 --> 00:02:30,217
请查看 WWDC 2021

48
00:02:30,217 --> 00:02:32,819
“理解和消除 App 中的卡顿”

49
00:02:32,819 --> 00:02:34,087
App 的开发过程

50
00:02:34,087 --> 00:02:36,723
可以分为三个阶段

51
00:02:36,723 --> 00:02:41,395
首先 使用 Xcode 在桌面上
开发最新的 App 版本

52
00:02:41,395 --> 00:02:43,997
然后 在没有 Xcode 的
测试环境中

53
00:02:43,997 --> 00:02:46,967
测试 App 并收集反馈

54
00:02:46,967 --> 00:02:48,836
例如 您可能有一个 App 版本

55
00:02:48,836 --> 00:02:50,971
是在您的设备上开发的 或是通过

56
00:02:50,971 --> 00:02:53,540
TestFlight 分发的

57
00:02:53,540 --> 00:02:57,678
最后 在 App Store 上
发布最新的 App 版本

58
00:02:57,678 --> 00:02:59,913
即使对于最积极主动的开发者

59
00:02:59,913 --> 00:03:02,583
新的卡顿问题也可能
会出现在任何情况下

60
00:03:02,583 --> 00:03:05,085
所以知道在各个阶段
帮助定位卡顿的工具

61
00:03:05,085 --> 00:03:07,120
是非常重要的

62
00:03:07,120 --> 00:03:09,857
在 iOS 16 和
Xcode 14 之前

63
00:03:09,857 --> 00:03:12,626
我们提供了两种帮助发现和诊断

64
00:03:12,626 --> 00:03:14,995
App 中卡顿的工具

65
00:03:14,995 --> 00:03:17,698
MetricKit
是一个支持收集卡顿率指标

66
00:03:17,698 --> 00:03:21,201
和反馈诊断报告的框架

67
00:03:21,201 --> 00:03:26,106
可用于您的 Beta 版
或公开发布的 App

68
00:03:26,106 --> 00:03:29,776
Xcode Organizer
会收集用户在使用

69
00:03:29,776 --> 00:03:32,946
您公开发布的 App 时
产生的卡顿率数据

70
00:03:32,946 --> 00:03:35,782
这里存在一些差距

71
00:03:35,782 --> 00:03:39,052
特别是在开发 App 或试图理解

72
00:03:39,052 --> 00:03:43,657
什么源代码
导致公开发布卡顿率指标上升时

73
00:03:43,657 --> 00:03:46,226
在 iOS 16 和
Xcode 14 中

74
00:03:46,226 --> 00:03:50,697
我们致力于引入新工具来提供帮助

75
00:03:50,697 --> 00:03:52,799
在我们更详细介绍这些工具之前

76
00:03:52,799 --> 00:03:55,669
让我先简要地概述一下

77
00:03:55,669 --> 00:03:57,938
在调试 App 时
Xcode 中的线程性能检查器

78
00:03:57,938 --> 00:04:00,407
会在没有主动跟踪的情况下

79
00:04:00,407 --> 00:04:04,578
提醒您引起线程卡顿的问题

80
00:04:04,578 --> 00:04:07,915
Xcode 中的 Instruments
在跟踪您的

81
00:04:07,915 --> 00:04:10,484
App 时可以检测并标注卡顿

82
00:04:10,484 --> 00:04:13,420
设备上的卡顿检测
可以提供卡顿检测

83
00:04:13,420 --> 00:04:16,256
而无需 Xcode 和跟踪

84
00:04:16,256 --> 00:04:18,458
提供实时卡顿通知

85
00:04:18,458 --> 00:04:20,827
并在使用您开发签名或

86
00:04:20,827 --> 00:04:24,164
TestFlight App 时
支持诊断

87
00:04:24,164 --> 00:04:26,400
最后 Xcode 中的 Organizer

88
00:04:26,400 --> 00:04:29,036
现在支持卡顿报告 它将提供

89
00:04:29,036 --> 00:04:33,373
用户在实际使用中汇总的卡顿率数据

90
00:04:33,373 --> 00:04:35,108
现在您知道什么是卡顿

91
00:04:35,108 --> 00:04:37,077
以及它们可能出现的不同阶段

92
00:04:37,077 --> 00:04:39,313
接下来我将介绍在使用 Xcode

93
00:04:39,313 --> 00:04:43,350
开发 App 时如何追踪卡顿

94
00:04:43,350 --> 00:04:46,620
在 Xcode 14 中
当新的线程性能检查工具检测到

95
00:04:46,620 --> 00:04:49,823
您的 App 主线程中存在
优先级反转和非 UI 工作时

96
00:04:49,823 --> 00:04:52,426
它会在 Xcode 问题导航器中

97
00:04:52,426 --> 00:04:54,328
通知您

98
00:04:54,328 --> 00:04:58,298
这两种情况都是导致卡顿的常见原因

99
00:04:58,298 --> 00:04:59,633
我现在已经回到 Xcode

100
00:04:59,633 --> 00:05:03,036
来诊断我之前滚动浏览甜甜圈列表时

101
00:05:03,036 --> 00:05:06,607
发现的食品车 App 卡顿问题

102
00:05:06,607 --> 00:05:08,375
当我构建并运行 App

103
00:05:08,375 --> 00:05:10,577
并重复用户交互时

104
00:05:10,577 --> 00:05:13,714
线程性能检查器工具提醒我

105
00:05:13,714 --> 00:05:16,984
由优先级反转引起的卡顿风险

106
00:05:16,984 --> 00:05:19,586
这意味着更高优先级的线程正在尝试

107
00:05:19,586 --> 00:05:22,556
与较低优先级的线程同步

108
00:05:22,556 --> 00:05:24,791
这可能表明我们注意到的卡顿

109
00:05:24,791 --> 00:05:27,861
是由主线程

110
00:05:27,861 --> 00:05:30,063
在等待不同的低优先级线程引起的

111
00:05:30,063 --> 00:05:32,599
为了检测您的 App 主线程上的

112
00:05:32,599 --> 00:05:34,134
优先级反转和非 UI 工作

113
00:05:34,134 --> 00:05:36,370
从相应 scheme 的 Diagnostics 部分

114
00:05:36,370 --> 00:05:40,607
启用Thread Performance Checker 工具

115
00:05:40,607 --> 00:05:43,243
线程性能检查器警报能帮助我发现

116
00:05:43,243 --> 00:05:45,746
卡顿潜在的罪魁祸首

117
00:05:45,746 --> 00:05:48,115
但为了进一步分析 我想知道

118
00:05:48,115 --> 00:05:51,552
在卡顿期间另一个线程在做什么

119
00:05:51,552 --> 00:05:56,456
让我们使用另一个工具
进行更深入的研究

120
00:05:56,456 --> 00:05:58,992
Time Profiler 工具
通过提供调用堆栈

121
00:05:58,992 --> 00:06:01,828
让您能够知道 App 中的

122
00:06:01,828 --> 00:06:04,264
每个线程在一段时间内做了什么

123
00:06:04,264 --> 00:06:08,235
Xcode 14 中提供了新功能
Time Profiler

124
00:06:08,235 --> 00:06:12,239
还可以检测卡顿
并直接在相应的流程轨迹中进行标注

125
00:06:12,239 --> 00:06:14,741
在食品车 App 中 我将使用
Time Profiler

126
00:06:14,741 --> 00:06:16,610
来确认在滚动浏览甜甜圈列表时

127
00:06:16,610 --> 00:06:18,445
发生卡顿

128
00:06:18,445 --> 00:06:21,682
卡顿是由于
主线程上的优先级反转引起的

129
00:06:21,682 --> 00:06:23,784
我也将找出低优先级线程

130
00:06:23,784 --> 00:06:28,255
正在忙于做什么导致主线程等待

131
00:06:28,255 --> 00:06:31,325
打开 Xcode 中的
Product  Profile

132
00:06:31,325 --> 00:06:33,327
这将构建发行版的 App

133
00:06:33,327 --> 00:06:37,464
并启动为目标 App 配置
好的 Instruments

134
00:06:37,464 --> 00:06:40,234
我启动 Time Profiler 模板

135
00:06:40,234 --> 00:06:43,437
并开始记录食品车 App 中

136
00:06:43,437 --> 00:06:45,572
有问题的用户交互

137
00:06:49,543 --> 00:06:51,411
我看到这里检测到卡顿

138
00:06:51,411 --> 00:06:53,213
并在时间轴上标注

139
00:06:53,213 --> 00:06:55,115
卡顿持续时间也会标出

140
00:06:55,115 --> 00:06:58,719
来帮助评估问题的严重性

141
00:06:58,719 --> 00:07:01,588
接下来 我可以三击卡顿间隔

142
00:07:01,588 --> 00:07:04,391
为卡顿的持续时间创建时间过滤器

143
00:07:04,391 --> 00:07:06,793
并将底部的详细视图中的信息筛选为

144
00:07:06,793 --> 00:07:09,296
仅在选定的时间间隔内

145
00:07:09,296 --> 00:07:11,431
发生的事件

146
00:07:11,431 --> 00:07:14,034
它还可以更轻松地查看

147
00:07:14,034 --> 00:07:17,738
在此期间其他轨道正在发生的事情

148
00:07:17,738 --> 00:07:19,840
我首先注意到的是主线程
在卡顿间隔期

149
00:07:19,840 --> 00:07:23,510
几乎没有任何 CPU 使用率

150
00:07:23,510 --> 00:07:25,913
这表示主线程没有响应

151
00:07:25,913 --> 00:07:27,981
因为它正在等待另一个线程

152
00:07:27,981 --> 00:07:31,285
而不是因为它本身工作过载

153
00:07:31,285 --> 00:07:33,954
这与之前线程性能检查器的

154
00:07:33,954 --> 00:07:37,424
优先级反转警报反馈一致

155
00:07:37,424 --> 00:07:39,159
然后 我看到一个在卡顿期间

156
00:07:39,159 --> 00:07:42,296
有很多 CPU 使用率的工作线程

157
00:07:42,296 --> 00:07:46,567
这可能就是主线程正在等待的线程

158
00:07:46,567 --> 00:07:48,101
下一步将是检查

159
00:07:48,101 --> 00:07:50,737
工作线程在卡顿期间在做什么

160
00:07:50,737 --> 00:07:53,640
并解决优先级反转问题

161
00:07:53,640 --> 00:07:55,442
Instruments 中的
卡顿检测和标记

162
00:07:55,442 --> 00:07:58,345
以很好的方法显示出

163
00:07:58,345 --> 00:08:00,347
在分析 App 时遇到的任何卡顿

164
00:08:00,347 --> 00:08:02,816
它在 Time Profiler

165
00:08:02,816 --> 00:08:06,019
和 CPU Profiler 中默认可用

166
00:08:06,019 --> 00:08:09,256
还有一个新的独立卡顿跟踪工具

167
00:08:09,256 --> 00:08:11,525
您可以将其添加到任何跟踪文件中

168
00:08:11,525 --> 00:08:15,495
以便与其他工具结合检测卡顿

169
00:08:15,495 --> 00:08:17,898
除了卡顿检测和标记

170
00:08:17,898 --> 00:08:20,901
它还让您配置卡顿持续时间阈值

171
00:08:20,901 --> 00:08:24,838
找出特定的无响应时期

172
00:08:24,838 --> 00:08:26,773
您现在已经学会了
如何使用 Xcode

173
00:08:26,773 --> 00:08:30,043
来发现和诊断卡顿

174
00:08:30,043 --> 00:08:32,846
即使在开发过程中有很好的测试覆盖

175
00:08:32,846 --> 00:08:35,182
Beta 版和
公开发布环境也很可能

176
00:08:35,182 --> 00:08:39,586
发现您忽略了的
代码路径中的卡顿

177
00:08:39,586 --> 00:08:42,256
接下来 我将介绍 一旦
App 部署在 Beta 环境中

178
00:08:42,256 --> 00:08:45,526
该如何跟踪卡顿

179
00:08:45,526 --> 00:08:48,161
我现在已通过
App Store Connect

180
00:08:48,161 --> 00:08:50,430
将食品车 App 的内部版本
部署至 TestFlight

181
00:08:50,430 --> 00:08:53,400
也将它下载至我的个人设备上

182
00:08:53,400 --> 00:08:56,303
我会在城镇售卖甜甜圈时
测试这个 App

183
00:08:56,303 --> 00:08:58,505
包括在网络连接较弱

184
00:08:58,505 --> 00:09:00,507
的地方测试

185
00:09:00,507 --> 00:09:03,343
但如果我的设备
没有连接到 Xcode

186
00:09:03,343 --> 00:09:08,315
我该如何发现和诊断卡顿呢

187
00:09:08,315 --> 00:09:11,318
要在这些情况下继续监视卡顿

188
00:09:11,318 --> 00:09:16,123
iOS 16 在开发者设置中
引入了设备内卡顿检测

189
00:09:16,123 --> 00:09:18,759
提供实时卡顿通知

190
00:09:18,759 --> 00:09:21,461
以及支持诊断

191
00:09:21,461 --> 00:09:23,363
这可用于开发签名

192
00:09:23,363 --> 00:09:25,766
或 TestFlight App

193
00:09:25,766 --> 00:09:28,435
是时候开始销售了

194
00:09:28,435 --> 00:09:30,704
当我尝试打开当前订单时

195
00:09:30,704 --> 00:09:33,473
我收到设备上卡顿检测通知

196
00:09:33,473 --> 00:09:35,108
这表示我的 App 卡顿了

197
00:09:35,108 --> 00:09:38,312
这次卡顿持续了三秒多

198
00:09:38,312 --> 00:09:40,147
我想知道
在我使用 Xcode 进行开发时

199
00:09:40,147 --> 00:09:42,749
为什么我没有注意到这个卡顿

200
00:09:42,749 --> 00:09:45,052
于是我将需要使用

201
00:09:45,052 --> 00:09:49,389
设备上卡顿检测工具提供的诊断信息
以了解更多

202
00:09:49,389 --> 00:09:51,325
只要你的 App 是为开发而设置的

203
00:09:51,325 --> 00:09:52,993
该功能可以通过打开

204
00:09:52,993 --> 00:09:55,729
设置  开发者  卡顿检测

205
00:09:55,729 --> 00:09:58,799
并切换开关来启用

206
00:09:58,799 --> 00:10:00,634
卡顿阈值可设置

207
00:10:00,634 --> 00:10:03,303
要检测的卡顿的最短持续时间

208
00:10:03,303 --> 00:10:06,540
最短卡顿阈值为 250 毫秒

209
00:10:06,540 --> 00:10:10,010
并且可提高到 500 毫秒或更高

210
00:10:10,010 --> 00:10:12,813
长时间卡顿往往会对用户
产生更大的影响

211
00:10:12,813 --> 00:10:15,849
但即便是更短时间的卡顿
也可能会破坏用户使用体验

212
00:10:15,849 --> 00:10:17,518
这取决于上下文

213
00:10:17,518 --> 00:10:20,287
特别是当它们连续发生时

214
00:10:20,287 --> 00:10:21,622
安装您的 App 后

215
00:10:21,622 --> 00:10:24,725
它将出现在监控 App 列表

216
00:10:24,725 --> 00:10:27,294
最后一部分为您已收到警告的

217
00:10:27,294 --> 00:10:30,764
按时间顺序排列的卡顿列表

218
00:10:30,764 --> 00:10:33,200
请注意 这些诊断是尽力而为的

219
00:10:33,200 --> 00:10:36,036
并在后台以低优先级处理

220
00:10:36,036 --> 00:10:39,072
以最小化性能开销

221
00:10:39,072 --> 00:10:41,241
这意味着处理可能需要更长的时间

222
00:10:41,241 --> 00:10:44,378
特别是在系统繁忙的情况下

223
00:10:44,378 --> 00:10:47,047
幸运的是 当新的诊断可用时

224
00:10:47,047 --> 00:10:50,284
被动通知会被显示

225
00:10:50,284 --> 00:10:53,620
让我们来查看一下

226
00:10:53,620 --> 00:10:55,589
当我在镇上卖甜甜圈时

227
00:10:55,589 --> 00:10:58,592
在 App 中打开订单
检测到的卡顿诊断

228
00:10:58,592 --> 00:11:00,761
我得到了基于文本的卡顿日志

229
00:11:00,761 --> 00:11:03,597
和用于检测卡顿的 tailspin

230
00:11:03,597 --> 00:11:06,066
基于文本的卡顿日志信息较少

231
00:11:06,066 --> 00:11:08,202
但可以让我们一眼

232
00:11:08,202 --> 00:11:10,070
就了解到卡顿

233
00:11:10,070 --> 00:11:12,606
要进行更深入的研究
打开 Instruments 中的 tailspin

234
00:11:12,606 --> 00:11:15,642
查看进程中的线程交互

235
00:11:15,642 --> 00:11:19,413
或识别系统资源的使用情况

236
00:11:19,413 --> 00:11:21,381
之类的内容

237
00:11:21,381 --> 00:11:23,217
首先 我将使用“分享”按钮

238
00:11:23,217 --> 00:11:25,652
将基于文本的卡顿日志
发送到 Mac

239
00:11:25,652 --> 00:11:30,424
以便我符号化和在更大的屏幕上查看

240
00:11:30,424 --> 00:11:33,126
从查看我转移和标记的
基于文本的卡顿日志摘录

241
00:11:33,126 --> 00:11:36,396
可以看到在卡顿期间

242
00:11:36,396 --> 00:11:38,532
我在主线程上调用一个方法

243
00:11:38,532 --> 00:11:42,736
我知道该方法执行对网络的同步请求

244
00:11:42,736 --> 00:11:44,805
当我在桌面上和
网络连接良好的环境下

245
00:11:44,805 --> 00:11:47,674
使用 Xcode 测试 App 时

246
00:11:47,674 --> 00:11:49,076
从网络请求数据

247
00:11:49,076 --> 00:11:51,645
可能不会有任何延迟

248
00:11:51,645 --> 00:11:53,881
但是 在某些网络连接受限的地方

249
00:11:53,881 --> 00:11:55,849
测试 App 时

250
00:11:55,849 --> 00:12:00,087
该请求需要更长的时间并会导致卡顿

251
00:12:00,087 --> 00:12:02,256
在这些不同的真实条件下

252
00:12:02,256 --> 00:12:04,625
测试 App 的 Beta 版很重要

253
00:12:04,625 --> 00:12:07,761
且设备上卡顿检测仅允许

254
00:12:07,761 --> 00:12:10,664
您使用自己的设备来监控卡顿

255
00:12:10,664 --> 00:12:13,500
至此 我已经使用开发和测试阶段

256
00:12:13,500 --> 00:12:16,870
可用的工具来发现并诊断出卡顿

257
00:12:16,870 --> 00:12:19,306
我已准备将食品车 App

258
00:12:19,306 --> 00:12:22,075
上线至 App Store

259
00:12:22,075 --> 00:12:24,711
我现在将介绍当您的 App

260
00:12:24,711 --> 00:12:26,513
上线后 该如何跟踪卡顿

261
00:12:26,513 --> 00:12:28,048
在不同的操作系统版本

262
00:12:28,048 --> 00:12:30,584
设备和其他现实环境中

263
00:12:30,584 --> 00:12:35,856
您可能无法在之前的测试中复现

264
00:12:35,856 --> 00:12:38,892
Xcode 14 中的新功能
Xcode Organizer

265
00:12:38,892 --> 00:12:42,763
能够从用户设备收集卡顿数据

266
00:12:42,763 --> 00:12:46,333
并展示卡顿报告和诊断

267
00:12:46,333 --> 00:12:49,036
收集的数据来自已同意

268
00:12:49,036 --> 00:12:51,839
共享 App 分析的用户设备

269
00:12:51,839 --> 00:12:57,377
数据包含导致卡顿的
主线程堆栈跟踪信息

270
00:12:57,377 --> 00:13:00,614
可在 Xcode Organizer

271
00:13:00,614 --> 00:13:03,750
的左侧导航器中查看卡顿报告

272
00:13:03,750 --> 00:13:05,786
当收集到类似的堆栈跟踪时

273
00:13:05,786 --> 00:13:09,556
将它们组合在一起形成单个签名

274
00:13:09,556 --> 00:13:11,925
在列表中

275
00:13:11,925 --> 00:13:14,428
签名是根据用户影响排序的

276
00:13:14,428 --> 00:13:18,031
对于每个签名
您可以找到一些示例卡顿日志

277
00:13:18,031 --> 00:13:20,934
每个卡顿日志都包含主线程堆栈跟踪

278
00:13:20,934 --> 00:13:24,872
其中包含导致卡顿的代码
卡顿持续时间

279
00:13:24,872 --> 00:13:28,642
以及生成日志的设备和操作系统版本

280
00:13:28,642 --> 00:13:32,145
每个签名还提供关于签名

281
00:13:32,145 --> 00:13:35,449
相关的卡顿日志数量的
汇总统计信息

282
00:13:35,449 --> 00:13:39,386
并按操作系统版本和设备
细分这些日志

283
00:13:39,386 --> 00:13:42,289
要确定对您的用户影响最大的卡顿

284
00:13:42,289 --> 00:13:45,692
请密切留意您的排名靠前的签名

285
00:13:45,692 --> 00:13:49,663
在本例中 顶部签名

286
00:13:49,663 --> 00:13:53,267
占用该版本中 21% 的卡顿时间

287
00:13:53,267 --> 00:13:55,169
由于我已向 App Store
提交了带有符号信息的 App

288
00:13:55,169 --> 00:13:58,005
卡顿报告显示了所有函数的名称

289
00:13:58,005 --> 00:14:02,342
就像它们在源代码中一样

290
00:14:02,342 --> 00:14:05,812
通过检查
这个主线程调用堆栈中的函数

291
00:14:05,812 --> 00:14:08,882
我可以推断这个卡顿
是由于在主线程上

292
00:14:08,882 --> 00:14:11,618
从磁盘同步读取文件引起的

293
00:14:11,618 --> 00:14:15,956
我们知道这会阻塞主线程很长时间

294
00:14:15,956 --> 00:14:18,091
解决对用户影响最大的性能问题

295
00:14:18,091 --> 00:14:20,093
至关重要

296
00:14:20,093 --> 00:14:23,664
Organizer 是定位这种问题的好工具

297
00:14:23,664 --> 00:14:25,899
在每个 App 发布后
检查这些数据

298
00:14:25,899 --> 00:14:28,635
以确认之前的卡顿问题已被解决

299
00:14:28,635 --> 00:14:31,738
并处理可能出现的新卡顿问题

300
00:14:33,740 --> 00:14:36,109
您还可以通过
App Store Connect REST API

301
00:14:36,109 --> 00:14:39,146
检索相同的卡顿报告数据

302
00:14:39,146 --> 00:14:41,148
这可以帮助您将性能数据

303
00:14:41,148 --> 00:14:45,118
与您自己的系统集成
或运行其他分析

304
00:14:45,118 --> 00:14:46,887
我强烈建议您查看

305
00:14:46,887 --> 00:14:50,224
“Identify trends with the
Power and Performance API” 讲座

306
00:14:50,224 --> 00:14:54,394
了解更多有关使用
Power and Performance API 的信息

307
00:14:54,394 --> 00:14:58,465
从 Xcode 13.2 起

308
00:14:58,465 --> 00:15:02,536
当您在 App 中监控功耗
和性能指标时 可接收通知

309
00:15:02,536 --> 00:15:04,571
建议从 Xcode Organizer

310
00:15:04,571 --> 00:15:07,307
的 Regression 视图

311
00:15:07,307 --> 00:15:10,511
点击右上角的通知按钮启用通知

312
00:15:10,511 --> 00:15:14,515
这将提醒您注意
App 卡顿率的突然上升

313
00:15:14,515 --> 00:15:16,650
可在 2021 年的

314
00:15:16,650 --> 00:15:19,653
“诊断 App 中的功耗
和性能回归”讲座

315
00:15:19,653 --> 00:15:21,755
了解更多信息

316
00:15:21,755 --> 00:15:24,424
为了改善您的
Xcode Organizer 使用体验

317
00:15:24,424 --> 00:15:27,461
我强烈建议您构建并提交 App

318
00:15:27,461 --> 00:15:30,564
到 App Store 时包含符号信息

319
00:15:30,564 --> 00:15:33,333
此符号信息用于将 App 中的
函数名添加到

320
00:15:33,333 --> 00:15:36,570
Xcode Organizer
的报告中

321
00:15:36,570 --> 00:15:37,804
这大大方便了

322
00:15:37,804 --> 00:15:40,374
理解堆栈跟踪

323
00:15:40,374 --> 00:15:42,743
它还支持从堆栈跟踪中的函数名

324
00:15:42,743 --> 00:15:44,478
到 Xcode 源代码编辑器中

325
00:15:44,478 --> 00:15:47,881
函数定义的一键式导航

326
00:15:47,881 --> 00:15:49,449
提取的信息

327
00:15:49,449 --> 00:15:51,585
仅限于函数和方法

328
00:15:51,585 --> 00:15:53,687
源代码文件的名称和路径

329
00:15:53,687 --> 00:15:55,656
以及行号信息

330
00:15:55,656 --> 00:15:58,492
需要注意的是 有限的符号信息

331
00:15:58,492 --> 00:16:02,296
将被安全存储并且永远不会被共享

332
00:16:02,296 --> 00:16:03,830
很好

333
00:16:03,830 --> 00:16:06,033
您现在知道在开发过程的每个阶段

334
00:16:06,033 --> 00:16:09,603
如何发现和诊断卡顿

335
00:16:09,603 --> 00:16:11,839
运行 发现 诊断

336
00:16:11,839 --> 00:16:14,241
在开发过程的最早阶段

337
00:16:14,241 --> 00:16:16,076
发现并修复卡顿

338
00:16:16,076 --> 00:16:18,212
使用可用的工具提供帮助

339
00:16:18,212 --> 00:16:22,816
包括使用 Instruments
主动分析新功能

340
00:16:22,816 --> 00:16:25,285
确保启用线程性能检查器

341
00:16:25,285 --> 00:16:28,288
和设备上卡顿检测

342
00:16:28,288 --> 00:16:31,158
在每个版本发布后 使用
Xcode Organizer

343
00:16:31,158 --> 00:16:33,827
来解决最影响用户的卡顿问题

344
00:16:33,827 --> 00:16:36,363
并验证之前 App 版本的

345
00:16:36,363 --> 00:16:38,565
卡顿问题是否已经解决

346
00:16:38,565 --> 00:16:41,735
启用退化通知

347
00:16:41,735 --> 00:16:43,804
主动提醒性能指标的退化

348
00:16:43,804 --> 00:16:48,008
这可能是耗电和
性能问题的第一个迹象

349
00:16:48,008 --> 00:16:50,978
最后 构建带有符号信息的 App

350
00:16:50,978 --> 00:16:52,479
并提交至 App Store

351
00:16:52,479 --> 00:16:55,816
以提高
Xcode Organizer 的实用性

352
00:16:55,816 --> 00:16:57,251
按照这些步骤

353
00:16:57,251 --> 00:16:59,353
您的 App 将会有更好的性能

354
00:16:59,353 --> 00:17:02,122
提供最佳的用户体验

355
00:17:02,122 --> 00:17:05,592
感谢您参加 WWDC

356
00:17:05,592 --> 00:17:09,029
♪

