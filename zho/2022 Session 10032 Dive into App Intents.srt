1
00:00:00,000 --> 00:00:03,737
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,737 --> 00:00:09,543
♪

3
00:00:09,543 --> 00:00:11,745
嗨 朋友们 我是
Michael Gorbach

4
00:00:11,745 --> 00:00:13,714
来自快捷指令工程团队

5
00:00:13,714 --> 00:00:17,117
感谢您收看本次对
App Intents 的深度解析

6
00:00:17,117 --> 00:00:18,118
App Intents 是
我们新推出的框架

7
00:00:18,118 --> 00:00:22,489
用于向系统注册 App 的功能

8
00:00:22,489 --> 00:00:24,224
以下是今天深度解析讲座的安排

9
00:00:24,224 --> 00:00:26,159
简单介绍后

10
00:00:26,159 --> 00:00:28,729
我将讨论意图及其参数

11
00:00:28,729 --> 00:00:31,431
以及应该如何定义实体

12
00:00:31,431 --> 00:00:33,834
我将介绍几种您可以创建的

13
00:00:33,834 --> 00:00:35,102
强大的搜索和过滤功能

14
00:00:35,102 --> 00:00:38,472
以及您的意图如何与用户进行交互

15
00:00:38,472 --> 00:00:43,277
最后 我会谈一谈 App Intents
架构和生命周期

16
00:00:43,277 --> 00:00:45,913
让我们从头开始

17
00:00:45,913 --> 00:00:49,683
在 iOS 10 中 我们
引入了 SiriKit Intents 框架

18
00:00:49,683 --> 00:00:51,952
它可以让您将 App 的功能

19
00:00:51,952 --> 00:00:56,690
连接到 Siri 域
例如消息传递 锻炼和支付

20
00:00:56,690 --> 00:00:59,193
现在我们将引入一个新框架

21
00:00:59,193 --> 00:01:01,528
它就是 App Intents

22
00:01:01,528 --> 00:01:04,097
它有三个关键组成部分

23
00:01:04,097 --> 00:01:06,400
意图是内置于 App 中的操作

24
00:01:06,400 --> 00:01:08,602
它们可以在整个系统中使用

25
00:01:08,602 --> 00:01:12,906
意图使用实体
来表述 App 的概念

26
00:01:12,906 --> 00:01:15,175
App 快捷指令包装意图

27
00:01:15,175 --> 00:01:18,378
使它们自动化并可被发现

28
00:01:18,378 --> 00:01:19,980
让我们来谈谈

29
00:01:19,980 --> 00:01:22,583
利用 App Intents
使您的 App 功能

30
00:01:22,583 --> 00:01:26,653
在更多地方可用
并让您的用户受益的几种方法

31
00:01:26,653 --> 00:01:28,755
借助 App 快捷指令
每个人都可以

32
00:01:28,755 --> 00:01:31,592
通过 Siri
以声音使用 App 的功能

33
00:01:31,592 --> 00:01:34,928
无需提前设置任何东西

34
00:01:34,928 --> 00:01:38,398
相同的采用方式
也在用户搜索您的 App

35
00:01:38,398 --> 00:01:42,135
以及您的 App 得到推荐时
使意图出现在 Spotlight 中

36
00:01:42,135 --> 00:01:45,873
这将使您的工作处于核心位置

37
00:01:45,873 --> 00:01:49,576
使用 App Intents
您还可以创建“焦点筛选”

38
00:01:49,576 --> 00:01:53,947
让客户能够针对特定的“焦点”
对您的 App 进行自定义

39
00:01:53,947 --> 00:01:56,450
例如 他们可能会将
自己的“日历”App 设置为

40
00:01:56,450 --> 00:02:01,021
仅在实际工作时显示工作日历

41
00:02:01,021 --> 00:02:02,923
您可以查看这个讲座来了解更多关于

42
00:02:02,923 --> 00:02:06,660
如何运用“焦点筛选”的信息

43
00:02:06,660 --> 00:02:08,161
使用 App 快捷指令

44
00:02:08,161 --> 00:02:11,298
您的意图会自动
显示在“快捷指令”App 中

45
00:02:11,298 --> 00:02:14,201
无需手动添加

46
00:02:14,201 --> 00:02:16,737
将操作集成到“快捷指令”中

47
00:02:16,737 --> 00:02:18,939
对客户来说非常有价值

48
00:02:18,939 --> 00:02:20,674
因为他们可以通过运行快捷指令

49
00:02:20,674 --> 00:02:22,876
使用您的 App 来自

50
00:02:22,876 --> 00:02:25,913
整个系统各个位置的功能

51
00:02:25,913 --> 00:02:28,882
在主屏幕上轻点一下
即可运行快捷指令

52
00:02:28,882 --> 00:02:32,386
也可通过 macOS 的菜单栏
以及其他众多方式运行

53
00:02:32,386 --> 00:02:34,955
甚至可以通过自动化设置

54
00:02:34,955 --> 00:02:37,991
使快捷指令自动运行

55
00:02:37,991 --> 00:02:40,727
将您的 App 接入
整个“快捷指令”生态系统

56
00:02:40,727 --> 00:02:43,297
借助 Apple 的
一系列 App

57
00:02:43,297 --> 00:02:46,366
和其他开发者的强大力量

58
00:02:46,366 --> 00:02:49,236
对快捷指令进行支持

59
00:02:49,236 --> 00:02:51,271
将使您的 App 威力倍增

60
00:02:51,271 --> 00:02:53,874
这是因为快捷指令可以组合

61
00:02:53,874 --> 00:02:55,242
来自多个 App 的操作

62
00:02:55,242 --> 00:02:59,046
让用户创造出全新的特性和功能

63
00:02:59,046 --> 00:03:02,816
而无需您进行任何开发

64
00:03:02,816 --> 00:03:05,052
如果想学习如何使操作

65
00:03:05,052 --> 00:03:08,655
与他人配合默契并无缝融入生态系统

66
00:03:08,655 --> 00:03:11,191
请查看我们的设计演讲

67
00:03:11,191 --> 00:03:13,026
我们创建
App Intents 的目标

68
00:03:13,026 --> 00:03:16,163
是为了让它的开发成为一种快乐

69
00:03:16,163 --> 00:03:18,599
App Intents 十分简洁

70
00:03:18,599 --> 00:03:21,668
编写一个简单的意图
只需要几行代码

71
00:03:21,668 --> 00:03:23,871
但 API 也可扩展出

72
00:03:23,871 --> 00:03:27,374
更深入和更定制化的操作

73
00:03:27,374 --> 00:03:29,276
App Intents 非常现代化

74
00:03:29,276 --> 00:03:30,644
我们对 Swift 全力投入

75
00:03:30,644 --> 00:03:33,213
充分利用结果构建器 属性包装器

76
00:03:33,213 --> 00:03:36,049
面向协议的编程和通用算法

77
00:03:36,049 --> 00:03:37,851
没有尖端的语言特性

78
00:03:37,851 --> 00:03:41,221
这些 API 根本不可能存在

79
00:03:41,221 --> 00:03:43,624
使用 App Intents 也很容易

80
00:03:43,624 --> 00:03:45,259
因为它既不要求重新架构

81
00:03:45,259 --> 00:03:49,029
您的产品和目标 也不需要创建框架

82
00:03:49,029 --> 00:03:50,697
它不需要扩展

83
00:03:50,697 --> 00:03:53,233
并且可以直接应用于您的 App

84
00:03:53,233 --> 00:03:55,802
同时 App Intents
代码是可维护的

85
00:03:55,802 --> 00:03:58,605
与 SwiftUI 一样
App Intents 将您的代码

86
00:03:58,605 --> 00:04:00,574
视作事实的根本来源

87
00:04:00,574 --> 00:04:04,578
避免了对独立编辑器
或定义文件的需求

88
00:04:04,578 --> 00:04:07,881
让您可以快速创建和迭代采用

89
00:04:07,881 --> 00:04:09,082
并简化维护

90
00:04:09,082 --> 00:04:12,452
因为它们都在同一个位置

91
00:04:12,452 --> 00:04:15,389
话说回来 让我们来
探讨一下这些新 API

92
00:04:15,389 --> 00:04:16,790
就从意图开始

93
00:04:16,790 --> 00:04:19,960
它我们新框架的核心组成部分

94
00:04:19,960 --> 00:04:22,663
App 意图 或简称“意图”

95
00:04:22,663 --> 00:04:25,265
是一个单体的 独立的功能单元

96
00:04:25,265 --> 00:04:27,634
由您的 App 向系统公开

97
00:04:27,634 --> 00:04:30,537
比如说 一个意图可以
创建一个新的日历事件

98
00:04:30,537 --> 00:04:34,007
打开一个特定的屏幕
或者下一份订单

99
00:04:34,007 --> 00:04:37,277
意图可以根据用户请求运行

100
00:04:37,277 --> 00:04:40,180
例如通过快捷指令或询问 Siri

101
00:04:40,180 --> 00:04:41,348
也可以是自动的

102
00:04:41,348 --> 00:04:45,319
例如使用“焦点筛选”
或自动化“快捷指令”

103
00:04:45,319 --> 00:04:46,587
当意图运行之后

104
00:04:46,587 --> 00:04:51,024
要么返回结果 要么出现错误

105
00:04:51,024 --> 00:04:54,294
意图包含三个关键部分

106
00:04:54,294 --> 00:04:56,797
元数据 也就是有关意图的信息

107
00:04:56,797 --> 00:04:59,066
也包括本地化的标题

108
00:04:59,066 --> 00:05:01,802
参数 这是意图运行时可以使用的

109
00:05:01,802 --> 00:05:03,036
输入值

110
00:05:03,036 --> 00:05:05,572
还有 perform 方法 它负责

111
00:05:05,572 --> 00:05:09,042
意图被执行时的实际工作

112
00:05:09,042 --> 00:05:11,945
今天我们将从这个“图书馆”
App 出发进行讨论

113
00:05:11,945 --> 00:05:13,480
因为我很痴迷读书

114
00:05:13,480 --> 00:05:15,516
这个 App 完全是
用于追踪我读过的书

115
00:05:15,516 --> 00:05:18,485
以及想读或正在读的书

116
00:05:18,485 --> 00:05:21,421
每个类别都作为
单独选项卡显示在 App 中

117
00:05:21,421 --> 00:05:24,391
我称这些选项卡为“书架”

118
00:05:24,391 --> 00:05:26,593
我的用户随时都在访问

119
00:05:26,593 --> 00:05:27,694
“正在阅读”书架

120
00:05:27,694 --> 00:05:29,897
所以我要公开一个 App 意图

121
00:05:29,897 --> 00:05:34,034
让打开书架变得更快 更方便

122
00:05:34,034 --> 00:05:36,970
我准备在这里创建一个
OpenCurrentlyReading 意图

123
00:05:36,970 --> 00:05:38,472
通过定义一个
符合 AppIntent 协议的

124
00:05:38,472 --> 00:05:41,975
Swift 结构来实现

125
00:05:41,975 --> 00:05:45,479
我只需要实施一种方法
即 perform

126
00:05:45,479 --> 00:05:48,949
我的 App 中已经有了
可以打开标签的导航器

127
00:05:48,949 --> 00:05:50,317
所以对我来说 实现意图

128
00:05:50,317 --> 00:05:52,853
只是几行代码的事

129
00:05:52,853 --> 00:05:55,756
我将使用 @MainActor
来注释 perform 方法

130
00:05:55,756 --> 00:05:59,860
因为我的导航器需要主线程

131
00:05:59,860 --> 00:06:02,663
我的意图也需要一个标题

132
00:06:02,663 --> 00:06:04,631
和我今天要展示的其他字符串一样

133
00:06:04,631 --> 00:06:06,300
如果将键添加到字符串文件中

134
00:06:06,300 --> 00:06:09,136
它将自动本地化

135
00:06:09,136 --> 00:06:13,907
要让一个基本的 App 意图生效
我只需要做这些就够了

136
00:06:13,907 --> 00:06:15,776
由于我已经在代码中定义了它

137
00:06:15,776 --> 00:06:19,179
它将自动出现在快捷指令编辑器中

138
00:06:19,179 --> 00:06:24,084
在这里 用户可以将它
添加到快捷指令

139
00:06:24,084 --> 00:06:27,621
仅仅公开意图
就可以带来巨大的影响力

140
00:06:27,621 --> 00:06:30,424
因为一旦客户把意图变成快捷指令

141
00:06:30,424 --> 00:06:33,293
它就可以在系统中的多个位置使用

142
00:06:33,293 --> 00:06:36,129
包括屏幕上所有这些

143
00:06:36,129 --> 00:06:39,099
为了让我的新意图更容易
得到使用和发现

144
00:06:39,099 --> 00:06:41,635
我还将添加
对 App 快捷指令的支持

145
00:06:41,635 --> 00:06:43,003
只需要一点代码

146
00:06:43,003 --> 00:06:46,240
我就可以让意图在
Spotlight 和“快捷指令”App 中

147
00:06:46,240 --> 00:06:47,841
中自动显示

148
00:06:47,841 --> 00:06:51,044
我还可以定义用户在借助声音

149
00:06:51,044 --> 00:06:53,981
使用这个意图时
对 Siri 说的短语

150
00:06:53,981 --> 00:06:56,517
请查看“使用 App Intents
实现 App 快捷指令”讲座

151
00:06:56,517 --> 00:07:00,487
获取全部详细信息

152
00:07:00,487 --> 00:07:02,322
现在 我已经公开了一个

153
00:07:02,322 --> 00:07:05,025
可以打开“正在阅读”书架的意图

154
00:07:05,025 --> 00:07:06,860
接下来 让我们对它进行泛化

155
00:07:06,860 --> 00:07:12,432
添加一个参数
使它可以打开任意书架

156
00:07:12,432 --> 00:07:15,235
我有一个代表货架的枚举

157
00:07:15,235 --> 00:07:17,671
为了将其用作意图参数

158
00:07:17,671 --> 00:07:21,175
我需要使它符合
AppEnum 协议

159
00:07:21,175 --> 00:07:24,044
AppEnum 需要
一个字符串原始值

160
00:07:24,044 --> 00:07:26,413
所以我先把它加上

161
00:07:26,413 --> 00:07:28,916
它还要求我为每个枚举案例

162
00:07:28,916 --> 00:07:32,753
提供可本地化的 人可读的标题

163
00:07:32,753 --> 00:07:35,189
这些必须作为字典文字提供

164
00:07:35,189 --> 00:07:39,626
因为编译器将在构建时读取此代码

165
00:07:39,626 --> 00:07:42,095
最后 我将添加
typeDisplayName

166
00:07:42,095 --> 00:07:44,398
将枚举类型视作一个整体的

167
00:07:44,398 --> 00:07:47,000
一种用户可见的 可本地化的名称

168
00:07:47,000 --> 00:07:49,436
我将使用“书架”

169
00:07:49,436 --> 00:07:51,939
在一个意图中 每个参数都借助

170
00:07:51,939 --> 00:07:54,408
@Parameter 属性包装器的
使用进行声明

171
00:07:54,408 --> 00:07:57,177
依靠有关参数的信息进行初始化

172
00:07:57,177 --> 00:07:58,846
就像标题一样

173
00:07:58,846 --> 00:08:01,515
在这里 我定义了一个新的书架参数

174
00:08:01,515 --> 00:08:04,818
由我的 perform 方法
中读取

175
00:08:04,818 --> 00:08:06,820
参数支持所有这些类型

176
00:08:06,820 --> 00:08:10,023
包括数字 字符串 文件等等

177
00:08:10,023 --> 00:08:13,594
以及您 App 中的实体和枚举

178
00:08:13,594 --> 00:08:17,297
这是此意图在
“快捷指令”编辑器中的外观

179
00:08:17,297 --> 00:08:21,201
请注意 书架参数
出现在了一个表格行中

180
00:08:21,201 --> 00:08:23,070
我可以通过使用
ParameterSummary API

181
00:08:23,070 --> 00:08:24,938
让 UI 更精简

182
00:08:24,938 --> 00:08:29,009
并使其更适合“快捷指令”

183
00:08:29,009 --> 00:08:31,078
“参数摘要”是在编辑器中

184
00:08:31,078 --> 00:08:33,680
表述您的意图及其参数的

185
00:08:33,680 --> 00:08:37,684
一个语句 例如“打开 [书架]”

186
00:08:37,684 --> 00:08:39,620
为了在“快捷指令”中获得最佳效果

187
00:08:39,620 --> 00:08:41,989
您应当为创建的每一个意图

188
00:08:41,989 --> 00:08:45,459
提供“参数摘要”

189
00:08:45,459 --> 00:08:47,027
您也可以定义哪些参数

190
00:08:47,027 --> 00:08:50,497
将显示在折叠区域下 哪些是隐藏的

191
00:08:50,497 --> 00:08:53,166
这些 API 可以做很酷的事情

192
00:08:53,166 --> 00:08:56,103
比如依据您意图任何参数的

193
00:08:56,103 --> 00:08:58,372
实际值来改变摘要

194
00:08:58,372 --> 00:09:00,807
只需使用 When 和 Otherwise API

195
00:09:00,807 --> 00:09:05,512
或者 Switch Case 和 Default API

196
00:09:05,512 --> 00:09:06,947
为了添加参数摘要

197
00:09:06,947 --> 00:09:09,650
我实施了这项静态属性

198
00:09:09,650 --> 00:09:11,718
在这里 我将返回字符串“打开”

199
00:09:11,718 --> 00:09:15,756
并插入书架参数

200
00:09:15,756 --> 00:09:18,759
要让“打开书架”生效
我需要做的最后一件事

201
00:09:18,759 --> 00:09:21,495
就是确保意图在运行时

202
00:09:21,495 --> 00:09:25,866
打开“图书馆”App 就像这样

203
00:09:25,866 --> 00:09:28,836
打开 App 的操作由静态属性

204
00:09:28,836 --> 00:09:30,838
openAppWhenRun 控制

205
00:09:30,838 --> 00:09:33,941
它默认设置为假
这对大多数意图而言都有效

206
00:09:33,941 --> 00:09:36,176
但对于那些需要在 UI 中
打开某些内容的意图

207
00:09:36,176 --> 00:09:40,214
比如眼下这一个
就需要将其设置为真

208
00:09:40,214 --> 00:09:43,083
我刚才创建了一个打开书架的意图

209
00:09:43,083 --> 00:09:47,187
它非常简单
因为书架的集合是固定的

210
00:09:47,187 --> 00:09:50,257
那么如果我想创建一个意图来打开

211
00:09:50,257 --> 00:09:53,193
集合为动态而非固定的“书本”
该怎么做呢？

212
00:09:53,193 --> 00:09:55,729
为此 我需要实体

213
00:09:55,729 --> 00:09:59,666
实体是您的 App
向 App Intents 公开的概念

214
00:09:59,666 --> 00:10:02,202
当值为动态或由用户定义时

215
00:10:02,202 --> 00:10:05,072
您应该使用实体而非枚举

216
00:10:05,072 --> 00:10:09,209
例如“备忘录”中的笔记
或“照片”中的图片或相册

217
00:10:09,209 --> 00:10:11,512
要提供实体的实例

218
00:10:11,512 --> 00:10:13,514
您的 App 可以实施查询

219
00:10:13,514 --> 00:10:17,818
并返回实体作为意图的结果

220
00:10:17,818 --> 00:10:21,321
首先 我要在 App 中
创建打开一本书的意图

221
00:10:21,321 --> 00:10:25,158
在“快捷指令”编辑器中
它看起来应该是这样

222
00:10:25,158 --> 00:10:27,261
当用户轻点“书本”参数时

223
00:10:27,261 --> 00:10:29,263
就会获得一个选取书目的选择器

224
00:10:29,263 --> 00:10:30,964
也包括由我的 App 提供的

225
00:10:30,964 --> 00:10:34,401
一组推荐实体

226
00:10:34,401 --> 00:10:36,703
用户还可以使用选择器顶部的搜索栏

227
00:10:36,703 --> 00:10:41,375
在自己的图书馆中找到任何书籍

228
00:10:41,375 --> 00:10:43,343
在我建立意图本身之前

229
00:10:43,343 --> 00:10:45,312
我需要先创建一个书本实体

230
00:10:45,312 --> 00:10:47,614
及相应的查询

231
00:10:47,614 --> 00:10:50,484
一个实体至少包含三个部分

232
00:10:50,484 --> 00:10:53,153
标识符 显示表述

233
00:10:53,153 --> 00:10:56,190
和实体类型名称

234
00:10:56,190 --> 00:10:58,926
要添加实体 首先要使结构

235
00:10:58,926 --> 00:11:01,528
符合 AppEntity 协议

236
00:11:01,528 --> 00:11:03,997
在这里 我将为 BookEntity
定义一个新结构

237
00:11:03,997 --> 00:11:08,569
但也可以用我模型中
现有的类型执行符合

238
00:11:08,569 --> 00:11:11,371
通过符合实体来向可识别协议

239
00:11:11,371 --> 00:11:14,041
提供标识符

240
00:11:14,041 --> 00:11:17,110
App Intents 使用此标识符
来引用您的实体

241
00:11:17,110 --> 00:11:20,881
因为它在您的 App
和系统其他部分之间传递

242
00:11:20,881 --> 00:11:23,717
标识符应当是稳定而持久的

243
00:11:23,717 --> 00:11:25,752
因为它可能被保存在由您的

244
00:11:25,752 --> 00:11:29,156
客户创建的快捷指令中

245
00:11:29,156 --> 00:11:31,058
显示表述的作用是

246
00:11:31,058 --> 00:11:33,560
向用户展示此实体

247
00:11:33,560 --> 00:11:35,596
它可以像一串文本一样简单

248
00:11:35,596 --> 00:11:37,531
比如书名

249
00:11:37,531 --> 00:11:41,635
您也可以为它提供副标题和图像

250
00:11:41,635 --> 00:11:44,071
typeDisplayName 是一种
人可读的字符串

251
00:11:44,071 --> 00:11:46,440
用来表述实体的类型

252
00:11:46,440 --> 00:11:49,209
在这个案例中 它就是“书本”

253
00:11:49,209 --> 00:11:51,545
现在 为了完善书本实体

254
00:11:51,545 --> 00:11:54,181
我需要添加查询

255
00:11:54,181 --> 00:11:56,617
查询为系统提供了一个接口

256
00:11:56,617 --> 00:12:00,020
用于从您的 App 中检索实体

257
00:12:00,020 --> 00:12:03,156
查询可以通过几种方式寻找实体

258
00:12:03,156 --> 00:12:05,292
所有查询都需要能够基于标识符

259
00:12:05,292 --> 00:12:07,361
对实体进行查找

260
00:12:07,361 --> 00:12:09,796
字符串查询支持搜索

261
00:12:09,796 --> 00:12:11,899
稍后您还会看到属性查询

262
00:12:11,899 --> 00:12:13,934
它的灵活度更大

263
00:12:13,934 --> 00:12:17,337
所有查询都可以提供建议实体

264
00:12:17,337 --> 00:12:21,708
允许用户从列表中选择

265
00:12:21,708 --> 00:12:24,611
每个实体都应当与一个查询相关联

266
00:12:24,611 --> 00:12:29,016
使系统可以查找该实体的实例

267
00:12:29,016 --> 00:12:31,585
您可以通过
创建 Swift 结构来提供

268
00:12:31,585 --> 00:12:35,222
符合 EntityQuery 协议的查询

269
00:12:35,222 --> 00:12:38,292
基础查询只需要实施一种方法

270
00:12:38,292 --> 00:12:39,960
在给定标识符数组时

271
00:12:39,960 --> 00:12:42,863
用于解析实体

272
00:12:42,863 --> 00:12:45,666
我实现的方式是访问模型数据库

273
00:12:45,666 --> 00:12:49,970
并找到与标识符匹配的任何书目

274
00:12:49,970 --> 00:12:53,373
现在 我需要将查询连接到实体

275
00:12:53,373 --> 00:12:56,410
可以通过在
BookEntity 类型上实施

276
00:12:56,410 --> 00:12:58,278
defaultQuery 静态属性

277
00:12:58,278 --> 00:13:03,183
并返回 BookQuery 的
一个实例来完成

278
00:13:03,183 --> 00:13:05,152
当用户选择一本书时

279
00:13:05,152 --> 00:13:08,121
它的标识符将被保存到快捷指令中

280
00:13:08,121 --> 00:13:09,556
快捷指令运行时

281
00:13:09,556 --> 00:13:12,492
App Intents 会将标识符
传递给我的查询

282
00:13:12,492 --> 00:13:16,797
用于检索
BookEntity 实例

283
00:13:16,797 --> 00:13:18,198
现在 BookEntity 类型

284
00:13:18,198 --> 00:13:20,667
已经符合
AppEntity 协议

285
00:13:20,667 --> 00:13:24,671
我可以将它用作
OpenBook 意图中的参数

286
00:13:24,671 --> 00:13:26,940
perform 方法
使用我的导航器

287
00:13:26,940 --> 00:13:28,942
找到这本书

288
00:13:32,546 --> 00:13:34,648
为了支持书本选择器

289
00:13:34,648 --> 00:13:38,485
我的查询还需要提供建议结果

290
00:13:38,485 --> 00:13:42,022
为此 我需要在
查询中实施另一种方法

291
00:13:42,022 --> 00:13:45,092
返回我的“图书馆”
App 里添加的所有书

292
00:13:45,092 --> 00:13:49,997
快捷指令将用这些结果填充选择器

293
00:13:49,997 --> 00:13:53,700
请注意 “快捷指令”
UI 顶部有一个搜索框

294
00:13:53,700 --> 00:13:55,669
我的 App 中
可能有大量书本实体

295
00:13:55,669 --> 00:13:58,739
所以我非常需要
在 App 进程中运行

296
00:13:58,739 --> 00:14:00,908
直接针对数据库的搜索

297
00:14:00,908 --> 00:14:04,411
StringQuery API
可以帮我做到

298
00:14:04,411 --> 00:14:06,813
采用 StringQuery 子协议需要我

299
00:14:06,813 --> 00:14:08,515
实施另一种方法

300
00:14:08,515 --> 00:14:10,717
即 entities (matching string:)

301
00:14:10,717 --> 00:14:13,287
来返回给定字符串的结果

302
00:14:13,287 --> 00:14:16,690
在这里 我实现了简单的
不区分大小写的

303
00:14:16,690 --> 00:14:18,392
书名匹配

304
00:14:18,392 --> 00:14:19,960
但我也可以做实现更复杂的功能

305
00:14:19,960 --> 00:14:22,396
比如说 使用作者或系列名称

306
00:14:22,396 --> 00:14:24,598
来进行搜索

307
00:14:24,598 --> 00:14:28,168
如果我的书总量很大
但收藏夹里的数量少一些

308
00:14:28,168 --> 00:14:31,238
在 suggestedEntities 中可以
只返回收藏夹内容

309
00:14:31,238 --> 00:14:33,574
并借助 entities (matching string:)

310
00:14:33,574 --> 00:14:38,912
允许用户在更长的列表中进行搜索

311
00:14:38,912 --> 00:14:41,882
我已经公开了一种
在 App 中打开书本的方法

312
00:14:41,882 --> 00:14:45,485
并在此过程中创建了
书本实体和书本查询

313
00:14:45,485 --> 00:14:49,323
现在就可以使用同样的
实体和查询来创建更多意图

314
00:14:49,323 --> 00:14:51,758
我的下一个任务是创建

315
00:14:51,758 --> 00:14:53,894
将书本添加到图书馆的意图

316
00:14:53,894 --> 00:14:56,630
客户在线浏览的同时
可以使用共享表单快捷指令

317
00:14:56,630 --> 00:14:58,232
快速添加书本

318
00:14:58,232 --> 00:15:00,534
也可以呼唤 HomePod 上的
Siri 来添加书本

319
00:15:00,534 --> 00:15:03,003
甚至不需要看屏幕

320
00:15:03,003 --> 00:15:06,673
像这样创建直接操作模型

321
00:15:06,673 --> 00:15:11,879
而不显示 UI 的意图
可以真正为您的用户赋权

322
00:15:11,879 --> 00:15:14,715
这是我对
AddBook 意图的实现

323
00:15:14,715 --> 00:15:16,817
参数是书名和

324
00:15:16,817 --> 00:15:19,520
可选的作者姓名

325
00:15:19,520 --> 00:15:21,622
它还包含了可选的备注

326
00:15:21,622 --> 00:15:24,791
用于记录是哪个朋友推荐了这本书

327
00:15:24,791 --> 00:15:27,728
perform 方法
通过使用 async/await 的

328
00:15:27,728 --> 00:15:31,765
API 调用来查找
并将书本添加到图书馆

329
00:15:31,765 --> 00:15:36,670
如果找不到匹配项 将引发错误

330
00:15:36,670 --> 00:15:39,473
为了将这个错误本地化
我使错误类型符合

331
00:15:39,473 --> 00:15:43,944
CustomLocalizedStringResourceConvertible 协议

332
00:15:43,944 --> 00:15:47,214
我将从属性返回本地化的字符串键

333
00:15:47,214 --> 00:15:50,951
并将键添加到我的字符串文件中

334
00:15:50,951 --> 00:15:54,288
配合 Siri 小组件等等工具
“添加书本”意图

335
00:15:54,288 --> 00:15:56,857
已经非常有用了

336
00:15:56,857 --> 00:15:58,759
但如果将它与其他意图相结合

337
00:15:58,759 --> 00:16:01,628
它的灵活度将进一步提高

338
00:16:01,628 --> 00:16:02,896
只需稍加改动

339
00:16:02,896 --> 00:16:05,165
我就可以使“添加书本”意图与

340
00:16:05,165 --> 00:16:07,634
我之前创建的“打开书本”组合

341
00:16:07,634 --> 00:16:10,938
将结果从一个传递到另一个

342
00:16:10,938 --> 00:16:13,807
为此 我将让“添加书本”意图

343
00:16:13,807 --> 00:16:17,110
返回一个值作为其结果的一部分

344
00:16:17,110 --> 00:16:19,213
请注意我的
perform 方法的返回类型

345
00:16:19,213 --> 00:16:20,981
已经选取了一个新协议

346
00:16:20,981 --> 00:16:23,951
来表述我返回的值

347
00:16:23,951 --> 00:16:27,421
现在 用户可以将这个意图的结果值

348
00:16:27,421 --> 00:16:31,859
与以书本实体为参数的
其他意图连接起来

349
00:16:31,859 --> 00:16:34,928
“添加书本”意图
和“打开书本”意图

350
00:16:34,928 --> 00:16:36,396
就很自然地配合起来

351
00:16:36,396 --> 00:16:38,866
让您可以创建快捷指令来添加一本书

352
00:16:38,866 --> 00:16:41,435
随后立即在库中打开它

353
00:16:41,435 --> 00:16:44,505
一种常见模式是从意图返回结果

354
00:16:44,505 --> 00:16:46,874
并在 App 中打开它

355
00:16:46,874 --> 00:16:49,343
App Intents 中有一种
名为 openIntent 的内置方式

356
00:16:49,343 --> 00:16:51,578
来表述这种模式

357
00:16:51,578 --> 00:16:53,881
如果我添加了
openIntent 则客户会在

358
00:16:53,881 --> 00:16:57,484
“快捷指令”中获得一个
名为“运行时打开”的新开关

359
00:16:57,484 --> 00:16:59,086
如果他们关掉开关

360
00:16:59,086 --> 00:17:00,254
他们将能够在不被打断的情况下

361
00:17:00,254 --> 00:17:04,625
在后台将这一意图
作为快捷指令的一部分使用

362
00:17:04,625 --> 00:17:07,528
如果他们打开开关 新添加的书

363
00:17:07,528 --> 00:17:12,399
将立即在“图书馆”App 中打开

364
00:17:12,399 --> 00:17:15,269
采用 openIntent 就像

365
00:17:15,269 --> 00:17:17,671
为“打开书本”意图创建实例

366
00:17:17,671 --> 00:17:20,908
并将其作为部分结果返回一样简单

367
00:17:20,908 --> 00:17:22,309
当意图运行时

368
00:17:22,309 --> 00:17:24,278
如果“运行时打开”状态为开

369
00:17:24,278 --> 00:17:27,147
“打开书本”意图将在

370
00:17:27,147 --> 00:17:31,351
“添加书本”意图完成后自动执行

371
00:17:31,351 --> 00:17:35,055
借助实体和查询
还可以实现更多功能

372
00:17:35,055 --> 00:17:36,623
使用以下这组 API

373
00:17:36,623 --> 00:17:39,326
AppIntents
开启了一些在

374
00:17:39,326 --> 00:17:43,497
SiriKit Intents 框架下
从未有过的强大性能

375
00:17:43,497 --> 00:17:45,999
让我们来看看如何公开

376
00:17:45,999 --> 00:17:47,301
更多实体信息

377
00:17:47,301 --> 00:17:52,306
并允许客户据此进行查找和筛选

378
00:17:52,306 --> 00:17:55,175
到目前为止 我已经将所有基础请求

379
00:17:55,175 --> 00:17:56,677
添加到了我的书本实体中

380
00:17:56,677 --> 00:17:58,145
但要想让用户更深入地将书本

381
00:17:58,145 --> 00:18:00,247
整合到快捷指令中

382
00:18:00,247 --> 00:18:05,085
我将需要公开更多书的信息

383
00:18:05,085 --> 00:18:07,120
实体支持属性

384
00:18:07,120 --> 00:18:09,423
属性则持有您想向用户公开的

385
00:18:09,423 --> 00:18:11,992
关于该实体的额外信息

386
00:18:11,992 --> 00:18:13,994
在本例中 我将添加书本的作者

387
00:18:13,994 --> 00:18:16,997
出版日期 阅读日期和推荐人

388
00:18:16,997 --> 00:18:22,069
这样用户就可以
在快捷指令中使用这些属性

389
00:18:22,069 --> 00:18:24,071
我将使用名为
@Property 的属性包装器

390
00:18:24,071 --> 00:18:27,341
来将属性
添加到 BookEntity

391
00:18:27,341 --> 00:18:30,244
属性支持与参数相同的所有类型

392
00:18:30,244 --> 00:18:35,516
且每个种类都有本地化的标题

393
00:18:35,516 --> 00:18:37,251
有了这些新属性

394
00:18:37,251 --> 00:18:40,387
我的客户现在可以在
“快捷指令”中使用魔法变量

395
00:18:40,387 --> 00:18:42,689
提取与书本实体配合时的

396
00:18:42,689 --> 00:18:45,292
每一条新信息

397
00:18:45,292 --> 00:18:47,661
当使用此前创建的
“添加书本”意图时

398
00:18:47,661 --> 00:18:49,997
用户可以在快捷指令中用到

399
00:18:49,997 --> 00:18:53,000
新增书籍的作者或出版日期

400
00:18:55,135 --> 00:18:57,671
当您将属性与查询结合使用时

401
00:18:57,671 --> 00:19:00,607
借助这个灵活的谓词编辑器 UI

402
00:19:00,607 --> 00:19:03,076
您的 App 将在
“快捷指令”中自动获得

403
00:19:03,076 --> 00:19:06,547
难以置信的强大“查找与筛选”操作

404
00:19:06,547 --> 00:19:09,316
现在 我的客户将能够基于

405
00:19:09,316 --> 00:19:13,053
阅读日期 标题 作者等条件
查找和筛选书本

406
00:19:13,053 --> 00:19:14,555
比如说 要找到

407
00:19:14,555 --> 00:19:18,759
Delia Owens 的所有书
可以说是小菜一碟

408
00:19:18,759 --> 00:19:20,661
使用排序依据和限制选项

409
00:19:20,661 --> 00:19:22,729
您可以支持更高阶的查询

410
00:19:22,729 --> 00:19:25,065
比如找到 Delia Owens

411
00:19:25,065 --> 00:19:27,868
最近出版的三本书

412
00:19:27,868 --> 00:19:30,003
客户可以使用这些组成部件

413
00:19:30,003 --> 00:19:32,372
做一些很酷的事 比如查找

414
00:19:32,372 --> 00:19:36,043
自己的收藏中最常见的三位作者

415
00:19:36,043 --> 00:19:37,277
为了实现这些

416
00:19:37,277 --> 00:19:39,680
我需要采用另一种查询

417
00:19:39,680 --> 00:19:41,915
即属性查询

418
00:19:41,915 --> 00:19:44,918
属性查询并非基于字符串

419
00:19:44,918 --> 00:19:50,390
或标识符对实体进行查找
而是基于实体内的属性

420
00:19:50,390 --> 00:19:53,594
实施属性查询分为三个步骤

421
00:19:53,594 --> 00:19:55,929
首先 声明查询属性

422
00:19:55,929 --> 00:19:58,365
指定如何通过属性对实体

423
00:19:58,365 --> 00:20:00,634
进行搜索

424
00:20:00,634 --> 00:20:02,469
接下来 填加排序选项

425
00:20:02,469 --> 00:20:06,373
定义如何对查询结果进行排序

426
00:20:06,373 --> 00:20:09,476
最后 实施
entities(matching:)

427
00:20:09,476 --> 00:20:12,212
并运行搜索

428
00:20:12,212 --> 00:20:13,447
查询属性

429
00:20:13,447 --> 00:20:16,216
声明了 AppIntents
可以在与此查询关联的

430
00:20:16,216 --> 00:20:19,520
实体上进行搜索的所有方式

431
00:20:19,520 --> 00:20:21,989
每种都列出了实体的一个属性

432
00:20:21,989 --> 00:20:23,790
和可用于它的比较运算符

433
00:20:23,790 --> 00:20:26,126
例如包含 等于

434
00:20:26,126 --> 00:20:28,529
或小于

435
00:20:28,529 --> 00:20:31,532
在这里 我为日期属性列出了

436
00:20:31,532 --> 00:20:33,333
“小于”和“大于”比较器

437
00:20:33,333 --> 00:20:38,672
为书名属性列出了
“包含”和“等于”

438
00:20:38,672 --> 00:20:41,508
查询属性将每个属性组合

439
00:20:41,508 --> 00:20:45,546
和比较器映射为您选择的类型

440
00:20:45,546 --> 00:20:48,048
这被称为比较器映射类型

441
00:20:48,048 --> 00:20:51,952
在这里 因为使用了 CoreData
所以我选 NSPredicate 来用

442
00:20:51,952 --> 00:20:55,222
如果使用的是
自定义数据库或 REST API

443
00:20:55,222 --> 00:20:57,524
可以设计自己的比较器类型

444
00:20:57,524 --> 00:21:00,594
并且选择使用它

445
00:21:00,594 --> 00:21:04,198
这是用于设置书本查询属性的代码

446
00:21:04,198 --> 00:21:08,669
我使 BooksQuery
符合 EntityPropertyQuery 协议

447
00:21:08,669 --> 00:21:11,572
然后使用 QueryProperties
结果构建器

448
00:21:11,572 --> 00:21:15,275
实施静态变量属性

449
00:21:15,275 --> 00:21:18,145
每个条目都指定一个可查询的

450
00:21:18,145 --> 00:21:20,380
属性 keyPath 在它内部

451
00:21:20,380 --> 00:21:24,184
是适用于该属性的所有比较器

452
00:21:24,184 --> 00:21:26,687
对于每个比较器
我都提供一个 NSPredicate

453
00:21:26,687 --> 00:21:31,458
因为我选择了 NSPredicate
作为比较器映射类型

454
00:21:31,458 --> 00:21:35,195
当系统要求我的 App
返回查询结果时

455
00:21:35,195 --> 00:21:37,097
它将再次提供我在这里

456
00:21:37,097 --> 00:21:39,967
创建的 NSPredicates

457
00:21:39,967 --> 00:21:42,703
排序的定义也与之类似

458
00:21:42,703 --> 00:21:44,404
这是一张所有属性的列表

459
00:21:44,404 --> 00:21:46,640
我的模型可以用这些属性
对书本进行排序

460
00:21:46,640 --> 00:21:48,842
在这个案例中 我允许按书名

461
00:21:48,842 --> 00:21:52,179
阅读日期和出版日期排序

462
00:21:52,179 --> 00:21:55,215
最后 我实施 entities(matching:)

463
00:21:55,215 --> 00:21:59,152
它会查询我的数据库
并返回匹配的实体

464
00:21:59,152 --> 00:22:02,523
此方法采用了比较器映射类型的

465
00:22:02,523 --> 00:22:05,926
一个我在之前定义
查询参数时使用的数组

466
00:22:05,926 --> 00:22:07,895
在这个案例里
就是 NSPredicate

467
00:22:07,895 --> 00:22:11,031
这些谓词描述了我想通过

468
00:22:11,031 --> 00:22:15,035
实体属性的哪些标准来查询

469
00:22:15,035 --> 00:22:16,470
它也采用了一种模式

470
00:22:16,470 --> 00:22:18,505
来指示是否要使用

471
00:22:18,505 --> 00:22:22,543
“和”及“或”来合并谓词
进行排序的关键路径

472
00:22:22,543 --> 00:22:26,380
以及结果数量的可选限制

473
00:22:26,380 --> 00:22:28,649
我在实施时使用这些参数

474
00:22:28,649 --> 00:22:34,454
对 CoreData 数据库
执行查询

475
00:22:34,454 --> 00:22:37,391
那么客户可以使用
此属性查询做什么呢？

476
00:22:37,391 --> 00:22:40,961
可以从库中随机挑选一本书来读

477
00:22:40,961 --> 00:22:42,496
也可以找到所有出版于

478
00:22:42,496 --> 00:22:45,832
20 世纪初的书

479
00:22:45,832 --> 00:22:48,268
可以借助“快捷指令”生态系统

480
00:22:48,268 --> 00:22:51,572
通过将自己的 App 与其他人的连接
使自己的 App 变得更有用

481
00:22:51,572 --> 00:22:53,574
例如 可以使用电子表格 App

482
00:22:53,574 --> 00:22:57,477
将今年阅读的所有书
导出为 CSV 文件

483
00:22:57,477 --> 00:22:59,780
也可以使用绘图 App 制作图表

484
00:22:59,780 --> 00:23:03,283
呈现过去的 10 年里
每年读书的数量

485
00:23:03,283 --> 00:23:04,918
而这仅仅是个开始

486
00:23:04,918 --> 00:23:07,321
这种深入的
App Intents 运用

487
00:23:07,321 --> 00:23:09,256
真正让客户使用您的 App

488
00:23:09,256 --> 00:23:11,325
去完成他们期待它实现的功能

489
00:23:11,325 --> 00:23:14,328
让您的 App 成为他们
工作流程的关键部分

490
00:23:14,328 --> 00:23:15,863
所有这些集成

491
00:23:15,863 --> 00:23:17,931
比如制作图表

492
00:23:17,931 --> 00:23:21,735
都是您不必费心去构建的功能

493
00:23:21,735 --> 00:23:23,504
当您的意图被执行时

494
00:23:23,504 --> 00:23:25,772
您的 App 可能需要
与用户进行交互

495
00:23:25,772 --> 00:23:29,142
去展示或说出结果 或解决歧义

496
00:23:29,142 --> 00:23:32,946
无论是 Siri 请求
还是快捷指令

497
00:23:32,946 --> 00:23:36,517
App Intents
支持几种此类交互

498
00:23:36,517 --> 00:23:38,852
“对话”用于意图完成时向用户

499
00:23:38,852 --> 00:23:41,455
提供文本和语音反馈

500
00:23:41,455 --> 00:23:43,991
“片段”则用于提供视觉反馈

501
00:23:43,991 --> 00:23:46,260
“请求值”和“消歧义”

502
00:23:46,260 --> 00:23:50,364
用于要求用户澄清意图参数的值

503
00:23:50,364 --> 00:23:53,734
“确认”用于对参数值进行验证

504
00:23:53,734 --> 00:23:55,169
或与用户核实

505
00:23:55,169 --> 00:23:59,439
意图是否具有交易性或破坏性

506
00:23:59,439 --> 00:24:02,543
“对话”向运行意图者

507
00:24:02,543 --> 00:24:04,578
提供口头或文字回应

508
00:24:04,578 --> 00:24:06,713
提供对话对于使意图在

509
00:24:06,713 --> 00:24:10,184
语音体验中发挥作用真的非常重要

510
00:24:10,184 --> 00:24:12,119
在我之前创建的“添加书本”意图中

511
00:24:12,119 --> 00:24:13,820
我将添加
needsValueDialog

512
00:24:13,820 --> 00:24:16,223
在询问书名时说出

513
00:24:16,223 --> 00:24:20,027
还要添加针对
perform 方法返回结果的对话

514
00:24:20,027 --> 00:24:22,729
对话将在我们的不同平台上
由“快捷指令”或 Siri

515
00:24:22,729 --> 00:24:25,866
来朗读或显示

516
00:24:25,866 --> 00:24:30,404
您可以将“片段”
视为“对话”的视觉等价物

517
00:24:30,404 --> 00:24:32,539
它让您能够为意图的结果

518
00:24:32,539 --> 00:24:34,942
添加视觉表述

519
00:24:34,942 --> 00:24:38,212
要使用片段
只需添加您选择的 SwiftUI 视图

520
00:24:38,212 --> 00:24:42,349
作为意图结果的尾随闭包

521
00:24:42,349 --> 00:24:46,019
与小部件一样
SwiftUI 视图将被归档

522
00:24:46,019 --> 00:24:51,258
并发送给“快捷指令”或 Siri

523
00:24:51,258 --> 00:24:54,561
App Intents 还支持
通过抛出 requestValue

524
00:24:54,561 --> 00:24:56,730
向用户询问值

525
00:24:56,730 --> 00:24:59,433
比如说 当您需要
一个有时是可选的参数值时

526
00:24:59,433 --> 00:25:02,769
这就能派上用场

527
00:25:02,769 --> 00:25:06,106
在这里 当字符串搜索
返回不止一本书时

528
00:25:06,106 --> 00:25:08,275
requestValue
就可以帮上忙

529
00:25:08,275 --> 00:25:10,544
在这种情况下
我提示并询问作者姓名

530
00:25:10,544 --> 00:25:12,779
来缩小书本的搜索范围

531
00:25:12,779 --> 00:25:15,482
requestValue 给出了
一个可以引发的错误

532
00:25:15,482 --> 00:25:17,017
它将提示用户

533
00:25:17,017 --> 00:25:21,955
并使用更新的作者姓名
重新运行该操作

534
00:25:21,955 --> 00:25:24,024
同时 “消歧义”

535
00:25:24,024 --> 00:25:25,926
在您需要用户在参数的一组值之间

536
00:25:25,926 --> 00:25:29,329
进行选择时非常有用

537
00:25:29,329 --> 00:25:31,465
它为我提供了一种更好的方式

538
00:25:31,465 --> 00:25:35,802
来处理“添加书本”
操作中的多个可能结果

539
00:25:35,802 --> 00:25:39,206
在这里 我从生成的书本中
获取了作者姓名列表

540
00:25:39,206 --> 00:25:43,076
并要求对这些可能的值进行消歧

541
00:25:43,076 --> 00:25:45,078
用户将被要求在它们之中进行选择

542
00:25:45,078 --> 00:25:49,149
而我会得到结果

543
00:25:49,149 --> 00:25:53,687
最后 App Intents 支持
两种不同的确认方式

544
00:25:53,687 --> 00:25:57,624
第一种是参数值的确认

545
00:25:57,624 --> 00:25:59,193
您可能会在心里对值已有大概猜想

546
00:25:59,193 --> 00:26:02,162
但仍想证实的情况下

547
00:26:02,162 --> 00:26:04,331
使用这种确认方式

548
00:26:04,331 --> 00:26:05,599
在添加书本时

549
00:26:05,599 --> 00:26:08,836
有时我调用的按书名查找网络服务

550
00:26:08,836 --> 00:26:10,237
会返回几个匹配项

551
00:26:10,237 --> 00:26:13,106
但其中有一项在目前看来更受欢迎

552
00:26:13,106 --> 00:26:15,275
在这样的情况下 我会假设

553
00:26:15,275 --> 00:26:17,978
用户打算添加那本受欢迎的书

554
00:26:17,978 --> 00:26:21,381
但我会加上“确认”来保证我猜对了

555
00:26:21,381 --> 00:26:23,684
为此 我将在书名参数上

556
00:26:23,684 --> 00:26:26,286
调用 requestConfirmation

557
00:26:26,286 --> 00:26:28,856
第二种方式是确认

558
00:26:28,856 --> 00:26:31,024
意图的结果

559
00:26:31,024 --> 00:26:33,927
举例来说 它非常适合用于下订单

560
00:26:33,927 --> 00:26:35,963
如果我想通过
“图书馆”App 获利

561
00:26:35,963 --> 00:26:38,265
并通过书店添加订购

562
00:26:38,265 --> 00:26:41,401
我需要确保订单信息正确

563
00:26:41,401 --> 00:26:44,104
为此 我可以在意图上
调用 requestConfirmation

564
00:26:44,104 --> 00:26:47,708
来传递要下的订单

565
00:26:47,708 --> 00:26:52,346
我也会在这里指定片段
来显示订单的预览

566
00:26:52,346 --> 00:26:55,048
我在调用前加上了 try
因为 requestConfirmation

567
00:26:55,048 --> 00:26:57,718
在用户取消而不是确认的情况下

568
00:26:57,718 --> 00:27:00,888
将引发错误

569
00:27:00,888 --> 00:27:02,956
在结束讲座前 我还想向您介绍

570
00:27:02,956 --> 00:27:05,826
App Intents 架构的
几个方面

571
00:27:05,826 --> 00:27:09,630
这些是您在采用此框架时
就应该了解的

572
00:27:09,630 --> 00:27:12,733
实际上 有两种构建
App Intents 的途径

573
00:27:12,733 --> 00:27:16,036
在您的 App 中
或者在单独的扩展程序中

574
00:27:16,036 --> 00:27:18,805
直接在您的 App 中实施意图

575
00:27:18,805 --> 00:27:20,841
是最简单的

576
00:27:20,841 --> 00:27:23,110
这种方法很好用 因为您不需要框架

577
00:27:23,110 --> 00:27:25,245
不用复制代码

578
00:27:25,245 --> 00:27:28,649
也不需要跨流程进行协调

579
00:27:28,649 --> 00:27:31,485
使用您的 App 还能够
提供更高的内存限制

580
00:27:31,485 --> 00:27:34,121
让您有能力完成一些

581
00:27:34,121 --> 00:27:36,023
在扩展程序中更难实现的功能

582
00:27:36,023 --> 00:27:39,626
比如播放音频

583
00:27:39,626 --> 00:27:41,495
如果在意图返回“真”的情况下
实施 openAppWhenRun

584
00:27:41,495 --> 00:27:45,632
您的 App 就可以在前台运行

585
00:27:45,632 --> 00:27:48,602
否则 它将在后台运行

586
00:27:48,602 --> 00:27:50,170
在后台运行时

587
00:27:50,170 --> 00:27:52,072
您的 App 将以特殊模式启动

588
00:27:52,072 --> 00:27:55,576
无需调出场景来将性能最大化

589
00:27:55,576 --> 00:27:58,579
事实上 如果您在 App 中

590
00:27:58,579 --> 00:27:59,680
实施后台 App 意图

591
00:27:59,680 --> 00:28:05,452
我们强烈建议您也实施场景支持

592
00:28:05,452 --> 00:28:08,822
或者 您也可以在扩展程序中
构建您的 App 意图

593
00:28:08,822 --> 00:28:10,924
这种方式有几个优点

594
00:28:10,924 --> 00:28:11,825
它更轻量

595
00:28:11,825 --> 00:28:15,262
因为扩展程序进程
只处理 App 意图

596
00:28:15,262 --> 00:28:18,365
也不需要启动您的 App

597
00:28:18,365 --> 00:28:20,734
如果您正在处理“焦点”意图

598
00:28:20,734 --> 00:28:23,203
使用扩展程序也意味着您可以

599
00:28:23,203 --> 00:28:25,839
在“焦点”改变时 立即使意图

600
00:28:25,839 --> 00:28:28,141
在扩展程序上执行 而无需要求

601
00:28:28,141 --> 00:28:32,045
App 首先在前台运行

602
00:28:32,045 --> 00:28:33,647
扩展程序的工作量更大

603
00:28:33,647 --> 00:28:35,749
因为您需要添加一个新目标

604
00:28:35,749 --> 00:28:37,251
将部分代码转移到框架中

605
00:28:37,251 --> 00:28:39,253
并处理您的 App
和扩展程序之间的

606
00:28:39,253 --> 00:28:43,023
协调配合

607
00:28:43,023 --> 00:28:45,058
要创建
App Intents 扩展程序

608
00:28:45,058 --> 00:28:47,261
在 Xcode 中转到
“文件” “新目标”

609
00:28:47,261 --> 00:28:52,065
并选择“App Intents
扩展程序”

610
00:28:52,065 --> 00:28:56,737
使用 App Intents 时
您的代码是唯一的事实来源

611
00:28:56,737 --> 00:28:59,606
App Intents
通过静态提取构建时

612
00:28:59,606 --> 00:29:02,943
您的意图 实体 查询和参数信息

613
00:29:02,943 --> 00:29:06,914
实现了这种优雅的开发者体验

614
00:29:06,914 --> 00:29:10,050
Xcode 将在您的 App 中
生成元数据文件

615
00:29:10,050 --> 00:29:12,653
或构建过程中的扩展包

616
00:29:12,653 --> 00:29:15,789
包含了从 Swift
编译器接收到的信息

617
00:29:15,789 --> 00:29:18,292
因为它基于您的代码运行

618
00:29:18,292 --> 00:29:21,395
为确保这些都能起作用
请将您的 App Intents 类型

619
00:29:21,395 --> 00:29:25,732
直接保留在目标或扩展程序里
而非框架中

620
00:29:25,732 --> 00:29:27,467
同样 您的本地化字符串

621
00:29:27,467 --> 00:29:29,403
应该可以在与您的
App Intents 类型

622
00:29:29,403 --> 00:29:34,508
同处一个包的字符串文件中找到

623
00:29:34,508 --> 00:29:36,777
对于已有使用
SiriKit Intents 框架的

624
00:29:36,777 --> 00:29:39,780
App 并考虑升级的人来说

625
00:29:39,780 --> 00:29:42,850
如果您采用意图与小部件

626
00:29:42,850 --> 00:29:45,319
或消息和媒体等域进行集成

627
00:29:45,319 --> 00:29:48,755
请继续使用
SiriKit Intents 框架

628
00:29:48,755 --> 00:29:51,825
但如果您要为 Siri 和
“快捷指令”添加自定义意图

629
00:29:51,825 --> 00:29:55,162
您应当更进一步
升级到 App Intents

630
00:29:55,162 --> 00:29:57,164
您可以通过在
SiriKit Intents 定义文件中

631
00:29:57,164 --> 00:29:59,399
点按“转换为 App Intents”按钮

632
00:29:59,399 --> 00:30:04,438
开始升级过程

633
00:30:04,438 --> 00:30:06,940
使用 App Intents 将
您的 App 集成到“快捷指令”中

634
00:30:06,940 --> 00:30:10,777
是将您作为开发人员的
影响力最大化的绝佳方法

635
00:30:10,777 --> 00:30:14,214
只需通过少量工作
来运用 App Intents

636
00:30:14,214 --> 00:30:17,784
您就将为客户创造大量的价值

637
00:30:17,784 --> 00:30:18,886
感谢您参与今天的讲座

638
00:30:18,886 --> 00:30:21,755
我非常希望您能
立刻试用 App Intents

639
00:30:21,755 --> 00:30:23,323
并为我们提供反馈

640
00:30:23,323 --> 00:30:25,192
我对这个新框架可以如何帮助您

641
00:30:25,192 --> 00:30:27,995
通过 App 为人们带来
惊喜和快乐 并为其赋权

642
00:30:27,995 --> 00:30:29,496
充满了期待

643
00:30:29,496 --> 00:30:33,367
阅读愉快 希望您能
在 WWDC 有绝佳的体验

644
00:30:33,367 --> 00:30:37,638
♪

