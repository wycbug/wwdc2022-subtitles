1
00:00:00,334 --> 00:00:03,837
[欢快的音乐]

2
00:00:10,043 --> 00:00:11,411
Kelvin Chiu: 大家好 欢迎

3
00:00:11,445 --> 00:00:14,948
我是 Kelvin Chiu
来自 Apple GPU Software 团队

4
00:00:14,982 --> 00:00:17,985
今天 我来谈下如何
用 MetalFX Upscaling 功能

5
00:00:18,018 --> 00:00:20,087
提高您的 Metal 应用性能

6
00:00:20,721 --> 00:00:23,090
MetalFX 是一个新的 API

7
00:00:23,123 --> 00:00:26,627
为 Metal 应用
提供平台优化的图形效果

8
00:00:27,361 --> 00:00:29,730
它通过高性能放大

9
00:00:29,763 --> 00:00:31,865
提高应用的性能

10
00:00:31,899 --> 00:00:34,868
同时维持渲染质量

11
00:00:34,902 --> 00:00:38,172
渲染高分辨率帧是非常
耗费 GPU 时间的

12
00:00:38,205 --> 00:00:41,041
为了减少这一时间 通常会使用

13
00:00:41,074 --> 00:00:42,910
低分辨率渲染的方法

14
00:00:42,943 --> 00:00:45,879
然而 代价就是低渲染质量

15
00:00:45,913 --> 00:00:47,748
通过 MetalFX 放大

16
00:00:47,781 --> 00:00:49,716
您的应用可以在渲染帧时

17
00:00:49,750 --> 00:00:52,686
使用低分辨率 减少渲染时间

18
00:00:52,719 --> 00:00:55,923
同时无需为渲染质量做妥协

19
00:00:55,956 --> 00:00:58,292
MetalFX 放大经过优化

20
00:00:58,325 --> 00:01:00,928
可更好地
在 Apple 设备上运行

21
00:01:00,961 --> 00:01:04,364
应用到游戏中也易如反掌

22
00:01:04,398 --> 00:01:07,000
MetalFX 提供了两种放大效果

23
00:01:07,034 --> 00:01:09,236
我稍后将详细解释

24
00:01:09,269 --> 00:01:11,338
空间放大使用简单

25
00:01:11,371 --> 00:01:13,674
也能带来极大的性能提高

26
00:01:14,541 --> 00:01:17,611
时序抗锯齿和放大
可整合多帧信息

27
00:01:17,644 --> 00:01:20,914
从而生成高质量输出

28
00:01:22,216 --> 00:01:24,418
我稍后会跟大家说下

29
00:01:24,451 --> 00:01:27,020
使用这些效果的最佳实践

30
00:01:27,054 --> 00:01:29,022
在讲座的最后 我会为大家

31
00:01:29,056 --> 00:01:31,625
演示实际效果

32
00:01:32,893 --> 00:01:35,329
我们先从空间放大开始

33
00:01:36,096 --> 00:01:37,865
MetalFX 空间放大

34
00:01:37,898 --> 00:01:40,167
分析输入的空间信息

35
00:01:40,200 --> 00:01:43,003
以生成全新的 放大的样本

36
00:01:43,036 --> 00:01:45,506
整合空间放大很简单

37
00:01:45,539 --> 00:01:48,475
只需抗锯齿色彩输入

38
00:01:48,509 --> 00:01:51,445
即可生成空间放大色彩输出

39
00:01:51,478 --> 00:01:54,248
在典型游戏渲染管线中

40
00:01:54,281 --> 00:01:57,484
有多个渲染通道 包括抗锯齿渲染

41
00:01:57,518 --> 00:02:00,721
和多种后期效果处理

42
00:02:00,754 --> 00:02:02,623
将 MetalFX 空间放大

43
00:02:02,656 --> 00:02:04,725
紧接着添加在游戏的色彩映射过程

44
00:02:04,758 --> 00:02:05,792
完成之后

45
00:02:05,826 --> 00:02:08,595
如果输入已完成色彩映射
且在视觉色彩空间中

46
00:02:08,629 --> 00:02:10,497
运行效果最佳

47
00:02:10,531 --> 00:02:13,634
我们来看看 MetalFX
空间放大的实际效果

48
00:02:15,135 --> 00:02:18,505
这个象棋场景是
高质量参考渲染器

49
00:02:18,539 --> 00:02:20,140
在 4K 分辨率下生成的

50
00:02:20,174 --> 00:02:23,076
它使用路径跟踪 结合复杂的图形效果

51
00:02:23,110 --> 00:02:26,413
如光线追踪反射和阴影

52
00:02:26,446 --> 00:02:28,882
这是并排比较

53
00:02:28,916 --> 00:02:31,451
左边是 540p 输入

54
00:02:32,553 --> 00:02:36,023
右边通过 MetalFX 空间放大
以 1080p 输出

55
00:02:38,926 --> 00:02:41,595
如果我放大这个皇后 左边

56
00:02:41,628 --> 00:02:44,965
图像缺少细节 分辨率低

57
00:02:44,998 --> 00:02:47,568
右边 空间放大输出下

58
00:02:47,601 --> 00:02:50,938
倒影更清晰 边缘更精细

59
00:02:52,439 --> 00:02:55,943
接下来 我和大家一起看下
如何实现 MetalFX 空间放大

60
00:02:57,044 --> 00:03:00,080
在 Metal 中 您通常会创建
一个指令编码器

61
00:03:00,113 --> 00:03:02,382
将指令编码到指令缓冲区

62
00:03:02,416 --> 00:03:04,885
为效果生成输入

63
00:03:04,918 --> 00:03:08,388
类似的 您也可以创建一个
MetalFX 效果对象

64
00:03:08,422 --> 00:03:11,758
将指令编码到指令缓冲区
从而运行效果

65
00:03:12,226 --> 00:03:15,362
最后 创建第三个指令缓冲区
编码指令

66
00:03:15,395 --> 00:03:17,965
使用 MetalFX 输出

67
00:03:17,998 --> 00:03:20,634
您应该只在 App 首次运行

68
00:03:20,667 --> 00:03:22,302
或改变显示分辨率时

69
00:03:22,336 --> 00:03:24,505
创建一个新的空间缩放器对象

70
00:03:24,538 --> 00:03:26,507
因为它创建的成本很高

71
00:03:27,541 --> 00:03:29,676
首先 创建和配置

72
00:03:29,710 --> 00:03:32,846
一个 MTLFXSpatialScalerDescriptor

73
00:03:32,880 --> 00:03:34,948
然后 通过调用
makeSpatialScaler() 方法

74
00:03:34,982 --> 00:03:37,818
创建缩放器对象

75
00:03:37,851 --> 00:03:39,720
在初始化代码中

76
00:03:39,753 --> 00:03:41,822
先为描述符

77
00:03:41,855 --> 00:03:43,290
填入输入和输出纹理的

78
00:03:43,323 --> 00:03:45,559
宽度和高度

79
00:03:45,592 --> 00:03:48,662
然后 为稍后要在缩放器对象上
设置的纹理

80
00:03:48,695 --> 00:03:50,597
设置纹理格式

81
00:03:50,631 --> 00:03:53,200
设置色彩处理模式

82
00:03:53,233 --> 00:03:55,435
告诉 API 输入和输出

83
00:03:55,469 --> 00:03:57,804
在什么色彩空间

84
00:03:57,838 --> 00:04:00,474
您可以将模式设置为

85
00:04:00,507 --> 00:04:03,310
视觉 线性 或 HDR 色彩空间

86
00:04:03,343 --> 00:04:06,647
描述符填完后 创建缩放器对象

87
00:04:08,549 --> 00:04:11,985
创建缩放器对象后
您可以随时

88
00:04:12,019 --> 00:04:14,354
修改属性

89
00:04:14,388 --> 00:04:17,491
然后调用 encode() 方法
开始放大过程

90
00:04:18,458 --> 00:04:21,628
在您每帧的绘图代码中
在缩放效果编码到指令缓冲区前

91
00:04:21,662 --> 00:04:24,331
确保缩放器对象上

92
00:04:24,364 --> 00:04:27,501
输入和输出纹理都已设置正确

93
00:04:28,335 --> 00:04:31,839
空间放大提供了
可提高性能的简单方法

94
00:04:32,906 --> 00:04:35,209
如果您想要更高质量的渲染

95
00:04:35,242 --> 00:04:37,377
MetalFX 时序抗锯齿和放大

96
00:04:37,411 --> 00:04:39,479
就可以发挥作用了

97
00:04:39,513 --> 00:04:42,583
时序抗锯齿和放大技术

98
00:04:42,616 --> 00:04:45,819
使用了上一帧的数据
来生成高质量放大输出

99
00:04:46,286 --> 00:04:49,089
这意味着上一帧的放大输出

100
00:04:49,122 --> 00:04:52,559
将会成为当前帧放大的输入之一

101
00:04:53,961 --> 00:04:57,364
为了更好地理解为什么
时序抗锯齿和放大

102
00:04:57,397 --> 00:04:58,565
需要上一帧的数据

103
00:04:58,599 --> 00:05:01,368
我先回顾下超级采样的概念

104
00:05:02,536 --> 00:05:03,937
在超级采样中

105
00:05:03,971 --> 00:05:06,707
每个像素会做多重采样计算

106
00:05:06,740 --> 00:05:09,877
然后再整合到一个像素值中

107
00:05:09,910 --> 00:05:12,279
我们整合到每个像素的样本越多

108
00:05:12,312 --> 00:05:14,548
效果就越好

109
00:05:14,581 --> 00:05:16,783
然而 在单一帧内计算

110
00:05:16,817 --> 00:05:18,652
每个像素的多重样本

111
00:05:18,685 --> 00:05:21,121
成本很高

112
00:05:21,154 --> 00:05:23,524
但是 你可以通过时序采样

113
00:05:23,557 --> 00:05:25,292
代替在同一帧内

114
00:05:25,325 --> 00:05:27,995
对每个像素进行多重位置采样

115
00:05:28,028 --> 00:05:30,430
时序采样这一概念
指的是在指定帧内

116
00:05:30,464 --> 00:05:31,865
为所有像素

117
00:05:31,899 --> 00:05:34,368
都按不同的采样位置渲染

118
00:05:34,401 --> 00:05:37,004
这让您能以极低的成本

119
00:05:37,037 --> 00:05:40,507
通过多重帧
获得超级采样的质量

120
00:05:41,308 --> 00:05:44,378
通过从多重帧对应采样位置

121
00:05:44,411 --> 00:05:46,113
累积采样

122
00:05:46,146 --> 00:05:47,948
时序抗锯齿和放大

123
00:05:47,981 --> 00:05:49,683
可以将样本合理地

124
00:05:49,716 --> 00:05:51,919
整合为目标分辨率像素

125
00:05:52,052 --> 00:05:55,556
带来高质量抗锯齿放大输出

126
00:05:56,323 --> 00:05:59,760
然而 由于内容通常
在帧与帧之间变化

127
00:05:59,793 --> 00:06:02,963
它会要求更多输入数据
来感知这些变化

128
00:06:03,931 --> 00:06:06,133
除了上一帧的输出

129
00:06:06,166 --> 00:06:08,569
时序抗锯齿和放大也需要

130
00:06:08,602 --> 00:06:10,871
抖动色彩输入

131
00:06:10,904 --> 00:06:14,341
以及场景中的运动数据
和深度数据

132
00:06:14,942 --> 00:06:18,245
我会逐一解释其原因

133
00:06:19,613 --> 00:06:21,982
首先是抖动色彩输入

134
00:06:23,383 --> 00:06:26,820
这是无抖动渲染的红色三角形

135
00:06:26,854 --> 00:06:30,123
亮白色的边缘代表三角形已渲染

136
00:06:30,757 --> 00:06:33,760
每个小正方形代表一个像素

137
00:06:33,794 --> 00:06:37,130
中间的灰点是像素采样处

138
00:06:38,999 --> 00:06:40,868
这是通过微小抖动

139
00:06:40,901 --> 00:06:43,270
渲染的同一个三角形

140
00:06:43,303 --> 00:06:46,573
灰点表示指定像素的采样位置

141
00:06:47,174 --> 00:06:50,377
抖动偏移对一组数量的帧来说是唯一的

142
00:06:50,410 --> 00:06:53,380
从而可以充分收集到所需数量的样本

143
00:06:54,147 --> 00:06:57,451
我稍后将会详细讲到
抖动序列的话题

144
00:06:58,685 --> 00:07:01,889
接下来是来自场景的运动信息

145
00:07:01,922 --> 00:07:03,824
来自场景的运动信息指的是

146
00:07:03,857 --> 00:07:05,559
对象从上一帧移动了多少

147
00:07:05,592 --> 00:07:09,096
从哪个方向移动

148
00:07:09,129 --> 00:07:12,566
时序抗锯齿和放大
通过回溯运动信息

149
00:07:12,599 --> 00:07:15,102
找到上一帧的对应位置

150
00:07:15,135 --> 00:07:17,437
从而正确收集采样

151
00:07:18,739 --> 00:07:21,842
另一个输入是来自场景的
深度信息

152
00:07:22,476 --> 00:07:23,744
通过场景的深度数据

153
00:07:23,777 --> 00:07:26,914
可以知道什么在前
什么在后

154
00:07:26,947 --> 00:07:30,217
这对于优先处理
前景边缘抗锯齿非常重要

155
00:07:30,651 --> 00:07:33,887
也可在上一帧收集采样时
提供相关线索

156
00:07:33,921 --> 00:07:37,257
提示有哪些其它对象可能是新出现的

157
00:07:37,291 --> 00:07:40,627
最后一个输入数据是
上一帧的输出

158
00:07:42,729 --> 00:07:45,365
上一帧的输出包括

159
00:07:45,399 --> 00:07:48,836
之前整合的所有采样

160
00:07:48,869 --> 00:07:52,139
这些与当前帧的抖动色彩输入相融合

161
00:07:52,172 --> 00:07:55,409
增加了每像素的采样数据

162
00:07:56,176 --> 00:07:59,513
通过结合当前帧和上一帧的信息

163
00:07:59,546 --> 00:08:02,649
生成的图像提供更多细节

164
00:08:02,683 --> 00:08:05,552
MetalFX 持续跟踪放大输出

165
00:08:05,586 --> 00:08:07,521
所以您只需传入当前渲染帧的

166
00:08:07,554 --> 00:08:10,490
色彩 动作和深度即可

167
00:08:11,191 --> 00:08:13,861
回到典型游戏的渲染管线

168
00:08:13,894 --> 00:08:16,697
MetalFX 时序抗锯齿和放大应在

169
00:08:16,730 --> 00:08:18,832
所有后期效果处理前运行

170
00:08:18,866 --> 00:08:20,834
因为这些效果将会

171
00:08:20,868 --> 00:08:23,103
干扰放大效果

172
00:08:24,371 --> 00:08:26,306
我们再来看这个象棋渲染

173
00:08:26,340 --> 00:08:29,810
这次用的是 MetalFX
时序抗锯齿和放大

174
00:08:29,843 --> 00:08:33,347
左边是 1080p 输入
右边是 4K 放大输出

175
00:08:34,248 --> 00:08:36,583
我们对两者并排比较

176
00:08:41,488 --> 00:08:44,258
放大看下皇后

177
00:08:44,291 --> 00:08:47,361
输入为低分辨率 带锯齿

178
00:08:47,394 --> 00:08:50,430
而右边的时序放大输出
为高分辨率

179
00:08:50,464 --> 00:08:53,934
边缘平滑 反射细节更精细

180
00:08:55,068 --> 00:08:58,372
如空间缩放器一样
创建新的时序缩放器

181
00:08:58,405 --> 00:09:00,440
成本高 只应在

182
00:09:00,474 --> 00:09:02,209
App 首次启动

183
00:09:02,242 --> 00:09:05,312
或改变显示分辨率时完成

184
00:09:05,345 --> 00:09:07,247
首先 您要分配及填写

185
00:09:07,281 --> 00:09:10,117
一个 MTLFXTemporalScalerDescriptor

186
00:09:10,851 --> 00:09:14,354
然后调用 makeTemporalScaler() 方法
来创建缩放器对象

187
00:09:15,656 --> 00:09:19,092
在初始化代码中
先从描述符开始

188
00:09:19,726 --> 00:09:23,230
填入输入和输出纹理的
宽度和高度

189
00:09:23,897 --> 00:09:25,632
然后为缩放器对象上

190
00:09:25,666 --> 00:09:27,501
稍后作为输入纹理的
抖动色彩 深度

191
00:09:27,534 --> 00:09:30,971
和动作纹理的设置格式

192
00:09:32,339 --> 00:09:35,042
最后 为 MetalFX
存储放大输出的

193
00:09:35,075 --> 00:09:38,378
输出纹理设置格式

194
00:09:38,412 --> 00:09:41,515
描述符填写好后
创建缩放器对象

195
00:09:42,482 --> 00:09:45,686
在缩放器对象中
设置动作缩放属性

196
00:09:45,719 --> 00:09:49,223
这可以帮助您按 API 期望的方式
缩放 App 的动作数据

197
00:09:50,057 --> 00:09:51,992
MetalFX 期望运动数据

198
00:09:52,025 --> 00:09:54,661
是在渲染分辨率像素空间

199
00:09:54,695 --> 00:09:57,497
提供从当前帧的位置

200
00:09:57,531 --> 00:09:59,733
到上一帧的位置

201
00:09:59,766 --> 00:10:01,034
作为示例

202
00:10:01,068 --> 00:10:03,637
我用了 1080p 的渲染分辨率

203
00:10:03,670 --> 00:10:06,707
假设有一个对象
从剪辑空间坐标

204
00:10:06,740 --> 00:10:09,243
(-0.75, -0.75) 开始

205
00:10:09,276 --> 00:10:12,346
移动到
剪辑空间坐标 (0.25, 0.25)

206
00:10:12,913 --> 00:10:15,582
动作数据存储为 (1, 1)

207
00:10:17,150 --> 00:10:19,119
设置运动矢量比例属性

208
00:10:19,152 --> 00:10:21,021
为 (-960, 540)

209
00:10:21,054 --> 00:10:24,358
这样 MetalFX 可以
正确分析您游戏的动作数据

210
00:10:26,660 --> 00:10:29,530
您可以随时修改

211
00:10:29,563 --> 00:10:30,464
缩放器对象的属性

212
00:10:30,497 --> 00:10:33,934
调用 encode() 方法
来开启放大过程

213
00:10:35,402 --> 00:10:37,304
在每帧绘图代码方面

214
00:10:37,337 --> 00:10:39,606
首先设置 resetHistory 属性

215
00:10:39,640 --> 00:10:42,476
当您的 App 加载第一帧
或场景切换时

216
00:10:42,509 --> 00:10:44,745
将数值设置为 true

217
00:10:44,778 --> 00:10:48,148
然后设置效果输入的纹理

218
00:10:48,182 --> 00:10:50,984
随后是输出纹理

219
00:10:51,018 --> 00:10:53,253
接下来 设置
reversedDepth 属性

220
00:10:53,287 --> 00:10:56,323
表明深度值
是否采用反向 Z 映射

221
00:10:57,558 --> 00:10:58,825
编码缩放器效果前

222
00:10:58,859 --> 00:11:02,062
最后一个要设置的属性
是当前的抖动补偿

223
00:11:03,263 --> 00:11:05,465
正确获取抖动补偿
对输出质量来说

224
00:11:05,499 --> 00:11:06,967
是很重要的

225
00:11:07,000 --> 00:11:10,103
我们来快速看下
如何设置抖动补偿

226
00:11:11,371 --> 00:11:14,775
在示例中 左边是
抖动渲染的三角形

227
00:11:16,376 --> 00:11:19,379
右边是像素的放大视图

228
00:11:19,413 --> 00:11:22,716
样本位于
(0.625, 0.78) 坐标

229
00:11:23,150 --> 00:11:26,153
橙色点的位置是像素中心

230
00:11:26,186 --> 00:11:28,889
位于坐标 (0.5, 0.5)

231
00:11:30,357 --> 00:11:31,425
在这个示例中

232
00:11:31,458 --> 00:11:34,895
抖动补偿是 (-0.125, -0.28)

233
00:11:35,796 --> 00:11:37,431
注意抖动补偿的范围

234
00:11:37,464 --> 00:11:40,634
通常是 -0.5 至 0.5

235
00:11:40,667 --> 00:11:43,670
要验证您提供的抖动补偿
是否正确

236
00:11:43,704 --> 00:11:46,340
用不同的抖动补偿序列
在没有镜头和对象动作的情况下

237
00:11:46,373 --> 00:11:49,343
渲染场景

238
00:11:49,376 --> 00:11:51,445
左边是设置了

239
00:11:51,478 --> 00:11:53,881
错误抖动补偿的示例

240
00:11:53,914 --> 00:11:57,050
静态对象会偏移 细线变得模糊

241
00:11:57,718 --> 00:11:59,453
右边是设置了

242
00:11:59,486 --> 00:12:01,688
正确抖动补偿的输出

243
00:12:01,722 --> 00:12:03,056
对象保持在正确位置

244
00:12:03,090 --> 00:12:05,626
细线逐步得以解析

245
00:12:05,659 --> 00:12:08,328
MetalFX 的时序抗锯齿和放大效果

246
00:12:08,362 --> 00:12:09,930
提高了您 App 的性能

247
00:12:09,963 --> 00:12:13,033
为您提供了可与原生目标分辨率渲染

248
00:12:13,066 --> 00:12:16,069
相比拟的放大质量

249
00:12:16,103 --> 00:12:18,672
当使用两种放大效果时

250
00:12:18,705 --> 00:12:20,607
为了获得最佳质量和性能

251
00:12:20,641 --> 00:12:24,011
我来为大家展示一些最佳实践

252
00:12:25,245 --> 00:12:28,081
首先是空间放大

253
00:12:28,115 --> 00:12:30,584
为了达到最佳空间放大质量

254
00:12:30,617 --> 00:12:33,754
色彩输入应为抗锯齿且无噪声

255
00:12:33,787 --> 00:12:35,289
因为噪声效果和锯齿图像

256
00:12:35,322 --> 00:12:38,325
影响边缘判定

257
00:12:38,358 --> 00:12:41,094
进而影响空间放大质量

258
00:12:41,929 --> 00:12:43,597
要达到最佳性能

259
00:12:43,630 --> 00:12:46,066
请使用视觉色彩处理模式

260
00:12:46,099 --> 00:12:48,702
这意味着您的输入色彩
应为经过色彩映射

261
00:12:48,735 --> 00:12:52,172
在 sRGB 色彩空间中
从 0 到 1 的数值

262
00:12:53,073 --> 00:12:56,043
最后 要为更高的纹理细节

263
00:12:56,076 --> 00:12:58,712
设置合适的负向 mip bias

264
00:12:58,745 --> 00:13:00,848
为空间放大

265
00:13:00,881 --> 00:13:03,450
推荐的 mip bias 计算方法为

266
00:13:03,483 --> 00:13:05,018
渲染分辨率宽度

267
00:13:05,052 --> 00:13:07,187
除以目标分辨率宽度
再取 log2

268
00:13:08,388 --> 00:13:11,525
比如 将每个渲染分辨率尺寸

269
00:13:11,558 --> 00:13:15,062
按 2x 缩放
结果是 -1 mip bias

270
00:13:15,095 --> 00:13:17,865
而如果按 1.5x 比例缩放

271
00:13:17,898 --> 00:13:20,801
结果是 -0.58 mip bias

272
00:13:21,602 --> 00:13:24,838
注意较低的 mip 等级
可能会导致高频图案的

273
00:13:24,872 --> 00:13:26,573
纹理闪烁

274
00:13:26,607 --> 00:13:28,876
如果看到这种失真现象 应调整

275
00:13:28,909 --> 00:13:31,378
特定纹理的 mip bias

276
00:13:31,411 --> 00:13:33,514
接下来 我为大家介绍下

277
00:13:33,547 --> 00:13:35,449
时序抗锯齿和放大的最佳实践

278
00:13:36,183 --> 00:13:39,486
时序抗锯齿和放大
要获得最高质量

279
00:13:39,520 --> 00:13:42,990
选择良好的抖动序列是很重要的

280
00:13:43,023 --> 00:13:44,324
要找到一个抖动序列

281
00:13:44,358 --> 00:13:46,560
可以为放大后目标分辨率中

282
00:13:46,593 --> 00:13:47,628
所有的像素

283
00:13:47,661 --> 00:13:50,230
都能提供良好的分布

284
00:13:50,264 --> 00:13:53,333
通常 每个输出像素
8 个抖动样本

285
00:13:53,367 --> 00:13:56,703
可生成高质量的
抗锯齿放大输出

286
00:13:57,671 --> 00:14:00,908
在 2x 缩放的案例中建议使用

287
00:14:00,941 --> 00:14:03,710
有 32 次抖动的 Halton (2,3) 序列

288
00:14:03,744 --> 00:14:06,513
生成抖动色彩输入

289
00:14:06,547 --> 00:14:09,483
这是 Halton (2,3) 序列中

290
00:14:09,516 --> 00:14:11,318
前 32 个样本位置

291
00:14:11,351 --> 00:14:14,521
每个输出像素大约生成
8 个样本

292
00:14:15,322 --> 00:14:18,525
设置合适的负向 mip bias
对更高纹理细节

293
00:14:18,559 --> 00:14:20,661
同样重要

294
00:14:20,694 --> 00:14:22,529
时序抗锯齿和放大的

295
00:14:22,563 --> 00:14:24,498
推荐 mip bias 计算方法为

296
00:14:24,531 --> 00:14:27,367
渲染分辨率宽度

297
00:14:27,401 --> 00:14:30,771
除以目标分辨率宽度 取 log2
再减去 1

298
00:14:31,538 --> 00:14:34,808
比如 每个渲染分辨率尺寸

299
00:14:34,842 --> 00:14:38,011
以 2x 比例缩放
结果是 -2 mip bias

300
00:14:38,045 --> 00:14:40,480
而每个尺寸

301
00:14:40,514 --> 00:14:43,483
以 1.5x 比例缩放
结果是 -1.58 mip bias

302
00:14:44,318 --> 00:14:47,487
接下来 我给大家演示下
mip bias 如何在不同情况下

303
00:14:47,521 --> 00:14:49,656
影响您的输出的示例

304
00:14:50,524 --> 00:14:52,659
这是同一个场景下

305
00:14:52,693 --> 00:14:54,461
MetalFX 时序抗锯齿和放大输出

306
00:14:54,494 --> 00:14:57,998
分别使用 0 -1 和 -2 的 mip bias

307
00:15:00,167 --> 00:15:01,869
-2 的 mip bias 可生成

308
00:15:01,902 --> 00:15:03,904
锐化度最高 最清晰的输出

309
00:15:03,937 --> 00:15:05,639
而 0 mip bias 生成

310
00:15:05,672 --> 00:15:08,175
最柔和 最模糊的输出

311
00:15:09,610 --> 00:15:11,712
这是使用时序放大效果的

312
00:15:11,745 --> 00:15:14,381
电路板的三种渲染

313
00:15:14,414 --> 00:15:16,984
从上到下 纹理采样时

314
00:15:17,017 --> 00:15:19,319
应用的 mip bias 数值分别是

315
00:15:19,353 --> 00:15:21,922
0 -1 -2

316
00:15:21,955 --> 00:15:25,359
因为电路板的纹理
有高频图案

317
00:15:25,392 --> 00:15:27,661
如微型跟踪电线

318
00:15:27,694 --> 00:15:30,264
-2 的 mip bias 会导致闪烁

319
00:15:30,297 --> 00:15:31,865
和波纹效果

320
00:15:31,899 --> 00:15:34,134
然而 -1 的 mip bias

321
00:15:34,168 --> 00:15:35,769
可极大减少这种效果

322
00:15:35,802 --> 00:15:38,705
0 mip bias 可完全抵消
该效果

323
00:15:39,673 --> 00:15:43,143
低 mip 水平
能带来更精细的细节

324
00:15:43,177 --> 00:15:45,913
使用我们的 mip bias 建议
作为初始点

325
00:15:45,946 --> 00:15:47,948
但为高频图案的纹理

326
00:15:47,981 --> 00:15:50,150
选择 mip bias 时要谨慎

327
00:15:50,184 --> 00:15:53,120
遵循这些方法就可以确保

328
00:15:53,153 --> 00:15:54,621
通过 MetalFX 时序抗锯齿和放大

329
00:15:54,655 --> 00:15:57,858
产生抗锯齿的高质量的放大输出

330
00:16:00,561 --> 00:16:02,863
最后 我再说下使用
MetalFX 放大以获得

331
00:16:02,896 --> 00:16:05,399
最佳性能的方法

332
00:16:05,432 --> 00:16:08,468
要通过 MetalFX 放大
获得最佳性能

333
00:16:08,502 --> 00:16:11,338
你应该注意避免
两个没有依赖关系的渲染器

334
00:16:11,371 --> 00:16:14,174
或计算通道

335
00:16:14,208 --> 00:16:16,043
绑定同样的资源产生读写

336
00:16:16,076 --> 00:16:18,879
这样会
造成错误依赖关系

337
00:16:18,912 --> 00:16:21,014
在 Metal 中应该尽量避免

338
00:16:21,048 --> 00:16:22,816
错误的依赖关系

339
00:16:22,850 --> 00:16:25,786
但这对 MetalFX 放大来说
尤为重要

340
00:16:25,819 --> 00:16:27,688
我稍后会进一步阐述

341
00:16:27,721 --> 00:16:30,424
在这个例子中 有两个帧

342
00:16:30,457 --> 00:16:33,794
阴影和后处理通道完全无关

343
00:16:33,827 --> 00:16:36,997
没有资源依赖

344
00:16:37,030 --> 00:16:39,666
Metal 会用当前帧的
后处理通道

345
00:16:39,700 --> 00:16:42,369
重叠下一帧的阴影通道

346
00:16:43,504 --> 00:16:45,906
然而 如果后处理通道
在阴影通道

347
00:16:45,939 --> 00:16:48,475
要读取 Metal 缓冲区时

348
00:16:48,509 --> 00:16:50,410
还在写入同一缓冲区

349
00:16:50,444 --> 00:16:53,347
Metal 会阻止这两个通道

350
00:16:53,380 --> 00:16:56,617
在 GPU 上并发运行
以此避免读取同时写入

351
00:16:56,650 --> 00:16:59,786
同一资源的潜在风险

352
00:16:59,820 --> 00:17:01,555
帧与帧之间的错误依赖关系

353
00:17:01,588 --> 00:17:03,223
对 MetalFX 的放大性能

354
00:17:03,257 --> 00:17:05,492
会带来负面影响

355
00:17:05,526 --> 00:17:07,160
如果帧与帧之间

356
00:17:07,194 --> 00:17:09,496
没有错误依赖关系

357
00:17:09,530 --> 00:17:11,965
下一帧的阴影通道可能会

358
00:17:11,999 --> 00:17:14,935
与上一帧的
MetalFX 放大重叠

359
00:17:14,968 --> 00:17:17,204
然而 由于帧与帧之间的

360
00:17:17,237 --> 00:17:18,272
错误依赖关系

361
00:17:18,305 --> 00:17:19,540
现在的性能下降了

362
00:17:19,573 --> 00:17:20,674
还包括了

363
00:17:20,707 --> 00:17:22,109
MetalFX 放大用于

364
00:17:22,142 --> 00:17:23,944
完成处理的时间

365
00:17:23,977 --> 00:17:25,479
理想情况上 您应该确保

366
00:17:25,512 --> 00:17:26,847
在帧与帧之间

367
00:17:26,880 --> 00:17:28,715
没有错误的依赖关系

368
00:17:28,749 --> 00:17:30,851
允许不同帧之间的任务可以重叠

369
00:17:30,884 --> 00:17:32,786
确保使用
MetalFX 放大时的

370
00:17:32,819 --> 00:17:35,822
最佳性能

371
00:17:35,856 --> 00:17:36,957
在这个示例中

372
00:17:36,990 --> 00:17:38,725
您可以为后期处理和阴影通道

373
00:17:38,759 --> 00:17:40,894
创建一个独立的缓冲区

374
00:17:40,928 --> 00:17:44,264
来阻止错误的依赖关系

375
00:17:44,298 --> 00:17:46,233
使得独立通道彼此可以

376
00:17:46,266 --> 00:17:48,435
并行执行

377
00:17:49,436 --> 00:17:52,306
避免错误依赖关系
是您在应用

378
00:17:52,339 --> 00:17:55,142
MetalFX 放大时
需要留意的

379
00:17:55,175 --> 00:17:57,978
在确定这两个效果之间
如何选择时

380
00:17:58,011 --> 00:18:01,215
有几个因素需要考虑

381
00:18:01,949 --> 00:18:05,152
对于不断增长的着色成本
和像素数量

382
00:18:05,185 --> 00:18:07,855
可以考虑
时序抗锯齿和放大

383
00:18:07,888 --> 00:18:11,058
按时序分期绘制像素
可以增加视觉保真

384
00:18:11,091 --> 00:18:12,993
并提高性能

385
00:18:13,026 --> 00:18:15,996
如果您还没有较好的
时序抗锯齿方案

386
00:18:16,029 --> 00:18:17,664
并且可以渲染抖动色彩

387
00:18:17,698 --> 00:18:19,933
位移和深度缓冲区

388
00:18:19,967 --> 00:18:22,336
MetalFX 时序抗锯齿和放大

389
00:18:22,369 --> 00:18:24,438
可为您提供

390
00:18:24,471 --> 00:18:26,206
强大的平台优化方案

391
00:18:26,240 --> 00:18:28,275
如果您没有所需的输入

392
00:18:28,308 --> 00:18:30,644
或者已经有了一个调整好的
抗锯齿方案

393
00:18:30,677 --> 00:18:34,114
可以考虑使用 MetalFX 空间放大

394
00:18:34,147 --> 00:18:36,917
希望您现在对选择
哪种放大效果

395
00:18:36,950 --> 00:18:39,219
有了较好的了解

396
00:18:39,253 --> 00:18:42,256
接下来我为大家演示下
Metal 应用程序中的

397
00:18:42,289 --> 00:18:44,658
实际运行效果

398
00:18:44,691 --> 00:18:47,361
这是我们 “Modern Rendering
with Metal” 代码中

399
00:18:47,394 --> 00:18:50,130
“Bistro” 场景的并排比较

400
00:18:50,163 --> 00:18:52,666
它提供多种实时渲染算法功能

401
00:18:52,699 --> 00:18:56,203
如环境光遮蔽和体积雾

402
00:18:56,236 --> 00:18:58,839
左边是 1080p 本地渲染

403
00:18:58,872 --> 00:19:00,140
右边是使用
MetalFX 空间放大的

404
00:19:00,174 --> 00:19:02,876
4K 输出

405
00:19:02,910 --> 00:19:06,246
这个示例有自己的
时序抗锯齿解决方案

406
00:19:06,280 --> 00:19:09,550
我们以此作为 MetalFX 空间放大的输入

407
00:19:10,584 --> 00:19:13,520
放大仔细看看这部摩托车

408
00:19:15,422 --> 00:19:18,692
左边的图像有点模糊 而右边

409
00:19:18,725 --> 00:19:20,894
空间放大输出

410
00:19:20,928 --> 00:19:23,697
图像锐化度更高
边缘更清晰

411
00:19:23,730 --> 00:19:26,967
车把的直线抗锯齿效果很好

412
00:19:28,268 --> 00:19:31,305
车身的曲线也比较平滑

413
00:19:32,239 --> 00:19:35,509
我们来对比下性能

414
00:19:35,542 --> 00:19:38,512
左边是 4K 的原生渲染

415
00:19:38,545 --> 00:19:40,547
右边是 MetalFX  空间放大的

416
00:19:40,581 --> 00:19:42,850
4K 输出

417
00:19:44,184 --> 00:19:46,954
随着镜头的移动
左边的原生渲染

418
00:19:46,987 --> 00:19:48,956
运行帧率有起伏

419
00:19:48,989 --> 00:19:50,891
而右边的空间放大输出

420
00:19:50,924 --> 00:19:53,060
则更为平滑

421
00:19:55,429 --> 00:19:57,531
接下来是光线跟踪场景的

422
00:19:57,564 --> 00:20:00,400
并排比较
有很多反射和阴影

423
00:20:01,235 --> 00:20:04,438
左边是 1080p 的原生渲染

424
00:20:04,471 --> 00:20:06,507
右边是 MetalFX 时序抗锯齿和放大的

425
00:20:06,540 --> 00:20:08,976
4K 输出

426
00:20:10,310 --> 00:20:13,347
放大仔细看看吊灯

427
00:20:14,448 --> 00:20:17,651
左边的原生输出有锯齿

428
00:20:17,684 --> 00:20:19,720
而右边的时序放大输出

429
00:20:19,753 --> 00:20:22,890
边缘锐化度更高 细节更精细

430
00:20:22,923 --> 00:20:26,393
阴影很清晰 不会模糊

431
00:20:26,426 --> 00:20:29,396
吊灯上的细节都能看清楚

432
00:20:32,266 --> 00:20:34,201
MetalFX 时序抗锯齿和放大下

433
00:20:34,234 --> 00:20:37,037
性能提升很明显

434
00:20:37,070 --> 00:20:40,007
左边是 4K 原生渲染

435
00:20:40,040 --> 00:20:41,909
右边是 MetalFX 时序抗锯齿和放大的

436
00:20:41,942 --> 00:20:44,978
4K 输出

437
00:20:45,012 --> 00:20:47,748
随着镜头的移动
左边的原生渲染

438
00:20:47,781 --> 00:20:49,983
运行帧率非常低

439
00:20:50,017 --> 00:20:51,585
而右边的时序放大输出

440
00:20:51,618 --> 00:20:53,654
则更平滑

441
00:21:06,967 --> 00:21:08,836
顶尖的游戏开发者们

442
00:21:08,869 --> 00:21:11,605
对 MetalFX 放大的实力
都很兴奋

443
00:21:11,638 --> 00:21:13,807
今年晚些时候将会带来

444
00:21:13,841 --> 00:21:15,576
“Grid: Legends”
“Resident Evil: Village”

445
00:21:15,609 --> 00:21:18,512
和 “No Man’s Sky”

446
00:21:18,545 --> 00:21:21,682
接下来 我为大家演示下
使用这一框架的初期作品

447
00:21:21,715 --> 00:21:24,718
[隆隆声和撞击声]

448
00:21:25,986 --> 00:21:28,689
在这个场景中 我们可以看到

449
00:21:28,722 --> 00:21:30,824
使用 MetalFX 时序抗锯齿和放大

450
00:21:30,858 --> 00:21:33,794
带来的叹为观止的视觉效果
和流畅的游戏体验

451
00:21:33,827 --> 00:21:34,795
[羊叫声]

452
00:21:34,828 --> 00:21:37,331
[引擎轰隆声]

453
00:21:41,301 --> 00:21:42,269
回顾下

454
00:21:42,302 --> 00:21:45,639
MetalFX 是专注于放大的全新 API

455
00:21:45,672 --> 00:21:47,841
空间放大应用简单

456
00:21:47,875 --> 00:21:50,043
可以带来明显的性能提升

457
00:21:50,077 --> 00:21:52,246
您也可以使用时序抗锯齿和放大

458
00:21:52,279 --> 00:21:54,715
获得高质量的渲染

459
00:21:54,748 --> 00:21:57,818
按照我之前跟您说的
最佳实践

460
00:21:57,851 --> 00:22:01,121
可以确保您充分利用
MetalFX 放大的功能

461
00:22:01,154 --> 00:22:02,656
感谢大家的观看

462
00:22:02,689 --> 00:22:06,193
[欢快的音乐]

