1
00:00:00,000 --> 00:00:03,036
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,036 --> 00:00:09,610
♪

3
00:00:09,610 --> 00:00:12,045
欢迎收看
“ SwiftUI 与 AppKit 组合使用方法”

4
00:00:12,045 --> 00:00:16,350
我是 Ian 是快捷指令的工程师

5
00:00:16,350 --> 00:00:20,120
在 macOS Monterey 中
上线了macOS版的快捷指令 App

6
00:00:20,120 --> 00:00:23,757
快捷指令 App 在 Mac 上
大量地采用 SwiftUI 来实现

7
00:00:23,757 --> 00:00:26,760
SwiftUI 有助于为平台定制体验

8
00:00:26,760 --> 00:00:28,862
同时在 iOS
和 watchOS 上

9
00:00:28,862 --> 00:00:31,398
与 App 共享常用视图

10
00:00:31,398 --> 00:00:33,333
本次视频 我将用

11
00:00:33,333 --> 00:00:36,703
快捷指令 App 的例子向大家展示

12
00:00:36,703 --> 00:00:40,707
在 Mac 的 App 中
采用 SwiftUI 的方法

13
00:00:40,707 --> 00:00:42,543
首先 我将向您展示

14
00:00:42,543 --> 00:00:45,512
如何在 App 中
托管 SwiftUI 视图

15
00:00:45,512 --> 00:00:47,447
然后为您讲解如何在 AppKit

16
00:00:47,447 --> 00:00:50,817
和 SwiftUI 之间传输数据

17
00:00:50,817 --> 00:00:53,086
还有如何在集合或表格视图的

18
00:00:53,086 --> 00:00:55,989
单元格中
引入 SwiftUI 视图

19
00:00:55,989 --> 00:00:58,926
当 SwiftUI 视图
嵌入到 AppKit 中时

20
00:00:58,926 --> 00:01:01,495
如何处理视图的布局和大小

21
00:01:01,495 --> 00:01:03,931
如何将您的
SwiftUI 视图加入到

22
00:01:03,931 --> 00:01:07,000
响应链中并获得焦点

23
00:01:07,000 --> 00:01:12,439
以及如何在 SwiftUI 中
引入 AppKit 视图

24
00:01:12,439 --> 00:01:16,877
好 我先从在 AppKit 中
引入 SwiftUI 开始

25
00:01:16,877 --> 00:01:18,579
在快捷指令 App 中

26
00:01:18,579 --> 00:01:23,150
主窗口包含一个
AppKit 分割视图控制器

27
00:01:23,150 --> 00:01:28,589
左边的侧边栏
是用 SwiftUI 编写的

28
00:01:28,589 --> 00:01:32,326
侧边栏视图
就是一个 SwiftUI 列表

29
00:01:32,326 --> 00:01:35,896
列表中显示的各行可以

30
00:01:35,896 --> 00:01:38,899
导航至相应条目

31
00:01:38,899 --> 00:01:42,302
视图通过被选中的绑定条目

32
00:01:42,302 --> 00:01:45,806
来追踪所选中的条目

33
00:01:45,806 --> 00:01:47,908
可能选中的条目

34
00:01:47,908 --> 00:01:53,113
在 SidebarItem 类型中
显示为案例

35
00:01:53,113 --> 00:01:56,850
在此情况下
由于已经有了一个分割视图控制器

36
00:01:56,850 --> 00:01:58,986
要引入该侧边栏视图

37
00:01:58,986 --> 00:02:03,891
我们要用 SwiftUI 中一个名为
NSHostingController 的类

38
00:02:03,891 --> 00:02:06,727
SwiftUI 侧边栏视图

39
00:02:06,727 --> 00:02:10,898
作为该主控制器的根视图被导入

40
00:02:10,898 --> 00:02:12,633
由于主控制器

41
00:02:12,633 --> 00:02:14,801
同任一视图控制器一样可被利用

42
00:02:14,801 --> 00:02:19,072
在这里 我们将其配置为
splitViewItem

43
00:02:19,072 --> 00:02:23,076
并添加到 splitViewController

44
00:02:23,076 --> 00:02:26,213
现在分屏浏览引入了侧边栏

45
00:02:26,213 --> 00:02:29,983
但要让其在选项变化时发挥作用

46
00:02:29,983 --> 00:02:35,522
分割视图的右侧需要显示不同的页面

47
00:02:35,522 --> 00:02:37,791
现在 所选条目状态

48
00:02:37,791 --> 00:02:40,527
仅存在于 SwiftUI 中

49
00:02:40,527 --> 00:02:43,864
我们需要将其移动到分屏浏览和

50
00:02:43,864 --> 00:02:47,234
侧边栏均可共享的位置

51
00:02:47,234 --> 00:02:50,704
最好的办法是创建一个可以存储在

52
00:02:50,704 --> 00:02:54,241
SwiftUI 之外的模型对象 并包含

53
00:02:54,241 --> 00:02:56,109
需要共享的状态

54
00:02:56,109 --> 00:02:59,479
我将这个对象称为 SelectionModel

55
00:02:59,479 --> 00:03:02,583
现在
侧边栏仍可在 SelectionModel 中

56
00:03:02,583 --> 00:03:05,285
保持读写状态

57
00:03:05,285 --> 00:03:08,989
在代码中
SelectionModel 是一个符合

58
00:03:08,989 --> 00:03:11,425
ObservableObject 的类

59
00:03:11,425 --> 00:03:15,195
作为可观察对象
当模型中存储的状态发生变化时

60
00:03:15,195 --> 00:03:18,799
SwiftUI 就会重新加载视图

61
00:03:18,799 --> 00:03:23,103
它还存储了当前选中的侧边栏条目

62
00:03:23,103 --> 00:03:27,241
发布此属性
可让 SwiftUI 侧边栏视图

63
00:03:27,241 --> 00:03:31,211
在所选条目更改时同步更新

64
00:03:31,211 --> 00:03:34,314
每次更改侧边栏中的选项时

65
00:03:34,314 --> 00:03:39,119
该模型就可在细节视图中显示新页面

66
00:03:39,119 --> 00:03:42,856
介绍完在 AppKit 中
引入 SwiftUI 的方法

67
00:03:42,856 --> 00:03:46,760
接下来看集合和表格单元格

68
00:03:46,760 --> 00:03:50,731
将快捷指令 App
从其他平台带到 macOS 时

69
00:03:50,731 --> 00:03:53,600
就有一个标志性的
SwiftUI 视图

70
00:03:53,600 --> 00:03:57,137
可在集合视图单元格
或主屏幕小组件中

71
00:03:57,137 --> 00:04:00,007
显示快捷方式

72
00:04:00,007 --> 00:04:03,777
在 macOS 上
这些相同的视图显示在

73
00:04:03,777 --> 00:04:06,880
NSCollectionView 的单元格中

74
00:04:06,880 --> 00:04:10,317
在包含大量条目的集合或表格视图中

75
00:04:10,317 --> 00:04:13,654
随着滚动
每个单元格视图都会被回收

76
00:04:13,654 --> 00:04:17,024
显示不同的内容

77
00:04:17,024 --> 00:04:20,027
为保证单元重用良好运作

78
00:04:20,027 --> 00:04:22,763
您要避免在用户滚动时

79
00:04:22,763 --> 00:04:26,800
从单元格中添加和删除子视图

80
00:04:26,800 --> 00:04:29,803
在每个单元格中
显示 SwiftUI 视图时

81
00:04:29,803 --> 00:04:32,539
要使用单个托管视图 并在

82
00:04:32,539 --> 00:04:35,542
单元格内容需要改变时

83
00:04:35,542 --> 00:04:37,778
用不同的根视图更新

84
00:04:37,778 --> 00:04:40,280
您需用以下方法构建集合视图单元

85
00:04:40,280 --> 00:04:42,249
以托管 SwiftUI

86
00:04:42,249 --> 00:04:43,684
在这个例子中

87
00:04:43,684 --> 00:04:47,688
我正在构建
显示快捷指令视图的单元格

88
00:04:47,688 --> 00:04:52,359
每个单元格都包含一个
NSHostingView 来托管 SwiftUI

89
00:04:52,359 --> 00:04:54,094
由于单元格创建于

90
00:04:54,094 --> 00:04:56,663
添加任何内容之前

91
00:04:56,663 --> 00:04:58,565
所以要从零开始

92
00:04:58,565 --> 00:05:00,300
并在第一次准备

93
00:05:00,300 --> 00:05:03,504
显示快捷指令时设置

94
00:05:03,504 --> 00:05:06,773
displayShortcut 方法在配置单元格

95
00:05:06,773 --> 00:05:10,344
以显示快捷方式时被数据源调用

96
00:05:10,344 --> 00:05:14,615
该方法创建了一个
SwiftUI ShortcutView

97
00:05:14,615 --> 00:05:17,551
那么 如果已经
有一个 hostingView

98
00:05:17,551 --> 00:05:21,989
其 rootView 就要
设置为新视图

99
00:05:21,989 --> 00:05:24,291
否则 如果是第一次显示快捷指令

100
00:05:24,291 --> 00:05:26,927
就会创建一个
newHostingView

101
00:05:26,927 --> 00:05:30,264
作为单元格的子视图添加其中

102
00:05:30,264 --> 00:05:34,001
以下是一个主
SwiftUI 单元格的生命周期

103
00:05:34,001 --> 00:05:38,772
首先 单元格被初始化 没有子视图

104
00:05:38,772 --> 00:05:41,909
因为此时还未显示快捷方式

105
00:05:41,909 --> 00:05:44,711
第一次调用 displayShortcut 时

106
00:05:44,711 --> 00:05:49,683
hostingView 就被创建
shortcutView 也显示出来

107
00:05:49,683 --> 00:05:52,319
这会创建一个
SwiftUI 视图层次结构

108
00:05:52,319 --> 00:05:59,993
包含一个 Vstack 视图 一个图像视图
一个空格视图和两个文本视图

109
00:05:59,993 --> 00:06:02,896
如果该单元格滚动到屏幕外

110
00:06:02,896 --> 00:06:05,566
就可能会被系统从伫列中移除

111
00:06:05,566 --> 00:06:08,268
并且需要显示不同的快捷指令

112
00:06:08,268 --> 00:06:12,072
发生这种情况时
一个新的 ShortcutView 会被创建

113
00:06:12,072 --> 00:06:15,042
并提供给 HostingView

114
00:06:15,042 --> 00:06:17,511
由于 HostingView
已经显示出

115
00:06:17,511 --> 00:06:19,313
不同的快捷指令视图

116
00:06:19,313 --> 00:06:22,549
它将重用视图的整体结构

117
00:06:22,549 --> 00:06:25,385
包括 VStack 和空格视图

118
00:06:25,385 --> 00:06:30,791
并且只更新变化了的
图像 文本和背景视图

119
00:06:30,791 --> 00:06:35,596
好 接下来
我们讨论一下布局和尺寸

120
00:06:35,596 --> 00:06:37,798
主控制器和主视图的

121
00:06:37,798 --> 00:06:39,900
固定尺寸

122
00:06:39,900 --> 00:06:43,604
基于 SwiftUI 视图的
理想宽度和高度

123
00:06:43,604 --> 00:06:46,273
SwiftUI 会自动创建和更新

124
00:06:46,273 --> 00:06:49,843
Auto Layout
约束 AppKit 布局系统

125
00:06:49,843 --> 00:06:53,313
会用其适当调整视图大小

126
00:06:53,313 --> 00:06:56,350
视图也很灵活 这意味着它们支持

127
00:06:56,350 --> 00:07:00,854
各种尺寸 可从小到大变化

128
00:07:00,854 --> 00:07:05,359
SwiftUI 也为以下这些
创建约束

129
00:07:05,359 --> 00:07:08,762
在层次结构中
嵌入 SwiftUI 主视图时

130
00:07:08,762 --> 00:07:11,865
您要将自己的
Auto Layout 约束

131
00:07:11,865 --> 00:07:15,936
应用到超级视图或其他相邻视图

132
00:07:15,936 --> 00:07:19,506
使用框架修饰符
或其他 SwiftUI 布局

133
00:07:19,506 --> 00:07:23,377
将更新所创建的约束

134
00:07:23,377 --> 00:07:28,215
例如将宽度覆盖为固定大小

135
00:07:28,215 --> 00:07:31,185
由于用户可以调整窗口大小

136
00:07:31,185 --> 00:07:35,088
窗口则可以最小化和最大化

137
00:07:35,088 --> 00:07:36,723
在设置 HostingViews

138
00:07:36,723 --> 00:07:39,793
为一个窗口的顶层
contentView 时

139
00:07:39,793 --> 00:07:43,096
SwiftUI
将基于显示内容自动更新

140
00:07:43,096 --> 00:07:47,401
该窗口的最小和最大尺寸

141
00:07:47,401 --> 00:07:49,670
这让窗口可按垂直或水平方向

142
00:07:49,670 --> 00:07:52,673
调整大小 也可两者都做调整

143
00:07:52,673 --> 00:07:55,275
取决于显示内容

144
00:07:55,275 --> 00:07:58,412
放置在托管控制器中的
SwiftUI 视图

145
00:07:58,412 --> 00:08:02,349
在以模态形式呈现时
也会根据内容调整大小

146
00:08:02,349 --> 00:08:05,586
例如 您可以
轻松将 SwiftUI 视图

147
00:08:05,586 --> 00:08:07,521
放在 AppKit 弹出框中

148
00:08:07,521 --> 00:08:09,556
用 NSViewController 上的

149
00:08:09,556 --> 00:08:13,260
popover presentation API 呈现托管控制器

150
00:08:13,260 --> 00:08:15,262
如此处所示

151
00:08:15,262 --> 00:08:18,031
您还可以将 SwiftUI 视图
呈现为工作表

152
00:08:18,031 --> 00:08:20,968
用 presentAsSheet 方法即可实现

153
00:08:20,968 --> 00:08:23,570
最后 对于模态窗口

154
00:08:23,570 --> 00:08:26,607
您可以使用
presentAsModalWindow 方法

155
00:08:26,607 --> 00:08:30,777
呈现一个阻止交互的窗口
关闭窗口即可结束阻止

156
00:08:30,777 --> 00:08:34,615
窗口的大小会根据内容调整

157
00:08:34,615 --> 00:08:37,551
macOS Ventura 中
NSHostingView

158
00:08:37,551 --> 00:08:40,721
和 NSHostingController 上
新增了 API

159
00:08:40,721 --> 00:08:42,923
可允许您自定义

160
00:08:42,923 --> 00:08:45,459
自动添加的约束

161
00:08:45,459 --> 00:08:47,961
默认情况下 托管控制器和视图

162
00:08:47,961 --> 00:08:50,497
会为最小尺寸 固定尺寸

163
00:08:50,497 --> 00:08:53,867
和最大尺寸创建约束

164
00:08:53,867 --> 00:08:56,904
出于性能原因
您可能希望禁用其中一些约束

165
00:08:56,904 --> 00:09:00,174
比如您希望视图始终具有灵活尺寸

166
00:09:00,174 --> 00:09:02,209
或者您已
为 AppKit 中的周围视图

167
00:09:02,209 --> 00:09:05,345
添加了约束

168
00:09:05,345 --> 00:09:06,747
对于托管控制器

169
00:09:06,747 --> 00:09:08,682
为让视图的理想尺寸

170
00:09:08,682 --> 00:09:11,618
确定首选的内容尺寸

171
00:09:11,618 --> 00:09:15,622
您可启用
preferredContentSize 选项

172
00:09:15,622 --> 00:09:18,825
当您开始在 App 中
添加 SwiftUI 视图时

173
00:09:18,825 --> 00:09:21,595
该视图像您 App 中的
其他视图一样

174
00:09:21,595 --> 00:09:26,200
参与响应链和
焦点系统就显得非常重要

175
00:09:26,200 --> 00:09:29,303
在快捷指令中 我们的编辑器以

176
00:09:29,303 --> 00:09:32,039
SwiftUI 视图实现

177
00:09:32,039 --> 00:09:35,008
但是编辑器需要处理主菜单中定义的

178
00:09:35,008 --> 00:09:40,013
菜单栏命令
这也是在 AppKit 中实现

179
00:09:40,013 --> 00:09:45,085
该命令包括剪切 复制 粘贴等

180
00:09:45,085 --> 00:09:49,089
我们还实现了
我们自己的自定义菜单项

181
00:09:49,089 --> 00:09:52,526
用于上下移动操作

182
00:09:52,526 --> 00:09:56,230
在 AppKit 中
您的视图层次结构组成了一个

183
00:09:56,230 --> 00:09:58,899
称为“响应者链”的视图链

184
00:09:58,899 --> 00:10:02,903
焦点响应者称为第一响应者

185
00:10:02,903 --> 00:10:04,838
选择菜单项时

186
00:10:04,838 --> 00:10:08,709
该条目的选择器
会被发送至第一响应者

187
00:10:08,709 --> 00:10:10,210
但若第一响应者

188
00:10:10,210 --> 00:10:12,145
未响应该选择器

189
00:10:12,145 --> 00:10:15,215
那选择器就会被
依次发送至下一个响应者

190
00:10:15,215 --> 00:10:17,651
直到选择器被响应

191
00:10:17,651 --> 00:10:20,654
或者到达 App

192
00:10:20,654 --> 00:10:23,790
SwiftUI 中
相当于第一响应者的

193
00:10:23,790 --> 00:10:26,994
是焦点视图

194
00:10:26,994 --> 00:10:31,098
可聚焦的 SwiftUI 视图
可以响应键盘输入

195
00:10:31,098 --> 00:10:35,602
并处理发送至响应链的选择器

196
00:10:35,602 --> 00:10:40,207
像文本字段
这样的视图已经可以获得焦点

197
00:10:40,207 --> 00:10:42,910
但您可以使用可聚焦修饰符

198
00:10:42,910 --> 00:10:46,313
让其他视图也获得焦点

199
00:10:46,313 --> 00:10:50,017
SwiftUI
有处理常用命令的修饰符

200
00:10:50,017 --> 00:10:52,886
例如复制 剪切和粘贴等

201
00:10:52,886 --> 00:10:55,556
这些修饰符可将值传入 传出粘贴板

202
00:10:55,556 --> 00:10:58,392
是用户从您的 App
传入传出数据的

203
00:10:58,392 --> 00:11:00,994
简便方法

204
00:11:00,994 --> 00:11:03,764
快捷指令编辑器
利用 onMoveCommand

205
00:11:03,764 --> 00:11:07,334
和 onExit 命令修饰符
来处理方向键

206
00:11:07,334 --> 00:11:09,603
和返回键

207
00:11:09,603 --> 00:11:12,272
onCommand 修饰符
可用于处理

208
00:11:12,272 --> 00:11:14,675
AppKit
和您的 App 定义的

209
00:11:14,675 --> 00:11:17,845
自定义选择器中的任一常见选择器

210
00:11:17,845 --> 00:11:21,748
在此 我们可处理来自
AppKit 的 selectAll 命令

211
00:11:21,748 --> 00:11:25,686
以及在快捷方式 App 中
定义的 moveActionUp

212
00:11:25,686 --> 00:11:28,856
和 moveActionDown 命令

213
00:11:28,856 --> 00:11:32,092
在您的 App 中
测试焦点和键盘可导航性时

214
00:11:32,092 --> 00:11:34,628
一定要确保打开键盘系统设置

215
00:11:34,628 --> 00:11:36,897
并在全键盘导航开启和关闭的情况下

216
00:11:36,897 --> 00:11:39,633
进行测试

217
00:11:39,633 --> 00:11:44,371
因为许多控件仅在启用时才可聚焦

218
00:11:44,371 --> 00:11:46,006
还有很多方法可以

219
00:11:46,006 --> 00:11:48,775
让您的 App 与键盘完美配合

220
00:11:48,775 --> 00:11:52,579
比如
FocusState 等 API

221
00:11:52,579 --> 00:11:54,314
以及能让您用编程更改

222
00:11:54,314 --> 00:11:58,218
需要聚焦的视图的焦点修饰符

223
00:11:58,218 --> 00:12:01,054
要了解有关焦点和键盘的更多信息

224
00:12:01,054 --> 00:12:02,222
您可以观看

225
00:12:02,222 --> 00:12:06,326
“在 SwiftUI 中
直接和间接获取焦点”视频

226
00:12:06,326 --> 00:12:11,932
最后 我们来讨论在
SwiftUI 中托管 AppKit 视图的方法

227
00:12:11,932 --> 00:12:13,267
在某些情况下

228
00:12:13,267 --> 00:12:15,602
“快捷指令”
会在 SwiftUI 布局内

229
00:12:15,602 --> 00:12:17,971
托管 AppKit 视图

230
00:12:17,971 --> 00:12:20,641
当您在 App 中
采用 SwiftUI 时

231
00:12:20,641 --> 00:12:24,244
也可能需要
托管 AppKit 视图

232
00:12:24,244 --> 00:12:29,483
其中一种情况是在
SwiftUI 快捷指令编辑器内部

233
00:12:29,483 --> 00:12:32,052
其中有一个嵌入式
AppleScript 编辑器视图

234
00:12:32,052 --> 00:12:33,921
由一个 AppKit 控件

235
00:12:33,921 --> 00:12:37,624
和 macOS 上
其他一些系统 App 共享

236
00:12:37,624 --> 00:12:40,694
SwiftUI 提供了两种
representable 协议

237
00:12:40,694 --> 00:12:43,363
允许 AppKit 视图
和视图控制器

238
00:12:43,363 --> 00:12:48,402
嵌入到 SwiftUI
视图层次结构中

239
00:12:48,402 --> 00:12:50,337
与 SwiftUI 视图一样

240
00:12:50,337 --> 00:12:54,007
Representable 协议
描述了 AppKit 视图

241
00:12:54,007 --> 00:12:57,311
创建和更新的方式

242
00:12:57,311 --> 00:13:01,481
由于 AppKit 中的
许多类都有委托 观察者

243
00:13:01,481 --> 00:13:06,053
或依赖 KVO 或通知来观察

244
00:13:06,053 --> 00:13:09,823
协议还包括一个可选的协调器对象

245
00:13:09,823 --> 00:13:12,326
您可利用其配合您的视图

246
00:13:12,326 --> 00:13:15,662
或视图控制器

247
00:13:15,662 --> 00:13:18,232
这是托管对象的生命周期

248
00:13:18,232 --> 00:13:20,267
及其协调器

249
00:13:20,267 --> 00:13:23,604
我们从初始化托管视图开始

250
00:13:23,604 --> 00:13:26,139
当视图即将首次显示时

251
00:13:26,139 --> 00:13:28,609
会发生以下情况

252
00:13:28,609 --> 00:13:31,645
SwiftUI 在初始化期间
做的第一件事

253
00:13:31,645 --> 00:13:33,447
就是创建协调器

254
00:13:33,447 --> 00:13:35,949
这可自行选择
但您可以定义自己的类型

255
00:13:35,949 --> 00:13:37,951
并从 makeCoordinator 返回

256
00:13:37,951 --> 00:13:41,822
如果您需要它来
进行委派或状态管理的话

257
00:13:41,822 --> 00:13:43,690
协调器的单个实例

258
00:13:43,690 --> 00:13:47,594
将在视图的生命周期内一直存在

259
00:13:47,594 --> 00:13:50,330
其次 makeNSView 和

260
00:13:50,330 --> 00:13:53,967
makeNSViewController
方法会有一个被调用

261
00:13:53,967 --> 00:13:56,203
这是您向 SwiftUI 描述

262
00:13:56,203 --> 00:14:00,407
如何创建视图新实例的地方

263
00:14:00,407 --> 00:14:03,810
上下文包含了刚刚创建的协调器

264
00:14:03,810 --> 00:14:07,447
如果有的话
这里就可将协调器分配为

265
00:14:07,447 --> 00:14:13,387
视图的委托或其他类型的观察者

266
00:14:13,387 --> 00:14:15,355
创建视图后

267
00:14:15,355 --> 00:14:17,491
每当 SwiftUI 状态或

268
00:14:17,491 --> 00:14:22,129
环境发生变化时
就会调用更新视图方法

269
00:14:22,129 --> 00:14:25,966
在这里 您有义务更新
存储在 AppKit 视图中的

270
00:14:25,966 --> 00:14:28,836
任何属性或状态

271
00:14:28,836 --> 00:14:31,638
使其与周围的
SwiftUI 状态和环境

272
00:14:31,638 --> 00:14:33,473
保持同步

273
00:14:33,473 --> 00:14:35,843
更新方法可经常被调用

274
00:14:35,843 --> 00:14:38,011
所以您对视图应尽可能

275
00:14:38,011 --> 00:14:40,747
少做更改

276
00:14:40,747 --> 00:14:42,749
在进行更改时

277
00:14:42,749 --> 00:14:45,185
您应检查所做的更改

278
00:14:45,185 --> 00:14:47,855
只重新加载视图受影响的部分

279
00:14:47,855 --> 00:14:50,691
当 SwiftUI
完成显示托管视图时

280
00:14:50,691 --> 00:14:53,093
就会被清除

281
00:14:53,093 --> 00:14:57,297
托管视图和协调器都将被释放

282
00:14:57,297 --> 00:15:00,634
而被释放之前
representable 协议

283
00:15:00,634 --> 00:15:02,836
会给您提供选择来操作

284
00:15:02,836 --> 00:15:06,106
如果需要 您可在其中清理状态

285
00:15:06,106 --> 00:15:08,675
好了 现在您了解了生命周期

286
00:15:08,675 --> 00:15:12,112
也熟悉了
representable 协议

287
00:15:12,112 --> 00:15:14,381
我来向您展示
“快捷指令”在 App 中

288
00:15:14,381 --> 00:15:18,118
托管自定义脚本编辑器视图的方法

289
00:15:18,118 --> 00:15:22,990
脚本编辑器是一个名为
ScriptEditorView 的 NSView

290
00:15:22,990 --> 00:15:25,659
编辑器中编写的代码可被访问

291
00:15:25,659 --> 00:15:28,662
并可通过 sourceCode
属性进行修改

292
00:15:28,662 --> 00:15:30,364
且视图可被禁用

293
00:15:30,364 --> 00:15:33,000
以防止进行更改

294
00:15:33,000 --> 00:15:35,736
脚本编辑器还有一个委托

295
00:15:35,736 --> 00:15:38,372
每当有人更改源代码时都会

296
00:15:38,372 --> 00:15:40,774
收到通知

297
00:15:40,774 --> 00:15:42,976
托管 AppKit 视图时

298
00:15:42,976 --> 00:15:46,613
首先思考一下
视图在 SwiftUI 中的位置

299
00:15:46,613 --> 00:15:50,450
以及需要传入和传出的数据

300
00:15:50,450 --> 00:15:54,154
在快捷指令中
该视图被放到编译按钮旁边的

301
00:15:54,154 --> 00:15:57,291
一个容器视图中

302
00:15:57,291 --> 00:16:00,761
编译按钮的处理程序需要访问

303
00:16:00,761 --> 00:16:03,597
输入到视图中的源代码

304
00:16:03,597 --> 00:16:05,999
源代码用 State 属性包装器

305
00:16:05,999 --> 00:16:08,502
存储在 SwiftUI 中

306
00:16:08,502 --> 00:16:10,437
representable 协议
需要阅读

307
00:16:10,437 --> 00:16:13,407
并写入此状态

308
00:16:13,407 --> 00:16:15,108
为了构建
representable 协议

309
00:16:15,108 --> 00:16:19,213
首先要创建一个符合
NSViewRepresentable 的类型

310
00:16:19,213 --> 00:16:22,916
因为它要托管一个 NSView

311
00:16:22,916 --> 00:16:26,353
为每个需要从
SwiftUI 中配置的事物

312
00:16:26,353 --> 00:16:28,155
添加属性

313
00:16:28,155 --> 00:16:31,058
对于绑定源代码

314
00:16:31,058 --> 00:16:36,129
这会读取和写入
存储在 SwiftUI 中的状态

315
00:16:36,129 --> 00:16:40,167
您需要操作的第一个方法
是 makeNSView

316
00:16:40,167 --> 00:16:41,468
这是您描述

317
00:16:41,468 --> 00:16:44,004
创建视图新实例

318
00:16:44,004 --> 00:16:47,975
以及进行一次性设置的地方

319
00:16:47,975 --> 00:16:51,144
在此 委托被设置为协调器

320
00:16:51,144 --> 00:16:55,249
稍后我将进一步介绍协调器

321
00:16:55,249 --> 00:16:58,552
接下来
操作 updateNSView

322
00:16:58,552 --> 00:17:01,221
这会在源代码更改时

323
00:17:01,221 --> 00:17:05,092
或在 SwiftUI 环境
发生变化时调用

324
00:17:05,092 --> 00:17:07,628
由于脚本编辑器在设置

325
00:17:07,628 --> 00:17:09,830
sourceCode 属性时
做了很多工作

326
00:17:09,830 --> 00:17:12,199
所以我们只比较视图中已经存在的值

327
00:17:12,199 --> 00:17:15,035
并且仅在更改时设置属性

328
00:17:15,035 --> 00:17:17,938
以避免不必要的工作

329
00:17:17,938 --> 00:17:20,908
传递给 updateNSView
的上下文

330
00:17:20,908 --> 00:17:23,544
包含 SwiftUI 环境

331
00:17:23,544 --> 00:17:25,746
isEnabled 环境键

332
00:17:25,746 --> 00:17:30,017
会被传递给
脚本编辑器上的 isEditable 属性

333
00:17:30,017 --> 00:17:31,718
因此若
SwiftUI 视图层次结构的

334
00:17:31,718 --> 00:17:35,689
其余部分被禁用 编辑也会被禁用

335
00:17:35,689 --> 00:17:39,193
每当有人修改视图中的源代码时

336
00:17:39,193 --> 00:17:42,829
源代码绑定就需要捕获新值

337
00:17:42,829 --> 00:17:44,932
为此 我们将构建一个

338
00:17:44,932 --> 00:17:49,269
符合 ScriptEditorViewDelegate 的协调器

339
00:17:49,269 --> 00:17:52,206
协调器将存储
representable 值

340
00:17:52,206 --> 00:17:56,243
包含需要更新的源代码绑定

341
00:17:56,243 --> 00:17:59,179
在 sourceCodeDidChange 方法中

342
00:17:59,179 --> 00:18:01,515
绑定被设置为来自视图的

343
00:18:01,515 --> 00:18:04,318
新字符串值

344
00:18:04,318 --> 00:18:07,554
最后 我们要告知
SwiftUI representable

345
00:18:07,554 --> 00:18:10,490
构建和更新协调器的方法

346
00:18:10,490 --> 00:18:14,094
首先 您需要使用
makeCoordinator 方法

347
00:18:14,094 --> 00:18:17,297
构建一个新协调器

348
00:18:17,297 --> 00:18:21,068
协调器与托管视图
具有相同的生命周期

349
00:18:21,068 --> 00:18:23,203
和托管视图一样

350
00:18:23,203 --> 00:18:25,305
添加到协调器的属性

351
00:18:25,305 --> 00:18:29,376
随着 representable 的
变化更新

352
00:18:29,376 --> 00:18:31,545
当存储在
representable 的值

353
00:18:31,545 --> 00:18:34,948
发生变化时 由于
updateNSView 被调用

354
00:18:34,948 --> 00:18:40,320
在这里 协调器上的
representable 属性就被更新

355
00:18:40,320 --> 00:18:43,624
现在您已了解将 AppKit
添加到 SwiftUI

356
00:18:43,624 --> 00:18:46,727
以及将 SwiftUI 添加到
AppKit 中的方法

357
00:18:46,727 --> 00:18:50,397
您就可以将 SwiftUI
集成到 App 中了

358
00:18:50,397 --> 00:18:52,766
从侧边栏或表格
和集合视图单元格开始

359
00:18:52,766 --> 00:18:55,536
将会是不错的选择

360
00:18:55,536 --> 00:18:58,071
可以确保您的视图尺寸合适

361
00:18:58,071 --> 00:19:01,508
能正常处理常见命令和焦点

362
00:19:01,508 --> 00:19:02,509
感谢收看

363
00:19:02,509 --> 00:19:05,045
期待您的成果

364
00:19:05,045 --> 00:19:08,982
♪

