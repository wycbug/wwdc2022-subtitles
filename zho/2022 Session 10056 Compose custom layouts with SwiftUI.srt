1
00:00:00,501 --> 00:00:08,509
♪ ♪

2
00:00:09,843 --> 00:00:13,514
Paul: 大家好 欢迎收看
使用 SwiftUI 编写自定义布局

3
00:00:13,547 --> 00:00:16,183
我是 Paul  负责开发者文档

4
00:00:16,216 --> 00:00:18,919
SwiftUI 提供了一组丰富的构建模块

5
00:00:18,952 --> 00:00:22,489
你可以使用它们来搭建
你的 App 界面

6
00:00:22,523 --> 00:00:27,761
你们可以组合显示文本 图像
和图形等元素的

7
00:00:27,794 --> 00:00:31,932
内置视图
以创建自定义的复合视图

8
00:00:31,965 --> 00:00:35,769
SwiftUI 提供了布局工具
来将所有元素

9
00:00:35,802 --> 00:00:37,804
进行更复杂的分组

10
00:00:39,139 --> 00:00:42,709
像水平和垂直叠放之类的容器

11
00:00:42,743 --> 00:00:45,112
让你告诉 SwiftUI 放置视图的
相对位置

12
00:00:45,145 --> 00:00:47,581
而视图修饰器可以让你们
对间距和对齐

13
00:00:47,614 --> 00:00:50,484
等内容进行额外的控制

14
00:00:51,218 --> 00:00:53,487
在本次讲座中
我将介绍一些新工具

15
00:00:53,520 --> 00:00:56,590
它们会使一些常见的布局
更容易构建

16
00:00:56,623 --> 00:00:59,560
并且复杂的布局也能实现

17
00:00:59,593 --> 00:01:04,364
在此过程中 我会介绍一些在
SwiftUI 中使用布局的技巧

18
00:01:04,398 --> 00:01:06,967
首先 我将向你们展示
网格家族中的一个新成员

19
00:01:07,000 --> 00:01:09,269
当你们需要展示一组静态视图时

20
00:01:09,303 --> 00:01:12,372
它就非常适合二维布局

21
00:01:12,406 --> 00:01:16,176
接下来我将讨论如何使用
新的布局协议

22
00:01:16,210 --> 00:01:18,979
创建自定义视图容器类型

23
00:01:19,012 --> 00:01:21,949
直接与布局引擎交互

24
00:01:21,982 --> 00:01:24,318
然后我会讲到 ViewThatFits

25
00:01:24,351 --> 00:01:27,621
这是一种容器类型
它自动从视图集合中

26
00:01:27,654 --> 00:01:31,792
选择适合可用空间的视图

27
00:01:31,825 --> 00:01:34,862
最后 我将向你展示
如何使用 AnyLayout

28
00:01:34,895 --> 00:01:38,232
在布局类型之间添加无缝过渡

29
00:01:38,265 --> 00:01:40,334
要查看所有这些新功能的实际效果

30
00:01:40,367 --> 00:01:42,703
我们来看看
我一直在开发的一款 App

31
00:01:44,204 --> 00:01:45,906
近年来 我的一些同事

32
00:01:45,939 --> 00:01:50,410
总是在争论什么是最好的宠物伙伴

33
00:01:50,444 --> 00:01:54,781
我有自己的看法
但我很好奇大家能否达成共识

34
00:01:54,815 --> 00:01:58,452
所以我决定做一个 App 来进行投票

35
00:01:58,485 --> 00:02:00,754
我还想让对皮毛过敏的人也加入

36
00:02:00,787 --> 00:02:03,357
所以我额外加了一个选项

37
00:02:03,390 --> 00:02:07,160
现在 我喜欢用 SwiftUI
做大部分的界面设计

38
00:02:07,194 --> 00:02:09,997
因为使用预览制作原型非常容易

39
00:02:10,030 --> 00:02:14,334
但作为起点 我画了一个
目标设计界面的速写

40
00:02:14,368 --> 00:02:16,737
我预计投票会持续一段时间

41
00:02:16,770 --> 00:02:20,774
所以我想要一个
显示当前排名的排行榜

42
00:02:20,807 --> 00:02:22,676
我会把投票按钮放在底部

43
00:02:22,709 --> 00:02:26,647
而在顶部 我将展示一些
大家投票的图片

44
00:02:28,482 --> 00:02:30,751
好 我要做的第一件事是
搭建排行榜

45
00:02:30,784 --> 00:02:33,554
我们来仔细看看

46
00:02:33,587 --> 00:02:38,559
排行榜是一个二维元素网格
每个参选者都有

47
00:02:38,592 --> 00:02:43,197
列显示名称 百分比和选票计数

48
00:02:43,230 --> 00:02:47,367
在这里 我想实现几个具体的目标

49
00:02:47,401 --> 00:02:51,104
首先 我希望两个文本的列宽
尽可能的压缩

50
00:02:51,138 --> 00:02:54,074
仅需在各种情况下
容纳最宽单元格即可

51
00:02:54,107 --> 00:02:56,610
因为我希望表示百分比的进度视图

52
00:02:56,643 --> 00:02:58,812
获得尽可能多的空间

53
00:02:58,846 --> 00:03:02,349
这个规则同样也会应用在
当数量变大的时候

54
00:03:02,382 --> 00:03:05,018
以及对于说其它语言的朋友

55
00:03:05,052 --> 00:03:09,022
或者是在设备上使用
不同字体大小的用户

56
00:03:09,056 --> 00:03:11,792
其次 我希望名称是向前对齐

57
00:03:11,825 --> 00:03:14,728
但数量是向后对齐的

58
00:03:14,761 --> 00:03:20,167
现在 SwiftUI 已经有了 lazy grids
非常适合滚动内容

59
00:03:20,200 --> 00:03:23,704
当你们有很多视图时
这些容器非常有效

60
00:03:23,737 --> 00:03:27,774
因为它们只加载
可见或即将可见的视图

61
00:03:27,808 --> 00:03:29,776
另一方面 这意味着容器

62
00:03:29,810 --> 00:03:33,080
不能在两个维度上
自动调整单元格的大小

63
00:03:34,515 --> 00:03:38,118
例如 LazyHGrid 可以计算出
每一列的宽度

64
00:03:38,151 --> 00:03:42,823
因为它可以在绘制列之前
测量列中的所有视图

65
00:03:42,856 --> 00:03:46,827
但它不能测量一行中的
每个视图来计算行高

66
00:03:46,860 --> 00:03:48,795
为了实现这一点 lazy grids 需要你们

67
00:03:48,829 --> 00:03:52,366
在初始化时提供其中一个维度的信息

68
00:03:53,867 --> 00:03:58,305
如需详细了解 lazy grids 和
其他现有 SwiftUI 布局容器类型

69
00:03:58,338 --> 00:04:02,176
请参阅 2020 年的
Stacks Grids 和 Outlines 讲座

70
00:04:02,209 --> 00:04:06,079
但就我而言 我不需要滚动
我想让 SwiftUI

71
00:04:06,113 --> 00:04:09,616
计算出每个单元格的高度和宽度

72
00:04:09,650 --> 00:04:14,421
对于这种布局 SwiftUI
现在提供了一个网格视图

73
00:04:14,454 --> 00:04:17,891
与 lazy grid 不同的是
网格一次性加载其所有视图

74
00:04:17,925 --> 00:04:21,161
因此它可以
自动调整其单元格的大小

75
00:04:21,195 --> 00:04:25,265
并在其列和行之间对齐

76
00:04:25,299 --> 00:04:27,201
我们来看看它的代码

77
00:04:28,135 --> 00:04:31,438
这是我以 Grid 形式编写的
排行榜的基本版本

78
00:04:31,471 --> 00:04:35,142
这个特定的网格视图包含
三个 GridRow 实例

79
00:04:35,175 --> 00:04:38,512
在一行中 每个视图对应一列

80
00:04:38,545 --> 00:04:41,815
所以在这个示例中 每一行中的

81
00:04:41,849 --> 00:04:43,684
第一个文本视图对应于第一列

82
00:04:43,717 --> 00:04:45,919
进度视图在第二列

83
00:04:45,953 --> 00:04:49,623
最后一个文本视图对应第三列

84
00:04:49,656 --> 00:04:53,393
请注意 网格为每行和每列
分配了所需的空间

85
00:04:53,427 --> 00:04:55,696
以容纳其最大的视图

86
00:04:55,729 --> 00:05:00,234
因此 第一列文本的列宽足以容纳
最长的名称 但不能更宽

87
00:05:00,267 --> 00:05:04,104
进度指示器等灵活视图
会占用网格提供的尽可能多的空间

88
00:05:04,137 --> 00:05:06,139
在本例中 是为文本列

89
00:05:06,173 --> 00:05:09,343
分配空间后剩余的内容

90
00:05:09,376 --> 00:05:13,247
我想稍微调整一下 但首先
我来创建一个基本的数据模型

91
00:05:13,280 --> 00:05:15,382
以存储投票数

92
00:05:16,683 --> 00:05:20,354
我需要更多的逻辑来管理
以及在网络中共享这个数据

93
00:05:20,387 --> 00:05:24,892
但当我创建接口原型时
只需要这样一个简单的结构

94
00:05:24,925 --> 00:05:28,195
我会遵循 Identifiable 协议
这样我们可以更容易的

95
00:05:28,228 --> 00:05:30,497
在 ForEach 中使用这种类型

96
00:05:30,531 --> 00:05:34,368
遵循 Equatable 协议
可以实现动画过渡

97
00:05:35,869 --> 00:05:41,475
我将创建一组示例数据
以便在我制作原型时在预览中使用

98
00:05:41,508 --> 00:05:44,578
回到网格 我可以创建一个状态变量

99
00:05:44,611 --> 00:05:46,947
并用示例数据进行初始化

100
00:05:46,980 --> 00:05:51,218
使用这些数据
我现在可以使用 ForEach 创建行

101
00:05:51,251 --> 00:05:53,453
请注意 渲染输出没有更改

102
00:05:53,487 --> 00:05:56,757
因为它仍然显示相同的数据

103
00:05:56,790 --> 00:06:00,460
已经很接近了
但我需要调整单元格对齐

104
00:06:00,494 --> 00:06:02,529
现在 所有单元格都是居中对齐的

105
00:06:02,563 --> 00:06:05,399
这是网格的默认设置
但如果你还记得

106
00:06:05,432 --> 00:06:07,568
我希望名称是向前对齐的

107
00:06:07,601 --> 00:06:09,970
数值是向后对齐的

108
00:06:10,804 --> 00:06:14,808
为此 我将使用前沿对齐
来初始化网格

109
00:06:14,842 --> 00:06:18,512
我在这里使用的值
适用于网格中的所有单元格

110
00:06:18,545 --> 00:06:23,183
对前两列很有效 但最后一列呢

111
00:06:23,217 --> 00:06:25,385
要影响单个列的对齐

112
00:06:25,419 --> 00:06:31,091
我可以对该列中的任何一个单元格
应用 gridColumnAlignment 视图修饰器

113
00:06:31,124 --> 00:06:34,862
我将在最后一列的文本视图中
执行此操作

114
00:06:34,895 --> 00:06:37,764
好了 已经成功了 但现在我看一下

115
00:06:37,798 --> 00:06:41,835
我觉得每行之间有个分隔符会更好

116
00:06:41,869 --> 00:06:45,272
如果我只是使用分隔符
向 for-each 添加一个新行

117
00:06:45,305 --> 00:06:47,407
这并不是我想要的

118
00:06:47,441 --> 00:06:50,677
但请注意 这显示了一些有趣的东西

119
00:06:50,711 --> 00:06:53,814
首先 因为分隔符是一个灵活的视图

120
00:06:53,847 --> 00:06:56,550
会导致第一列占用更多的空间

121
00:06:56,583 --> 00:06:59,586
基本上 网格现在为最后一列
提供所需的宽度

122
00:06:59,620 --> 00:07:03,824
并在前两列之间划分剩余空间

123
00:07:03,857 --> 00:07:08,028
其次 对于没有像其他网格行
一样多的视图的网格行

124
00:07:08,061 --> 00:07:11,965
缺少的视图只会在后面的列中
创建空单元格

125
00:07:11,999 --> 00:07:16,670
但我真正想要的是让分隔符
跨越网格的所有列

126
00:07:16,703 --> 00:07:20,440
而 SwiftUI 有一个新的视图修饰器
可以让我做到这一点

127
00:07:23,744 --> 00:07:27,014
通过在视图中
添加 gridCellColumns 修饰器

128
00:07:27,047 --> 00:07:30,017
我可以设置单个视图跨越若干列

129
00:07:30,050 --> 00:07:32,719
在这种情况下 一共3列

130
00:07:32,753 --> 00:07:35,923
实际上 对于视图应该
跨越整个网格的情况

131
00:07:35,956 --> 00:07:40,994
我可以通过在网格行之外
单独编写视图来简化这一点

132
00:07:41,028 --> 00:07:44,264
好吧 我的排行榜状态很不错

133
00:07:44,298 --> 00:07:47,668
接下来让我看看用于投票的按钮

134
00:07:48,836 --> 00:07:51,338
乍一看 这里没有什么特别的东西

135
00:07:51,371 --> 00:07:54,641
不过 我有一个特殊的要求

136
00:07:54,675 --> 00:07:57,077
一方面 我不想为参与者
带来倾向性选择

137
00:07:57,110 --> 00:08:00,013
由于某些选项的按钮更小

138
00:08:00,047 --> 00:08:03,050
但我也不希望
按钮们和它们的容器一样大

139
00:08:03,083 --> 00:08:06,386
在 iPad 或 Mac 上可能会非常大

140
00:08:06,420 --> 00:08:11,825
相反 所有按钮的宽度
都应该等于最宽的按钮文字宽度

141
00:08:11,859 --> 00:08:15,462
那么 如果我尝试用 Hstack创建它
会发生什么呢

142
00:08:15,495 --> 00:08:19,666
我发现每个按钮的大小
都是为了适应它的文本标签

143
00:08:19,700 --> 00:08:23,203
而 HStack 将这些水平地打包在一起

144
00:08:23,237 --> 00:08:27,508
这种默认叠放行为正是你们
在很多情况下想要的

145
00:08:27,541 --> 00:08:30,177
但它并不完全符合
我对这个项目的规范

146
00:08:31,778 --> 00:08:34,781
如需重新了解 SwiftUI 中的
布局基础知识

147
00:08:34,815 --> 00:08:39,019
请参阅 2019 年的讲座
Building Custom Views with SwiftUI

148
00:08:39,052 --> 00:08:42,789
利用那个讲座中的概念
我们来看看这个视图层次结构

149
00:08:42,823 --> 00:08:45,659
看看我可以改变什么
来达到我想要的行为

150
00:08:47,694 --> 00:08:52,132
首先 叠放的容器
会为叠放视图建议一个尺寸

151
00:08:52,165 --> 00:08:56,069
基于此 叠放视图为其三个按钮
建议一个尺寸

152
00:08:56,103 --> 00:09:00,674
然后每个按钮将该尺寸
传递给它的文本标签

153
00:09:00,707 --> 00:09:03,377
文本视图计算它们实际需要的大小

154
00:09:03,410 --> 00:09:05,746
这取决于它们包含的字符串

155
00:09:05,779 --> 00:09:08,115
并将此报告给按钮

156
00:09:08,148 --> 00:09:10,884
该按钮将信息传递回去

157
00:09:10,918 --> 00:09:13,387
叠放视图使用此信息调整自己的尺寸

158
00:09:13,420 --> 00:09:18,425
将按钮放在其空间中
然后向容器报告自己的大小

159
00:09:18,458 --> 00:09:21,028
好了 如果按钮取其文本的大小

160
00:09:21,061 --> 00:09:26,133
如果我将每个文本视图包装在
一个灵活框架中并允许其扩大呢

161
00:09:26,166 --> 00:09:29,770
文本没有改变
但按钮看到一个灵活的子视图

162
00:09:29,803 --> 00:09:33,607
它尽可能多的占用了
HStack 提供的空间

163
00:09:33,640 --> 00:09:38,178
然后叠放视图在它包含的视图之间
平均分配其空间

164
00:09:38,212 --> 00:09:40,714
所以现在按钮都具有相同的大小了
这一点很棒

165
00:09:40,747 --> 00:09:44,117
但它们的实际大小取决于
叠放的容器

166
00:09:44,151 --> 00:09:47,921
叠放视图将会扩展
以填充容器提供的任何空间

167
00:09:47,955 --> 00:09:49,590
这不是我想要的

168
00:09:49,623 --> 00:09:52,793
我真正想要的是一种
自定义叠放类型

169
00:09:52,826 --> 00:09:55,562
它要求每个按钮的理想大小

170
00:09:55,596 --> 00:09:59,800
找到最宽的
然后为每个按钮提供相应的空间

171
00:09:59,833 --> 00:10:04,471
幸运的是 SwiftUI 有一个新工具
可以让我做到这一点

172
00:10:04,505 --> 00:10:07,841
使用布局协议
我可以设定一个自定义布局容器

173
00:10:07,875 --> 00:10:10,777
它直接参与布局过程

174
00:10:10,811 --> 00:10:13,981
其行为根据我的用例量身定制

175
00:10:14,014 --> 00:10:15,682
我们看看它是怎么运行的

176
00:10:16,583 --> 00:10:21,788
再看一下 HStack
我把它改成 EqualWidthHStack

177
00:10:21,822 --> 00:10:26,093
我要对它进行设定
以解决我的特定问题

178
00:10:26,126 --> 00:10:29,129
这种类型将平均分配按钮的宽度

179
00:10:29,162 --> 00:10:33,500
其宽度就是最宽按钮的理想宽度

180
00:10:33,534 --> 00:10:36,970
我将保留灵活的框架
以便文本较窄的按钮

181
00:10:37,004 --> 00:10:40,174
可以扩展以填充叠放提供的空间

182
00:10:40,207 --> 00:10:43,310
但是按钮仍然有一个
我可以测量的理想尺寸

183
00:10:43,343 --> 00:10:45,779
即它们的文本宽度

184
00:10:45,812 --> 00:10:49,316
让我们看看如何实现
MyEqualWidthHStack

185
00:10:52,052 --> 00:10:56,290
我先创建一个遵循 Layout 协议的类型

186
00:10:56,323 --> 00:10:59,693
对于一个基本的布局
我只需要两个必需的方法

187
00:10:59,726 --> 00:11:02,462
让我们为其添加存根

188
00:11:02,496 --> 00:11:04,831
第一个方法是 sizeThatFits

189
00:11:04,865 --> 00:11:08,669
我将在其中计算并报告
我的布局容器有多大

190
00:11:10,571 --> 00:11:12,739
我得到一个建议的视图大小输入

191
00:11:12,773 --> 00:11:16,677
这是一个布局自身容器视图的
大小建议

192
00:11:16,710 --> 00:11:21,648
我可以用 subviews 参数
建议布局的子视图大小

193
00:11:22,883 --> 00:11:25,953
注意 我不能直接访问子视图

194
00:11:25,986 --> 00:11:28,789
相反 子视图输入是一个代理的集合

195
00:11:28,822 --> 00:11:32,059
让我以特定的方式与子视图交互

196
00:11:32,092 --> 00:11:34,761
例如建议大小

197
00:11:34,795 --> 00:11:39,132
每个代理都会根据我提出的建议
返回一个具体的大小

198
00:11:39,166 --> 00:11:43,437
我将收集所有这些响应
并使用它们进行一些计算

199
00:11:43,470 --> 00:11:48,041
然后将等宽 HStack 的具体大小
返回到其容器

200
00:11:49,209 --> 00:11:52,846
我要实现的第二个函数
是 placeSubviews

201
00:11:52,880 --> 00:11:56,850
我将使用这个来告诉我的布局
子视图出现在哪里

202
00:11:56,884 --> 00:12:01,054
此方法采用相同的大小建议
和子视图输入

203
00:12:01,088 --> 00:12:04,157
并且还接受边界输入

204
00:12:04,191 --> 00:12:07,060
它表示我需要放置子视图的区域

205
00:12:07,094 --> 00:12:10,097
边界是一个矩形 它的大小

206
00:12:10,130 --> 00:12:12,666
与我在 sizeThatFits 里要求的大小相符

207
00:12:12,699 --> 00:12:15,202
请记住 视图在 SwiftUI 中
选择自己的大小

208
00:12:15,235 --> 00:12:19,673
因此我的布局容器将获取
它要求的大小

209
00:12:19,706 --> 00:12:22,309
这个区域的原点在左上角

210
00:12:22,342 --> 00:12:25,812
positive X 在右边
positive Y 在下面

211
00:12:25,846 --> 00:12:28,515
即使是在从右到左的语言环境中

212
00:12:28,549 --> 00:12:30,851
你也可以假设
所有的布局计算都是如此

213
00:12:30,884 --> 00:12:34,655
因为框架在沿该方向布置视图时

214
00:12:34,688 --> 00:12:37,457
会自动翻转每个视图的 x 位置

215
00:12:37,491 --> 00:12:42,596
但是 不要假设
矩形的原点值为(0,0)

216
00:12:42,629 --> 00:12:45,299
除此之外 允许非零原点

217
00:12:45,332 --> 00:12:47,334
可以启用布局组合

218
00:12:47,367 --> 00:12:49,536
其中一个布局的 placeSubviews 方法

219
00:12:49,570 --> 00:12:52,206
调用另一个布局的相同方法

220
00:12:52,239 --> 00:12:55,442
为了使其更容易操作 矩形提供了

221
00:12:55,475 --> 00:12:57,945
访问区域重要部分的属性

222
00:12:57,978 --> 00:12:59,980
如每个维度中的最小点

223
00:13:00,013 --> 00:13:03,884
中心点和最大值点

224
00:13:05,152 --> 00:13:07,421
现在 在我继续讲之前
请注意这两个方法都具有的

225
00:13:07,454 --> 00:13:09,356
另一个参数

226
00:13:09,389 --> 00:13:11,458
双向缓存 我可以使用它

227
00:13:11,491 --> 00:13:16,363
来跨方法调用共享中间计算的结果

228
00:13:16,396 --> 00:13:18,899
对于许多简单的布局 你不需要这个

229
00:13:18,932 --> 00:13:22,035
我会暂时忽略缓存

230
00:13:22,069 --> 00:13:25,772
但如果使用 Instruments
分析你的应用

231
00:13:25,806 --> 00:13:27,908
表明需要提高布局代码的效率

232
00:13:27,941 --> 00:13:29,877
可以考虑添加一个

233
00:13:29,910 --> 00:13:32,513
关于这方面的更多信息
请查阅文档

234
00:13:34,715 --> 00:13:37,084
好 我们来实现 sizeThatFits

235
00:13:37,117 --> 00:13:39,419
记住 我想为我的容器返回一个大小

236
00:13:39,453 --> 00:13:44,825
该大小适合所有水平排列
宽度都相同的按钮

237
00:13:44,858 --> 00:13:47,761
首先 我会询问每个按钮的大小

238
00:13:47,794 --> 00:13:51,565
提出一个大小并查看返回的内容

239
00:13:51,598 --> 00:13:53,567
为了衡量子视图的灵活性

240
00:13:53,600 --> 00:13:57,137
我可以使用最小 最大
和理想尺寸的特殊建议

241
00:13:57,171 --> 00:13:59,406
进行多次测量

242
00:13:59,439 --> 00:14:01,875
或者我可以提出一个特定的大小

243
00:14:01,909 --> 00:14:07,347
在本例中 我使用未指定的大小建议
来要求理想大小

244
00:14:08,582 --> 00:14:11,318
然后我将找到所有尺寸中

245
00:14:11,351 --> 00:14:13,487
每个维度上的最大值

246
00:14:13,520 --> 00:14:15,789
在本例中 金鱼按钮设置宽度

247
00:14:15,822 --> 00:14:18,625
而且高度都相同

248
00:14:18,659 --> 00:14:20,360
现在我把它重构成一个方法

249
00:14:20,394 --> 00:14:23,964
因为放置子视图时还需要它

250
00:14:23,997 --> 00:14:27,401
接下来 我需要考虑视图之间的间距

251
00:14:27,434 --> 00:14:30,604
我可以使用固定间距 比如10点

252
00:14:30,637 --> 00:14:33,440
但布局协议让我做得更好

253
00:14:33,473 --> 00:14:37,377
在 SwiftUI 中 所有视图都有间距偏好

254
00:14:37,411 --> 00:14:42,015
这表明视图希望其自身
和下一个视图之间拥有多少空间

255
00:14:42,049 --> 00:14:45,219
这些首选项存储在可用于

256
00:14:45,252 --> 00:14:48,488
布局容器的 ViewSpacing 实例中

257
00:14:48,522 --> 00:14:51,024
视图可能喜欢在不同的边上
使用不同的值

258
00:14:51,058 --> 00:14:54,928
甚至对不同类型的相邻视图
使用不同的值

259
00:14:54,962 --> 00:14:57,497
例如 一个视图
与文本视图之间的空间

260
00:14:57,531 --> 00:15:02,803
可能比它与图像之间的空间
要大或小

261
00:15:02,836 --> 00:15:06,206
并且值也可能因平台而异

262
00:15:06,240 --> 00:15:09,743
如果对你的布局有意义
你可以忽略这些参考值

263
00:15:09,776 --> 00:15:13,380
这基本上是你们使用
自定义间距初始化内置叠放时

264
00:15:13,413 --> 00:15:15,415
发生的情况

265
00:15:15,449 --> 00:15:17,584
但在你自己的布局中尊重这些偏好

266
00:15:17,618 --> 00:15:20,487
是获得自动遵循
Apple 界面指南结果的

267
00:15:20,521 --> 00:15:22,489
好方法

268
00:15:22,523 --> 00:15:26,527
从而与系统其他部分的外观相匹配

269
00:15:26,560 --> 00:15:29,796
现在 每个视图对所有边都有偏好

270
00:15:29,830 --> 00:15:31,532
当我把两个视图放在一起时

271
00:15:31,565 --> 00:15:35,068
同一条边的偏好可能不匹配

272
00:15:35,102 --> 00:15:37,204
为了解决这个问题 内置布局容器

273
00:15:37,237 --> 00:15:39,740
使用两个首选项中较大的一个

274
00:15:39,773 --> 00:15:41,942
我可以在自己的布局中
做同样的事情

275
00:15:43,443 --> 00:15:47,314
子视图代理给出了一种方法
可以沿给定轴设定每个按钮

276
00:15:47,347 --> 00:15:50,651
与其他按钮的首选间距

277
00:15:50,684 --> 00:15:54,688
所以我通过扫描子视图
来创建一个数组的值

278
00:15:54,721 --> 00:15:59,493
并在每个代理的间距实例上
调用距离方法

279
00:15:59,526 --> 00:16:02,930
来获取下一个视图的间距实例

280
00:16:02,963 --> 00:16:05,599
沿水平轴的间距

281
00:16:05,632 --> 00:16:07,601
这个调用考虑了两个视图

282
00:16:07,634 --> 00:16:11,004
在它们的共同边上的偏好

283
00:16:11,038 --> 00:16:13,407
这个数组中的第一个元素告诉我

284
00:16:13,440 --> 00:16:17,611
猫按钮相对于金鱼按钮水平
需要多少空间

285
00:16:17,644 --> 00:16:22,216
下一个元素告诉我金鱼按钮
相对于狗按钮需要多少空间

286
00:16:22,249 --> 00:16:24,952
我将强制数组中的
最后一个元素为零

287
00:16:24,985 --> 00:16:28,622
因为没有任何按钮可进行比较

288
00:16:28,655 --> 00:16:32,626
好 让我把它重构成一个方法
稍后再用

289
00:16:32,659 --> 00:16:36,597
现在我可以结合间距值来找到总间距

290
00:16:36,630 --> 00:16:39,132
并将其与宽度和高度测量值
一起使用

291
00:16:39,166 --> 00:16:41,168
以返回大小值

292
00:16:41,201 --> 00:16:43,070
这是我的布局需要的大小

293
00:16:43,103 --> 00:16:45,439
给定它的子视图的理想大小

294
00:16:45,472 --> 00:16:49,376
和每个子视图的首选间距

295
00:16:49,409 --> 00:16:52,946
我需要实现的另一个函数
是 placeSubview

296
00:16:52,980 --> 00:16:55,983
正如我前面提到的
我得到了容器的边界

297
00:16:56,016 --> 00:17:01,021
以及可以用来引导按钮的
子视图代理的集合

298
00:17:01,054 --> 00:17:04,291
首先
我像在 sizeThatFits 方法中那样

299
00:17:04,324 --> 00:17:06,593
计算 maxSize 和间距数组

300
00:17:06,627 --> 00:17:10,030
因为这里也需要这些值

301
00:17:10,063 --> 00:17:13,967
然后我将创建一个
可用于每个子视图的尺寸建议

302
00:17:14,001 --> 00:17:16,537
这一次基于我希望它们具有的尺寸

303
00:17:16,570 --> 00:17:18,639
而不是它们的理想尺寸

304
00:17:18,672 --> 00:17:23,443
我只需要一个建议
因为我希望所有按钮的大小相同

305
00:17:23,477 --> 00:17:26,313
我会在我的第一个子视图的
水平维度上

306
00:17:26,346 --> 00:17:30,250
找到一个起始位置 作为边界的前缘

307
00:17:30,284 --> 00:17:32,553
加上按钮宽度的一半

308
00:17:32,586 --> 00:17:34,955
请注意 我不依赖原点为零

309
00:17:34,988 --> 00:17:39,159
而是从 minX 值开始

310
00:17:39,193 --> 00:17:42,296
最后 我可以浏览每个子视图代理

311
00:17:42,329 --> 00:17:45,532
并用一个点调用它的放置方法

312
00:17:45,566 --> 00:17:49,036
声明该点在按钮方面代表什么

313
00:17:49,069 --> 00:17:52,105
以及尺寸建议

314
00:17:52,139 --> 00:17:55,075
每次通过循环 我都将水平位置

315
00:17:55,108 --> 00:17:58,545
更新为视图的宽度
加上下一个视图对的间距

316
00:17:58,579 --> 00:18:01,114
以便为下一次迭代做好准备

317
00:18:01,148 --> 00:18:02,549
就是这样

318
00:18:02,583 --> 00:18:06,053
现在让我们看看使用
新的视图布局类型会发生什么

319
00:18:07,454 --> 00:18:08,655
就是这个

320
00:18:08,689 --> 00:18:11,058
我将自己的自定义布局容器实例化

321
00:18:11,091 --> 00:18:13,527
就像我使用内置 HStack 一样

322
00:18:13,560 --> 00:18:18,532
按钮水平排列 宽度相同

323
00:18:18,565 --> 00:18:20,467
现在 我想在这里暂停片刻

324
00:18:20,501 --> 00:18:22,970
谈谈布局协议如何解决过去你们

325
00:18:23,003 --> 00:18:27,040
可能尝试使用 Geometry reader
解决的问题

326
00:18:27,074 --> 00:18:31,378
毕竟 Geometry reader
是测量视图大小的工具

327
00:18:31,411 --> 00:18:35,015
但是在这种情况下 这不是最佳选择

328
00:18:35,048 --> 00:18:38,919
这是因为 geometry reader
旨在测量其容器视图

329
00:18:38,952 --> 00:18:41,288
并将该大小报告给其子视图

330
00:18:41,321 --> 00:18:45,792
然后子视图使用这些信息
来绘制它自己的内容

331
00:18:45,826 --> 00:18:48,428
注意 对于 geometry reader 来说

332
00:18:48,462 --> 00:18:50,330
信息是向下传递的

333
00:18:50,364 --> 00:18:52,432
reader所做的测量对其自身容器的

334
00:18:52,466 --> 00:18:54,701
布局没有影响

335
00:18:55,836 --> 00:18:59,439
这对于绘制随容器缩放的路径
非常有用

336
00:18:59,473 --> 00:19:03,143
geometry reader 告诉路径逻辑
它必须使用多少空间

337
00:19:03,177 --> 00:19:07,714
子视图中的路径逻辑相应地调整

338
00:19:07,748 --> 00:19:10,984
如果容器改变了大小 路径也会改变

339
00:19:11,018 --> 00:19:14,755
因为 geometry reader
会沿着新的大小传递

340
00:19:14,788 --> 00:19:17,591
但是 对于我的按钮来说
我将在这里只关注一个

341
00:19:17,624 --> 00:19:21,528
以便更容易看到
我需要测量文本视图

342
00:19:21,562 --> 00:19:26,967
然后使用它来决定如何设置
以作为文本视图容器的框架

343
00:19:27,000 --> 00:19:30,938
因此 我可以在文本视图的叠加中
添加一个 geometry reader

344
00:19:30,971 --> 00:19:33,173
记住 测量其容器

345
00:19:33,207 --> 00:19:36,343
然后以某种方式将测量数据
发送回框架

346
00:19:36,376 --> 00:19:38,645
在正常的流程之外

347
00:19:38,679 --> 00:19:41,548
但请注意 如果我这样做
就会绕过布局引擎

348
00:19:41,582 --> 00:19:43,784
这可能会导致循环

349
00:19:43,817 --> 00:19:46,887
读取器测量布局并改变框架

350
00:19:46,920 --> 00:19:51,925
可能会改变布局
可能需要再次测量等等

351
00:19:51,959 --> 00:19:54,394
现在要实现这个是有可能的

352
00:19:54,428 --> 00:19:57,931
但如果我不小心
最终可能会导致我的 App 崩溃

353
00:19:57,965 --> 00:20:00,868
因此 不建议使用这个策略

354
00:20:00,901 --> 00:20:04,238
幸运的是 布局协议提供了一种
更好的方法来解决这个问题

355
00:20:04,271 --> 00:20:07,140
允许你们在布局引擎中操作

356
00:20:08,108 --> 00:20:10,711
好 让我们再看看按钮

357
00:20:10,744 --> 00:20:13,013
这里我还想做点别的事

358
00:20:13,046 --> 00:20:14,882
首先 为了更易于观看

359
00:20:14,915 --> 00:20:18,519
我将把按钮重构为
它们自身的子视图

360
00:20:18,552 --> 00:20:21,321
现在 我碰巧知道我的一位同事
在他们的设备上使用

361
00:20:21,355 --> 00:20:22,990
更大的字体

362
00:20:23,023 --> 00:20:27,461
我的 App 自动支持 Dynamic Type
因为我使用了默认字体

363
00:20:27,494 --> 00:20:30,898
所以基本上可以
免费获得正确的行为

364
00:20:30,931 --> 00:20:35,235
让我们看看如果增加字体大小
会发生什么

365
00:20:35,269 --> 00:20:37,437
啊哦 按钮不适合了

366
00:20:37,471 --> 00:20:41,041
请记住 我的自定义叠放
没有限制按钮的宽度

367
00:20:41,074 --> 00:20:43,644
而只是让它们拥有理想的大小

368
00:20:43,677 --> 00:20:47,080
在这种情况下 超过了显示的宽度

369
00:20:47,114 --> 00:20:48,582
那么我能做什么呢

370
00:20:48,615 --> 00:20:51,318
好吧 当视图不适合时
我可以修改布局

371
00:20:51,351 --> 00:20:54,421
以做一些更复杂的事情

372
00:20:54,454 --> 00:20:56,323
同时考虑到布局容器的大小建议

373
00:20:56,356 --> 00:20:59,626
但是对于这种情况
我可以使用新的 ViewThatFits 容器

374
00:20:59,660 --> 00:21:01,828
来为我完成大部分工作

375
00:21:01,862 --> 00:21:05,499
这个新类型从我提供的视图列表中
选择第一个

376
00:21:05,532 --> 00:21:07,901
适合可用空间的视图

377
00:21:09,336 --> 00:21:13,006
通过将我的自定义叠放
包装在一个适合视图的结构中

378
00:21:13,040 --> 00:21:16,076
然后添加相同内容的垂直叠放版本

379
00:21:16,109 --> 00:21:20,747
我可以让 SwiftUI 知道按钮
什么时候需要以不同的方式排列

380
00:21:20,781 --> 00:21:24,284
当然 内置的 VStack
没有我自定义水平叠放

381
00:21:24,318 --> 00:21:27,521
所具有的等宽属性

382
00:21:27,554 --> 00:21:31,725
所以我也实现了自定义叠放的
垂直版本

383
00:21:31,758 --> 00:21:34,061
它与我之前说的非常相似

384
00:21:34,094 --> 00:21:37,564
不同的是它将等宽的项目

385
00:21:37,598 --> 00:21:40,067
放置在垂直轴而不是水平轴上

386
00:21:41,668 --> 00:21:44,771
当然 当我删除动态类型大小覆盖时

387
00:21:44,805 --> 00:21:47,574
它又回到了水平布局

388
00:21:47,608 --> 00:21:50,010
现在 我还需要构建
App 的最后一个部分

389
00:21:50,043 --> 00:21:52,846
那就是顶部的图像

390
00:21:52,880 --> 00:21:56,483
我可以做一些简单的事情
比如只显示一组个人资料图片

391
00:21:56,517 --> 00:21:59,186
但我想可以从中获得一些乐趣

392
00:21:59,219 --> 00:22:01,321
所以我做了另一个自定义布局类型

393
00:22:01,355 --> 00:22:04,458
以圆形排列方式绘制视图

394
00:22:04,491 --> 00:22:08,028
然后根据排名旋转排列

395
00:22:08,061 --> 00:22:11,031
所以这个配置显示金鱼排名第一

396
00:22:11,064 --> 00:22:13,500
其他两个并列第二

397
00:22:13,534 --> 00:22:17,070
然后如果狗放到猫前面
我可以旋转一下来展示

398
00:22:17,104 --> 00:22:19,740
或者我可以通过旋转径向布局

399
00:22:19,773 --> 00:22:23,110
展示一个更真实的结果

400
00:22:23,143 --> 00:22:27,014
使用布局协议创建此布局
实际上非常简单

401
00:22:27,047 --> 00:22:30,317
和之前一样 我只需要两种方法

402
00:22:30,350 --> 00:22:33,687
对于适合的大小
我希望视图填充可用空间

403
00:22:33,720 --> 00:22:37,724
所以我将返回容器视图建议的大小

404
00:22:37,758 --> 00:22:40,360
我将使用
replace-unspecified-dimensions 方法

405
00:22:40,394 --> 00:22:44,031
将建议转换为具体尺寸

406
00:22:44,064 --> 00:22:47,234
如果容器要求理想的大小

407
00:22:47,267 --> 00:22:50,737
该方法会自动处理可能出现的 nil 值

408
00:22:50,771 --> 00:22:53,340
然后在放置子视图方法中

409
00:22:53,373 --> 00:22:55,609
我将根据布局区域的大小

410
00:22:55,642 --> 00:22:59,213
将每个子视图从中间偏移一些半径

411
00:22:59,246 --> 00:23:03,350
并应用取决于视图索引的旋转

412
00:23:03,383 --> 00:23:07,588
作为基线 会将视图

413
00:23:07,621 --> 00:23:12,459
放置在圆周的 0 1 和 三分之二处

414
00:23:12,492 --> 00:23:14,161
为了反映当前的排名

415
00:23:14,194 --> 00:23:18,365
我还将应用一个对所有视图
产生同等影响的偏移量

416
00:23:18,398 --> 00:23:20,033
但是我从哪里获得排名呢

417
00:23:20,067 --> 00:23:23,537
记住 我的布局只能访问子视图代理

418
00:23:23,570 --> 00:23:27,107
而不能访问视图
更不用说数据模型了

419
00:23:27,140 --> 00:23:31,044
原来布局协议还有另一个妙招

420
00:23:31,078 --> 00:23:33,380
它允许我们在每个子视图上存储值

421
00:23:33,413 --> 00:23:37,384
并从布局协议方法中读取值

422
00:23:37,417 --> 00:23:41,822
让我们看看我如何使用它
来传达排名信息

423
00:23:41,855 --> 00:23:46,593
首先 我声明了一个新的类型
遵循 LayoutValueKey 协议

424
00:23:46,627 --> 00:23:48,829
并给它一个默认值

425
00:23:48,862 --> 00:23:53,166
除了在未显式设置视图时
为视图提供值外

426
00:23:53,200 --> 00:23:56,303
默认值还建立关联值的类型

427
00:23:56,336 --> 00:23:59,339
在本例中为整数

428
00:23:59,373 --> 00:24:03,410
然后 我在 View 上
创建了一个方便的方法

429
00:24:03,443 --> 00:24:07,114
使用 layoutValue 视图修饰器
来设置值

430
00:24:07,147 --> 00:24:08,882
现在 在我的视图层次结构中

431
00:24:08,916 --> 00:24:13,187
可以将便利排名修饰器
应用到布局中的视图

432
00:24:13,220 --> 00:24:15,322
在这里 我计算每个宠物的排名

433
00:24:15,355 --> 00:24:20,894
并将其添加到我的径向布局中
对应的宠物头像视图中

434
00:24:20,928 --> 00:24:23,597
最后 回到我的放置子视图方法

435
00:24:23,630 --> 00:24:27,167
我可以添加一些代码
通过使用布局值键作为索引

436
00:24:27,201 --> 00:24:31,371
从每个子视图读取值

437
00:24:31,405 --> 00:24:34,675
我可以使用排名来计算偏移量

438
00:24:34,708 --> 00:24:37,511
我在这里就不赘述这种逻辑了
但它基本上

439
00:24:37,544 --> 00:24:40,914
为任何可能的排名
产生了一个合适的角度

440
00:24:40,948 --> 00:24:43,283
好吧 除了这个

441
00:24:43,317 --> 00:24:45,752
如果三个并列会怎么样呢

442
00:24:45,786 --> 00:24:48,856
无法通过旋转布局
来使所有视图排成一行

443
00:24:48,889 --> 00:24:53,393
所以我必须替换
完全不同的布局逻辑

444
00:24:53,427 --> 00:24:56,330
但是 已经有一种布局类型
可以做到这一点

445
00:24:56,363 --> 00:24:58,498
那就是内置的 HStack

446
00:24:58,532 --> 00:25:01,168
所以我真正想做的是
当检测到三个并列时

447
00:25:01,201 --> 00:25:03,604
转换到 HStack

448
00:25:03,637 --> 00:25:07,107
事实证明
也有一个新工具可以做到这一点

449
00:25:07,140 --> 00:25:09,476
AnyLayout 类型允许你们
将不同的布局

450
00:25:09,510 --> 00:25:12,513
应用于单个视图层次结构
这样 当你从一个布局类型

451
00:25:12,546 --> 00:25:16,517
转换到另一个布局类型时
可以保持视图的标识

452
00:25:17,451 --> 00:25:20,988
所以这里有
我们之前看到的径向布局

453
00:25:21,021 --> 00:25:24,057
我所要做的就是用一个
新的布局类型替换它

454
00:25:24,091 --> 00:25:27,528
取决于是否是三个并列

455
00:25:27,561 --> 00:25:31,465
因为 isThreeWayTie 属性是
从状态派生的

456
00:25:31,498 --> 00:25:33,333
所以 SwiftUI 会注意到它的变化

457
00:25:33,367 --> 00:25:36,370
并识别出它需要重新绘制这个视图

458
00:25:36,403 --> 00:25:39,540
但是由于视图层次结构的结构标识
始终保持不变

459
00:25:39,573 --> 00:25:43,844
SwiftUI 将其视为一个变化的视图

460
00:25:43,877 --> 00:25:46,213
而不是一个新的视图

461
00:25:46,246 --> 00:25:48,949
因此 只需要多一行

462
00:25:48,982 --> 00:25:52,553
我就可以在布局类型之间
创建平滑的过渡

463
00:25:52,586 --> 00:25:55,155
而事实上 通过添加动画视图修饰器

464
00:25:55,189 --> 00:25:59,726
我还可以获得径向布局的
所有不同状态之间的动画

465
00:25:59,760 --> 00:26:03,931
因为径向布局的配置
依赖于相同的数据

466
00:26:03,964 --> 00:26:06,733
这是它实际运行的样子

467
00:26:06,767 --> 00:26:09,403
当我点击不同的按钮来更改
投票计数时

468
00:26:09,436 --> 00:26:13,540
你可以看到头像如何平滑地移动
来反映当前的排名

469
00:26:17,845 --> 00:26:20,447
这些是 SwiftUI 用于组合

470
00:26:20,480 --> 00:26:23,083
你的 App 的视图布局的一些新工具

471
00:26:23,116 --> 00:26:25,719
你可以使用 Grid 类型
构建静态信息的

472
00:26:25,752 --> 00:26:28,589
高度可定制的二维布局

473
00:26:28,622 --> 00:26:31,859
你们可以使用布局协议
来定义自己的通用布局

474
00:26:31,892 --> 00:26:36,730
可重用布局
或高度针对特定用例的布局

475
00:26:36,763 --> 00:26:40,734
当你想让 SwiftUI 从一组视图中
选择最适合可用空间的视图时

476
00:26:40,767 --> 00:26:43,303
可以使用 ViewThatFits

477
00:26:43,337 --> 00:26:48,442
你可以使用 AnyLayout
在布局类型之间无缝切换

478
00:26:48,475 --> 00:26:51,411
感谢你今天加入我的行列
希望你能像我一样

479
00:26:51,445 --> 00:26:54,214
从这些新的布局工具中获得乐趣

