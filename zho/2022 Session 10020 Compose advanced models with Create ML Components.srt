1
00:00:00,200 --> 00:00:03,003
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,003 --> 00:00:09,676
♪

3
00:00:09,676 --> 00:00:11,612
嗨 我的名字叫 David Findlay

4
00:00:11,612 --> 00:00:14,014
我是 Create ML 团队的工程师

5
00:00:14,014 --> 00:00:16,583
本讲座的主题
是 Create ML 组件

6
00:00:16,583 --> 00:00:20,487
这是一种强大的新方法
用于构建您自己的机器学习任务

7
00:00:20,487 --> 00:00:23,023
我的同事 Alejandro

8
00:00:23,023 --> 00:00:25,092
在“了解 Create ML 组件”
讲座中做了介绍

9
00:00:25,092 --> 00:00:27,394
他探讨了
如何将 Create ML 任务

10
00:00:27,394 --> 00:00:29,863
解构为组件 并揭示了

11
00:00:29,863 --> 00:00:31,865
构建自定义模型是多么简单

12
00:00:31,865 --> 00:00:35,002
转换器和估算器是主要的构件

13
00:00:35,002 --> 00:00:37,938
您可以将它们组合在一起

14
00:00:37,938 --> 00:00:40,140
构建自定义模型 如图像回归

15
00:00:40,140 --> 00:00:43,377
本讲座的内容远不止基础知识

16
00:00:43,377 --> 00:00:46,613
我想演示 Create ML 组件
会带来哪些可能性

17
00:00:46,613 --> 00:00:49,917
我们看一下本讲座的内容
有很多东西要讲

18
00:00:49,917 --> 00:00:53,187
我先讲视频数据 再详细介绍

19
00:00:53,187 --> 00:00:57,090
处理时序数据的新组件

20
00:00:57,090 --> 00:00:58,792
然后我会把这些概念付诸实践

21
00:00:58,792 --> 00:01:01,061
只使用转换器构建一个

22
00:01:01,061 --> 00:01:03,430
人体动作重复次数计数器

23
00:01:03,430 --> 00:01:05,232
最后 我会训练

24
00:01:05,232 --> 00:01:07,201
自定义声音分类器模型

25
00:01:07,201 --> 00:01:09,469
我将讨论增量拟合 它允许您

26
00:01:09,469 --> 00:01:11,271
批量更新模型 提前停止训练

27
00:01:11,271 --> 00:01:13,941
并为模型设置检查点

28
00:01:13,941 --> 00:01:17,144
这种级别的灵活性带来了很多机会

29
00:01:17,144 --> 00:01:19,012
我等不及了

30
00:01:19,012 --> 00:01:21,081
让我们开始吧

31
00:01:21,081 --> 00:01:24,551
在 2020 年
全球开发者大会 (WWDC) 上

32
00:01:24,551 --> 00:01:26,153
我们介绍了
Create ML 中的动作分类

33
00:01:26,153 --> 00:01:28,989
它允许您对视频中的动作进行分类

34
00:01:28,989 --> 00:01:31,625
我们还演示了如何创建健身分类器

35
00:01:31,625 --> 00:01:34,127
来识别一个人的锻炼项目

36
00:01:34,127 --> 00:01:37,998
如开合跳 弓步和深蹲

37
00:01:37,998 --> 00:01:40,501
例如 您可以使用动作分类器

38
00:01:40,501 --> 00:01:44,037
将此视频中的动作识别为开合跳

39
00:01:44,037 --> 00:01:47,441
但如果您想数一下您的开合跳次数
该怎么办？

40
00:01:47,441 --> 00:01:49,109
您需要考虑的第一件事是

41
00:01:49,109 --> 00:01:52,079
开合跳跨越连续多帧

42
00:01:52,079 --> 00:01:55,182
您需要一种处理时序数据的方法

43
00:01:55,182 --> 00:01:57,050
感谢 Swift AsyncSequence

44
00:01:57,050 --> 00:01:59,386
让这变得很容易

45
00:01:59,386 --> 00:02:01,889
如果您不熟悉 AsyncSequence

46
00:02:01,889 --> 00:02:06,260
请查看
“认识 AsyncSequence”讲座

47
00:02:06,260 --> 00:02:09,062
通过 Create ML 组件
您可以

48
00:02:09,062 --> 00:02:13,133
使用视频阅读器
将视频作为异步序列帧读取

49
00:02:13,133 --> 00:02:16,170
AsyncSequence 提供了一种
循环访问序列帧的方式

50
00:02:16,170 --> 00:02:19,840
和从视频中接收的顺序一样

51
00:02:19,840 --> 00:02:22,576
例如 我可以使用 map 方法

52
00:02:22,576 --> 00:02:26,146
轻松地异步转换每个视频帧

53
00:02:26,146 --> 00:02:30,551
当您想一次处理一帧时 这很有用

54
00:02:30,551 --> 00:02:32,085
但如果您想一次处理多帧

55
00:02:32,085 --> 00:02:34,254
该怎么办？

56
00:02:34,254 --> 00:02:36,857
这就是时序转换器的用武之地

57
00:02:36,857 --> 00:02:39,626
例如 您可能想要对视频帧进行下采样

58
00:02:39,626 --> 00:02:42,095
以加快视频中的动作

59
00:02:42,095 --> 00:02:44,064
您可以为此使用下采样器

60
00:02:44,064 --> 00:02:45,766
下采样器需要传入一个异步序列

61
00:02:45,766 --> 00:02:48,802
并返回一个经过下采样的异步序列

62
00:02:48,802 --> 00:02:51,505
或者您可能想要将帧分组到窗口中

63
00:02:51,505 --> 00:02:54,708
这对于计算动作重复次数很重要

64
00:02:54,708 --> 00:02:58,111
这就是滑动窗口转换器的用武之地

65
00:02:58,111 --> 00:03:00,881
您可以指定窗口长度
也就是分组到窗口中的帧数

66
00:03:00,881 --> 00:03:03,450
并指定步幅

67
00:03:03,450 --> 00:03:06,587
也就是控制滑动间隔的方式

68
00:03:06,587 --> 00:03:09,957
同样 输入是一个异步序列

69
00:03:09,957 --> 00:03:15,662
在这种情况下
输出是一个窗口化的异步序列

70
00:03:15,662 --> 00:03:17,965
一般来说 时序转换器

71
00:03:17,965 --> 00:03:20,601
提供了一种将异步序列处理为

72
00:03:20,601 --> 00:03:22,903
新的异步序列的方法

73
00:03:22,903 --> 00:03:25,772
那么让我们把这些概念付诸实践

74
00:03:25,772 --> 00:03:27,941
我不知道您的情况 但是当我锻炼时

75
00:03:27,941 --> 00:03:30,143
我总是数不清我的动作重复次数

76
00:03:30,143 --> 00:03:32,112
所以我决定稍微改变一下

77
00:03:32,112 --> 00:03:34,214
用 Create ML 组件
构建一个

78
00:03:34,214 --> 00:03:36,383
动作重复次数计数器

79
00:03:36,383 --> 00:03:39,920
在这个例子中 我将介绍如何

80
00:03:39,920 --> 00:03:42,256
将转换器和时序转换器组合在一起

81
00:03:42,256 --> 00:03:45,526
让我们从姿态提取开始

82
00:03:45,526 --> 00:03:49,296
我可以使用人体姿态提取器
来提取姿态

83
00:03:49,296 --> 00:03:50,831
输入是一个图像

84
00:03:50,831 --> 00:03:54,401
输出是一个人体姿态数组

85
00:03:54,401 --> 00:03:56,837
在底层
我们利用 Vision 框架

86
00:03:56,837 --> 00:03:59,573
来提取姿态

87
00:03:59,573 --> 00:04:02,376
请注意 图像可以包含多个人

88
00:04:02,376 --> 00:04:05,012
这在集体锻炼中很常见

89
00:04:05,012 --> 00:04:08,415
这就是输出是人体姿态数组的原因

90
00:04:08,415 --> 00:04:11,185
但我只对一次计算一个人的

91
00:04:11,185 --> 00:04:13,520
动作重复次数感兴趣

92
00:04:13,520 --> 00:04:16,356
所以我将姿态提取器

93
00:04:16,356 --> 00:04:19,660
和姿态选择器组合

94
00:04:19,660 --> 00:04:22,129
姿态选择器接受传入姿态数组

95
00:04:22,129 --> 00:04:26,834
以及选择策略
然后返回一个单独的姿态

96
00:04:26,834 --> 00:04:29,236
有几个选择策略可供选择

97
00:04:29,236 --> 00:04:30,604
对于这个例子

98
00:04:30,604 --> 00:04:33,507
我将使用
rightMostJointLocation 策略

99
00:04:33,507 --> 00:04:38,312
下一步是将姿态分组到窗口中

100
00:04:38,312 --> 00:04:42,015
我将为此添加一个滑动窗口转换器

101
00:04:42,015 --> 00:04:44,852
我将使用 90 的窗口长度和步幅

102
00:04:44,852 --> 00:04:47,120
这将生成不重叠窗口

103
00:04:47,120 --> 00:04:49,823
每个窗口 90 个姿态

104
00:04:49,823 --> 00:04:52,826
回想一下 滑动窗口转换器
是时序的

105
00:04:52,826 --> 00:04:55,729
这使整个任务都是时序的

106
00:04:55,729 --> 00:05:00,367
预期输入是一个异步序列帧

107
00:05:00,367 --> 00:05:05,639
最后 我将添加一个
人体动作计数器

108
00:05:05,639 --> 00:05:06,740
这个时序转换器

109
00:05:06,740 --> 00:05:10,043
需要传入窗口化的异步序列帧

110
00:05:10,043 --> 00:05:13,013
并返回截止到当时的

111
00:05:13,013 --> 00:05:14,515
累积动作重复次数

112
00:05:14,515 --> 00:05:15,749
到目前为止 您可能已经注意到

113
00:05:15,749 --> 00:05:18,285
这个次数是一个浮点数

114
00:05:18,285 --> 00:05:21,822
这是因为此任务也计算
部分动作的次数

115
00:05:21,822 --> 00:05:23,323
就这么简单

116
00:05:23,323 --> 00:05:25,626
现在我可以在我的锻炼视频中
计算我的重复次数了

117
00:05:25,626 --> 00:05:27,961
并确保我没有作弊

118
00:05:27,961 --> 00:05:31,265
但更好的方法是
在 App 中实时计算重复次数

119
00:05:31,265 --> 00:05:35,169
这样就可以跟踪当前的锻炼情况

120
00:05:35,169 --> 00:05:38,071
让我告诉您如何做到这一点

121
00:05:38,071 --> 00:05:40,607
首先 我将使用
readCamera 方法

122
00:05:40,607 --> 00:05:42,409
该方法需要传入相机配置

123
00:05:42,409 --> 00:05:45,879
会返回一个异步的相机序列帧

124
00:05:45,879 --> 00:05:49,149
接下来 我将步幅参数
调整为 15 帧

125
00:05:49,149 --> 00:05:52,286
这样我就可以更频繁地获得
更新的计数

126
00:05:52,286 --> 00:05:55,422
如果我的相机
以每秒 30 帧的速度捕获帧

127
00:05:55,422 --> 00:05:58,859
那么我每半秒计数一次

128
00:05:58,859 --> 00:06:03,397
现在我可以锻炼了
而无需担心漏记某个重复动作

129
00:06:03,397 --> 00:06:06,133
到目前为止 我已经探讨了

130
00:06:06,133 --> 00:06:08,669
用于转换异步序列的时序组件

131
00:06:08,669 --> 00:06:11,238
接下来 我想专注于训练

132
00:06:11,238 --> 00:06:14,641
依赖时序数据的自定义模型

133
00:06:14,641 --> 00:06:18,445
2019 年 我们演示了
如何在 Create ML 中

134
00:06:18,445 --> 00:06:19,947
训练声音分类器

135
00:06:19,947 --> 00:06:22,716
然后在 2021 年 我们推出了

136
00:06:22,716 --> 00:06:24,952
声音分类的增强功能

137
00:06:24,952 --> 00:06:26,420
我想更进一步

138
00:06:26,420 --> 00:06:30,657
增量训练自定义声音分类器

139
00:06:30,657 --> 00:06:33,393
Create ML 框架中的
MLSoundClassifier

140
00:06:33,393 --> 00:06:34,695
仍是训练自定义声音分类器模型的

141
00:06:34,695 --> 00:06:36,897
最简单方法

142
00:06:36,897 --> 00:06:39,933
但是当您需要更多的
可定制性和控制性时

143
00:06:39,933 --> 00:06:42,169
您可以使用其底层的组件

144
00:06:42,169 --> 00:06:46,406
最简单的形式下
声音分类器有两个组件：

145
00:06:46,406 --> 00:06:49,076
Audio Feature Print
是一个特征提取器

146
00:06:49,076 --> 00:06:51,745
以及您选择的一个分类器

147
00:06:51,745 --> 00:06:54,248
AudioFeaturePrint 是一个

148
00:06:54,248 --> 00:06:56,850
从音频缓冲区的异步序列中

149
00:06:56,850 --> 00:06:59,253
提取音频特征的时序转换器

150
00:06:59,253 --> 00:07:01,755
与滑动窗口转换器相似

151
00:07:01,755 --> 00:07:04,358
AudioFeaturePrint
将异步序列窗口化

152
00:07:04,358 --> 00:07:07,327
然后提取特征

153
00:07:07,327 --> 00:07:09,530
有几个分类器可供选择

154
00:07:09,530 --> 00:07:14,034
但对于这个例子
我将使用逻辑回归分类器

155
00:07:14,034 --> 00:07:16,837
然后将其与特征提取器组合在一起

156
00:07:16,837 --> 00:07:20,574
以构建自定义声音分类器

157
00:07:20,574 --> 00:07:23,644
下一步是将自定义声音分类器

158
00:07:23,644 --> 00:07:25,379
与标记过的训练数据相拟合

159
00:07:25,379 --> 00:07:27,881
如要了解有关收集训练数据的
更多信息

160
00:07:27,881 --> 00:07:30,150
“了解 Create ML 组件”讲座

161
00:07:30,150 --> 00:07:32,085
是一个很好的起点

162
00:07:32,085 --> 00:07:34,688
到目前为止 一切进展顺利

163
00:07:34,688 --> 00:07:36,623
但是构建机器学习模型

164
00:07:36,623 --> 00:07:39,660
可能是一个迭代过程

165
00:07:39,660 --> 00:07:43,030
例如 您可能会随着时间的推移
发现和收集新的训练数据

166
00:07:43,030 --> 00:07:46,333
并希望更新您的模型

167
00:07:46,333 --> 00:07:49,503
您可以提高模型质量

168
00:07:49,503 --> 00:07:53,340
但是从头开始重新训练模型
非常耗时

169
00:07:53,340 --> 00:07:55,943
这是因为您需要对以前的所有数据

170
00:07:55,943 --> 00:07:58,045
重新进行特征提取

171
00:07:58,045 --> 00:08:00,714
让我举个例子说明

172
00:08:00,714 --> 00:08:04,184
在使用新发现的数据
对模型进行训练时如何节省时间

173
00:08:04,184 --> 00:08:06,687
关键是对训练数据进行预处理

174
00:08:06,687 --> 00:08:09,456
并将此过程与模型拟合分开

175
00:08:09,456 --> 00:08:12,793
在这个例子中 我可以
将提取音频特征

176
00:08:12,793 --> 00:08:15,429
与分类器拟合分开进行

177
00:08:15,429 --> 00:08:17,531
这通常是有效的

178
00:08:17,531 --> 00:08:19,967
在一系列转换器

179
00:08:19,967 --> 00:08:21,635
后接一个估算器时

180
00:08:21,635 --> 00:08:24,638
您可以对
经过转换器进入估算器的输入

181
00:08:24,638 --> 00:08:26,507
进行预处理

182
00:08:26,507 --> 00:08:30,143
您需要做的就是调用预处理方法

183
00:08:30,143 --> 00:08:33,514
然后将模型与经过预处理的特征
相拟合

184
00:08:33,514 --> 00:08:35,849
我觉得这很方便 因为我不需要

185
00:08:35,849 --> 00:08:38,785
改变声音分类器的组成

186
00:08:38,785 --> 00:08:41,088
现在可以单独提取特征

187
00:08:41,088 --> 00:08:44,057
我可以灵活地只对新数据提取

188
00:08:44,057 --> 00:08:46,760
音频特征

189
00:08:46,760 --> 00:08:49,129
当您发现模型的新训练数据时

190
00:08:49,129 --> 00:08:51,999
您可以轻松地对这些数据
进行单独的预处理

191
00:08:51,999 --> 00:08:54,001
然后将新增的特征添加到

192
00:08:54,001 --> 00:08:56,770
之前提取的特征上

193
00:08:56,770 --> 00:08:58,605
这只是预处理可以节省时间的

194
00:08:58,605 --> 00:09:01,742
第一个例子

195
00:09:01,742 --> 00:09:04,645
让我们回到模型构建周期

196
00:09:04,645 --> 00:09:06,813
您可能需要调整估算器参数

197
00:09:06,813 --> 00:09:09,483
直到您对模型的质量感到满意为止

198
00:09:09,483 --> 00:09:12,386
通过将特征提取与拟合分开

199
00:09:12,386 --> 00:09:14,821
您可以只提取一次特征

200
00:09:14,821 --> 00:09:18,325
然后将模型与不同的估算器参数
相拟合

201
00:09:18,325 --> 00:09:19,593
我们来看一个

202
00:09:19,593 --> 00:09:21,261
在不重新进行特征提取的情况下

203
00:09:21,261 --> 00:09:24,531
更改分类器参数的例子

204
00:09:24,531 --> 00:09:26,934
假设我已经提取了特征

205
00:09:26,934 --> 00:09:30,771
我将修改分类器的 L2 惩罚参数

206
00:09:30,771 --> 00:09:33,006
然后我需要将新的分类器

207
00:09:33,006 --> 00:09:35,375
添加到旧的特征提取器上

208
00:09:35,375 --> 00:09:37,945
在调整估算器时

209
00:09:37,945 --> 00:09:40,747
不更改特征提取器很重要

210
00:09:40,747 --> 00:09:43,050
因为这会使之前提取的特征无效

211
00:09:43,050 --> 00:09:47,421
我们看一下如何以增量方式
使用批量数据拟合模型

212
00:09:47,421 --> 00:09:49,323
机器学习模型

213
00:09:49,323 --> 00:09:51,725
通常受益于大量的训练数据

214
00:09:51,725 --> 00:09:55,095
但是 您的 App 可能
受到有限内存的限制

215
00:09:55,095 --> 00:09:56,730
那么您该怎么办？

216
00:09:56,730 --> 00:09:59,266
您可以使用 Create ML 组件
来训练模型

217
00:09:59,266 --> 00:10:02,569
每次只将一批数据加载到内存中

218
00:10:02,569 --> 00:10:05,606
我需要做的第一件事是将现有分类器

219
00:10:05,606 --> 00:10:07,708
更换为可更新的分类器

220
00:10:07,708 --> 00:10:10,077
为了使用批量数据训练自定义模型

221
00:10:10,077 --> 00:10:12,679
分类器需要可更新

222
00:10:12,679 --> 00:10:16,383
例如 可以轻松使用的

223
00:10:16,383 --> 00:10:17,684
全连接神经网络分类器

224
00:10:17,684 --> 00:10:20,220
而不是不可更新的

225
00:10:20,220 --> 00:10:22,022
逻辑回归分类器

226
00:10:25,292 --> 00:10:28,795
好 现在我将编写一个训练循环

227
00:10:28,795 --> 00:10:32,032
我首先将创建一个默认的
初始化模型

228
00:10:32,032 --> 00:10:34,034
还不能用来进行预测

229
00:10:34,034 --> 00:10:37,838
因为这只是训练的起点

230
00:10:37,838 --> 00:10:39,873
然后我会在训练开始前

231
00:10:39,873 --> 00:10:41,909
提取音频特征

232
00:10:41,909 --> 00:10:43,110
这是一个重要的步骤

233
00:10:43,110 --> 00:10:46,914
因为我不想每次迭代都提取特征

234
00:10:46,914 --> 00:10:49,750
下一步是定义训练循环

235
00:10:49,750 --> 00:10:51,385
并指定您想要训练的

236
00:10:51,385 --> 00:10:53,854
迭代次数

237
00:10:53,854 --> 00:10:57,891
在继续之前 我将导入
Swift Algorithms 开源软件包

238
00:10:57,891 --> 00:11:01,328
我将用它来创建批量训练数据

239
00:11:01,328 --> 00:11:02,796
请务必查看 WWDC 2021 的

240
00:11:02,796 --> 00:11:05,332
“认识 Swift 算法
和集合包”讲座

241
00:11:05,332 --> 00:11:08,702
以了解更多信息

242
00:11:10,404 --> 00:11:13,507
分批次发生在训练循环内

243
00:11:13,507 --> 00:11:15,709
我将使用 chunks 方法
将特征分组为批次

244
00:11:15,709 --> 00:11:18,345
以便进行训练

245
00:11:18,345 --> 00:11:20,347
块大小是一次性加载到内存中的

246
00:11:20,347 --> 00:11:23,116
特征数量

247
00:11:23,116 --> 00:11:26,520
然后 我通过迭代批次

248
00:11:26,520 --> 00:11:28,655
调用 update 方法来更新模型

249
00:11:31,491 --> 00:11:33,293
当您增量训练模型时

250
00:11:33,293 --> 00:11:35,495
您可以解锁更多的训练技巧

251
00:11:35,495 --> 00:11:36,597
例如

252
00:11:36,597 --> 00:11:39,066
在这个训练图中
经过大约 10 次迭代

253
00:11:39,066 --> 00:11:42,669
模型精度就会稳定在 95%

254
00:11:42,669 --> 00:11:45,005
此时模型已经收敛

255
00:11:45,005 --> 00:11:46,640
您可以提前停止

256
00:11:46,640 --> 00:11:50,511
让我们在训练循环中实施提前停止

257
00:11:50,511 --> 00:11:52,779
我需要做的第一件事是

258
00:11:52,779 --> 00:11:54,581
对我的验证集进行预测

259
00:11:54,581 --> 00:11:56,350
我在这里使用了
mapFeatures 方法

260
00:11:56,350 --> 00:11:58,819
因为我需要将验证集预测结果
与其标注数据

261
00:11:58,819 --> 00:12:01,722
进行配对

262
00:12:01,722 --> 00:12:04,691
下一步是衡量模型的质量

263
00:12:04,691 --> 00:12:06,760
我现在将使用内置衡量标准

264
00:12:06,760 --> 00:12:08,128
但没有什么能阻止您

265
00:12:08,128 --> 00:12:10,664
实施自定义标准

266
00:12:10,664 --> 00:12:12,499
最后 我将

267
00:12:12,499 --> 00:12:16,270
在模型达到
95% 的精度时 停止训练

268
00:12:16,270 --> 00:12:19,506
在训练循环之外
我会将模型写入磁盘

269
00:12:19,506 --> 00:12:22,843
以便以后使用它进行预测

270
00:12:22,843 --> 00:12:24,378
除了提前停止

271
00:12:24,378 --> 00:12:26,780
我还想谈谈模型检查点

272
00:12:28,549 --> 00:12:30,984
您可以在训练期间保存模型的进度

273
00:12:30,984 --> 00:12:33,153
而不是等到最后

274
00:12:33,153 --> 00:12:34,788
您甚至可以使用检查点来恢复训练

275
00:12:34,788 --> 00:12:37,424
这很方便

276
00:12:37,424 --> 00:12:41,328
尤其是在模型需要很长时间
来训练时

277
00:12:41,328 --> 00:12:45,032
您需要做的就是在训练循环中
保存您的模型

278
00:12:45,032 --> 00:12:47,501
我们建议通过定义检查点间隔

279
00:12:47,501 --> 00:12:49,469
每隔几次迭代就这样做一次

280
00:12:49,469 --> 00:12:51,605
就这么简单

281
00:12:51,605 --> 00:12:54,675
在本讲座中 我介绍了时序组件

282
00:12:54,675 --> 00:12:56,643
这是一种通过时序数据
比如音频和视频

283
00:12:56,643 --> 00:13:00,247
构建机器学习任务的新方法

284
00:13:00,247 --> 00:13:02,916
我将时序组件组合在一起

285
00:13:02,916 --> 00:13:05,752
以制作人体动作重复次数计数器

286
00:13:05,752 --> 00:13:08,922
最后 我谈到了增量拟合

287
00:13:08,922 --> 00:13:10,724
这将为您开启新的可能性

288
00:13:10,724 --> 00:13:13,427
以便将机器学习构建到
您的 App 中

289
00:13:13,427 --> 00:13:16,763
感谢您的光临
请畅享 WWDC 的其余部分

290
00:13:16,763 --> 00:13:21,301
♪

