1
00:00:00,334 --> 00:00:07,341
♪ ♪

2
00:00:09,309 --> 00:00:13,113
David Stites: 嗨 欢迎来到
发展您的 Core Data 架构

3
00:00:13,146 --> 00:00:17,718
我叫 David Stites
是 Core Data 团队的一名工程师

4
00:00:17,751 --> 00:00:20,187
在本期讲座中 我很高兴与您讨论

5
00:00:20,220 --> 00:00:24,658
如何在您的 App 中更新和迁移
Core Data 架构

6
00:00:24,691 --> 00:00:29,229
本期讲座的议程是
了解什么是架构迁移

7
00:00:29,263 --> 00:00:33,700
为什么您的 App 必须在更新
其数据模型后执行架构迁移

8
00:00:33,734 --> 00:00:37,070
如何迁移现有架构

9
00:00:37,104 --> 00:00:41,275
以及 CloudKit 和架构迁移如何交互

10
00:00:41,308 --> 00:00:45,812
首先 什么是架构迁移
以及为什么在更新数据模型时

11
00:00:45,846 --> 00:00:47,681
App 必须迁移

12
00:00:49,049 --> 00:00:54,788
由于涉及到 App
可能有必要更改您的数据模型

13
00:00:54,821 --> 00:00:58,592
更新数据模型需要在底层存储架构中

14
00:00:58,625 --> 00:01:00,861
具体化这些更改

15
00:01:00,894 --> 00:01:02,763
考虑一下这个数据模型

16
00:01:02,796 --> 00:01:06,200
这有一个 Aircraft 实体 它有两个属性

17
00:01:06,233 --> 00:01:09,136
即类型和发动机数量

18
00:01:09,169 --> 00:01:13,440
这些属性反映在底层存储中

19
00:01:13,473 --> 00:01:16,677
如果我添加了“乘客数量”属性

20
00:01:16,710 --> 00:01:20,147
那我需要添加相应的存储

21
00:01:20,180 --> 00:01:25,285
迁移后 更改完全反映在底层存储中

22
00:01:25,319 --> 00:01:28,488
如果不迁移底层存储中的更改

23
00:01:28,522 --> 00:01:31,792
Core Data 将拒绝打开您的持久存储

24
00:01:31,825 --> 00:01:36,897
因为新更改的模型
与用于存储的模型不匹配

25
00:01:36,930 --> 00:01:40,868
试图打开不兼容的存储将导致代码

26
00:01:40,901 --> 00:01:45,873
NSPersistentStore-
IncompatibleVersionHashError出错

27
00:01:45,906 --> 00:01:48,675
如果您收到此错误
这应该是在指示您

28
00:01:48,709 --> 00:01:51,512
需要进行迁移

29
00:01:51,545 --> 00:01:54,548
现在我已经解释了什么是架构迁移

30
00:01:54,581 --> 00:01:56,850
以及为什么它对开发 App 至关重要

31
00:01:56,884 --> 00:01:59,553
让我来告诉您迁移是如何完成的

32
00:01:59,586 --> 00:02:02,523
Core Data 具有内置的数据迁移工具

33
00:02:02,556 --> 00:02:08,028
可帮助您的 App 进行数据存储
使其与当前数据模型保持同步

34
00:02:08,061 --> 00:02:12,566
这些工具统称为“轻量级迁移”

35
00:02:14,067 --> 00:02:17,905
轻量级迁移是首选的迁移方法

36
00:02:17,938 --> 00:02:22,643
轻量级迁移从源
和目标托管对象模型之间的

37
00:02:22,676 --> 00:02:27,581
差异自动分析和推断迁移

38
00:02:27,614 --> 00:02:31,518
在运行时
Core Data 在 NSBundle 类的

39
00:02:31,552 --> 00:02:36,757
.allBundles 和 .allFrameworks 方法
返回的包中查找模型

40
00:02:36,790 --> 00:02:39,760
然后轻量级迁移
会生成一个映射模型

41
00:02:39,793 --> 00:02:44,231
将您在 App 中所做的更改
具体化到您的数据库架构中

42
00:02:45,966 --> 00:02:49,803
使用轻量级迁移需要
对数据模型进行更改

43
00:02:49,837 --> 00:02:52,239
以适应明显的迁移架构

44
00:02:54,041 --> 00:02:57,110
涉及属性的轻量级操作

45
00:02:57,144 --> 00:03:00,614
包括添加属性 移除属性

46
00:03:00,647 --> 00:03:04,084
将非可选属性变为可选

47
00:03:04,117 --> 00:03:07,087
将可选属性变为非可选

48
00:03:07,120 --> 00:03:09,423
并定义默认值

49
00:03:09,456 --> 00:03:11,391
以及重命名属性

50
00:03:11,425 --> 00:03:15,062
如果您想要重命名属性
请将目标模型中的

51
00:03:15,095 --> 00:03:16,864
重命名标识符

52
00:03:16,897 --> 00:03:19,366
设置为源模型中相应属性的名称

53
00:03:20,534 --> 00:03:22,236
重命名标识符位于

54
00:03:22,269 --> 00:03:25,973
Xcode 数据模型编辑器的
属性检查器中

55
00:03:26,006 --> 00:03:28,575
例如 您可以将

56
00:03:28,609 --> 00:03:32,713
Aircraft 实体的颜色属性
重命名为 paintColor

57
00:03:32,746 --> 00:03:35,749
重命名标识符要创建一个规范名称

58
00:03:35,782 --> 00:03:38,719
因此将重命名标识符
设置为源模型中属性的名称

59
00:03:38,752 --> 00:03:43,490
除非该属性已经具有重命名标识符

60
00:03:43,524 --> 00:03:47,661
这意味着您可以在模型的
版本 2 中重命名一个属性

61
00:03:47,694 --> 00:03:50,497
然后在版本 3 中再次重命名它

62
00:03:50,531 --> 00:03:55,002
重命名将从版本 2 到版本 3
或者从版本 1 到版本 3

63
00:03:55,035 --> 00:03:58,539
正确工作

64
00:04:00,240 --> 00:04:03,544
轻量级迁移还可以毫不费力地

65
00:04:03,577 --> 00:04:05,479
处理关系的变化

66
00:04:05,512 --> 00:04:10,150
您可以添加新关系或删除现有关系

67
00:04:10,184 --> 00:04:13,787
您还可以通过使用重命名标识符
来重命名关系

68
00:04:13,820 --> 00:04:15,989
就跟属性一样

69
00:04:16,023 --> 00:04:19,259
此外 您还可以更改关系基数

70
00:04:19,293 --> 00:04:23,630
例如 从一对一迁移到一对多

71
00:04:23,664 --> 00:04:27,668
或者从无序的一对多
迁移到有序的一对多 反之亦然

72
00:04:29,236 --> 00:04:32,539
如果您猜测实体也有资格
进行轻量级迁移

73
00:04:32,573 --> 00:04:33,974
那么您是对的

74
00:04:34,007 --> 00:04:38,145
您可以添加新实体 删除现有实体

75
00:04:38,178 --> 00:04:40,547
以及重命名实体

76
00:04:40,581 --> 00:04:43,750
您还可以创建新的父实体或子实体

77
00:04:43,784 --> 00:04:48,488
并在实体层次结构中上下移动属性

78
00:04:48,522 --> 00:04:53,594
您可以将实体移入或移出层次结构

79
00:04:53,627 --> 00:04:56,530
但是不能合并实体层次结构

80
00:04:56,563 --> 00:05:00,534
如果两个现有实体
在源中不共享公共父级

81
00:05:00,567 --> 00:05:03,237
则它们无法在目标中共享公共父级

82
00:05:03,270 --> 00:05:07,841
轻量级迁移由两个选项键控制

83
00:05:07,875 --> 00:05:11,545
NSMigratePersistent-
StoresAutomaticallyOption

84
00:05:11,578 --> 00:05:16,383
和 NSInferMappingModelAutomaticallyOption

85
00:05:16,416 --> 00:05:19,386
将存储添加到持久性协调器时

86
00:05:19,419 --> 00:05:23,056
如果检测到持久性存储
不再匹配当前模型

87
00:05:23,090 --> 00:05:26,727
这两个将值设置为真的键的存在

88
00:05:26,760 --> 00:05:31,031
将导致核心数据自动执行轻量级迁移

89
00:05:31,064 --> 00:05:33,667
如果您使用 NSPersistentContainer

90
00:05:33,700 --> 00:05:36,203
或 NSPersistentStoreDescription

91
00:05:36,236 --> 00:05:38,605
这些选项会自动为您设置

92
00:05:38,639 --> 00:05:41,275
您无需执行任何操作

93
00:05:41,308 --> 00:05:43,443
如果您使用的是替代 API

94
00:05:43,477 --> 00:05:47,648
例如 .NSPersistentStoreCoordinator
.addPersistentStore

95
00:05:47,681 --> 00:05:50,918
(type:configuration:at:options:)

96
00:05:50,951 --> 00:05:56,857
可以通过设置和传递带有能够将
NSMigratePersistent-StoresAutomaticallyOption

97
00:05:56,890 --> 00:06:02,496
和 NSInferMappingModelAutomaticallyOption 的值
设置为 YES 的键的

98
00:06:02,529 --> 00:06:07,968
选项字典 NSMigratePersistent-StoresAutomaticallyOption
来请求轻量级迁移

99
00:06:08,001 --> 00:06:11,138
如果 Core Data 检测到持久存储
不再匹配当前模型

100
00:06:11,171 --> 00:06:15,676
它将自动执行轻量级迁移

101
00:06:16,910 --> 00:06:19,379
以下是它在代码中的工作方式

102
00:06:19,413 --> 00:06:23,684
首先我将导入 CoreData
并创建一个托管对象模型

103
00:06:23,717 --> 00:06:27,020
然后我将使用刚刚创建的模型

104
00:06:27,054 --> 00:06:29,923
创建一个持久存储协调器

105
00:06:29,957 --> 00:06:33,527
请注意我创建的选项字典
当我将存储添加到持久协调器时

106
00:06:33,560 --> 00:06:36,663
我将传递这个字典

107
00:06:36,697 --> 00:06:39,333
最后 我将把存储添加到协调器中

108
00:06:39,366 --> 00:06:43,604
如果需要 迁移将自动进行

109
00:06:43,637 --> 00:06:48,876
不管您使用什么 API
对数据模型的更改都可以直接

110
00:06:48,909 --> 00:06:52,579
在 App 附带的同一个模型中进行

111
00:06:52,613 --> 00:06:56,617
无需创建模型的新版本即可进行更改

112
00:06:56,650 --> 00:07:00,087
如果您想提前确定 Core Data
是否可以推断

113
00:07:00,120 --> 00:07:04,157
源模型和目标模型之间的映射模型

114
00:07:04,191 --> 00:07:06,593
而不需要实际进行迁移工作

115
00:07:06,627 --> 00:07:11,465
那么可以使用
NSMappingModel.inferredMappingModel 方法

116
00:07:11,498 --> 00:07:16,036
如果 Core Data 能够创建推断模型
则该方法将返回该模型

117
00:07:16,069 --> 00:07:18,071
否则 它将返回 nil

118
00:07:19,339 --> 00:07:22,176
有时 对模式的组合更改

119
00:07:22,209 --> 00:07:25,212
可能会超出轻量级迁移的能力

120
00:07:25,245 --> 00:07:28,282
我将向您描述如何处理该问题

121
00:07:28,315 --> 00:07:30,751
并仍然使用轻量级迁移

122
00:07:31,518 --> 00:07:36,089
回到我们之前的示例模型
假设我们之前添加了

123
00:07:36,123 --> 00:07:42,095
一个名为 flightData 的属性 该属性
使用外部存储来存储二进制数据

124
00:07:42,129 --> 00:07:46,233
由存储在 FLIGHT_DATA 中的
文件路径来指示

125
00:07:46,266 --> 00:07:49,503
此外 假设需要更改该属性

126
00:07:49,536 --> 00:07:53,707
以在内部存储数据并删除外部存储

127
00:07:53,740 --> 00:07:57,177
检查此迁移是否符合
轻量级迁移的任何功能

128
00:07:57,211 --> 00:08:00,948
然后发现它不符合

129
00:08:00,981 --> 00:08:03,317
从表面上看 我们似乎陷入了困境

130
00:08:03,350 --> 00:08:04,985
无法进行此更改

131
00:08:05,018 --> 00:08:06,453
但是不要害怕

132
00:08:06,486 --> 00:08:10,591
轻量级迁移仍可用于执行更复杂
且不一致的迁移

133
00:08:10,624 --> 00:08:14,761
尽管需要多个步骤

134
00:08:16,330 --> 00:08:20,434
目标是将不符合轻量级迁移条件的

135
00:08:20,467 --> 00:08:23,070
迁移任务分解为

136
00:08:23,103 --> 00:08:28,242
符合轻量级迁移条件的最小迁移系列

137
00:08:28,275 --> 00:08:33,981
通常 如果原始模型为 A
目标模型为 B

138
00:08:34,014 --> 00:08:36,817
但模型 B 的变更不符合

139
00:08:36,850 --> 00:08:40,721
轻量级迁移的条件
则可以通过引入一个或多个

140
00:08:40,754 --> 00:08:45,158
分解这些变更的模型版本来创建桥梁

141
00:08:46,827 --> 00:08:51,331
每一个引入的模型
都将具有一个或多个操作

142
00:08:51,365 --> 00:08:55,802
这些操作在组成不一致变更的
能力范围之内

143
00:08:55,836 --> 00:08:58,205
这导致了一系列的迁移

144
00:08:58,238 --> 00:09:01,575
其中每个模型现在是轻量级可迁移的

145
00:09:01,608 --> 00:09:05,279
但是等同于不一致的迁移

146
00:09:05,312 --> 00:09:07,781
回到不适合轻量级迁移的

147
00:09:07,814 --> 00:09:11,752
示例 我们的原始模型是模型 A

148
00:09:11,785 --> 00:09:16,957
我将通过引入新模型版本 A'
来开始分解任务

149
00:09:16,990 --> 00:09:20,794
并添加一个新属性 tmpStorage

150
00:09:20,827 --> 00:09:25,199
该属性将临时用于存储
从外部文件导入的数据

151
00:09:26,333 --> 00:09:29,303
接下来我将
把数据从外部文件导入到

152
00:09:29,336 --> 00:09:31,371
我们的新属性中

153
00:09:31,405 --> 00:09:33,674
导入此数据的代码

154
00:09:33,707 --> 00:09:37,010
与 Core Data 提供的功能是分开的

155
00:09:37,044 --> 00:09:41,715
该导入的执行介于两次迁移之间

156
00:09:42,683 --> 00:09:45,185
安全导入数据后

157
00:09:45,219 --> 00:09:50,657
我将从 A' 创建
另一个新版本的模型 A''

158
00:09:50,691 --> 00:09:55,028
在 A'' 中 我将删除旧的外部存储属性

159
00:09:55,062 --> 00:09:58,232
同时重命名新属性

160
00:09:58,265 --> 00:10:03,470
我描述的每个步骤
都在轻量级迁移的能力范围内

161
00:10:04,438 --> 00:10:09,076
直观地说 可以构建一个事件循环

162
00:10:09,109 --> 00:10:11,478
使用轻量级迁移选项集打开持久存储

163
00:10:11,512 --> 00:10:16,216
并以串行顺序迭代地
遍历每个未处理的模型

164
00:10:16,250 --> 00:10:19,253
Core Data 将迁移存储

165
00:10:19,286 --> 00:10:22,723
如果您在迁移期间
执行特定于 App 的逻辑

166
00:10:22,756 --> 00:10:26,927
例如在上一个示例中
我是如何从外部文件导入数据的

167
00:10:26,960 --> 00:10:31,832
那么在迁移因进程终止
而中断的情况下

168
00:10:31,865 --> 00:10:33,800
该逻辑必须是可重启的

169
00:10:34,668 --> 00:10:36,904
如果您的 App
使用 Core Data 和 CloudKit

170
00:10:36,937 --> 00:10:39,373
那么在使用 Core Data
设计数据模型时

171
00:10:39,406 --> 00:10:42,142
您应该牢记一些要点

172
00:10:42,176 --> 00:10:46,914
要在 Core Data 存储和
CloudKit 数据库之间传递记录

173
00:10:46,947 --> 00:10:51,285
它们需要对数据模型有共同的理解

174
00:10:51,318 --> 00:10:55,389
您可以在 Core Data 模型编辑器中
定义此模型

175
00:10:55,422 --> 00:10:59,860
该模型随后用于生成 CloudKit 架构

176
00:10:59,893 --> 00:11:04,264
生成的架构最初
是在开发环境中创建的

177
00:11:04,298 --> 00:11:07,067
然后升级到生产环境

178
00:11:07,100 --> 00:11:10,504
您应该意识到了 CloudKit 并不支持
Core Data 模型的

179
00:11:10,537 --> 00:11:12,406
所有功能

180
00:11:12,439 --> 00:11:16,109
设计模型时 请注意以下限制

181
00:11:16,143 --> 00:11:18,612
并创建兼容的数据模型

182
00:11:18,645 --> 00:11:23,417
例如 不支持对实体的唯一约束

183
00:11:23,450 --> 00:11:28,856
不支持将 undefined 和 objectID
属性类型作为其属性类型

184
00:11:28,889 --> 00:11:34,461
并且关系必须是可选的
并且具有反向关系

185
00:11:34,494 --> 00:11:38,899
此外 CloudKit 不支持拒绝删除规则

186
00:11:38,932 --> 00:11:43,937
在开发 App 时 您将使用开发环境

187
00:11:43,971 --> 00:11:48,475
CloudKit 架构可以在此环境中
自由修改

188
00:11:48,509 --> 00:11:51,612
但是 将架构升级到生产模式后

189
00:11:51,645 --> 00:11:54,882
记录类型及其字段是不可变的

190
00:11:54,915 --> 00:11:58,919
虽然轻量级迁移
可以处理许多不同的场景

191
00:11:58,952 --> 00:12:02,523
但 CloudKit 在它支持的内容上
受到更多限制

192
00:12:02,556 --> 00:12:07,561
我之前描述的许多轻量级操作
都不受支持

193
00:12:07,594 --> 00:12:10,998
具体来说 CloudKit 支持

194
00:12:11,031 --> 00:12:16,203
向现有记录类型添加新字段
和添加新记录类型

195
00:12:16,236 --> 00:12:21,441
您不能修改或删除
现有的记录类型或字段

196
00:12:21,475 --> 00:12:25,245
修改模型架构时 请考虑这些限制

197
00:12:26,680 --> 00:12:28,949
当需要更新数据模型时

198
00:12:28,982 --> 00:12:33,153
请记住轻量级迁移
仅在本地存储文件中实现

199
00:12:33,187 --> 00:12:35,155
架构更改

200
00:12:35,189 --> 00:12:38,859
无论 CloudKit 是否使用特定存储

201
00:12:38,892 --> 00:12:42,162
迁移只会更改磁盘上的存储

202
00:12:42,196 --> 00:12:45,799
而不会更改 CloudKit 架构

203
00:12:45,832 --> 00:12:48,001
您仍然需要通过运行架构初始化程序

204
00:12:48,035 --> 00:12:52,172
在开发数据库中使这些更改具体化

205
00:12:52,206 --> 00:12:55,042
然后使用 CloudKit 控制台

206
00:12:55,075 --> 00:12:58,212
将开发中的这些更改提升到生产中

207
00:12:58,245 --> 00:13:02,216
请记住 您的 App 用户
将同时使用旧版本

208
00:13:02,249 --> 00:13:04,384
和新版本

209
00:13:04,418 --> 00:13:06,954
最新版 App 当然会知道

210
00:13:06,987 --> 00:13:09,823
架构中所有新添加的功能

211
00:13:09,857 --> 00:13:14,127
旧版 App 不会知道
新字段或记录类型

212
00:13:15,863 --> 00:13:18,866
由于 CloudKit 架构本质上是附加的

213
00:13:18,899 --> 00:13:22,069
因此请考虑将架构迁移到

214
00:13:22,102 --> 00:13:24,938
运行旧版 App 设备上的影响

215
00:13:24,972 --> 00:13:29,743
例如 一个常见的缺陷是
忘记更新旧版 App

216
00:13:29,776 --> 00:13:33,747
从而使用新版本已不使用的旧字段

217
00:13:33,780 --> 00:13:37,885
下面是一些
迁移 CloudKit 架构的策略

218
00:13:37,918 --> 00:13:43,090
第一种选择是以增量方式
向现有记录类型添加新字段

219
00:13:43,123 --> 00:13:47,227
如果您采用这种方法
旧版 App 将可以访问

220
00:13:47,261 --> 00:13:50,964
用户创建的每条记录
但不能访问每个字段

221
00:13:52,332 --> 00:13:55,102
第二个选项是通过包含版本属性

222
00:13:55,135 --> 00:13:59,006
来对实体进行版本设置
然后使用提取请求

223
00:13:59,039 --> 00:14:03,110
仅选择与 App 当前版本兼容的记录

224
00:14:04,077 --> 00:14:07,714
如果您采用这种方法 旧版 App

225
00:14:07,748 --> 00:14:11,752
将无法获取
用户使用较新版本创建的记录

226
00:14:11,785 --> 00:14:15,122
从而有效地将它们隐藏在该设备上

227
00:14:15,155 --> 00:14:18,525
最后一个策略是使用

228
00:14:18,559 --> 00:14:21,595
NSPersistentCloudKitContainerOptions
创建一个全新的容器

229
00:14:21,628 --> 00:14:25,032
将新的存储与新的容器相关联

230
00:14:25,065 --> 00:14:28,068
请注意 如果用户有一个大型数据集

231
00:14:28,101 --> 00:14:33,106
将数据集上传到
iCloud 可能需要很长时间

232
00:14:33,140 --> 00:14:37,244
无论您使用哪种方法
都要小心设计您的数据模型

233
00:14:37,277 --> 00:14:40,948
一定要考虑跨版本的兼容性问题

234
00:14:40,981 --> 00:14:44,518
并一起测试不同版本的数据模型

235
00:14:44,551 --> 00:14:47,020
既然我们已经彻底讨论了数据模型

236
00:14:47,054 --> 00:14:51,124
迁移和 CloudKit
那么我来实际演示一下

237
00:14:51,158 --> 00:14:54,161
您可能已经猜到了 我是一名飞行员

238
00:14:54,194 --> 00:14:57,264
我创建了一个小 App
来记录我的飞行时间

239
00:14:57,297 --> 00:14:59,499
这是该 App 的数据模型

240
00:14:59,533 --> 00:15:04,037
我有一个名为 LogEntry 的实体
并添加了许多属性

241
00:15:04,071 --> 00:15:09,443
例如飞机类型 飞行时间
始发地 目的地和尾号

242
00:15:09,476 --> 00:15:14,414
可以让我记录需要的体验信息

243
00:15:14,448 --> 00:15:16,817
当我第一次运行这个 App 时

244
00:15:16,850 --> 00:15:21,455
Core Data 将创建存储
并在该存储中实现架构

245
00:15:21,488 --> 00:15:23,190
在运行 App 之前

246
00:15:23,223 --> 00:15:28,128
我将打开
com.Apple.CoreData.SQLDebug

247
00:15:28,161 --> 00:15:34,001
和 com.apple.CoreData.MigrationDebug
环境变量

248
00:15:34,034 --> 00:15:37,704
这会使 Core Data 记录
它正在执行的步骤

249
00:15:37,738 --> 00:15:40,574
有了这些参数 我将运行该 App

250
00:15:42,342 --> 00:15:46,180
随着 App 启动
Core Data 在记录它正在执行的步骤

251
00:15:46,213 --> 00:15:49,716
创建文件 为存储创建元数据

252
00:15:49,750 --> 00:15:52,019
以及实现架构

253
00:15:52,052 --> 00:15:56,623
SQLite 使用我们的架构创建了
表 ZLOGENTRY

254
00:15:56,657 --> 00:15:59,526
这也可以通过使用
sqlite3 命令行工具

255
00:15:59,560 --> 00:16:02,262
查看存储文件来确认

256
00:16:02,296 --> 00:16:07,201
在这里 我有一个 LogEntry 表
它有与我在

257
00:16:07,234 --> 00:16:09,970
数据模型中创建的属性对应的列

258
00:16:10,003 --> 00:16:12,973
现在我要做一些轻量级的改动

259
00:16:14,341 --> 00:16:18,445
我正在添加一些新的实体
Aircraft Pilot 和 Airport

260
00:16:18,478 --> 00:16:21,081
这会帮助我规范化架构

261
00:16:21,114 --> 00:16:26,086
我正在将 LogEntry 实体中的
一些属性更改为关系

262
00:16:26,119 --> 00:16:30,958
例如 目的地和始发地
从字符串属性转变为

263
00:16:30,991 --> 00:16:34,061
机场一对一关系

264
00:16:34,094 --> 00:16:37,164
Airport 实体还有两个新属性

265
00:16:37,197 --> 00:16:40,534
即 icaoIdentifier 和 faaIdentifier

266
00:16:40,567 --> 00:16:44,304
type 属性被提升为
一个新实体 Aircraft

267
00:16:44,338 --> 00:16:49,343
我添加了两个新属性
tailNumber 和 registrationNumber

268
00:16:49,376 --> 00:16:55,249
在 LogEntry 上 我正在从 LogEntry
创建与飞机的一对一关系

269
00:16:56,416 --> 00:17:01,522
最后 我添加了一个具有名称
和证书 ID 的 Pilot 实体

270
00:17:02,589 --> 00:17:06,393
每个日志条目
将与一个 Pilot 实体相关

271
00:17:06,426 --> 00:17:09,296
现在我已经完成了对数据模型的更改

272
00:17:09,329 --> 00:17:10,998
我将再次运行该 App

273
00:17:15,235 --> 00:17:19,039
噢 我在运行 App 时收到一个错误

274
00:17:19,072 --> 00:17:20,774
检查一下代码

275
00:17:20,807 --> 00:17:24,845
是 NSPersistentStore-
IncompatibleVersionHashError

276
00:17:24,878 --> 00:17:28,448
该错误意味着我当前模型的架构
不再与存储中的模型

277
00:17:28,482 --> 00:17:30,184
相匹配

278
00:17:30,217 --> 00:17:32,719
我需要迁移存储架构

279
00:17:32,753 --> 00:17:35,355
我可以通过以下三种方式中的一种
来做到这一点

280
00:17:35,389 --> 00:17:40,761
使用第一种方法 我可以将我的代码
转换为使用 NSPersistentContainer

281
00:17:40,794 --> 00:17:45,799
因为轻量级迁移选项会自动为我设置

282
00:17:45,832 --> 00:17:50,337
第二种方法 我可以使用
NSPersistentStoreDescription

283
00:17:50,370 --> 00:17:55,375
因为轻量级迁移选项
也会自动为我设置

284
00:17:55,409 --> 00:17:58,812
最后 使用第三种方法 我可以

285
00:17:58,846 --> 00:18:02,115
在选项字典上
手动设置轻量级迁移选项

286
00:18:02,149 --> 00:18:06,119
并在打开存储时
将该字典传递给协调器

287
00:18:06,987 --> 00:18:11,225
我想我会选择第一个选项
使用 NSPersistentContainer

288
00:18:11,258 --> 00:18:15,295
现在我已将代码转换为使用
NSPersistentContainer

289
00:18:15,329 --> 00:18:17,431
我将启动 App 并再次观察到

290
00:18:17,464 --> 00:18:20,467
Core Data 正在迁移
存储文件中的架构

291
00:18:32,012 --> 00:18:36,850
同样这可以使用
sqlite3 命令行工具来确认

292
00:18:36,884 --> 00:18:40,621
请注意 Core Data 使用轻量级迁移

293
00:18:40,654 --> 00:18:42,256
自动实现了新架构

294
00:18:42,289 --> 00:18:44,525
还有什么比这更容易呢

295
00:18:44,558 --> 00:18:48,562
在结束演示之前
我想展示第 3 个选项

296
00:18:48,595 --> 00:18:50,931
回想一下 在此选项中

297
00:18:50,964 --> 00:18:54,168
我在选项字典上手动设置
轻量级迁移选项

298
00:18:54,201 --> 00:18:58,739
然后在打开存储时
将该字典传递给协调器

299
00:18:58,772 --> 00:19:00,073
最终结果是相同的

300
00:19:00,107 --> 00:19:02,976
因为存储迁移到了新架构

301
00:19:03,010 --> 00:19:07,748
当对数据模型进行更改时
请使用轻量级迁移来帮助您

302
00:19:07,781 --> 00:19:11,385
对于绝大多数数据模型更改来说

303
00:19:11,418 --> 00:19:14,788
轻量级迁移非常灵活且易于使用

304
00:19:14,821 --> 00:19:18,692
如果您有更复杂的数据模型

305
00:19:18,725 --> 00:19:22,062
请将该模型分解成
由轻量级变化组成的模型

306
00:19:22,095 --> 00:19:24,965
最后如果您在 App 中使用 CloudKit

307
00:19:24,998 --> 00:19:29,303
请仔细考虑数据模型更改的影响

308
00:19:29,336 --> 00:19:32,506
彻底测试所有数据模型更改

309
00:19:32,539 --> 00:19:34,808
我希望您会发现这些信息很有用

310
00:19:34,842 --> 00:19:37,611
并且会考虑更新项目中的模型

311
00:19:37,644 --> 00:19:40,047
来构建一些很棒的新功能

312
00:19:40,080 --> 00:19:43,884
感谢您与我一起飞行
祝您的 WWDC 之旅一切顺利

