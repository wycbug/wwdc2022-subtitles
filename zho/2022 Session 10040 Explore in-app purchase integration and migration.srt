1
00:00:00,334 --> 00:00:07,341
♪ ♪

2
00:00:09,309 --> 00:00:11,011
Gabriel Ting:
大家好 欢迎大家收看我们的课程

3
00:00:11,044 --> 00:00:14,214
探索 App 内购买项目集成和迁移

4
00:00:14,248 --> 00:00:17,584
本次课程分为两部分
一部分专门介绍

5
00:00:17,618 --> 00:00:20,287
迁移到 App Store Server API
另一部分专门介绍

6
00:00:20,320 --> 00:00:22,956
迁移到 App Store Server
Notifications Version 2

7
00:00:22,990 --> 00:00:24,458
我叫 Gabriel 我会向大家介绍

8
00:00:24,491 --> 00:00:27,628
如何迁移到 App Store Server API

9
00:00:27,661 --> 00:00:29,830
我叫 Alex 我将带大家了解

10
00:00:29,863 --> 00:00:33,200
迁移到 App Store Server
Notifications Version 2 的过程

11
00:00:33,233 --> 00:00:36,670
我们先来简单介绍一下
App Store Server API

12
00:00:36,703 --> 00:00:38,639
和 App Store Server Notifications

13
00:00:38,672 --> 00:00:42,342
我们去年引入了
App Store Server API

14
00:00:42,376 --> 00:00:45,946
将其作为一种强大 安全和高效的
从服务器获取数据和执行操作的方法

15
00:00:45,979 --> 00:00:48,482
我们的目标是为大家提供
所需的数据

16
00:00:48,515 --> 00:00:51,885
这些数据是以 JSON Web Signature
或 JWS 格式签名的

17
00:00:51,919 --> 00:00:55,022
这样你就可以验证你收到的数据
是未经篡改的

18
00:00:55,055 --> 00:00:58,125
为你准备的
以及由 App Store 签名的

19
00:00:58,158 --> 00:01:00,894
例如我们的 App Store Server API
的一个接口：

20
00:01:00,928 --> 00:01:03,864
Get Transaction History 接口
与新的筛选和排序功能相结合

21
00:01:03,897 --> 00:01:07,134
可以让你只用一个
originalTransactionId

22
00:01:07,167 --> 00:01:10,337
就能获取任何指定的交易集

23
00:01:10,370 --> 00:01:13,473
在 App Store Notifications
Version 2 的窗格中

24
00:01:13,507 --> 00:01:16,944
随着表示订阅状态数量的增加

25
00:01:16,977 --> 00:01:19,012
Notifications Version 2 将实时更新

26
00:01:19,046 --> 00:01:22,416
订阅的所有可能状态

27
00:01:22,449 --> 00:01:25,152
我们的目标是主动提供你需要了解的

28
00:01:25,185 --> 00:01:27,454
有关订阅者情况的所有信息

29
00:01:27,487 --> 00:01:29,990
而无需向我们索取信息

30
00:01:30,023 --> 00:01:33,427
在本课程中 Alex 将详细介绍这一点

31
00:01:33,460 --> 00:01:36,363
如果你对轻松高效地
使用这些功能感兴趣

32
00:01:36,396 --> 00:01:37,731
本课程的内容就非常适合你

33
00:01:37,764 --> 00:01:41,068
我们将带你了解
如何使用 App Store Server API

34
00:01:41,101 --> 00:01:43,570
和 App Store Server
Notifications Version 2

35
00:01:43,604 --> 00:01:46,840
以及一些迁移技巧和最佳实践

36
00:01:46,874 --> 00:01:48,642
关于这些课程的其他信息

37
00:01:48,675 --> 00:01:51,612
请参阅下面列出的其他课程

38
00:01:53,080 --> 00:01:57,551
我们先来讨论迁移到
App Store Server API 的问题吧

39
00:01:57,584 --> 00:02:02,422
首先 我们将讨论如何使用
App Store Server API

40
00:02:02,456 --> 00:02:06,960
其次 我们将深入研究
签署 JSON Web Tokens 的一些细节

41
00:02:06,994 --> 00:02:09,696
第三 我们将演示如何验证
你从 App Store 收到的

42
00:02:09,730 --> 00:02:13,166
签名交易是否是真实的

43
00:02:13,200 --> 00:02:16,103
最后 我们将讨论如何
从 verifyReceipt

44
00:02:16,136 --> 00:02:19,106
迁移到 App Store Server API

45
00:02:19,139 --> 00:02:20,474
我们开始吧

46
00:02:20,507 --> 00:02:23,143
首先 我们要讨论的是如何
在不同的 StoreKit 版本中

47
00:02:23,177 --> 00:02:27,247
使用 App Store Server API
首先是原始 StoreKit

48
00:02:27,281 --> 00:02:30,651
然后是 StoreKit 2
然后讨论如何同时支持

49
00:02:30,684 --> 00:02:34,821
两个顾客端使用支持
StoreKit 2 的 iOS 版本

50
00:02:34,855 --> 00:02:38,358
即 iOS 15 或更高版本
以及那些不支持 StoreKit 2 的顾客端

51
00:02:39,092 --> 00:02:41,128
首先 让我们看看
App Store Server API 的

52
00:02:41,161 --> 00:02:43,630
请求是什么样子的

53
00:02:43,664 --> 00:02:47,701
我们可以看到 这里列出的五个 API
都使用 originalTransactionID

54
00:02:47,734 --> 00:02:49,102
作为路径参数

55
00:02:49,136 --> 00:02:51,471
让你可以使用从收据

56
00:02:51,505 --> 00:02:54,474
签名交易 签名续订和通知接收到的

57
00:02:54,508 --> 00:02:58,345
originalTransactionId 中
轻松调用这些 API

58
00:02:58,378 --> 00:03:00,881
接下来是 Look Up Order ID 端点

59
00:03:00,914 --> 00:03:04,017
此端点转而使用顾客提供的 orderId

60
00:03:04,051 --> 00:03:05,819
来支持查询

61
00:03:05,853 --> 00:03:09,089
这是为了更好地帮助顾客
直接提出问题

62
00:03:09,122 --> 00:03:13,026
因为顾客在每笔交易的顾客收据中
都会收到 orderId

63
00:03:13,060 --> 00:03:16,029
但没有提供 originalTransactionId

64
00:03:16,063 --> 00:03:18,765
这样可以确保
你可以直接使用顾客手头的数据

65
00:03:18,799 --> 00:03:21,635
来响应顾客的查询

66
00:03:21,668 --> 00:03:24,271
这里列出的最后一个端点与通知相关

67
00:03:24,304 --> 00:03:27,307
Alex 将在本次课程中讨论这个部分

68
00:03:28,442 --> 00:03:31,778
接下来
让我们看看在原始 StoreKit 中

69
00:03:31,812 --> 00:03:33,413
可以从哪里获得
originalTransactionId

70
00:03:33,447 --> 00:03:36,116
使用统一 App 收据调用
verifyReceipt 时

71
00:03:36,149 --> 00:03:39,853
originalTransactionId 会返回到

72
00:03:39,887 --> 00:03:41,455
该用户购买的

73
00:03:41,488 --> 00:03:44,358
每笔交易收据的 in_app 字段

74
00:03:44,391 --> 00:03:48,262
以及 latest_receipt_info 和
pending_renewal_info 中

75
00:03:48,295 --> 00:03:51,498
现在我们知道了如何从
Original StoreKit 交易中

76
00:03:51,532 --> 00:03:54,668
获取 originalTransactionId
那么让我们看看

77
00:03:54,701 --> 00:03:57,638
顾客 App Store Server 和
你的服务器之间的整个流程

78
00:03:59,173 --> 00:04:02,609
首先 在你的服务器上获取 App 收据

79
00:04:02,643 --> 00:04:06,580
接下来 拿到 App 收据
并从服务器上调用 verifyReceipt

80
00:04:08,549 --> 00:04:11,018
这样就能返回解码后的收据

81
00:04:11,051 --> 00:04:14,555
从解码的收据中
以我之前展示的完全相同的方式

82
00:04:14,588 --> 00:04:17,624
收集所有的 originalTransactionId

83
00:04:17,658 --> 00:04:20,661
接下来 你可以使用收集到的
任何 originalTransactionId

84
00:04:20,694 --> 00:04:24,331
调用 Get Transaction History 端点

85
00:04:24,364 --> 00:04:27,835
这将把该用户的交易历史记录
作为签名交易返回

86
00:04:27,868 --> 00:04:31,171
这些交易包括非消耗品 退款消耗品

87
00:04:31,205 --> 00:04:34,575
不续订订阅和自动续订订阅

88
00:04:34,608 --> 00:04:38,712
然后 如果你要获取特定订阅的

89
00:04:38,745 --> 00:04:43,083
最新签名交易和签名续订信息
请使用

90
00:04:43,116 --> 00:04:45,953
相应的 originalTransactionId 调用
Get All Subscription Statuses 接口

91
00:04:45,986 --> 00:04:48,388
这将返回与给定的
originalTransactionId 对应的

92
00:04:48,422 --> 00:04:52,526
订阅的所有签名交易和续订信息

93
00:04:52,559 --> 00:04:55,796
接下来
让我们看看在 StoreKit 2 交易用例中

94
00:04:55,829 --> 00:04:58,031
originalTransactionId 的位置

95
00:04:58,065 --> 00:05:01,435
这是顾客端上的代码 用于从交易中

96
00:05:01,468 --> 00:05:03,003
获取 originalTransactionId

97
00:05:03,036 --> 00:05:05,038
在支持 StoreKit 2 的设备上

98
00:05:05,072 --> 00:05:08,242
即 iOS 15 或更高版本

99
00:05:08,275 --> 00:05:11,278
你可以在经过验证 已解码的交易中

100
00:05:11,311 --> 00:05:15,082
获取 OriginalID 属性
以获取 OriginalTransactionID

101
00:05:15,115 --> 00:05:19,920
现在 看看服务器端
这是一个签名 JWS 交易的例子

102
00:05:19,953 --> 00:05:24,057
它是你从 App Store Server API
和 App Store Server Notifications 中

103
00:05:24,091 --> 00:05:28,195
收到的签名交易
和签名续订的数据类型

104
00:05:28,228 --> 00:05:32,132
这里 我们看到
originalTransactionId 是一个顶级字段

105
00:05:34,434 --> 00:05:37,204
接下来 让我们看看
顾客 App Store Server

106
00:05:37,237 --> 00:05:41,275
和 StoreKit 2 交易服务器之间的
整个流程

107
00:05:41,308 --> 00:05:44,478
首先 在设备上获取签名交易

108
00:05:44,511 --> 00:05:48,081
使用 StoreKit 2
你可以在设备上验证此交易

109
00:05:48,115 --> 00:05:51,185
使用设备上的状态侦听器
交易侦听器

110
00:05:51,218 --> 00:05:54,488
或最后一笔交易
将让你随时了解最新的交易情况

111
00:05:54,521 --> 00:05:58,492
取消和退款 然后将这些信息
发送到你的服务器进行记录

112
00:05:58,525 --> 00:06:01,061
例如 这些更新包括

113
00:06:01,094 --> 00:06:04,231
订阅续订 订阅报价赎回 过期等

114
00:06:05,532 --> 00:06:07,367
将交易发送到你的服务器

115
00:06:07,401 --> 00:06:09,970
结合
App Store Server Notifications

116
00:06:10,003 --> 00:06:12,439
Alex 将在接下来的部分详细介绍

117
00:06:12,472 --> 00:06:15,108
你无需调用 App Store Server API

118
00:06:15,142 --> 00:06:19,479
就可以了解订阅的最新状态

119
00:06:19,513 --> 00:06:22,516
如果确实需要对订阅执行操作

120
00:06:22,549 --> 00:06:25,452
例如延长订阅的续订日期

121
00:06:25,485 --> 00:06:29,423
你可以使用签名交易中的
originalTransactionId

122
00:06:29,456 --> 00:06:33,293
调用相应的端点并获取所需的数据

123
00:06:33,327 --> 00:06:36,196
现在我们已经了解了如何在
原始 StoreKit 和 StoreKit 2 中

124
00:06:36,230 --> 00:06:39,433
使用 App Store Server API
接下来让我们一起讨论下

125
00:06:39,466 --> 00:06:42,336
如何同时支持 StoreKit
和 StoreKit 2

126
00:06:42,369 --> 00:06:44,605
你可以在完全不采用
StoreKit 2 的情况下

127
00:06:44,638 --> 00:06:47,241
使用 App Store Server API

128
00:06:47,274 --> 00:06:50,077
如前所述
你可以从原始 StoreKit 的收据中

129
00:06:50,110 --> 00:06:52,779
获得 OriginalTransactionID

130
00:06:52,813 --> 00:06:57,651
你还可以从 JWS 交易中获取
StoreKit 2 的 originalTransactionID

131
00:06:59,386 --> 00:07:04,258
你也可以独立于任何其他 API
使用 App Store Server API

132
00:07:04,291 --> 00:07:07,928
它不依赖于使用其他 API 的特定版本

133
00:07:07,961 --> 00:07:09,963
就 App Store Server Notifications
而言

134
00:07:09,997 --> 00:07:13,567
它可以与 Version 1
或 Version 2 通知一起使用

135
00:07:13,600 --> 00:07:16,670
我们建议使用 Version 2 因为它会在

136
00:07:16,703 --> 00:07:21,241
订阅发生变化时
使用安全的 JWS 等格式通知你

137
00:07:21,275 --> 00:07:24,945
Alex 将在本课程的这个部分
对此进行详细介绍

138
00:07:24,978 --> 00:07:27,648
但是 你可以单独使用
App Store Server API

139
00:07:27,681 --> 00:07:31,218
使用 Version 1 通知或完全没有通知

140
00:07:31,251 --> 00:07:34,688
接下来 让我们讨论一下
在完成了我之前介绍的

141
00:07:34,721 --> 00:07:38,292
迁移步骤之后如何处理新的购买

142
00:07:38,325 --> 00:07:41,728
为了在使用原始 StoreKit 的设备上
支持新的购买

143
00:07:41,762 --> 00:07:45,299
你可以在收到新收据时
将其发送到你的服务器上

144
00:07:45,332 --> 00:07:48,202
并执行与我之前展示的
完全相同的步骤

145
00:07:48,235 --> 00:07:50,637
同时收集新数据

146
00:07:50,671 --> 00:07:52,806
使用新收据调用 verifyReceipt

147
00:07:52,840 --> 00:07:57,277
并使用 latest_receipt 中的
新 originalTransactionId

148
00:07:57,311 --> 00:08:01,148
获得解码的收据 将这些
originalTransactionId 与收据的

149
00:08:01,181 --> 00:08:03,050
in_app 部分中的其他
originalTransactionId 相关联

150
00:08:03,083 --> 00:08:06,019
以将你的交易信息分在一个组

151
00:08:06,053 --> 00:08:08,722
然后 你可以获取新的
originalTransactionId

152
00:08:08,755 --> 00:08:11,325
并根据需要调用
App Store Server API

153
00:08:11,358 --> 00:08:14,561
例如 如果需要调用
Get All Subscription Statuses 端点

154
00:08:14,595 --> 00:08:17,998
以获取相应订阅的最新状态

155
00:08:18,031 --> 00:08:20,968
现在 我们已经介绍了
如何将 App Store Server API

156
00:08:21,001 --> 00:08:23,437
与原始 StoreKit 和 StoreKit 2
一起使用

157
00:08:23,470 --> 00:08:26,673
那么让我们深入了解签署
JSON Web Tokens 的一些细节

158
00:08:26,707 --> 00:08:29,776
这是调用
App Store Server API 的要求

159
00:08:29,810 --> 00:08:33,514
为了验证你的开发人员帐户

160
00:08:33,547 --> 00:08:36,583
是 App Store Server API 的调用方

161
00:08:36,617 --> 00:08:39,887
我们用JSON Web Tokens
也就是 JWTs 来验证请求

162
00:08:39,920 --> 00:08:42,256
此令牌必须作为
服务器调用中的授权头

163
00:08:42,289 --> 00:08:45,559
包含在每个请求中

164
00:08:45,592 --> 00:08:49,429
JWT 由 header 有效载荷和签名组成

165
00:08:49,463 --> 00:08:54,001
接下来 我们将讨论如何构造
特定于 APP 的 JWT

166
00:08:55,068 --> 00:08:57,871
在这里 我们可以看到
JSON Web Token 是如何组成的

167
00:08:57,905 --> 00:09:00,541
以及 header 和有效载荷的结构

168
00:09:00,574 --> 00:09:04,778
令牌本身可以分为三个部分
由句点分隔

169
00:09:04,811 --> 00:09:09,016
Base 64 编码的 header
Base 64 编码的有效载荷

170
00:09:09,049 --> 00:09:11,952
然后是签名
由 Base 64 编码的 header

171
00:09:11,985 --> 00:09:16,690
和有效载荷组成 签名使用签名密钥

172
00:09:16,723 --> 00:09:19,593
header 由这些字段组成 其中包含

173
00:09:19,626 --> 00:09:21,929
有关如何对数据进行签名的元数据

174
00:09:21,962 --> 00:09:24,598
这里的一个重要字段是密钥 ID

175
00:09:24,631 --> 00:09:27,501
它是你在 App Store Connect 中的
私钥 ID

176
00:09:27,534 --> 00:09:31,038
这需要与你用来签署 JWT 的
密钥相匹配

177
00:09:32,706 --> 00:09:34,741
有效载荷包含有关

178
00:09:34,775 --> 00:09:37,411
特定 App 的附加信息

179
00:09:37,444 --> 00:09:40,314
有关如何获取 API 密钥的

180
00:09:40,347 --> 00:09:43,684
其他信息和指导 请参阅文章

181
00:09:43,717 --> 00:09:46,553
“Creating API Keys to Use With
the App Store Server API ”

182
00:09:46,587 --> 00:09:48,388
关于每个字段的详细信息

183
00:09:48,422 --> 00:09:52,025
请参阅文章“Generating Tokens
for API Requests”

184
00:09:53,260 --> 00:09:57,030
一旦获得了包含所有适当信息的
header 和有效载荷

185
00:09:57,064 --> 00:09:58,699
接下来将使用与 keyId 对应的证书

186
00:09:58,732 --> 00:10:01,969
对 JWT 进行签名

187
00:10:02,002 --> 00:10:06,340
这是你可以使用的核心伪代码
无论使用何种语言

188
00:10:06,373 --> 00:10:09,209
首先 确保你拥有与我们刚才查看的

189
00:10:09,243 --> 00:10:12,679
header 中提供的密钥 ID
相对应的私钥

190
00:10:12,713 --> 00:10:16,383
然后 用你的私钥 header 和有效载荷

191
00:10:16,416 --> 00:10:19,119
调用你的 JWT 库公开的签名函数

192
00:10:19,152 --> 00:10:21,522
由于 header 包含签名算法

193
00:10:21,555 --> 00:10:25,158
JWT 库根据提供的算法对其进行签名

194
00:10:27,127 --> 00:10:31,298
最后 下面是在验证对
Get All Subscription Statuses 端点的

195
00:10:31,331 --> 00:10:34,434
cURL 调用时该令牌的用法示例

196
00:10:34,468 --> 00:10:36,870
用你生成的令牌值

197
00:10:36,904 --> 00:10:38,906
和所需的 OriginalTransactionID 值

198
00:10:38,939 --> 00:10:41,909
分别替换 $
和 $

199
00:10:41,942 --> 00:10:45,479
接下来 让我们谈谈如何验证
你收到的签名交易

200
00:10:45,512 --> 00:10:49,316
是为你所用
并且是由 App Store 签名的

201
00:10:49,349 --> 00:10:51,552
签名交易本质上

202
00:10:51,585 --> 00:10:54,454
是 JavaScript 对象表示法或 JSON

203
00:10:54,488 --> 00:10:57,157
这些对象是经过加密签名的
如果在 App Store

204
00:10:57,191 --> 00:11:00,494
和服务器之间被篡改 你可以检测出来

205
00:11:00,527 --> 00:11:04,831
签名交易是以 JSON Web Signature
或 JWS 格式签署的

206
00:11:04,865 --> 00:11:09,303
App Store 发送给你的签名交易
将以 JWS 格式送达

207
00:11:09,336 --> 00:11:12,906
通过验证你收到的 JWS
你可以验证数据

208
00:11:12,940 --> 00:11:16,810
是否来自 App Store
且内容是否未被篡改

209
00:11:16,844 --> 00:11:20,514
现在 让我们看看如何验证签名交易

210
00:11:20,547 --> 00:11:23,183
首先是 Base 64 解码 header

211
00:11:23,217 --> 00:11:27,721
然后 可以通过算法声明
确定使用哪种签名算法

212
00:11:27,754 --> 00:11:31,425
这将作为验证 JWS 的一部分

213
00:11:31,458 --> 00:11:34,928
X5c 证书中的证书链
是由 Apple 颁发的

214
00:11:34,962 --> 00:11:37,464
证书的验证表明数据

215
00:11:37,497 --> 00:11:39,900
已正确签名且未被篡改

216
00:11:39,933 --> 00:11:42,302
有关如何验证 JWS 的更多信息

217
00:11:42,336 --> 00:11:46,773
请参阅 App Store 开发人员文档

218
00:11:46,807 --> 00:11:50,344
本质上 x5c 链是一个证书链

219
00:11:50,377 --> 00:11:53,413
证书链的成功验证表明

220
00:11:53,447 --> 00:11:57,351
数据是可信的
并且数据是由 Apple 签名的

221
00:11:57,384 --> 00:12:01,421
顺序对证书链很重要 首先是根证书

222
00:12:01,455 --> 00:12:04,391
此根证书之后可能会有其他证书

223
00:12:04,424 --> 00:12:08,028
其中每个证书都由前一个证书签名

224
00:12:08,061 --> 00:12:12,065
我将链中的最后一个证书
称为叶子证书

225
00:12:13,467 --> 00:12:16,503
第一个证书称为根证书

226
00:12:16,537 --> 00:12:18,105
是自签名的

227
00:12:18,138 --> 00:12:20,908
此证书应与你从 Apple 证书颁发机构

228
00:12:20,941 --> 00:12:22,743
获得的根证书相匹配

229
00:12:22,776 --> 00:12:27,014
如果证书不匹配 则该链不应被信任

230
00:12:27,047 --> 00:12:29,683
叶子证书是证书链中的
最后一个证书

231
00:12:29,716 --> 00:12:33,020
是用于签署 JWS 的证书

232
00:12:33,053 --> 00:12:35,489
下面是 App Store 发送的

233
00:12:35,522 --> 00:12:38,692
JWS header 的一个示例

234
00:12:38,725 --> 00:12:42,296
首先是用于签署 JWS 的算法

235
00:12:42,329 --> 00:12:47,334
接下来是 x5c 证书链
证书按顺序列出

236
00:12:48,168 --> 00:12:51,972
现在 让我们从高层次的角度来看
生成 x5c 证书链

237
00:12:52,005 --> 00:12:53,941
是什么样子的

238
00:12:53,974 --> 00:12:57,711
我们从 Apple 证书颁发机构的
根证书开始

239
00:12:57,744 --> 00:13:02,216
然后使用根证书
对中间签名证书进行签名

240
00:13:02,249 --> 00:13:07,020
接着使用中间签名证书
对叶子证书进行签名

241
00:13:08,455 --> 00:13:12,426
现在我们已经介绍了
生成 x5c 证书链的过程

242
00:13:12,459 --> 00:13:14,828
接下来让我们看看验证链的过程

243
00:13:14,862 --> 00:13:17,631
从叶子证书开始 我们确保它是由

244
00:13:17,664 --> 00:13:20,467
中间签名证书签名的

245
00:13:20,501 --> 00:13:23,170
然后 我们确保中间签名证书

246
00:13:23,203 --> 00:13:25,439
由根证书签名

247
00:13:25,472 --> 00:13:27,140
此外 根证书应与 Apple 证书颁发机构

248
00:13:27,174 --> 00:13:29,810
提供的证书相匹配

249
00:13:29,843 --> 00:13:31,845
如果所有这些步骤都成功

250
00:13:31,879 --> 00:13:35,516
则整个链被验证为合法

251
00:13:35,549 --> 00:13:38,919
我们来讨论一下验证证书链的方法

252
00:13:38,952 --> 00:13:43,657
下面是使用 OpenSSL
验证 x5c 证书链的命令

253
00:13:43,690 --> 00:13:46,727
大体上讲 verify 命令
将其分解为几个部分

254
00:13:46,760 --> 00:13:49,830
允许你传入证书进行验证

255
00:13:49,863 --> 00:13:53,267
trusted 标志
允许你提供可信任的证书

256
00:13:53,300 --> 00:13:57,738
换句话说
该证书将用于验证以下证书

257
00:13:57,771 --> 00:14:00,574
在这种情况下 我们传入的是
你从 Apple 证书颁发机构

258
00:14:00,607 --> 00:14:04,344
获得的根证书 因此是可信任的

259
00:14:04,378 --> 00:14:07,381
我们将用它来验证 WWDR 证书

260
00:14:07,414 --> 00:14:09,416
这是证书链中的下一个证书

261
00:14:10,951 --> 00:14:14,955
untrusted 标志允许你使用信任的证书

262
00:14:14,988 --> 00:14:18,892
提供要验证的一个或多个证书

263
00:14:18,926 --> 00:14:21,728
这里 我们首先从 Apple 证书颁发机构

264
00:14:21,762 --> 00:14:25,666
传入 WWDR 证书
该证书由根证书签名

265
00:14:25,699 --> 00:14:29,937
这应该与 x5c 链中的
第二个证书相匹配

266
00:14:29,970 --> 00:14:33,240
最后 这里的叶子证书
是最后一个证书

267
00:14:33,273 --> 00:14:36,743
由前一个证书签名

268
00:14:36,777 --> 00:14:41,215
如果验证成功 则返回成功代码

269
00:14:41,248 --> 00:14:44,551
然后 你可以继续使用解码后的信息

270
00:14:44,585 --> 00:14:46,787
如果验证失败

271
00:14:46,820 --> 00:14:49,389
请根据返回的错误代码确定问题

272
00:14:49,423 --> 00:14:53,927
如果无法验证 此数据可能被篡改
不应使用

273
00:14:53,961 --> 00:14:56,496
有关使用 OpenSSL
验证 x5c 证书链的完整说明

274
00:14:56,530 --> 00:15:01,602
请参考 App Store 开发者文档

275
00:15:02,402 --> 00:15:06,840
这里有一些关于如何验证
签名交易的伪代码

276
00:15:06,874 --> 00:15:10,210
首先 获取你想要验证的 JWS

277
00:15:10,244 --> 00:15:14,448
然后 获取 JWS 库验证所需的证书

278
00:15:14,481 --> 00:15:17,417
使用适当的证书

279
00:15:17,451 --> 00:15:19,520
调用 JWS 库的 verify function

280
00:15:19,553 --> 00:15:22,756
签署 JWS 的证书是叶子证书

281
00:15:22,789 --> 00:15:25,826
尽管有些库需要传递整个链

282
00:15:27,828 --> 00:15:31,865
如果调用成功 则可以继续执行任务

283
00:15:31,899 --> 00:15:35,502
如果这是调用
App Store Server API 的结果

284
00:15:35,536 --> 00:15:38,238
则可以继续存储已验证的数据

285
00:15:38,272 --> 00:15:41,408
至于通知的情况
Alex 将在他的视频部分

286
00:15:41,441 --> 00:15:44,211
进行更多的讨论

287
00:15:44,244 --> 00:15:48,115
如果 JWS 无法验证 请不要使用 JWS

288
00:15:48,148 --> 00:15:52,319
这可能意味着它已被篡改
或者不是由 App Store 发送的

289
00:15:52,352 --> 00:15:57,024
Alex 将深入探讨如何在使用通知时
更好地确保安全性

290
00:15:57,057 --> 00:15:59,326
有关验证和处理 JWS 的完整说明

291
00:15:59,359 --> 00:16:03,764
请参考 App Store 开发者文档

292
00:16:04,498 --> 00:16:08,068
现在 让我们回顾一下
从 verifyReceipt

293
00:16:08,101 --> 00:16:10,437
迁移到 App Store Server API 的
一些用例

294
00:16:10,470 --> 00:16:13,207
首先 让我们看看你想要检查

295
00:16:13,240 --> 00:16:16,009
任何给定订阅者的最新状态

296
00:16:16,043 --> 00:16:20,347
这使你可以随时了解
单个订阅的任何更改情况

297
00:16:20,380 --> 00:16:22,716
以前 要获取订阅者的最新状态

298
00:16:22,749 --> 00:16:25,519
必须调用 verifyReceipt

299
00:16:25,552 --> 00:16:28,188
并根据到期意图 宽限期

300
00:16:28,222 --> 00:16:32,192
到期日期等字段确定订阅的状态

301
00:16:32,226 --> 00:16:36,330
现在 使用 App Store Server API

302
00:16:36,363 --> 00:16:38,966
可以调用
Get All Subscription Statuses 端点

303
00:16:38,999 --> 00:16:41,335
来获取订阅的最新状态

304
00:16:41,368 --> 00:16:43,103
其中的状态字段包含当前状态

305
00:16:43,136 --> 00:16:45,873
以及最新的签名交易和续订信息

306
00:16:45,906 --> 00:16:48,575
让我们来看看如何执行这一流程

307
00:16:48,609 --> 00:16:51,545
首先 对于你拥有的
任何解码后的收据

308
00:16:51,578 --> 00:16:55,716
你可以按照我之前展示的方式
从中获取 originalTransactionId

309
00:16:55,749 --> 00:16:58,752
然后 可以调用
originalTransactionId 的

310
00:16:58,785 --> 00:17:01,989
Get All Subscription Statuses 端点
该端点将返回

311
00:17:02,022 --> 00:17:04,825
该交易的最新签名交易和续订信息

312
00:17:04,858 --> 00:17:08,562
接下来
我们来看获取最新交易的案例

313
00:17:08,595 --> 00:17:12,466
获取最新的交易信息会通知你
用户购买了哪些内容

314
00:17:12,499 --> 00:17:16,904
续订了哪些内容
用户的订阅是否有任何更改等

315
00:17:16,937 --> 00:17:19,940
以前 要获取用户的最新交易信息

316
00:17:19,973 --> 00:17:21,742
必须调用 verifyReceipt

317
00:17:21,775 --> 00:17:24,778
并使用 in_app 数组
并检查 Latest_Receipt_INFO

318
00:17:24,811 --> 00:17:27,915
其中包含用户的所有交易

319
00:17:27,948 --> 00:17:31,118
使用 App Store Server API
获取最新的交易

320
00:17:31,151 --> 00:17:33,887
Get Transaction History 端点

321
00:17:33,921 --> 00:17:36,423
允许你获取用户的
完整购买历史记录

322
00:17:36,456 --> 00:17:40,160
此外 分页与 WWDC22 演讲
“What's new with in-app purchase”中

323
00:17:40,194 --> 00:17:43,897
介绍的新的筛选和排序功能相结合

324
00:17:43,931 --> 00:17:47,601
确保你可以高效地准确获取
所需的数据

325
00:17:48,902 --> 00:17:51,004
让我们来看看可能需要的流程

326
00:17:51,038 --> 00:17:53,874
对于属于该用户的任何
OriginalTransactionID

327
00:17:53,907 --> 00:17:56,710
你可以调用
Get Transaction History 端点

328
00:17:56,743 --> 00:17:59,479
该端点将该用户的交易历史记录
作为签名交易返回

329
00:17:59,513 --> 00:18:04,518
并根据你的规范进行
筛选 排序和分页

330
00:18:06,153 --> 00:18:09,189
最后 我们看看采用
appAccountToken 的情况

331
00:18:09,223 --> 00:18:12,226
appAccountToken 字段允许你
提供一个 UUID

332
00:18:12,259 --> 00:18:15,762
将 StoreKit 2 交易与用户关联起来

333
00:18:15,796 --> 00:18:18,098
然后 在签名交易 签名续订

334
00:18:18,131 --> 00:18:22,336
和该交易的通知上
将出现 appAccountToken

335
00:18:22,369 --> 00:18:25,806
以前 原始 StoreKit
不支持 appAccountToken

336
00:18:25,839 --> 00:18:28,976
因为这是 StoreKit2 的新功能

337
00:18:29,009 --> 00:18:33,380
现在 我们在原始 StoreKit 的
applicationUsername 字段中

338
00:18:33,413 --> 00:18:36,016
增加了对提供 UUID 的支持

339
00:18:36,049 --> 00:18:38,118
以支持与
Original StoreKit 客户的兼容

340
00:18:38,151 --> 00:18:40,888
在这种情况下 UUID 将支持

341
00:18:40,921 --> 00:18:43,457
appAccountToken 的所有功能

342
00:18:43,490 --> 00:18:47,728
然后 appAccountToken
以 verifyReceipt 的形式

343
00:18:47,761 --> 00:18:51,231
返回给 Original StoreKit 用户
并在调用 App Store Server API

344
00:18:51,265 --> 00:18:53,267
和 App Store Server API 的通知中

345
00:18:53,300 --> 00:18:55,903
显示给原始
StoreKit 和 StoreKit 2 用户

346
00:18:56,670 --> 00:18:59,706
本课程的 App Store Server API 部分
到此为止

347
00:18:59,740 --> 00:19:04,511
接下来 Alex 将介绍迁移到
App Store Notifications Version 2 的内容

348
00:19:04,545 --> 00:19:05,479
Alex: 谢谢 Gabriel

349
00:19:05,512 --> 00:19:07,848
我是 Alex 很高兴今天能在这里

350
00:19:07,881 --> 00:19:11,518
讨论 App Store
Notifications Version 2

351
00:19:11,552 --> 00:19:15,789
首先 我们将讨论如何使用
Version 2 通知

352
00:19:15,822 --> 00:19:21,395
接下来是 Version 2 通知的不同之处
以及如何构建在其他可用模型的基础上

353
00:19:21,428 --> 00:19:24,898
第三 我们将讨论
在错过通知的情况下进行修复

354
00:19:24,932 --> 00:19:29,102
以及一些有助于
完成这项任务的新资源

355
00:19:29,136 --> 00:19:32,606
最后是 通知如何提供
对顾客行为的洞察

356
00:19:32,639 --> 00:19:34,842
并为了解订阅生命周期

357
00:19:34,875 --> 00:19:37,377
创造更多机会

358
00:19:37,411 --> 00:19:40,681
让我们简单介绍一下什么是通知

359
00:19:40,714 --> 00:19:42,616
以及谁可以使用它们

360
00:19:42,649 --> 00:19:45,419
App Store Server Notifications 是

361
00:19:45,452 --> 00:19:48,989
我们在 App 用户执行某些操作时
向你发送的消息

362
00:19:49,022 --> 00:19:52,025
这些通知大致分为两类

363
00:19:52,059 --> 00:19:54,428
订阅更新和退款更新

364
00:19:54,461 --> 00:19:57,564
虽然我们一直在努力覆盖其他场景

365
00:19:57,598 --> 00:20:00,868
我们提供这些通知
以帮助填补你在 App 中

366
00:20:00,901 --> 00:20:03,504
可能无法执行的用户操作的空白

367
00:20:03,537 --> 00:20:06,640
例如 我们最常见的一个用例

368
00:20:06,673 --> 00:20:08,408
是订阅的续订

369
00:20:08,442 --> 00:20:12,012
当此交易可用时
用户可能不在 App 中

370
00:20:12,045 --> 00:20:15,015
订阅更新时
App Store 服务器通知

371
00:20:15,048 --> 00:20:17,618
通过主动将最新的交易信息

372
00:20:17,651 --> 00:20:20,654
直接发送至你的服务器
来帮助解决这个问题

373
00:20:20,687 --> 00:20:24,558
Version 2 通知与 StoreKit 2 模型

374
00:20:24,591 --> 00:20:27,828
以及 Gabriel 刚刚讲的
App Store Server API 有很多相似之处

375
00:20:27,861 --> 00:20:31,465
然而 虽然它们可以很好地协同工作
但它们都是

376
00:20:31,498 --> 00:20:33,567
可以在不同时间使用的独立工具

377
00:20:33,600 --> 00:20:36,403
最重要的是 你可以
继续支持 StoreKit 2 不可用的客户端

378
00:20:36,436 --> 00:20:40,107
iOS 15 之前的客户端

379
00:20:40,140 --> 00:20:43,377
同时使用 Version 2 服务器通知

380
00:20:43,410 --> 00:20:46,213
我们已经努力使
Version 2 通知成为了

381
00:20:46,246 --> 00:20:49,316
我们最深入 灵活的工具之一

382
00:20:49,349 --> 00:20:52,553
用于在整个订阅生命周期中提供
有关用户的信息

383
00:20:52,586 --> 00:20:54,855
我们将在稍后的演示中
更深入地讨论该问题

384
00:20:54,888 --> 00:20:58,559
但通知提供的信息也可以抓取

385
00:20:58,592 --> 00:21:01,295
应用程序之外执行的操作

386
00:21:01,328 --> 00:21:03,664
我希望我已经引起了你对通知

387
00:21:03,697 --> 00:21:06,867
尤其是 Version 2 通知的概念的兴趣

388
00:21:06,900 --> 00:21:09,069
在我们深入讨论之前
虽然这个演示文稿

389
00:21:09,102 --> 00:21:11,471
能引导你了解接收通知的入门
及最佳解决方案

390
00:21:11,505 --> 00:21:14,508
但它并不能说明全部情况

391
00:21:14,541 --> 00:21:16,443
请参阅近期的一些视频

392
00:21:16,476 --> 00:21:20,447
了解有关通知以及它们
如何满足各种用例的更多信息

393
00:21:20,480 --> 00:21:23,116
我们来看看如何设置 Version 2 通知

394
00:21:23,150 --> 00:21:25,152
我们将逐步了解如何设置通知

395
00:21:25,185 --> 00:21:27,621
直到接收你的第一个通知

396
00:21:27,654 --> 00:21:32,092
首先 转到 App Store Connect 中的
应用页面

397
00:21:32,125 --> 00:21:37,064
向下滚动 你会看到一个
App Store Server Notifications 的部分

398
00:21:37,097 --> 00:21:41,101
大家会看到生产和沙盒的选项

399
00:21:41,134 --> 00:21:43,704
每个环境都可以包含一个单独的 URL

400
00:21:43,737 --> 00:21:47,107
和一个单独的通知版本

401
00:21:47,140 --> 00:21:50,711
下面是用于
产品设置选项页面的示例

402
00:21:50,744 --> 00:21:53,480
沙盒设置是完全相同的

403
00:21:53,514 --> 00:21:57,184
特别是
如果你是 Version 1 通知的用户

404
00:21:57,217 --> 00:22:01,555
我们建议你首先在沙盒环境下
尝试 Version 2 通知

405
00:22:01,588 --> 00:22:04,591
这是在不影响产品设置的情况下

406
00:22:04,625 --> 00:22:07,528
熟悉通知的好途径

407
00:22:07,561 --> 00:22:11,198
选择 Set Up Sandbox 按钮
提供服务器的 URL

408
00:22:11,231 --> 00:22:13,834
然后选择 Version 2 Notifications

409
00:22:15,169 --> 00:22:18,005
在触发通知之前
请确认你的服务器端点

410
00:22:18,038 --> 00:22:21,108
有一个有效的 HTTPS 证书

411
00:22:21,141 --> 00:22:25,245
还要确认你已允许 Apple 的
公共 IP 访问你的服务器

412
00:22:25,279 --> 00:22:27,848
在设置通知时 一些最常见的故障

413
00:22:27,881 --> 00:22:30,050
与防火墙和证书有关

414
00:22:30,083 --> 00:22:33,420
作为初始故障排除步骤
这些也非常适合检查

415
00:22:33,453 --> 00:22:36,423
你是否突然停止接收通知

416
00:22:36,456 --> 00:22:39,393
现在你已准备好接收第一个通知了

417
00:22:39,426 --> 00:22:41,628
在沙盒中
可以通过多种操作来触发通知

418
00:22:41,662 --> 00:22:44,898
例如购买应用内订阅

419
00:22:44,932 --> 00:22:47,134
然而 为了便于在测试时使用

420
00:22:47,167 --> 00:22:49,403
我们建议使用新的
Request a Test notification 端点

421
00:22:49,436 --> 00:22:54,007
来触发通知 这是
App Store Server API 的一部分

422
00:22:54,041 --> 00:22:57,110
该端点有助于自动化通知测试过程

423
00:22:57,144 --> 00:22:59,613
触发 Request a Test Notification
端点后

424
00:22:59,646 --> 00:23:02,583
你应该很快就会收到通知

425
00:23:02,616 --> 00:23:04,685
如果你在接收通知方面遇到问题

426
00:23:04,718 --> 00:23:07,554
请参考新的
Get Test Notification Status 端点

427
00:23:07,588 --> 00:23:10,991
该端点可以提供有关
通知未能传递原因的简要状态

428
00:23:11,024 --> 00:23:14,194
例如 SSL_ISSUE 这样的状态

429
00:23:14,228 --> 00:23:17,831
可能就是提示再次检查你的
HTTPS 证书

430
00:23:17,865 --> 00:23:20,267
我们建议在执行配置更改时

431
00:23:20,300 --> 00:23:22,536
触发测试通知

432
00:23:22,569 --> 00:23:25,272
这是确认你在更改后
仍能收到通知的

433
00:23:25,305 --> 00:23:26,907
好方法

434
00:23:26,940 --> 00:23:30,811
现在 让我们继续了解
你刚刚收到的通知

435
00:23:32,179 --> 00:23:34,515
就像我们之前从 Gabriel 那里
看到的交易一样

436
00:23:34,548 --> 00:23:37,885
通知也是 JWS 格式的

437
00:23:37,918 --> 00:23:42,322
让我们来看看如何解码
及验证通知有效载荷

438
00:23:42,356 --> 00:23:44,625
首先 收到通知时

439
00:23:44,658 --> 00:23:49,263
你希望提取 JSON 正文的
signedPayload 字段

440
00:23:49,296 --> 00:23:52,866
接下来 你将执行与前面
Gabriel 介绍的完全相同的步骤

441
00:23:52,900 --> 00:23:55,135
来验证签名交易

442
00:23:55,169 --> 00:23:57,538
你将按照相同的步骤
来验证签名数据

443
00:23:57,571 --> 00:24:00,841
无论它是来自通知的
签名通知有效载荷

444
00:24:00,874 --> 00:24:04,945
还是来自
App Store Server API 的签名交易

445
00:24:04,978 --> 00:24:09,750
接下来 重要的是要验证通知
是针对哪个 App 的

446
00:24:09,783 --> 00:24:12,553
如果你有多个应用程序
共享同一个端点

447
00:24:12,586 --> 00:24:15,856
那么这是确定目标 App 的好方法

448
00:24:15,889 --> 00:24:19,293
同样重要的是 要确认
通知针对的 App 是你的 App

449
00:24:19,326 --> 00:24:24,264
而且通知针对的不是其他开发者

450
00:24:24,298 --> 00:24:27,701
最后 一项更实用的检查是确保

451
00:24:27,734 --> 00:24:30,137
通知的环境与你的预期环境相匹配

452
00:24:30,170 --> 00:24:32,606
无论是生产环境还是沙盒环境

453
00:24:32,639 --> 00:24:35,709
由于 App Store Connect 允许
每个环境使用单独的 URL

454
00:24:35,742 --> 00:24:37,945
因此可以强制执行此要求

455
00:24:37,978 --> 00:24:41,481
或者 如果 URL 是共享的

456
00:24:41,515 --> 00:24:46,019
要保证你是基于环境单独存储
和处理通知

457
00:24:46,053 --> 00:24:50,691
此时 JWS 已完全验证
并可以存储以供进一步处理

458
00:24:50,724 --> 00:24:53,260
除了一些基本检查外

459
00:24:53,293 --> 00:24:56,463
我们建议你的服务器异步处理通知

460
00:24:56,496 --> 00:25:00,834
如果通知的处理时间过长
我们的服务器将记录超时

461
00:25:00,868 --> 00:25:03,670
并假设通知未成功传递

462
00:25:03,704 --> 00:25:06,840
然后我们将重新发送通知

463
00:25:06,874 --> 00:25:10,577
因此 将耗时的处理移到此功能之外

464
00:25:10,611 --> 00:25:13,247
有助于确保 App Store 服务器
将你的通知

465
00:25:13,280 --> 00:25:16,216
记录为成功发送 并且重试时

466
00:25:16,250 --> 00:25:19,553
无需服务器再重新处理通知

467
00:25:19,586 --> 00:25:24,558
现在 我们回顾一下
验证后的通知正文

468
00:25:24,591 --> 00:25:28,695
第一个字段是
通知类型和可选子类型

469
00:25:28,729 --> 00:25:32,032
结合在一起之后
它们将告诉你通知适用的场景

470
00:25:32,065 --> 00:25:35,903
这些字段还有助于显示
自上次通知以来发生了哪些更改

471
00:25:35,936 --> 00:25:38,872
并提供有关
发生这些更改原因的信息

472
00:25:38,906 --> 00:25:43,377
notificationUUID 是
每个通知的唯一标识符

473
00:25:43,410 --> 00:25:45,479
如果服务器重试通知

474
00:25:45,512 --> 00:25:49,583
则重试通知包含
相同的 notificationUUID

475
00:25:49,616 --> 00:25:52,920
这有助于检测服务器处理通知

476
00:25:52,953 --> 00:25:57,858
但没有及时响应成功的
HTTP 响应代码的情况

477
00:25:57,891 --> 00:26:01,428
我们建议基于此字段添加
由于重试导致的

478
00:26:01,461 --> 00:26:03,497
重复通知检测

479
00:26:03,530 --> 00:26:06,967
signedDate 字段告诉你
通知是何时创建的

480
00:26:07,000 --> 00:26:10,470
这对于检测重试通知特别有用

481
00:26:10,504 --> 00:26:13,507
接下来是 appAppleId 和 bundleId

482
00:26:13,540 --> 00:26:16,310
这些对于检测目标应用程序很重要

483
00:26:16,343 --> 00:26:19,146
正如我们前面所讨论的
检查这些字段并确认它们

484
00:26:19,179 --> 00:26:23,884
与预期值匹配是很重要的
以防止重放攻击

485
00:26:23,917 --> 00:26:26,854
此外 确保通知的环境

486
00:26:26,887 --> 00:26:29,756
与预期的环境相匹配
沙盒通知不会被记录为

487
00:26:29,790 --> 00:26:32,292
生产数据 反之亦然

488
00:26:33,861 --> 00:26:38,599
最后 实际的 signedTransactionInfo
和可选的 signedRenewalInfo

489
00:26:38,632 --> 00:26:41,001
这将是签署时的

490
00:26:41,034 --> 00:26:43,103
标的购买的最新状态

491
00:26:43,136 --> 00:26:45,439
此时 解析完通知后

492
00:26:45,472 --> 00:26:48,242
你只剩下最新的交易和更新信息

493
00:26:48,275 --> 00:26:51,411
以及状态更改的最新原因

494
00:26:51,445 --> 00:26:55,082
既然我们已经介绍了
特定通知的设置和接收

495
00:26:55,115 --> 00:26:57,451
我们通过与 Version 1 通知的比较

496
00:26:57,484 --> 00:27:00,854
来测试 Version 2 通知模型

497
00:27:00,888 --> 00:27:03,557
通知如何组合在一起
来跟踪订阅生命周期

498
00:27:03,590 --> 00:27:06,660
以及Version 2 通知背后的设计决策

499
00:27:06,693 --> 00:27:09,530
Version 2
在发送有关购买状态的信息时

500
00:27:09,563 --> 00:27:10,931
采用了不同的原理

501
00:27:10,964 --> 00:27:14,301
与每次通知都发送所有
最近的历史记录不同

502
00:27:14,334 --> 00:27:17,938
版本 2 的通知只专注于
发送最新的信息

503
00:27:17,971 --> 00:27:19,506
即最新的交易信息

504
00:27:19,540 --> 00:27:23,343
订阅的情况 还有待续订信息

505
00:27:24,912 --> 00:27:26,980
通过通知 我们可以提供

506
00:27:27,014 --> 00:27:30,050
关于订阅生命周期的每一步的信息

507
00:27:30,083 --> 00:27:33,453
因此 通知只包含关于

508
00:27:33,487 --> 00:27:36,123
最新的购买或订阅的信息

509
00:27:36,156 --> 00:27:39,226
这些通知一起创建了

510
00:27:39,259 --> 00:27:41,161
订阅状态的完整时间线

511
00:27:41,195 --> 00:27:44,598
如果你需要查看整个交易历史记录

512
00:27:44,631 --> 00:27:46,834
但无权访问通知历史记录

513
00:27:46,867 --> 00:27:49,169
则可以使用
Get transaction history 端点

514
00:27:49,203 --> 00:27:54,074
它能让你在分页和可筛选的上下文中
查询用户的整个交易历史记录

515
00:27:54,107 --> 00:27:58,879
第二 Version 1 通知不需要
客户端使用 StoreKit 2

516
00:27:58,912 --> 00:28:01,515
没错 Version 2 也是如此

517
00:28:01,548 --> 00:28:04,852
事实上 无论客户端使用什么框架

518
00:28:04,885 --> 00:28:09,122
你都可以从今天开始
享受 Version 2 通知的优点

519
00:28:09,156 --> 00:28:13,994
最后 Version 2
通知通过添加其他的类型

520
00:28:14,027 --> 00:28:16,897
以及添加新的子类型字段
来提高所提供的详细程度

521
00:28:16,930 --> 00:28:19,299
并扩展所涵盖的案例

522
00:28:19,333 --> 00:28:21,535
通过这种方式
我们能够覆盖更多的场景

523
00:28:21,568 --> 00:28:24,605
并在订阅生命周期的每个步骤中
提供通知

524
00:28:24,638 --> 00:28:28,041
我们添加的一些值得注意的场景
包括到期

525
00:28:28,075 --> 00:28:31,411
与自动续订状态更改相关的
更详细的信息

526
00:28:31,445 --> 00:28:34,281
以及与退款流程相关的更多场景

527
00:28:34,314 --> 00:28:37,651
现在 为了说明所涵盖场景的复杂性

528
00:28:37,684 --> 00:28:40,921
并提供一个更具体的示例

529
00:28:40,954 --> 00:28:43,156
让我们从头到尾看看通知是如何
通知订阅所采取的

530
00:28:43,190 --> 00:28:45,325
每个步骤的

531
00:28:45,359 --> 00:28:49,162
让我们想象一个订阅前的用户

532
00:28:49,196 --> 00:28:52,833
订阅后 用户进入续订订阅状态

533
00:28:52,866 --> 00:28:55,969
并发送带有子类型
INITIAL_BUY 的订阅通知

534
00:28:56,003 --> 00:29:00,107
或者如果使用了报价 则发送
带有子类型 INITIAL_BUY 的 OFFER_REDEEMED

535
00:29:00,140 --> 00:29:03,343
通知中包含第一个签名交易

536
00:29:03,377 --> 00:29:06,246
以及签名续订信息

537
00:29:06,280 --> 00:29:10,384
时间流逝 订阅更新 保持更新状态

538
00:29:10,417 --> 00:29:12,920
每次续订时 我们发送一个包含

539
00:29:12,953 --> 00:29:16,723
下一个签名交易信息的
DID_RENEW 通知

540
00:29:16,757 --> 00:29:19,159
每当用户取消自动续订时

541
00:29:19,193 --> 00:29:22,029
他们就会进入即将到期的订阅状态

542
00:29:22,062 --> 00:29:23,463
那么将收到一个子类型为
AUTO_RENEW_DISABLED 的

543
00:29:23,497 --> 00:29:26,700
DID_CHANGE_RENEWAL_STATUS

544
00:29:28,402 --> 00:29:31,405
如果他们不启用自动续订

545
00:29:31,438 --> 00:29:34,241
那么到期后 他们就会进入过期状态

546
00:29:34,274 --> 00:29:36,643
你将收到带有子类型
VOLUNTARY 的 EXPIRED

547
00:29:36,677 --> 00:29:38,278
现在 你可能会疑惑

548
00:29:38,312 --> 00:29:40,714
其他所有的通知类型在哪里呢

549
00:29:43,050 --> 00:29:46,520
下面是通过通知看到的
订阅生命周期

550
00:29:46,553 --> 00:29:49,289
有很多在进行

551
00:29:49,323 --> 00:29:52,626
这张图还不能说明全部

552
00:29:52,659 --> 00:29:57,130
例如 这里不包括退款 撤销生命周期

553
00:29:57,164 --> 00:29:59,566
这个图表说明了 Version 2 通知
所涵盖的大量场景

554
00:29:59,600 --> 00:30:02,603
它们可用于通知你

555
00:30:02,636 --> 00:30:05,439
订阅生命周期的每个步骤

556
00:30:06,507 --> 00:30:08,342
我要说的另一点是我们努力包含

557
00:30:08,375 --> 00:30:10,477
所有可能的过渡状态

558
00:30:10,511 --> 00:30:14,147
这有助于通过
成为跟踪订阅的单一来源

559
00:30:14,181 --> 00:30:16,950
来提高通知的效用

560
00:30:16,984 --> 00:30:19,987
并提高你看到
订阅者使用历程的信心

561
00:30:20,020 --> 00:30:22,623
然而 即使所有数据都在这里

562
00:30:22,656 --> 00:30:25,158
你也不需要使用所有可用的类型

563
00:30:25,192 --> 00:30:28,662
例如 即使只是处理
与续订偏好更改相关的通知

564
00:30:28,695 --> 00:30:31,064
也可以提供价值

565
00:30:31,098 --> 00:30:33,166
特别是 如果各位刚刚开始

566
00:30:33,200 --> 00:30:37,271
那么请从对自己的情况
最有用的通知类型开始

567
00:30:37,304 --> 00:30:40,207
现在 我们讨论一下
设置好服务器后会发生什么

568
00:30:40,240 --> 00:30:44,011
一切都很顺利 但是 唉 服务器罢工了

569
00:30:44,044 --> 00:30:47,014
不管是几天 几分钟
还是你认为你可能只错过了一分钟

570
00:30:47,047 --> 00:30:50,884
让我们通过一些步骤来帮助
解决此问题

571
00:30:50,918 --> 00:30:52,719
我们来想象一下你的服务器

572
00:30:52,753 --> 00:30:56,690
它已成功设置 并且正在接收通知

573
00:30:56,723 --> 00:31:01,695
在某些情况下
服务器出现问题 无法接收通知

574
00:31:01,728 --> 00:31:04,031
我们仍试图向你的服务器发送消息

575
00:31:04,064 --> 00:31:06,333
但现在这些请求开始失败了

576
00:31:06,366 --> 00:31:08,368
有几种方法可以处理这种情况

577
00:31:08,402 --> 00:31:10,170
首先就是等待

578
00:31:10,204 --> 00:31:13,006
如果我们没有从你的服务器
收到成功的状态代码

579
00:31:13,040 --> 00:31:14,441
或根本无法连接到它

580
00:31:14,474 --> 00:31:18,645
我们将根据记录的重试策略
来重试通知

581
00:31:18,679 --> 00:31:21,815
对于 Version 2 通知
我们在每次尝试后重试

582
00:31:21,849 --> 00:31:24,985
首先延迟 1 小时 然后延迟 12 小时

583
00:31:25,018 --> 00:31:28,789
延迟 24 小时 48 小时
最后延迟 72 小时

584
00:31:28,822 --> 00:31:31,225
对于 1小时内的中断来说
等待非常有效

585
00:31:31,258 --> 00:31:34,661
因为通知将在首次故障
1 小时后重试

586
00:31:36,029 --> 00:31:37,865
在某个时刻 服务器恢复了

587
00:31:37,898 --> 00:31:41,101
你开始再次接收通知

588
00:31:41,134 --> 00:31:46,306
首先 你会收到一个
与错过的通知无关的新通知

589
00:31:46,340 --> 00:31:49,776
通知会延迟重试
所以一旦你的服务器上线

590
00:31:49,810 --> 00:31:52,679
并不会立即收到所有错过的通知

591
00:31:53,914 --> 00:31:57,718
一段时间后 你开始收到错过的通知

592
00:31:57,751 --> 00:31:59,853
并穿插着新的通知

593
00:32:01,221 --> 00:32:04,391
这就产生了一个问题
那就是如何检测通知

594
00:32:04,424 --> 00:32:07,628
是原始通知还是重试通知

595
00:32:07,661 --> 00:32:09,496
让我们检查一个通知

596
00:32:10,531 --> 00:32:13,600
在这个通知里
我们只显示了几个字段

597
00:32:14,935 --> 00:32:17,838
通知包含一个 signedDate 字段

598
00:32:17,871 --> 00:32:20,007
通过比较签名日期

599
00:32:20,040 --> 00:32:23,677
与收到通知的时间
这个字段可用于检测重试

600
00:32:23,710 --> 00:32:26,980
如果你看到签名日期

601
00:32:27,014 --> 00:32:28,916
明显早于你收到通知的日期

602
00:32:28,949 --> 00:32:31,518
这表明你可能遇到了中断

603
00:32:32,619 --> 00:32:36,256
想象在这种情况下
标记为 6 和 3 的通知

604
00:32:36,290 --> 00:32:38,225
是针对同一个订阅的

605
00:32:38,258 --> 00:32:41,862
这可以通过比较
originalTransactionIds 来确定

606
00:32:41,895 --> 00:32:46,567
在这种情况下 仅仅因为通知 3
是在通知 6 之后收到的

607
00:32:46,600 --> 00:32:51,238
并不意味着它包含
比通知 6 更新的信息

608
00:32:51,271 --> 00:32:54,241
其他时候 你的服务器
可能已收到通知

609
00:32:54,274 --> 00:32:58,712
但它未能响应成功的
HTTP 200 状态代码

610
00:32:58,745 --> 00:33:02,015
这可能会导致通知
重新发送到你的服务器

611
00:33:02,049 --> 00:33:06,119
如前所述
请确保检查 notificationUUID 字段

612
00:33:06,153 --> 00:33:08,155
以重复这些请求

613
00:33:08,188 --> 00:33:11,058
即使你成功记录了通知

614
00:33:11,091 --> 00:33:13,994
也可能会看到大量的重试通知

615
00:33:14,027 --> 00:33:15,929
在这种情况下 确保每次

616
00:33:15,963 --> 00:33:19,900
收到通知时都使用
HTTP 200 响应来回应

617
00:33:19,933 --> 00:33:23,103
此外 确保及时地这样做

618
00:33:23,136 --> 00:33:27,474
并且在成功响应之前
没有进行大量处理

619
00:33:27,508 --> 00:33:30,777
以防止我们记录超时
并重新发送通知

620
00:33:30,811 --> 00:33:35,949
有时 尤其是较长的中断
下一次重试可能在数小时或数天之后

621
00:33:35,983 --> 00:33:39,553
或者对于较长时间的停机
可能已无法重试

622
00:33:39,586 --> 00:33:42,155
从错过的通知中恢复的下一个选项

623
00:33:42,189 --> 00:33:44,691
是 Get Notification History 端点

624
00:33:45,826 --> 00:33:48,729
我们刚刚介绍了新的
Get Notification History 端点

625
00:33:48,762 --> 00:33:52,232
它提供了我们发送给你的服务器的
六个月的通知历史记录

626
00:33:52,266 --> 00:33:54,601
请参阅视频
“What's new with in-app purchases”

627
00:33:54,635 --> 00:33:56,069
了解这个端点

628
00:33:56,103 --> 00:33:58,372
以及我们介绍的其他很棒的功能

629
00:33:58,405 --> 00:34:01,642
在这里 我们将重点介绍
使用此端点时的最佳实践

630
00:34:01,675 --> 00:34:04,411
以及它可以提供帮助的场景

631
00:34:04,444 --> 00:34:05,913
故障解决后

632
00:34:05,946 --> 00:34:08,849
请注意故障的开始和结束时间戳

633
00:34:08,882 --> 00:34:11,318
Get Notification History 端点

634
00:34:11,351 --> 00:34:13,053
允许在特定的时间范围内进行查询

635
00:34:13,086 --> 00:34:15,455
通过指定中断的开始和结束时间

636
00:34:15,489 --> 00:34:18,325
你可以只处理可能错过的通知

637
00:34:18,358 --> 00:34:21,295
而不需要翻阅整个历史记录

638
00:34:21,328 --> 00:34:22,996
这将有助于提高恢复速度

639
00:34:23,030 --> 00:34:26,600
并减少重新处理已记录通知的工作

640
00:34:27,534 --> 00:34:29,803
接下来
Get Notification History 端点

641
00:34:29,837 --> 00:34:32,306
允许你根据通知的类型进行筛选

642
00:34:32,339 --> 00:34:35,042
如果你经历了长时间的中断
并预计会收到大量通知

643
00:34:35,075 --> 00:34:38,111
请考虑按类型过滤

644
00:34:38,145 --> 00:34:42,482
并从可能产生直接影响的类型开始
如 DID_RENEW 和 EXPIRED

645
00:34:42,516 --> 00:34:46,854
这些将帮助你首先
对最相关的案例采取行动

646
00:34:46,887 --> 00:34:49,223
在传递通知类型时有一个提示

647
00:34:49,256 --> 00:34:51,758
如果忽略 notificationSubtype 字段

648
00:34:51,792 --> 00:34:55,596
将只返回同样没有子类型的通知

649
00:34:55,629 --> 00:34:59,766
因此 对于 DID_RENEW notificationType
所显示的示例

650
00:34:59,800 --> 00:35:01,935
它不会返回子类型为
BILLING_RECOVERY 的

651
00:35:01,969 --> 00:35:03,370
DID_RENEW 通知

652
00:35:05,105 --> 00:35:07,908
最后 Get Notification History 端点

653
00:35:07,941 --> 00:35:11,712
允许使用 originalTransactionId
过滤到特定用户

654
00:35:11,745 --> 00:35:13,614
回顾订阅生命周期

655
00:35:13,647 --> 00:35:16,016
我们努力确保通知

656
00:35:16,049 --> 00:35:17,985
覆盖用户使用的每一步

657
00:35:18,018 --> 00:35:21,555
因此 如果你发现自己的程序
以意想不到的方式跳跃

658
00:35:21,588 --> 00:35:24,825
例如从更新订阅直接跳到过期

659
00:35:24,858 --> 00:35:27,961
这可能表明你错过了该用户的通知

660
00:35:27,995 --> 00:35:30,364
在顾客支持环境中 如果用户帐户

661
00:35:30,397 --> 00:35:33,734
处于与你的预期不同的状态
这也很有用

662
00:35:33,767 --> 00:35:37,771
在这些情况下 你可以发送一个
查询该用户的通知历史记录

663
00:35:38,906 --> 00:35:42,176
让我们回顾一下
Get Notification History 端点的响应

664
00:35:42,209 --> 00:35:44,878
为简单起见 响应中仅显示某些值

665
00:35:46,613 --> 00:35:50,484
响应中恢复的值
在 notificationHistory 数组中

666
00:35:52,119 --> 00:35:55,589
数组中的每个条目都表示一个通知

667
00:35:56,823 --> 00:35:59,660
签名有效载荷字段

668
00:35:59,693 --> 00:36:00,894
包含发送给你的确切通知

669
00:36:02,162 --> 00:36:05,199
其次 我们有第一个
sendattemptresult 字段

670
00:36:05,232 --> 00:36:08,001
该字段包含基于服务器记录的

671
00:36:08,035 --> 00:36:11,638
初始通知尝试结果的几个值之一

672
00:36:11,672 --> 00:36:14,741
在成功的情况下 这个值将是 SUCCESS

673
00:36:14,775 --> 00:36:16,777
然而 正如我们刚才所讨论的

674
00:36:16,810 --> 00:36:19,780
有时服务器无法收到通知

675
00:36:19,813 --> 00:36:22,482
这些消息旨在作为一般指南帮助你

676
00:36:22,516 --> 00:36:25,819
指出问题的方向 以简化解决过程

677
00:36:25,853 --> 00:36:28,522
例如 我们在这里看到 SSL_ISSUE

678
00:36:28,555 --> 00:36:31,024
这表明服务器上的 SSL 证书

679
00:36:31,058 --> 00:36:33,126
或进程有问题

680
00:36:33,160 --> 00:36:36,697
除了看到通知未到达外
此字段还提高了

681
00:36:36,730 --> 00:36:39,233
诊断服务器问题的可见性

682
00:36:39,266 --> 00:36:42,803
我们还在
Get Test Notification Status 端点中

683
00:36:42,836 --> 00:36:45,806
提供了相同的字段

684
00:36:45,839 --> 00:36:48,976
这些可用于在引导流程
或故障排除期间提供帮助

685
00:36:49,009 --> 00:36:52,446
或在追溯确定中断的
根本原因期间提供帮助

686
00:36:52,479 --> 00:36:55,949
通知或许不能涵盖
用户历史记录的所有情况

687
00:36:55,983 --> 00:36:58,652
你可能刚刚采用了通知

688
00:36:58,685 --> 00:37:00,354
并有历史记录未覆盖的现有用户

689
00:37:00,387 --> 00:37:03,290
你还可能希望在
Get Notification history 端点中

690
00:37:03,323 --> 00:37:06,894
检查比通知保留周期更长的
历史记录

691
00:37:06,927 --> 00:37:09,763
这就是 Get Transaction History
端点的作用所在

692
00:37:09,796 --> 00:37:11,899
正如我们之前在 Gabriel 的
演讲中看到的那样

693
00:37:11,932 --> 00:37:14,401
此端点通过在你开始使用通知之前
为你的顾客

694
00:37:14,434 --> 00:37:18,605
提供涵盖案例的历史记录
来解决这些问题

695
00:37:18,639 --> 00:37:21,909
现在 我们来看看通知如何提供

696
00:37:21,942 --> 00:37:25,179
超越购买历史记录的洞察和机会

697
00:37:25,212 --> 00:37:29,082
Version 2 通知中新增的内容之一
是子类型字段

698
00:37:29,116 --> 00:37:32,386
它向 notificationType 字段
添加了额外的环境

699
00:37:32,419 --> 00:37:35,389
该字段用于在某些场景中
提供更详细的信息

700
00:37:35,422 --> 00:37:38,058
比如 EXPIRED
或 DID_CHANGE_RENEWAL_STATUS

701
00:37:38,091 --> 00:37:41,929
例如 使用 EXPIRED
你所采取的操作通常是相同的

702
00:37:41,962 --> 00:37:45,332
将订阅标记为⾮活跃状态
并撤销对产品的访问权限

703
00:37:45,365 --> 00:37:49,102
但是 了解用户过期的原因通常很有用

704
00:37:49,136 --> 00:37:51,772
是由于账单问题 自愿选择

705
00:37:51,805 --> 00:37:53,841
还是接受不了的涨价

706
00:37:53,874 --> 00:37:56,877
另一个通知
DID_CHANGE_RENEWAL_STATUS

707
00:37:56,910 --> 00:37:59,246
是在使用通知时获得额外信息

708
00:37:59,279 --> 00:38:01,815
和机会的一个很好的例子

709
00:38:01,849 --> 00:38:04,251
从表面上看 它的优先级似乎不高

710
00:38:04,284 --> 00:38:06,286
不需要立即采取行动

711
00:38:06,320 --> 00:38:09,022
撤销产品访问权的重要通知

712
00:38:09,056 --> 00:38:11,058
是 EXPIRED 通知

713
00:38:11,091 --> 00:38:14,127
别被骗了 这里有很多机会

714
00:38:14,161 --> 00:38:16,430
第一 此通知是尝试

715
00:38:16,463 --> 00:38:20,167
在订阅到期之前
赢回顾客的绝佳机会

716
00:38:20,200 --> 00:38:22,536
特别是由于停用自动续订
可能发生在应用程序之外

717
00:38:22,569 --> 00:38:25,038
这可能是在到期日期前

718
00:38:25,072 --> 00:38:29,443
续订状态更改中
被通知的唯一触发器

719
00:38:29,476 --> 00:38:32,546
此通知还提供对顾客行为的洞察

720
00:38:32,579 --> 00:38:34,014
此通知可用于确定订阅者

721
00:38:34,047 --> 00:38:36,550
在续订期间何时取消

722
00:38:36,583 --> 00:38:37,885
是续订的前一天吗

723
00:38:37,918 --> 00:38:39,786
新订阅者是否会在注册你的服务后

724
00:38:39,820 --> 00:38:42,256
立即停用自动续订呢

725
00:38:42,289 --> 00:38:43,824
此类信息对于了解取消的原因

726
00:38:43,857 --> 00:38:47,427
以及改进你的产品非常重要

727
00:38:47,461 --> 00:38:50,130
最后 在没有通知的情况下

728
00:38:50,163 --> 00:38:52,900
某些场景可能永远不会
反映在用户的历史记录中

729
00:38:52,933 --> 00:38:57,237
例如 用户可以在
订阅期到期之前停用

730
00:38:57,271 --> 00:38:59,940
但随后重新激活自动续订

731
00:38:59,973 --> 00:39:02,242
因为这一切都发生在订阅期内

732
00:39:02,276 --> 00:39:05,345
所以不会对订阅的长期状态
产生影响

733
00:39:05,379 --> 00:39:07,981
这些决策对于了解你的顾客
可能很重要

734
00:39:08,015 --> 00:39:09,483
通知提供了检测

735
00:39:09,516 --> 00:39:13,654
和记录这些类型场景的信息

736
00:39:13,687 --> 00:39:16,924
总体而言 通知通过
在顾客使用的每一步提供信息

737
00:39:16,957 --> 00:39:19,459
来增强和创造了解顾客行为的机会

738
00:39:19,493 --> 00:39:23,530
覆盖比以往任何时候都多的场景

739
00:39:23,564 --> 00:39:26,900
总之 今天我们已经介绍了
App Store Server API

740
00:39:26,934 --> 00:39:29,269
和 App Store Server Notifications

741
00:39:29,303 --> 00:39:30,871
这些功能可用于改进

742
00:39:30,904 --> 00:39:33,207
管理和跟踪购买的功能

743
00:39:33,240 --> 00:39:37,177
它们使用了更新的消息类型
覆盖了比以往任何时候都多的案例

744
00:39:37,211 --> 00:39:39,046
这些系统可用于所有的客户

745
00:39:39,079 --> 00:39:42,616
并与 Original StoreKit
和 StoreKit 2 交叉兼容

746
00:39:42,649 --> 00:39:46,086
可以提高你
监控订阅生命周期的能力

747
00:39:46,119 --> 00:39:49,489
最后 这些工具在沙盒和生产中
都是可用的

748
00:39:49,523 --> 00:39:51,458
并且是任何系统的重要补充

749
00:39:51,491 --> 00:39:54,795
谢谢你加入我们
祝你的 WWDC 之旅一切顺利

