1
00:00:00,501 --> 00:00:08,509
♪ ♪

2
00:00:09,309 --> 00:00:11,645
Vaibhav Gautam: 大家好
我是 Vaibhav Gautam

3
00:00:11,678 --> 00:00:15,482
我是 Software Power 团队的
工程师

4
00:00:15,516 --> 00:00:17,251
App 为人们的日常生活

5
00:00:17,284 --> 00:00:22,222
提供了多种多样的重要功能
让生活更丰富多彩

6
00:00:22,256 --> 00:00:26,293
但这些功能需要付出一定代价
即电量消耗

7
00:00:26,326 --> 00:00:30,230
因此 如何改进 App 的
耗电量

8
00:00:30,264 --> 00:00:32,432
让用户有更长的时间
使用设备和您的 App

9
00:00:32,466 --> 00:00:37,437
是需要格外关注的问题

10
00:00:37,471 --> 00:00:39,573
我们深入研究了不同的系统组件

11
00:00:39,606 --> 00:00:41,775
了解电量消耗的问题

12
00:00:41,808 --> 00:00:45,245
有四个关键行动

13
00:00:45,279 --> 00:00:47,281
可以大大改善您 App 的耗电量

14
00:00:47,314 --> 00:00:51,185
在本次讲座中
我们将与大家逐一分享

15
00:00:51,218 --> 00:00:54,454
其中包括 App 的深色模式

16
00:00:54,488 --> 00:00:56,823
审计帧率

17
00:00:56,857 --> 00:01:00,060
限制后台时间

18
00:01:00,093 --> 00:01:02,196
以及推迟 App 的任务

19
00:01:03,797 --> 00:01:05,899
首先 我们先看下深色模式

20
00:01:06,834 --> 00:01:09,703
深色模式在 iOS 13 中
首次推出

21
00:01:09,736 --> 00:01:14,942
用户可将设备配置为
深颜色的显示方式

22
00:01:14,975 --> 00:01:18,946
深色模式的个性化显示
您应该不陌生

23
00:01:18,979 --> 00:01:22,649
但这对耗电量同样有
极大的影响

24
00:01:24,051 --> 00:01:27,888
这是因为在使用
OLED 显示屏的设备中

25
00:01:27,921 --> 00:01:31,191
如 iPhone 13 和 13 Pro

26
00:01:31,225 --> 00:01:35,762
深色内容比浅色内容
耗电量更低

27
00:01:35,796 --> 00:01:40,434
在 OLED 显示屏中
每个像素都需要单独的能耗

28
00:01:40,467 --> 00:01:45,539
而深色模式下 点亮像素所需的
能耗较少

29
00:01:45,572 --> 00:01:48,609
系统的所有组件中

30
00:01:48,642 --> 00:01:52,779
显示屏是耗电最多的

31
00:01:52,813 --> 00:01:58,051
实际上 在典型用例中
显示屏是电池损耗的

32
00:01:58,085 --> 00:02:00,554
主要来源

33
00:02:00,587 --> 00:02:04,725
您可以改变显示屏的电池损耗

34
00:02:04,758 --> 00:02:07,961
其中一个方法就是应用深色模式

35
00:02:08,896 --> 00:02:12,933
我以我们团队正在开发的

36
00:02:12,966 --> 00:02:14,801
Food Truck App 为例

37
00:02:14,835 --> 00:02:18,071
这一 App 的背景颜色很显眼

38
00:02:18,105 --> 00:02:21,008
占据了显示屏的大部分

39
00:02:21,041 --> 00:02:22,910
使用深色模式时

40
00:02:22,943 --> 00:02:27,047
背景颜色比浅色模式下的深

41
00:02:27,080 --> 00:02:29,583
大大减少了电池损耗

42
00:02:29,616 --> 00:02:34,254
事实上 在这种案例中 我们预期

43
00:02:34,288 --> 00:02:38,759
电池损耗能减少 70% 以上

44
00:02:38,792 --> 00:02:41,495
这是非常惊人的比例

45
00:02:41,528 --> 00:02:43,897
屏幕亮度高

46
00:02:43,931 --> 00:02:46,667
电池电量节省更多

47
00:02:46,700 --> 00:02:49,603
对喜欢用深色模式的用户来说

48
00:02:49,636 --> 00:02:53,607
这是减少耗电的绝佳机会

49
00:02:53,640 --> 00:02:56,009
同时也可以减少热负荷

50
00:02:56,844 --> 00:03:01,215
要应用深色模式 首先要看下
您的 App 当前在

51
00:03:01,248 --> 00:03:03,884
深色模式下是如何显示的

52
00:03:03,917 --> 00:03:07,154
想想如果要适应系统 UI

53
00:03:07,187 --> 00:03:10,257
需要更新您 App 中哪些组件

54
00:03:10,290 --> 00:03:16,930
而 Xcode 构建 App 时使用外观功能
让这一过程更简便

55
00:03:18,165 --> 00:03:23,971
您的 App 如果仅支持浅色模式
可能会使用硬编码颜色

56
00:03:24,004 --> 00:03:28,275
在 Xcode 中使用动态颜色
以支持浅色和深色模式中的

57
00:03:28,308 --> 00:03:32,713
背景颜色 图像和文本

58
00:03:32,746 --> 00:03:36,350
系统会自动应用正确的色值

59
00:03:36,383 --> 00:03:38,919
根据模式改变进行更新

60
00:03:40,587 --> 00:03:44,558
您的 App 应同样支持
浅色和深色模式中的

61
00:03:44,591 --> 00:03:46,593
替代图像

62
00:03:46,627 --> 00:03:50,063
您可查看 WWDC 2019 中的
“Implementing Dark Mode on iOS”

63
00:03:50,097 --> 00:03:55,469
以了解更多关于自定义 App
深色模式的信息

64
00:03:57,004 --> 00:04:00,507
现在您知道如何在 App 中
应用深色模式了

65
00:04:00,541 --> 00:04:06,113
网页内容中如何应用深色模式
同样也是需要考虑的

66
00:04:06,146 --> 00:04:09,049
Safari 不会自动加深
网页内容颜色

67
00:04:09,082 --> 00:04:13,320
因此要确保您的网页内容
也能适应深色模式

68
00:04:14,321 --> 00:04:19,293
要在您网站的样式表中
实现配色方案属性

69
00:04:20,894 --> 00:04:25,399
在网页中启用默认文本及背景颜色

70
00:04:25,432 --> 00:04:27,768
从而匹配当前系统外观

71
00:04:27,801 --> 00:04:31,405
标准表单控件和滚动条

72
00:04:31,438 --> 00:04:34,374
其它指定的系统颜色
会改变外观

73
00:04:34,408 --> 00:04:38,011
在浅色和深色模式之间转换

74
00:04:38,045 --> 00:04:40,414
无论颜色在样式表中
哪个位置被引用

75
00:04:40,447 --> 00:04:44,418
都请使用样式表变量

76
00:04:44,451 --> 00:04:47,821
这让您的网页内容
可以随着设备在浅色模式

77
00:04:47,855 --> 00:04:51,925
和深色模式之间的切换
更新其颜色

78
00:04:51,959 --> 00:04:56,997
将同样的逻辑应用到
网页的图像及其它媒体 assets 中

79
00:04:57,030 --> 00:05:00,501
为不同模式套用不同变体

80
00:05:00,534 --> 00:05:04,371
您可查看 WWDC 2019 中的
“Supporting Dark Mode in Your Web Content”

81
00:05:04,404 --> 00:05:07,574
以了解更多关于在网页内容中

82
00:05:07,608 --> 00:05:11,211
应用深色模式的内容

83
00:05:11,245 --> 00:05:17,184
另一个减少 App 电池损耗的方法
是审计帧率

84
00:05:17,217 --> 00:05:19,953
在使用 ProMotion 显示屏的设备中

85
00:05:19,987 --> 00:05:23,257
刷新率会影响电池损耗

86
00:05:23,290 --> 00:05:26,760
高刷新率则需要高能耗

87
00:05:26,793 --> 00:05:29,696
您 App 中的动画帧率

88
00:05:29,730 --> 00:05:32,499
决定了显示屏的刷新率

89
00:05:32,533 --> 00:05:35,669
想想 App 的主要内容

90
00:05:35,702 --> 00:05:37,971
以及需求的帧率

91
00:05:38,005 --> 00:05:42,176
不一定 App 中的所有内容
都需要高帧率

92
00:05:42,209 --> 00:05:45,712
显示屏的刷新率是由您 App 中

93
00:05:45,746 --> 00:05:48,448
最高帧率的动画决定的

94
00:05:48,482 --> 00:05:52,619
您的 App 可能有次要元素的
刷新率

95
00:05:52,653 --> 00:05:54,454
高于必要水平

96
00:05:54,488 --> 00:05:58,792
导致 App 整体消耗比预期
更多的电量

97
00:06:00,427 --> 00:06:03,797
我们再以 food truck App 为例

98
00:06:03,830 --> 00:06:08,836
顶部主要的卡车场景
是以每秒 30 帧的速率渲染的

99
00:06:08,869 --> 00:06:12,439
在卡车下面 有一个文字蒙版
“Food Truck”

100
00:06:12,472 --> 00:06:15,142
以水平方向滚动

101
00:06:15,175 --> 00:06:19,613
这种次要文本是以
每秒 60 帧的速率渲染的

102
00:06:19,646 --> 00:06:24,351
结果是 整个屏幕现在均以
每秒 60 帧的刷新率渲染

103
00:06:24,384 --> 00:06:27,588
如果我们将文本动画
改为 30fps

104
00:06:27,621 --> 00:06:30,691
整个屏幕就以 30fps 来渲染

105
00:06:30,724 --> 00:06:33,961
我们可以减少高达 20% 的
电池损耗

106
00:06:33,994 --> 00:06:35,462
太神奇了

107
00:06:36,230 --> 00:06:40,701
要调试和获取更多关于
您 App 帧率的信息

108
00:06:40,734 --> 00:06:42,636
就使用 Instruments 吧

109
00:06:42,669 --> 00:06:45,572
使用 instrument 中的
CoreAnimation FPS

110
00:06:45,606 --> 00:06:51,178
可以查看您 App 随着时间推移的
帧率时间线

111
00:06:51,211 --> 00:06:54,414
首先审计主要用户场景

112
00:06:54,448 --> 00:06:59,052
确定帧是否以预期的帧率渲染

113
00:06:59,086 --> 00:07:01,955
确定屏幕上的次要元素帧率

114
00:07:01,989 --> 00:07:05,626
是否高于主要内容的帧率

115
00:07:06,693 --> 00:07:12,766
您的 App 可能使用 iOS 中的
CoreAnimation 所提供的 CADisplayLink

116
00:07:12,799 --> 00:07:16,603
来驱动自定义动画
以及自定义渲染循环

117
00:07:16,637 --> 00:07:21,542
CADisplayLink 是一个定时器
与显示屏刷新率同步

118
00:07:21,575 --> 00:07:25,145
它为您 App 提供了
必要的计时信息

119
00:07:25,179 --> 00:07:30,384
这样您的自定义绘图
能意识到刷新率

120
00:07:30,417 --> 00:07:34,288
您的 App 可提示
CADisplayLink 对象

121
00:07:34,321 --> 00:07:37,758
期望的屏幕刷新率是什么

122
00:07:37,791 --> 00:07:41,461
设置 CADisplayLink 的
preferredFrameRateRange

123
00:07:41,495 --> 00:07:46,466
指定您最小 最大和偏好帧率

124
00:07:47,868 --> 00:07:51,305
Display link 随后根据
系统能处理的范围

125
00:07:51,338 --> 00:07:55,676
选择可用帧率中
与您偏好帧率最接近的数值

126
00:07:55,709 --> 00:07:57,978
如果无法提供该数值

127
00:07:58,011 --> 00:08:02,382
则会尝试保留在您指定的范围内

128
00:08:02,416 --> 00:08:04,384
要配置您的 display link

129
00:08:04,418 --> 00:08:07,888
用 target 和 selector 初始化

130
00:08:07,921 --> 00:08:11,825
提供的 selector 用于
运行自定义动画

131
00:08:11,859 --> 00:08:16,163
计算下一次显示的视频帧

132
00:08:16,196 --> 00:08:18,298
初始化 display link 后

133
00:08:18,332 --> 00:08:20,667
设置偏好帧率范围

134
00:08:20,701 --> 00:08:24,404
在这一例子中 偏好帧率为 30

135
00:08:24,438 --> 00:08:29,076
但范围可在 10 至 60 之间

136
00:08:29,109 --> 00:08:32,746
最后 在当前运行循环中
添加 display link

137
00:08:34,882 --> 00:08:39,820
当考虑 App 的电池损耗时
要紧记刷新率

138
00:08:39,853 --> 00:08:43,891
这对于使用 ProMotion 显示屏
支持高动态刷新率的

139
00:08:43,924 --> 00:08:47,361
设备来说尤为重要

140
00:08:47,394 --> 00:08:50,831
使用 Instruments 监测
您 App 的帧率

141
00:08:50,864 --> 00:08:55,536
在发布 App 前先发现问题

142
00:08:55,569 --> 00:09:00,240
最后 将信息提供给系统
用 CADisplayLink

143
00:09:00,274 --> 00:09:03,810
限制 App 内容的刷新率

144
00:09:05,279 --> 00:09:08,215
您可查看 WWDC 2021 的

145
00:09:08,248 --> 00:09:11,852
“Optimize for variable
refresh rate displays” 以了解更多

146
00:09:11,885 --> 00:09:15,455
关于帧率优化的信息

147
00:09:15,489 --> 00:09:19,193
现在 我们来说下
App 后台运行时

148
00:09:19,226 --> 00:09:21,295
如何减少电池损耗

149
00:09:21,328 --> 00:09:25,365
当有人将您的 App
切换到另一个 App 时

150
00:09:25,399 --> 00:09:28,902
您的 App 可能会需要使用
后台执行 APIs

151
00:09:28,936 --> 00:09:31,438
来保证在后台持续运行

152
00:09:31,471 --> 00:09:33,106
在后台运行时

153
00:09:33,140 --> 00:09:39,112
您的 App 可能会继续使用
常用服务 如定位和音频

154
00:09:39,146 --> 00:09:43,550
长时间运行这些服务
将会导致电池损耗

155
00:09:43,584 --> 00:09:46,887
因此 当您的 App 在后台
使用这些服务时

156
00:09:46,920 --> 00:09:49,723
您需要尤为小心

157
00:09:49,756 --> 00:09:56,029
我们来说下使用这些模式时
如何避免过多的电池损耗

158
00:09:56,063 --> 00:09:58,866
定位服务保证设备处于唤醒状态

159
00:09:58,899 --> 00:10:01,201
从而持续定位

160
00:10:01,235 --> 00:10:04,304
即使对于用户来说
App 并不可见

161
00:10:04,338 --> 00:10:07,741
也可能在后台持续进行
定位的流式传输

162
00:10:07,774 --> 00:10:10,277
导致电池损耗过多

163
00:10:10,310 --> 00:10:15,616
很重要的是 要确保您清楚了解
您 App 后台定位 session 的

164
00:10:15,649 --> 00:10:17,718
运行时间

165
00:10:17,751 --> 00:10:19,853
当您不需要该 session 时

166
00:10:19,887 --> 00:10:23,323
确保 App
调用 stopUpdatingLocation()

167
00:10:23,357 --> 00:10:25,559
从而停止该 session

168
00:10:25,592 --> 00:10:28,161
在 App 开发的不同阶段

169
00:10:28,195 --> 00:10:31,765
您可以用不同的工具
来查看后台定位使用

170
00:10:31,798 --> 00:10:34,168
可能会超乎您所料

171
00:10:34,201 --> 00:10:36,403
在构建和测试 App 时

172
00:10:36,436 --> 00:10:40,541
Xcode gauges 可用于
查看系统能耗

173
00:10:40,574 --> 00:10:43,210
以及后台定位使用

174
00:10:43,243 --> 00:10:46,079
发布前测试 App 时

175
00:10:46,113 --> 00:10:51,685
您可以使用 MetricKit 来收集
一天内使用情况的诊断信息

176
00:10:51,718 --> 00:10:57,558
iOS 16 中新增了
在 Control Center 显示定位使用

177
00:10:57,591 --> 00:11:00,594
Xcode gauges 提供关于
系统使用的信息

178
00:11:00,627 --> 00:11:05,265
如 CPU 网络 定位使用

179
00:11:05,299 --> 00:11:09,069
Xcode gauges 会展示
您 App 的定位使用

180
00:11:09,102 --> 00:11:11,772
以及能量损耗时间线

181
00:11:11,805 --> 00:11:15,442
这一时间线视图可验证您的
定位运行时间是否在您

182
00:11:15,475 --> 00:11:19,446
预期的时间停止
这是一个绝佳的方法

183
00:11:20,314 --> 00:11:24,818
另一个工具是在测试 App 时
使用 MetricKit

184
00:11:24,852 --> 00:11:28,055
使用
cumulativeBackgroundLocationTime 属性

185
00:11:28,088 --> 00:11:33,727
查看您 App 在后台
使用定位服务的活跃时间

186
00:11:34,995 --> 00:11:38,365
在 iOS 16 的更新中
用户可以通过

187
00:11:38,398 --> 00:11:43,070
浏览 Control Center
监测当前使用定位服务的 App

188
00:11:43,103 --> 00:11:45,906
用户可以点击顶部的文本

189
00:11:45,939 --> 00:11:49,276
查看使用定位的 App 的详细视图

190
00:11:49,309 --> 00:11:52,112
用这种方式可以发现那些
不在前台运行

191
00:11:52,145 --> 00:11:54,548
却仍然在使用定位系统的情况

192
00:11:54,581 --> 00:11:57,885
如果您的 App 毫无征兆地
在这里显示

193
00:11:57,918 --> 00:12:03,090
就是您 App
有活跃定位流 session 的指标

194
00:12:03,123 --> 00:12:07,027
我们可以将同样的原则
应用到音频 sessions

195
00:12:07,060 --> 00:12:11,331
假设我们有一个音乐 App
使用音频播放器

196
00:12:11,365 --> 00:12:15,102
来回放一些文件
而用户停止了回放

197
00:12:15,936 --> 00:12:18,739
App 不仅应暂停或停止音频

198
00:12:18,772 --> 00:12:22,042
而且应暂停或停止 Audio Engine

199
00:12:22,075 --> 00:12:25,979
从而阻止其空运转

200
00:12:26,013 --> 00:12:28,448
我们推荐使用自动关闭模式

201
00:12:28,482 --> 00:12:32,619
该模式可通过设置
AVAudioEngine 类的

202
00:12:32,653 --> 00:12:35,556
autoShutdownEnabled 来启用

203
00:12:35,589 --> 00:12:39,726
在这一模式下 audio engine
继续监控及探测

204
00:12:39,760 --> 00:12:42,496
在一定期间内是否空运转

205
00:12:42,529 --> 00:12:47,000
如在空运转 引擎将关闭音频硬件

206
00:12:47,034 --> 00:12:51,205
随后 如果有任何软件源
再次活跃运行

207
00:12:51,238 --> 00:12:54,341
将会动态开启音频硬件

208
00:12:54,374 --> 00:12:57,611
这些都是在后台运行的

209
00:12:57,644 --> 00:13:02,249
watchOS 的自动关闭模式是
强制执行的行为

210
00:13:02,282 --> 00:13:05,385
确保在 Audio Engine 未使用时
将其停止

211
00:13:05,419 --> 00:13:07,654
从而减少能耗

212
00:13:07,688 --> 00:13:09,923
限制后台运行时间的关键在于

213
00:13:09,957 --> 00:13:13,894
要记得提示系统您完成的时间

214
00:13:13,927 --> 00:13:18,532
最后一个改善耗电量的动作
是延迟工作

215
00:13:18,565 --> 00:13:20,467
在一天的使用中

216
00:13:20,501 --> 00:13:24,838
您的 App 可能要处理
许多不同的任务和数据

217
00:13:24,872 --> 00:13:28,876
有些是需要在服务用户操作时
立即进行的

218
00:13:28,909 --> 00:13:32,412
如屏幕上的渲染内容

219
00:13:32,446 --> 00:13:35,282
或用户点击时播放音频或视频

220
00:13:37,584 --> 00:13:39,853
其它运行工作如机器学习任务

221
00:13:39,887 --> 00:13:45,292
上传分析或备份
时间敏感性并不高

222
00:13:45,325 --> 00:13:49,129
如果我们将这些非时间敏感性的工作
延迟到其它更合适的时间

223
00:13:49,162 --> 00:13:51,031
在设备充电时

224
00:13:51,064 --> 00:13:52,299
我们可以节省电池损耗

225
00:13:52,332 --> 00:13:56,537
避免与用户主动触发的
及交互性工作发生冲突

226
00:13:56,570 --> 00:14:01,008
我们来看下您可以用来完成
该行为的三个 APIs

227
00:14:01,041 --> 00:14:07,648
BGProcessingTask 是延迟
长时间运行工作的绝佳选择

228
00:14:07,681 --> 00:14:10,617
授权系统支配的 URLSession
是规划可延迟网络连接的

229
00:14:10,651 --> 00:14:13,053
完美选择

230
00:14:13,086 --> 00:14:16,456
利用正确的推送优先级
可帮助服务器

231
00:14:16,490 --> 00:14:19,059
在适宜的时间传递推送

232
00:14:19,092 --> 00:14:21,995
我们逐一详细了解下

233
00:14:22,029 --> 00:14:24,798
首先是 BGProcessingTask

234
00:14:24,831 --> 00:14:29,269
BGProcessingTask 可让您
将长时间运行的处理任务

235
00:14:29,303 --> 00:14:34,241
延迟到其它更适宜的时间
如设备充电时

236
00:14:34,274 --> 00:14:37,010
这对如数据库清理

237
00:14:37,044 --> 00:14:41,415
创建备份 运行机器学习训练
诸如此类的任务非常适合

238
00:14:41,448 --> 00:14:47,754
您只需通过使用
BGProcessingTaskRequest API 创建请求

239
00:14:47,788 --> 00:14:50,891
提供一个应用标识符

240
00:14:50,924 --> 00:14:52,359
然后提供更多信息

241
00:14:52,392 --> 00:14:57,497
如您的任务是否需要
外接电源或网络

242
00:14:57,531 --> 00:15:01,335
提供更多信息可帮助系统
在更好的时间窗口内

243
00:15:01,368 --> 00:15:03,537
规划该任务

244
00:15:03,570 --> 00:15:08,242
系统会在合适的时间
后台启动您的 App

245
00:15:08,275 --> 00:15:12,613
保证数分钟的运行时间
从而完成可延迟工作

246
00:15:12,646 --> 00:15:16,116
接下来是
discretionary URLSession

247
00:15:16,149 --> 00:15:20,254
您的 App 可能已经在普通网络连接中

248
00:15:20,287 --> 00:15:22,055
使用了 Background URLSessions

249
00:15:22,089 --> 00:15:28,195
在您使用 discretionary 标记时
Background URLSessions 将更为理想

250
00:15:28,228 --> 00:15:32,833
有 discretionary 标记的 URLSessions

251
00:15:32,866 --> 00:15:35,335
将完全由系统决定

252
00:15:35,369 --> 00:15:38,605
在更优时间运行网络连接任务

253
00:15:38,639 --> 00:15:42,743
如当设备接通电源
和连接至 Wi-Fi 时

254
00:15:42,776 --> 00:15:46,547
discretionary 标记非常适用于
非用户触发的

255
00:15:46,580 --> 00:15:50,784
长时间运行的网络
如远端信息收集

256
00:15:50,817 --> 00:15:54,454
或下载电视剧集的下一集

257
00:15:54,488 --> 00:15:57,090
由于网络任务是全权交给系统的

258
00:15:57,124 --> 00:15:59,927
意味着您的 App 不需要

259
00:15:59,960 --> 00:16:02,362
在网络事务完成时运行

260
00:16:03,230 --> 00:16:05,866
要使用 discretionary URL sessions

261
00:16:05,899 --> 00:16:09,970
您只需设置一个
background URL session

262
00:16:10,003 --> 00:16:14,074
将 isDiscretionary 设置为 true

263
00:16:14,107 --> 00:16:16,276
您可提供额外信息

264
00:16:16,310 --> 00:16:20,480
帮助系统在合适的时间计划下载

265
00:16:20,514 --> 00:16:24,451
设置超时间隔
这样系统不会一直尝试下载

266
00:16:24,484 --> 00:16:27,120
从而导致电池损耗

267
00:16:28,722 --> 00:16:31,291
如果您未来一段时间内

268
00:16:31,325 --> 00:16:33,694
不想上传或下载数据

269
00:16:33,727 --> 00:16:36,864
可以设置最早开始的时间

270
00:16:36,897 --> 00:16:40,033
最后 设置预期的工作量大小

271
00:16:40,067 --> 00:16:43,270
这样系统可智能地

272
00:16:43,303 --> 00:16:45,873
在您多个下载任务中
保持负载平衡

273
00:16:48,175 --> 00:16:52,913
与您用 BGProcessingTask
和 discretionary URL sessions

274
00:16:52,946 --> 00:16:57,417
控制某些操作的即时性类似

275
00:16:57,451 --> 00:17:00,554
您可以通过使用
不同的推送优先级

276
00:17:00,587 --> 00:17:03,123
影响推动的即时性

277
00:17:03,156 --> 00:17:07,327
推送优先级决定了一个通知
推送到设备的

278
00:17:07,361 --> 00:17:08,529
紧急性

279
00:17:08,562 --> 00:17:10,197
对于高优先级的推送

280
00:17:10,230 --> 00:17:13,867
服务器会将其立即推送到设备

281
00:17:13,901 --> 00:17:18,071
潜在地唤醒设备 导致电池损耗

282
00:17:18,105 --> 00:17:19,806
对于低优先级的推送

283
00:17:19,840 --> 00:17:24,011
服务器会将其延迟
直至更为恰当的时机再予以推送

284
00:17:24,044 --> 00:17:26,446
如设备唤醒时

285
00:17:26,480 --> 00:17:29,449
或者有高优先级推送出现时

286
00:17:29,483 --> 00:17:34,855
高优先级推送是如重大天气预警
这种紧急信息的最好选择

287
00:17:34,888 --> 00:17:39,059
低优先级推送适用于
更被动的通知

288
00:17:39,092 --> 00:17:42,496
不紧急且可以被延迟的

289
00:17:42,529 --> 00:17:46,667
利用低优先级推送
推迟可延迟信息的推送

290
00:17:46,700 --> 00:17:52,840
将减少电池损耗 因为设备
不会频繁地从休眠中被唤醒

291
00:17:52,873 --> 00:17:55,108
要配置低优先级推送

292
00:17:55,142 --> 00:17:59,780
只要在推送负载中
将 apns-priority 设置到 5

293
00:17:59,813 --> 00:18:01,782
服务器会处理余下的部分

294
00:18:01,815 --> 00:18:05,686
您的用户会为电量节省而满意

295
00:18:06,553 --> 00:18:10,324
我们来总结下最后的想法
和接下来的步骤

296
00:18:10,357 --> 00:18:13,427
在你的 App 中
提供深色模式的选项

297
00:18:13,460 --> 00:18:18,799
如果用户选择深色模式
尊重其选择可减少电池损耗

298
00:18:18,832 --> 00:18:20,634
查看您的动画

299
00:18:20,667 --> 00:18:25,172
寻找机会在必要时降低帧率

300
00:18:25,205 --> 00:18:28,709
一个小动画都可能带来大改变

301
00:18:28,742 --> 00:18:31,478
让系统知道您已完成动作

302
00:18:31,512 --> 00:18:34,715
时刻关注您的后台运行时间

303
00:18:34,748 --> 00:18:38,585
最后 考虑延迟
长时间运行的后台工作

304
00:18:38,619 --> 00:18:42,756
至其它更好的时机
如设备连接电源时

305
00:18:42,789 --> 00:18:44,691
如果您完成了这些操作

306
00:18:44,725 --> 00:18:47,594
就会真正降低您 App 的能耗

307
00:18:47,628 --> 00:18:49,463
感谢大家

