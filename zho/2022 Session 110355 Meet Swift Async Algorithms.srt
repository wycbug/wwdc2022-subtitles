1
00:00:00,334 --> 00:00:06,340
[欢快的音乐]

2
00:00:09,710 --> 00:00:11,612
Philippe Hausler：
您好 我叫 Philippe

3
00:00:11,645 --> 00:00:15,148
Swift 拥有越来越多的
开源软件包

4
00:00:15,182 --> 00:00:18,352
我很高兴向您介绍
最新添加的内容之一

5
00:00:18,385 --> 00:00:20,354
Swift Async Algorithms

6
00:00:20,387 --> 00:00:23,090
这个包和其他包一起

7
00:00:23,123 --> 00:00:26,493
例如 Swift Collections
和 Swift Algorithms

8
00:00:26,527 --> 00:00:29,997
Swift Async Algorithms 包含一组算法

9
00:00:30,030 --> 00:00:35,435
专门通过 AsyncSequence 按时序
处理数值

10
00:00:35,469 --> 00:00:37,171
但在我们进入内容之前

11
00:00:37,204 --> 00:00:40,207
让我们花点时间
回顾一下 AsyncSequence

12
00:00:40,240 --> 00:00:43,644
AsyncSequence 是一种协议
可以让您描述

13
00:00:43,677 --> 00:00:45,612
通过异步过程产生的值

14
00:00:45,646 --> 00:00:50,817
基本上 它与 Sequence 类似
但有两个关键区别

15
00:00:50,851 --> 00:00:54,288
其迭代器的
next 函数是异步的

16
00:00:54,321 --> 00:00:58,325
因为它可以使用
Swift 并发功能传递值

17
00:00:58,358 --> 00:01:03,297
它还允许您使用 Swift 的抛出异常
以便于处理任何潜在的故障

18
00:01:03,330 --> 00:01:06,233
并且您可以像
Sequence 一样

19
00:01:06,266 --> 00:01:09,002
使用 for-await-in 语法
迭代它

20
00:01:09,036 --> 00:01:11,905
总之 如果您知道
如何使用 Sequence

21
00:01:11,939 --> 00:01:15,409
那么您就已经知道了
如何使用 AsyncSequence

22
00:01:15,442 --> 00:01:19,847
现在 当引入 AsyncSequence
我们在异步版本中添加了

23
00:01:19,880 --> 00:01:23,984
几乎所有可以用于 Sequence 的工具

24
00:01:24,017 --> 00:01:29,990
例如 map、filter
reduce 等算法

25
00:01:30,023 --> 00:01:33,861
Swift Async Algorithms
通过合并更高级的算法

26
00:01:33,894 --> 00:01:37,664
以及与时钟的互操作
向您提供一些真正强大的功能

27
00:01:37,698 --> 00:01:41,535
让那些功能效果更上一层楼

28
00:01:41,568 --> 00:01:45,305
这是一个开源的
AsyncSequence 算法包

29
00:01:45,339 --> 00:01:48,008
可以增强 Swift 并发的功能

30
00:01:48,041 --> 00:01:51,011
去年我们推出了
Swift Algorithms 包

31
00:01:51,044 --> 00:01:53,680
为了演示这些算法的用途

32
00:01:53,714 --> 00:01:55,115
我们制作了一个消息 App

33
00:01:55,148 --> 00:01:58,485
这是一个很好的例子
您可以用这个包

34
00:01:58,519 --> 00:02:00,454
做一些丰富和强大的东西

35
00:02:00,487 --> 00:02:03,457
我们认为这是很好机会

36
00:02:03,490 --> 00:02:07,661
通过迁移 App 使用 Swift 并发

37
00:02:07,694 --> 00:02:10,998
为了强调一些异步算法的使用

38
00:02:11,031 --> 00:02:13,834
我将带您了解我们使用的一些功能

39
00:02:13,867 --> 00:02:16,036
以及它们是如何工作的

40
00:02:16,069 --> 00:02:18,972
首先 我们有一系列

41
00:02:19,006 --> 00:02:21,675
处理多输入
AsyncSequence 的算法

42
00:02:21,708 --> 00:02:27,581
这些算法侧重于以不同的方式将
多个 AsyncSequence 组合在一起

43
00:02:27,614 --> 00:02:30,083
但它们都有一个共同特点

44
00:02:30,117 --> 00:02:35,822
它们接受多个 AsyncSequence 输入
并产生一个 AsyncSequence 输出

45
00:02:36,857 --> 00:02:40,260
您可能已经非常熟悉 Zip

46
00:02:40,294 --> 00:02:44,064
Zip 算法接受多个
输入并对其进行迭代

47
00:02:44,097 --> 00:02:48,101
以便通过每个基础内容
生成一个结果元组

48
00:02:48,135 --> 00:02:52,539
Zip 的每个输入
都是构造 Zip 的基础内容

49
00:02:52,573 --> 00:02:56,276
在标准库中
异步 Zip 算法的工作原理

50
00:02:56,310 --> 00:02:57,744
与 Zip 算法一样

51
00:02:57,778 --> 00:03:00,347
但它并发迭代每个基础内容

52
00:03:00,380 --> 00:03:04,785
如果在迭代其中的
任何一个出现失败则重新抛出报错

53
00:03:04,818 --> 00:03:07,187
现在 完成并发迭代

54
00:03:07,221 --> 00:03:10,424
并支持重抛出错误会相当复杂

55
00:03:10,457 --> 00:03:13,460
但是 Swift Async Algorithms 包
在我们的消息 App 中

56
00:03:13,493 --> 00:03:15,629
为我们解决了所有这些问题

57
00:03:15,662 --> 00:03:17,297
我们之前有很多代码

58
00:03:17,331 --> 00:03:19,900
用来协同异步工作

59
00:03:19,933 --> 00:03:22,469
比如生成视频录制预览和视频转码

60
00:03:22,503 --> 00:03:26,673
以及生成各种尺寸的视频
用来实现高效存储和传输

61
00:03:26,707 --> 00:03:31,211
通过使用 Zip
我们可以确保转码视频

62
00:03:31,245 --> 00:03:33,213
在发送到服务器时得到预览

63
00:03:33,247 --> 00:03:36,416
由于 Zip 是并发的
所以转码和预览

64
00:03:36,450 --> 00:03:39,152
都不会对彼此的工作造成延迟

65
00:03:39,186 --> 00:03:40,988
但更进一步想一下

66
00:03:41,021 --> 00:03:43,924
Zip 本身对任何一边
都没有明显的偏向

67
00:03:43,957 --> 00:03:48,095
所以可以先出视频 也可以出预览

68
00:03:48,128 --> 00:03:51,098
不管它在哪一边 它都会

69
00:03:51,131 --> 00:03:54,968
等待另一方发送完成一个完整的元组

70
00:03:55,002 --> 00:03:58,505
我们可以等待视频和预览的资源配对
以便它们可以一起上传

71
00:03:58,539 --> 00:04:04,044
因为 Zip 会同时等待
双方构造的元组的值

72
00:04:04,077 --> 00:04:07,714
我们得出的结论是 对传入消息

73
00:04:07,748 --> 00:04:10,717
作为 AsyncSequence
建模会很有意义

74
00:04:10,751 --> 00:04:14,421
所以我们决定使用 AsyncStream
来处理这些消息

75
00:04:14,454 --> 00:04:17,157
因为它保留了顺序并
将我们的回调转换为

76
00:04:17,191 --> 00:04:20,093
消息的 AsyncSequence 实例

77
00:04:20,127 --> 00:04:23,130
我们需要解决的功能要求之一是

78
00:04:23,163 --> 00:04:25,532
我们希望支持多个帐户

79
00:04:25,566 --> 00:04:30,304
所以每个帐户都会
构建一个用于传入消息的 AsyncStream

80
00:04:30,337 --> 00:04:31,939
但在实现时

81
00:04:31,972 --> 00:04:36,844
我们需要将它们作为一个单一的
AsyncSequence 一起进行处理

82
00:04:36,877 --> 00:04:41,715
这意味着我们需要一种算法
来将这些 AsyncSequences 合并在一起

83
00:04:41,748 --> 00:04:47,421
多亏 Swift Async Algorithms 包
有一个算法可以做到这一点

84
00:04:47,454 --> 00:04:49,957
它的名字为 “Merge”

85
00:04:49,990 --> 00:04:54,194
在并发迭代多个
AsyncSequences 方面

86
00:04:54,228 --> 00:04:58,565
它的工作方式与 Zip 类似
但它不创建成对的元组

87
00:04:58,599 --> 00:05:01,735
它要求共享相同的元素类型

88
00:05:01,768 --> 00:05:04,137
并将基础 AsyncSequences 合并为

89
00:05:04,171 --> 00:05:08,141
这些元素的一个单独的
AsyncSequence

90
00:05:08,175 --> 00:05:12,346
Merge 的工作方式是在迭代时

91
00:05:12,379 --> 00:05:13,914
采用任何一边产生的第一个元素

92
00:05:13,947 --> 00:05:18,318
它不断迭代
直到没有更多的值可以产生

93
00:05:18,352 --> 00:05:23,357
具体就是当所有基本 AsyncSequence
从其迭代器返回 nil 时

94
00:05:23,390 --> 00:05:27,861
如果有任何基础错误产生
则会取消其他迭代器的工作

95
00:05:27,895 --> 00:05:33,400
这让我们可以获取
多个消息的 AsyncSequence 并合并它们

96
00:05:33,433 --> 00:05:38,338
这些组合算法
在产生值时同时进行工作

97
00:05:38,372 --> 00:05:43,076
但有时
与时间本身实际互动是有用的

98
00:05:43,110 --> 00:05:47,481
Swift Async Algorithms 包
引入了一系列算法

99
00:05:47,514 --> 00:05:51,919
通过利用 Swift 中新的
Clock API 来处理时间

100
00:05:51,952 --> 00:05:55,455
时间本身可以是
一个非常复杂的主题

101
00:05:55,489 --> 00:05:58,959
Swift (5.7) 中新增了
一组 API

102
00:05:58,992 --> 00:06:01,495
以确保其安全性和一致性

103
00:06:01,528 --> 00:06:04,565
Clock (时钟) 、Instant (即时)
和 Duration (持续时间)

104
00:06:06,433 --> 00:06:09,236
Clock (时钟)
协议定义了两个基元

105
00:06:09,269 --> 00:06:11,605
一种在给定时长后唤醒的方式

106
00:06:11,638 --> 00:06:13,740
和一种产生现在概念的方式

107
00:06:13,774 --> 00:06:15,876
它含有几个内置时钟

108
00:06:15,909 --> 00:06:17,811
其中比较常用的两个是

109
00:06:17,845 --> 00:06:20,280
ContinuousClock
和 SuspendingClock

110
00:06:20,314 --> 00:06:24,885
您可以使用 ContinuousClock
像秒表一样测量时间

111
00:06:24,918 --> 00:06:28,655
无论被测事物的状态如何
时间都在那里进行

112
00:06:28,689 --> 00:06:32,593
另一方面 SuspendingClock
正如它的名字一样

113
00:06:32,626 --> 00:06:35,462
当机器进入睡眠状态时它会挂起

114
00:06:35,495 --> 00:06:40,400
我们在 App 中
使用了新的 Clock API

115
00:06:40,434 --> 00:06:45,672
从现有的回调事件迁移到时钟睡眠功能
用来处理截止日期后解除警报

116
00:06:45,706 --> 00:06:49,943
我们能够通过添加
持续时间值来创建截止日期

117
00:06:49,977 --> 00:06:55,249
这个值需要特别表明
我们想要的延迟秒数

118
00:06:55,282 --> 00:06:58,785
Clock (时钟)
也有一些方便的方法

119
00:06:58,819 --> 00:07:00,454
来测量工作执行的持续时间

120
00:07:00,487 --> 00:07:03,891
这里我们有之前
提到的两个常见的时钟

121
00:07:03,924 --> 00:07:06,493
SuspendingClock 和
ContinuousClock

122
00:07:07,494 --> 00:07:09,363
下面展示出的计时器是

123
00:07:09,396 --> 00:07:11,031
用来解释实测工作的

124
00:07:11,064 --> 00:07:12,699
潜在工作时间的

125
00:07:12,733 --> 00:07:16,170
这两个时钟之间的主要区别

126
00:07:16,203 --> 00:07:19,373
来自于它在机器休眠时的行为

127
00:07:20,440 --> 00:07:24,244
对于此类长时间运行的工作
工作可以暂停

128
00:07:24,278 --> 00:07:25,812
就像我们在合上盖子一样

129
00:07:25,846 --> 00:07:30,083
但是 当我们恢复设备运行时

130
00:07:30,117 --> 00:07:32,286
可以看到 ContinuousClock
仍在记录时间

131
00:07:32,319 --> 00:07:33,887
即使在机器休眠的时候

132
00:07:33,921 --> 00:07:36,390
但 SuspendingClock 并没有

133
00:07:36,423 --> 00:07:39,426
通常 这种差异对于
通过暂停执行时间

134
00:07:39,459 --> 00:07:42,829
以确保动画之类的工作

135
00:07:42,863 --> 00:07:45,999
如预期方式完成很关键

136
00:07:46,033 --> 00:07:49,536
如果您需要与机器进行
在时间方面的交互

137
00:07:49,570 --> 00:07:52,873
比如像动画一样 请使用
SuspendingClock

138
00:07:53,907 --> 00:07:57,110
判定和计量
与设备前的人有关的任务

139
00:07:57,144 --> 00:07:59,813
使用 ContinuousClock
则更加合适

140
00:07:59,847 --> 00:08:03,116
因此 如果您需要做
一个绝对持续时间

141
00:08:03,150 --> 00:08:07,788
工作是相对于人类有关的话 就请用
ContinuousClock

142
00:08:07,821 --> 00:08:12,292
Swift Async Algorithms 包
使用这些新的 Clock、Instant

143
00:08:12,326 --> 00:08:16,263
和 Duration 类型
来构建通用算法

144
00:08:16,296 --> 00:08:21,001
用于许多与时间相关的事件处理方法

145
00:08:21,034 --> 00:08:24,404
在我们的消息 App 中
我们发现这些功能确实有助于

146
00:08:24,438 --> 00:08:27,508
提供对事件的精确控制

147
00:08:27,541 --> 00:08:32,412
它让我们可以限制交互
并有效的缓冲消息

148
00:08:33,347 --> 00:08:36,483
也许我们利用时间的最突出的领域

149
00:08:36,517 --> 00:08:38,352
是搜索消息

150
00:08:38,385 --> 00:08:42,289
我们创建了一个
管理结果通道的控制器

151
00:08:42,322 --> 00:08:47,661
通道会整理好搜索任务
的结果并返回给我们的 UI

152
00:08:47,694 --> 00:08:51,598
搜索任务本身需要有一些

153
00:08:51,632 --> 00:08:53,333
在时间方面的特征

154
00:08:53,367 --> 00:08:58,105
我们希望确保在服务器上
对搜索消息进行频率限制

155
00:08:59,740 --> 00:09:03,177
Debounce 算法会在迭代过程中
发出下一个值之前

156
00:09:03,210 --> 00:09:06,547
等待一个静止时间

157
00:09:06,580 --> 00:09:10,784
这意味着虽然事件可以很快到来
但我们希望确保

158
00:09:10,817 --> 00:09:14,588
在处理下一个值之前
有一个静默期

159
00:09:14,621 --> 00:09:18,025
当用户搜索时
对搜索框里的文本进行快速更改

160
00:09:18,058 --> 00:09:19,793
我们不希望搜索控制器

161
00:09:19,826 --> 00:09:22,796
对每次搜索内容的修改都发送请求

162
00:09:22,829 --> 00:09:26,133
而是 我们要确保
经过一个静默期

163
00:09:26,166 --> 00:09:29,670
直到我们确定打字的动作
很可能已经完成时

164
00:09:29,703 --> 00:09:33,740
默认情况下 Debounce 算法
将使用 ContinuousClock

165
00:09:33,774 --> 00:09:37,077
在这种情况下
我们可以对输入进行去抖动处理

166
00:09:37,110 --> 00:09:40,581
使它等待指定的
期间不发生任何事的时间段

167
00:09:40,614 --> 00:09:43,951
Clock (时钟) 和 Debounce (持续时间)
不仅用于去抖动

168
00:09:43,984 --> 00:09:46,420
它们也用于其他算法

169
00:09:46,453 --> 00:09:49,122
我们发现真正有用的一个方面

170
00:09:49,156 --> 00:09:52,626
是向服务器发送批量消息

171
00:09:52,659 --> 00:09:54,795
在 Swift 算法包中

172
00:09:54,828 --> 00:09:57,998
有一组算法来对值进行分块

173
00:09:58,031 --> 00:10:01,034
Swift Async Algorithms 包
提供了这些功能

174
00:10:01,068 --> 00:10:03,003
而且还添加了一组

175
00:10:03,036 --> 00:10:06,406
与时钟和持续时间互操作的版本

176
00:10:06,440 --> 00:10:10,244
分块算法系列允许按计数

177
00:10:10,277 --> 00:10:12,713
按时间或按内容控制分块

178
00:10:12,746 --> 00:10:16,517
如果其中任何一个发生错误
则重新抛出该报错

179
00:10:16,550 --> 00:10:19,853
所以我们的代码
在遇到故障时是安全的

180
00:10:20,821 --> 00:10:24,691
我们使用
“chunked(by:)” API 来确保

181
00:10:24,725 --> 00:10:28,529
消息块在一定的持续时间
内被序列化并发送出去

182
00:10:28,562 --> 00:10:33,667
这样 我们的服务器就可以
得到客户端发送的有效数据包

183
00:10:33,700 --> 00:10:37,037
我们能够使用这个 API
以每 500 毫秒的间隔

184
00:10:37,070 --> 00:10:39,506
来构建批量消息

185
00:10:39,540 --> 00:10:43,777
那样的话 如果有人
真的很兴奋并且打字很快

186
00:10:43,810 --> 00:10:47,014
那么发送到服务器的请求
就会被分组

187
00:10:47,047 --> 00:10:49,783
在使用集合和序列时

188
00:10:49,816 --> 00:10:54,621
延迟处理元素 通常是有用且高效的

189
00:10:54,655 --> 00:10:58,559
在 Swift 标准库中
AsyncSequence 与

190
00:10:58,592 --> 00:11:00,794
惰性算法的工作方式非常相似

191
00:11:00,827 --> 00:11:04,831
但就像那些惰性算法一样
很多时候您需要

192
00:11:04,865 --> 00:11:08,202
回到集合的世界

193
00:11:08,235 --> 00:11:12,005
Swift Async Algorithms 包
提供了一组初始化器

194
00:11:12,039 --> 00:11:15,342
用于使用 AsyncSequence
构建集合

195
00:11:15,375 --> 00:11:19,246
这些让您可以用已知限定的
AsyncSequence 异步序列

196
00:11:19,279 --> 00:11:23,183
构建字典、集合或数组

197
00:11:23,217 --> 00:11:26,820
集合初始化器让我们
将转换直接整合在消息初始化

198
00:11:26,854 --> 00:11:31,825
使我们仍然可以用数组作为的数据类型

199
00:11:31,859 --> 00:11:34,962
这真的很有用 因为我们有很多功能

200
00:11:34,995 --> 00:11:38,398
真的可以通过一些更新
来使用 Swift 并发

201
00:11:38,432 --> 00:11:41,268
通过保留我们现有的数据结构

202
00:11:41,301 --> 00:11:44,304
我们可以逐步迁移部分 App

203
00:11:44,338 --> 00:11:46,974
从有意义的地方开始

204
00:11:47,007 --> 00:11:49,910
到目前为止 我们只讨论了一小部分

205
00:11:49,943 --> 00:11:52,579
关于 Swift Async Algorithms 包的亮点

206
00:11:52,613 --> 00:11:54,047
除了我们今天介绍的

207
00:11:54,081 --> 00:11:55,849
还有很多其他内容

208
00:11:55,883 --> 00:12:01,855
我们的算法范围从
组合多个异步序列

209
00:12:01,889 --> 00:12:05,425
按时间限制速率

210
00:12:05,459 --> 00:12:08,061
将事项分块

211
00:12:08,095 --> 00:12:10,764
但这些只是我们最终

212
00:12:10,797 --> 00:12:13,233
在我们的 App 中
广泛使用的亮点功能

213
00:12:13,267 --> 00:12:16,436
这个软件包不仅只有这些

214
00:12:16,470 --> 00:12:19,139
它的范围包括 缓冲

215
00:12:19,173 --> 00:12:23,610
归约、合并

216
00:12:23,644 --> 00:12:27,848
间歇性注入值等等

217
00:12:27,881 --> 00:12:31,818
Swift Async Algorithms 包
采用了一组算法

218
00:12:31,852 --> 00:12:35,889
来处理随时间推移的工作
并将其扩展到一系列

219
00:12:35,923 --> 00:12:39,526
可以在您的 App 中
提供帮助的高级功能

220
00:12:39,560 --> 00:12:40,928
试试看

221
00:12:40,961 --> 00:12:44,198
我们真的很希望看看
您用这些构建了什么

222
00:12:44,231 --> 00:12:46,400
这种兴奋也是共享的

223
00:12:46,433 --> 00:12:50,437
该软件包面向您开放式开发

224
00:12:50,470 --> 00:12:53,173
感谢您的收看
并享受课程的其余部分

225
00:12:53,207 --> 00:12:58,345
[欢快的音乐]

