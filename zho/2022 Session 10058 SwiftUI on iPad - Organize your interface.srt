1
00:00:00,334 --> 00:00:07,341
♪ ♪

2
00:00:09,676 --> 00:00:12,546
大家好 欢迎收看

3
00:00:12,579 --> 00:00:14,147
“SwiftUI on iPad:
Organize your interface”

4
00:00:14,181 --> 00:00:17,751
我是 Raj 从事 SwiftUI 工作

5
00:00:17,784 --> 00:00:22,055
iPadOS 16 有许多更新
可以构建更高效

6
00:00:22,089 --> 00:00:25,592
更专业 功能更丰富的 App

7
00:00:25,626 --> 00:00:28,562
在本次讲座中
我将讨论其中的部分更新

8
00:00:28,595 --> 00:00:34,268
并讨论如何组织 SwiftUI app的界面
使其在 iPad 上大放异彩

9
00:00:34,301 --> 00:00:38,305
首先 我将带你浏览列表和表格

10
00:00:38,338 --> 00:00:41,041
然后 我将讨论 SwiftUI 选择模型

11
00:00:41,074 --> 00:00:44,378
以及如何将选择与菜单集成

12
00:00:44,411 --> 00:00:47,581
最后 我将讨论如何使用分屏浏览

13
00:00:47,614 --> 00:00:49,983
来构建 iPad app 的导航

14
00:00:50,017 --> 00:00:52,352
但请等等 还有更多

15
00:00:52,386 --> 00:00:55,689
这实际上是两部分系列的第一部分

16
00:00:55,722 --> 00:00:58,492
在第二部分 我的同事 Harry

17
00:00:58,525 --> 00:01:01,762
将带你浏览工具栏 标题等

18
00:01:01,795 --> 00:01:03,797
Harry 介绍了一些
非常重要的新增功能

19
00:01:03,830 --> 00:01:06,733
这些功能将 SwiftUI iPad app
提升到了一个新的水平

20
00:01:06,767 --> 00:01:09,970
因此请务必观看这两个讲座

21
00:01:10,003 --> 00:01:14,041
我们先从列表和表格开始

22
00:01:14,074 --> 00:01:18,011
我最近加入了几个读书俱乐部
但我的进展很慢

23
00:01:18,045 --> 00:01:20,848
很难找到一个安静的地方看书

24
00:01:20,881 --> 00:01:24,051
因此 为了帮助我专注于阅读
我开始开发一个 App

25
00:01:24,084 --> 00:01:26,620
来寻找这些神秘的安静之地

26
00:01:26,653 --> 00:01:30,858
安静的地方就像阅读的绿洲
只有沙沙的翻书声

27
00:01:30,891 --> 00:01:35,062
这个 App 可以帮助我跟踪
所有安静的地方

28
00:01:35,095 --> 00:01:38,131
我已经为 iPhone 构建了这款 App
但我认为为 iPad 更新这款 App

29
00:01:38,165 --> 00:01:42,035
会是一个有趣的练习
因为这样可以充分利用更大的屏幕

30
00:01:42,069 --> 00:01:45,305
通过让这款 App 更好地
适用于 iPad

31
00:01:45,339 --> 00:01:48,175
当我最终将其安装到 Mac 上时
还会做进一步的改进

32
00:01:48,208 --> 00:01:50,811
我不会在本讲座中明确介绍 Mac

33
00:01:50,844 --> 00:01:54,815
但所示的许多 API 也适用于 macOS

34
00:01:54,848 --> 00:01:58,318
这是到目前为止我发现的
所有安静地方的清单

35
00:01:58,352 --> 00:02:01,989
这份列表是更新 App 的
一个很好的起点

36
00:02:02,022 --> 00:02:04,424
我已经开始研究 iPad 版本了

37
00:02:04,458 --> 00:02:08,395
这并不可怕
但这并没有利用较大的屏幕

38
00:02:08,428 --> 00:02:12,833
这有点浪费空间 信息密度也很低

39
00:02:12,866 --> 00:02:16,336
幸运的是 在 iPadOS 16 中
有一个很好的解决方案

40
00:02:16,370 --> 00:02:19,072
适用于这些信息密集场景类型

41
00:02:19,106 --> 00:02:21,441
多列表

42
00:02:21,475 --> 00:02:24,178
我来让你们看看它是什么样子的

43
00:02:24,211 --> 00:02:27,915
这是为多列表采用 SwiftUI API 后

44
00:02:27,948 --> 00:02:29,816
“All Places”界面的视图效果

45
00:02:29,850 --> 00:02:33,420
在接下来的几分钟内
我将逐步完成这个截图

46
00:02:33,453 --> 00:02:37,291
SwiftUI 中的多列表格
最早是在 macOS Monterey 中引入的

47
00:02:37,324 --> 00:02:42,663
从 iPadOS 16 开始
同样的表 API 现在也可以用于 iPad

48
00:02:42,696 --> 00:02:47,968
像在 Mac 上一样 iPad 上的表格
支持多列和排序

49
00:02:48,001 --> 00:02:50,337
伴随着 iPad 上表格的引入

50
00:02:50,370 --> 00:02:54,374
SwiftUI 现在在 iPad 和 Mac 上
支持表格分段

51
00:02:55,976 --> 00:02:58,879
上一个讲座 “SwiftUI on the Mac:
Build the fundamentals”中

52
00:02:58,912 --> 00:03:03,016
关于表格的一般指导
仍然适用于 iPad

53
00:03:03,050 --> 00:03:06,320
所以如果你还没有看过该讲座
我建议你去看看

54
00:03:07,354 --> 00:03:10,924
我们从 iPhone 列表开始
建立之前显示的表格

55
00:03:10,958 --> 00:03:13,794
这是前面的位置列表的代码

56
00:03:15,495 --> 00:03:18,665
首先 我将从列表切换到表格

57
00:03:18,699 --> 00:03:21,502
表格和列表的构造函数是不同的

58
00:03:21,535 --> 00:03:24,872
表格接受列生成器 而不是视图生成器

59
00:03:26,406 --> 00:03:29,443
我添加的第一列是地名

60
00:03:29,476 --> 00:03:32,546
该列需要一个标题名称
和一个视图生成器

61
00:03:32,579 --> 00:03:35,616
来为集合中的每个元素生成视图

62
00:03:35,649 --> 00:03:39,119
我还指定了一个关键路径
这在以后

63
00:03:39,152 --> 00:03:41,889
向表中添加排序时很重要

64
00:03:41,922 --> 00:03:45,559
请注意 视图生成器
与基于列表的构造非常相似

65
00:03:45,592 --> 00:03:49,229
事实上 我甚至可以重复使用
之前的 PlaceCell 类型

66
00:03:50,797 --> 00:03:55,068
在紧凑尺寸类中
表格只显示它们的第一列

67
00:03:55,102 --> 00:03:58,939
这意味着我的列表在 iPhone 上和
在 iPad 上侧拉时看起来仍然很棒

68
00:04:00,340 --> 00:04:03,610
你可能会注意到
它在外观上与列表有些相似

69
00:04:03,644 --> 00:04:05,979
但我并没有仅仅用列表替换表格

70
00:04:06,013 --> 00:04:09,416
因为重用表格允许
在尺寸类型之间转换时

71
00:04:09,449 --> 00:04:12,920
保留滚动位置和选择

72
00:04:12,953 --> 00:04:15,322
一般而言 确保使用第一栏

73
00:04:15,355 --> 00:04:18,592
以获得紧凑型外观
并始终确保在各种环境中

74
00:04:18,625 --> 00:04:21,862
测试 iPad app 比如 侧拉

75
00:04:23,163 --> 00:04:25,165
好的 我们继续

76
00:04:25,199 --> 00:04:28,135
我将为舒适度和噪声级别添加列

77
00:04:28,168 --> 00:04:32,506
对于只包含文本内容的列
TableColumn 提供了一个方便的 API

78
00:04:32,539 --> 00:04:36,376
允许我在值指向字符串时
省略视图生成器

79
00:04:36,410 --> 00:04:38,645
在这种情况下
我知道舒适度不需要

80
00:04:38,679 --> 00:04:41,515
很大的空间 所以我采用了固定宽度

81
00:04:42,683 --> 00:04:45,686
我还可以使用比较器
将排序添加到表格中

82
00:04:45,719 --> 00:04:48,689
我将创建一些状态来存储比较器

83
00:04:48,722 --> 00:04:51,225
这里的状态是一个数组
因为它代表

84
00:04:51,258 --> 00:04:53,460
表格的所​​有比较器

85
00:04:53,493 --> 00:04:56,096
并且将初始值设置为名称比较器

86
00:04:56,129 --> 00:04:59,333
可以让表格在第一次显示时
显示排序的结果

87
00:05:00,534 --> 00:05:04,872
接下来 将状态绑定传递到表格中
以便将所有内容连接起来

88
00:05:06,073 --> 00:05:09,176
因为每个列都将其值指定为
可比较字段的

89
00:05:09,209 --> 00:05:12,613
关键路径
所以默认情况下它们是可排序的

90
00:05:12,646 --> 00:05:18,051
现在 这个表格完全可以
按名称 舒适度和噪声进行排序

91
00:05:18,085 --> 00:05:20,587
请注意 表格本身并不处理排序

92
00:05:20,621 --> 00:05:21,989
这取决于我

93
00:05:22,022 --> 00:05:26,059
当排序顺序改变时 我可以使用
onChange 修饰器对数据进行排序

94
00:05:27,361 --> 00:05:29,796
好的 我们来试一试吧

95
00:05:30,797 --> 00:05:33,600
这个表格看起来很棒
显示了所有位置数据

96
00:05:33,634 --> 00:05:37,137
真正利用了大屏幕的优势

97
00:05:37,171 --> 00:05:40,607
与 Mac 不同
iPad 上的表格不会水平滚动

98
00:05:40,641 --> 00:05:43,310
所以限制列数很重要

99
00:05:43,343 --> 00:05:47,181
这确保了所有列 都可以同时显示

100
00:05:47,214 --> 00:05:49,816
每列在头部显示标签

101
00:05:49,850 --> 00:05:52,286
点击标签对该列进行排序

102
00:05:52,319 --> 00:05:54,154
我甚至可以按噪声等级分类

103
00:05:57,090 --> 00:06:00,127
在侧拉功能中 表格折叠成一列

104
00:06:00,160 --> 00:06:03,897
以更简洁的格式表示所有信息

105
00:06:03,931 --> 00:06:07,868
现在我已经将列表更新为一个表格
我们开始选择吧

106
00:06:07,901 --> 00:06:11,071
在本节中 我将回顾 SwiftUI 选择模型

107
00:06:11,104 --> 00:06:14,041
并讨论如何将选择与菜单集成

108
00:06:14,074 --> 00:06:18,612
在此过程中
我将为位置表格增加丰富的功能

109
00:06:18,645 --> 00:06:22,149
但首先 我要谈谈 SwiftUI 中的
选择是如何工作的

110
00:06:22,182 --> 00:06:27,287
SwiftUI 包括一个强大的 API
用于管理列表和表格选择

111
00:06:27,321 --> 00:06:30,624
这是一个图解
里面的列表有多行

112
00:06:30,657 --> 00:06:32,426
每一行都有一个标签

113
00:06:32,459 --> 00:06:37,331
这些标签是每一行的唯一值
用于帮助列表管理所选内容

114
00:06:37,364 --> 00:06:40,234
在这张图表中 标签以绿色圆圈显示

115
00:06:41,602 --> 00:06:45,706
除了标签 还有一些状态保留的选择

116
00:06:45,739 --> 00:06:48,242
这是保存标签值的类型

117
00:06:48,275 --> 00:06:50,344
例如 对于多个选择

118
00:06:50,377 --> 00:06:54,448
这是一个集合
用于保存每个选定行的标签

119
00:06:54,481 --> 00:06:57,518
列表的任务是协调每行中的标签

120
00:06:57,551 --> 00:06:58,886
和选择状态

121
00:06:58,919 --> 00:07:02,289
它通过选择绑定来完成这一步

122
00:07:02,322 --> 00:07:05,926
所以当一行被选中时
比如这里的第二行

123
00:07:05,959 --> 00:07:09,763
列表通过选择绑定将它添加到集合中

124
00:07:09,796 --> 00:07:12,032
同样 如果 App 的其他部分

125
00:07:12,065 --> 00:07:17,437
以编程方式更改了集合
例如添加三个

126
00:07:17,471 --> 00:07:20,941
如图所示 则列表会选择它
因为选择绑定会更改

127
00:07:20,974 --> 00:07:24,611
这个通用模型在 iOS 和 macOS 上
都是一样的

128
00:07:24,645 --> 00:07:29,383
所以有两部分需要选择 标签和状态

129
00:07:29,416 --> 00:07:32,719
接下来我想说一下标签从何而来

130
00:07:32,753 --> 00:07:36,957
标签只是可选容器中视图的一个值

131
00:07:36,990 --> 00:07:40,260
用于跟踪该视图是否被选中

132
00:07:40,294 --> 00:07:44,998
在很多情况下 SwiftUI 可以为你
自动合成标签

133
00:07:45,032 --> 00:07:49,203
标签类似于标识符 但不完全相同

134
00:07:49,236 --> 00:07:52,673
使用 ForEach 时 SwiftUI 将自动

135
00:07:52,706 --> 00:07:55,242
从视图的显式标识符
派生出该视图的标签

136
00:07:55,275 --> 00:08:00,013
而且表格会使用其行值的标识符
作为选择标签

137
00:08:00,047 --> 00:08:04,885
在位置 App 中 这意味着将使用
位置结构的标识符类型

138
00:08:04,918 --> 00:08:07,120
有关显示标识的更多信息

139
00:08:07,154 --> 00:08:09,323
请查看 “Demystify SwiftUI”

140
00:08:11,325 --> 00:08:14,595
要手动为视图做标签
请使用 tag 修饰器

141
00:08:14,628 --> 00:08:16,763
这就是 ForEach 在内部所做的工作

142
00:08:16,797 --> 00:08:19,099
tag 修饰器采用哈希值

143
00:08:19,132 --> 00:08:22,336
但在使用标签修改器时 一定要注意

144
00:08:22,369 --> 00:08:25,405
可选择容器中的所有视图
都共享相同的标签类型

145
00:08:25,439 --> 00:08:27,708
这一点很重要

146
00:08:27,741 --> 00:08:31,612
否则 SwiftUI 可能不知道
如何选择视图

147
00:08:31,645 --> 00:08:35,582
请注意 如果使用 ID 修饰器
它不会设置标签

148
00:08:35,616 --> 00:08:39,219
以上就是标签的介绍
让我们再来回顾一下之前的图解

149
00:08:40,487 --> 00:08:42,789
现在我已经解释了这张图解的标签部分

150
00:08:42,823 --> 00:08:45,893
我想重点介绍选择等式的另一边

151
00:08:45,926 --> 00:08:47,561
选择状态

152
00:08:47,594 --> 00:08:51,498
在上一个示例中我使用了一个集合
但也有其他选项

153
00:08:52,900 --> 00:08:56,370
你可以使用这些数据结构代表选择

154
00:08:56,403 --> 00:08:59,806
SwiftUI 支持单选
macOS Ventura 中新增的

155
00:08:59,840 --> 00:09:03,810
macOS 侧边栏的必选项
以及多选项

156
00:09:06,680 --> 00:09:10,984
iPadOS 16 还引入了轻量级多选

157
00:09:11,018 --> 00:09:14,221
现在 有了键盘连接
你不需要进入编辑模式

158
00:09:14,254 --> 00:09:18,025
选择多行
这有助于避免模态视图

159
00:09:18,058 --> 00:09:20,527
使用键盘时 你可以使用 shift

160
00:09:20,561 --> 00:09:24,164
和 command 等常用快捷键
来扩展和修改选择

161
00:09:24,198 --> 00:09:26,633
这与指针配合使用时效果很好

162
00:09:26,667 --> 00:09:29,803
这是采用选择后位置表格的样子

163
00:09:29,837 --> 00:09:32,639
在本例中
我连接了一个键盘和触摸板

164
00:09:32,673 --> 00:09:35,976
因此行不会缩进
但它们仍处于选中状态

165
00:09:36,009 --> 00:09:39,413
然而 当使用触摸功能时
我仍然需要进入编辑模式

166
00:09:39,446 --> 00:09:42,850
使用双指平移可以加快编辑速度

167
00:09:42,883 --> 00:09:45,619
SwiftUI 自动支持这种手势

168
00:09:45,652 --> 00:09:47,454
说到编辑模式 也有一些

169
00:09:47,487 --> 00:09:50,257
单选和编辑模式的更新

170
00:09:50,290 --> 00:09:53,327
当选择单行时

171
00:09:53,360 --> 00:09:56,563
iPhone 和 iPad 上的列表选择
不再需要编辑模式

172
00:09:56,597 --> 00:10:00,334
这对于协调更新的导航 API
非常有用

173
00:10:01,502 --> 00:10:04,238
通过所有这些更新
我们会得到这个表格

174
00:10:04,271 --> 00:10:08,242
它是在前一个表的基础上
增加了一个编辑模式的新列

175
00:10:08,275 --> 00:10:12,446
只有在没有键盘的情况下
使用多重选择时 才需要编辑模式

176
00:10:12,479 --> 00:10:16,416
因此 我将更新位置表格以支持选择

177
00:10:16,450 --> 00:10:19,019
我可以通过添加一些状态
来存储所选内容

178
00:10:19,052 --> 00:10:22,589
从而轻松地将所选内容
添加到位置表格中

179
00:10:22,623 --> 00:10:24,992
创建状态后
我会向表格的初始值设定项

180
00:10:25,025 --> 00:10:27,628
传递一个绑定

181
00:10:27,661 --> 00:10:31,365
表格强制其选择类型
与其行标识符匹配

182
00:10:31,398 --> 00:10:34,668
因此我使用了位置 ID 类型
作为选择类型

183
00:10:34,701 --> 00:10:38,872
因为我想要多个选择
所以我使用了一个集合作为选择状态

184
00:10:38,906 --> 00:10:42,943
表格会自动为每行做标签
所以我不需要自己做任何标签

185
00:10:44,144 --> 00:10:46,346
现在我可以选择表格中的行了

186
00:10:46,380 --> 00:10:49,216
但我还没有对选中的行做任何事情

187
00:10:49,249 --> 00:10:53,120
我想最好能添加一个按钮
让我可以将选定的地点

188
00:10:53,153 --> 00:10:56,523
添加到指南中 以便与
读书俱乐部中的其他人共享

189
00:10:56,557 --> 00:10:58,992
这是添加工具栏按钮的代码

190
00:10:59,026 --> 00:11:03,096
如果有非空选择
按钮现在就会显示

191
00:11:03,130 --> 00:11:04,765
我还添加了一个编辑按钮

192
00:11:04,798 --> 00:11:07,634
它补充了现有的轻量级选择支持

193
00:11:07,668 --> 00:11:10,704
但在没有键盘的时候 它提供了一种

194
00:11:10,737 --> 00:11:12,606
进入和退出编辑模式的功能

195
00:11:12,639 --> 00:11:15,976
一款出色的 iPad app
无论有无键盘都会大放异彩

196
00:11:16,009 --> 00:11:19,780
因此提供进入和退出编辑模式的控件
非常重要

197
00:11:21,348 --> 00:11:22,416
我们来看看

198
00:11:22,449 --> 00:11:24,852
现在 当我们选择行时
会显示一个按钮

199
00:11:24,885 --> 00:11:28,021
以及一个进入和退出编辑模式的按钮

200
00:11:28,055 --> 00:11:30,390
有关工具栏的更多信息
请务必观看

201
00:11:30,424 --> 00:11:33,460
本讲座的第二部分

202
00:11:33,493 --> 00:11:35,162
我对这里的工具栏按钮很满意

203
00:11:35,195 --> 00:11:36,663
但我们可以做得更多

204
00:11:36,697 --> 00:11:39,333
对于选择操作
尽可能让它们容易访问

205
00:11:39,366 --> 00:11:41,702
是个很好的做法

206
00:11:41,735 --> 00:11:46,240
这就是为什么在 iOS16
iPadOS16 和 macOSVentura 中

207
00:11:46,273 --> 00:11:50,544
SwiftUI 增加了对多选快捷菜单的支持

208
00:11:50,577 --> 00:11:53,981
多选快捷菜单允许
在一组选定的标识符上

209
00:11:54,014 --> 00:11:57,417
显示一个快捷菜单

210
00:11:57,451 --> 00:12:00,621
让我们研究一下这张表格的结构
以了解更多

211
00:12:02,122 --> 00:12:05,325
基于项目的快捷菜单有三种变体

212
00:12:05,359 --> 00:12:07,728
首先 你可以在多个项目上显示菜单

213
00:12:07,761 --> 00:12:09,596
例如顶部的选择

214
00:12:10,764 --> 00:12:13,667
你还可以在单个项目上显示快捷菜单

215
00:12:15,102 --> 00:12:18,372
最后 你可以在
没有内容的空白区域

216
00:12:18,405 --> 00:12:19,840
显示快捷菜单

217
00:12:21,108 --> 00:12:24,077
让我们将这种支持
添加到我们的位置表格中

218
00:12:25,712 --> 00:12:28,282
我省略了前面代码示例中的一些细节

219
00:12:28,315 --> 00:12:30,784
这样我们就可以专注于快捷菜单

220
00:12:30,817 --> 00:12:34,888
我添加了新的 contextMenu 修饰器
该修饰器采用选择类型

221
00:12:34,922 --> 00:12:38,292
这需要匹配列表或表格的选择类型

222
00:12:38,325 --> 00:12:41,328
由于我使用的是表格
我将使用位置 ID 类型

223
00:12:43,030 --> 00:12:45,699
闭包被传递给一组要操作的项

224
00:12:45,732 --> 00:12:49,136
所以若它是空的
我就知道菜单是针对空区域的

225
00:12:49,169 --> 00:12:52,806
我认为一个添加新位置的按钮
对于空白区域来说非常有用

226
00:12:52,840 --> 00:12:56,109
这样 当我在旅途中找到一个
新的安静的地方阅读时

227
00:12:56,143 --> 00:12:58,145
我可以快速添加它

228
00:12:58,178 --> 00:13:00,848
请注意 如果空项目集的视图生成器

229
00:13:00,881 --> 00:13:02,549
无法解析为视图

230
00:13:02,583 --> 00:13:05,586
SwiftUI 将不会在空白区域显示菜单

231
00:13:05,619 --> 00:13:08,188
接下来 我们来处理单个选择

232
00:13:08,222 --> 00:13:09,923
如果该集合只有一个单项

233
00:13:09,957 --> 00:13:13,694
我就知道菜单显示的是单个位置

234
00:13:13,727 --> 00:13:16,063
对于单选和多选

235
00:13:16,096 --> 00:13:18,732
我希望能够将这些位置添加到指南中

236
00:13:18,765 --> 00:13:21,068
因此我将向菜单中添加另一个视图

237
00:13:21,101 --> 00:13:23,203
我们来看看进展

238
00:13:23,237 --> 00:13:25,873
下面是新的快捷菜单支持

239
00:13:25,906 --> 00:13:29,476
点击空白区域会显示一个
添加新位置的菜单项

240
00:13:29,510 --> 00:13:33,881
选择一行仅显示该行的快捷菜单

241
00:13:33,914 --> 00:13:36,183
我可以用键盘扩展选择

242
00:13:36,216 --> 00:13:38,085
创建这个蓝色高亮区域

243
00:13:38,118 --> 00:13:41,388
然后我可以在多行上激活快捷菜单

244
00:13:41,421 --> 00:13:44,091
轻松地将位置添加到指南中

245
00:13:45,459 --> 00:13:47,494
这个表格现在看起来很时髦

246
00:13:47,528 --> 00:13:49,997
是时候在它周围添加一些结构了

247
00:13:50,030 --> 00:13:52,833
为此 我需要一个分屏浏览

248
00:13:52,866 --> 00:13:55,702
导航是 iPad 体验的基础部分

249
00:13:55,736 --> 00:14:00,174
分屏浏览是一个避免在 iPad 更大的
显示屏上出现模态的好方法

250
00:14:00,207 --> 00:14:04,111
它可以一次显示更多信息 无需反复

251
00:14:04,144 --> 00:14:06,847
在本节中 我将介绍 SwiftUI 在

252
00:14:06,880 --> 00:14:08,982
导航和分屏浏览方面的一些更新

253
00:14:09,016 --> 00:14:12,386
在前面的部分中 我创建了位置表格

254
00:14:12,419 --> 00:14:16,089
并增加了丰富的功能
比如选择和编辑模式

255
00:14:16,123 --> 00:14:18,959
但我认为位置 App 缺乏一些结构

256
00:14:18,992 --> 00:14:22,062
所以在本讲座中
我将利用导航分屏浏览

257
00:14:22,095 --> 00:14:25,098
来构建我们 App 结构的基础

258
00:14:25,132 --> 00:14:27,868
SwiftUI 是 iPadOS 16
和 macOS Ventura 中的新功能

259
00:14:27,901 --> 00:14:30,370
它改进了对
NavigationSplitView 类型的

260
00:14:30,404 --> 00:14:32,906
分屏浏览的支持

261
00:14:32,940 --> 00:14:35,909
SwiftUI 支持两列或三列分屏浏览

262
00:14:35,943 --> 00:14:38,545
并具有多种样式
可对各列的显示方式

263
00:14:38,579 --> 00:14:41,215
进行复杂控制

264
00:14:41,248 --> 00:14:42,416
我不会在本期讲座中

265
00:14:42,449 --> 00:14:44,985
全面讲述如何呈现导航内容

266
00:14:45,018 --> 00:14:48,889
为此 我邀请你查看
SwiftUI 导航指南

267
00:14:48,922 --> 00:14:50,657
Curt 有很多秘诀

268
00:14:50,691 --> 00:14:53,827
可以拼凑出超棒的导航体验

269
00:14:53,861 --> 00:14:56,897
而我将更加专注分屏浏览

270
00:14:56,930 --> 00:15:00,534
这张图标显示了 iPad 上的
两列分屏浏览

271
00:15:00,567 --> 00:15:03,737
在 SwiftUI 前导列被称为侧边列

272
00:15:03,770 --> 00:15:07,207
后尾列被称为详细信息列

273
00:15:07,241 --> 00:15:10,177
注意这里的列是如何相互平衡的

274
00:15:10,210 --> 00:15:13,413
在横向 SwiftUI 默认提供此功能

275
00:15:13,447 --> 00:15:16,650
然而 在纵向中 侧边列会隐藏起来

276
00:15:16,683 --> 00:15:19,186
仅显示详细信息列

277
00:15:19,219 --> 00:15:20,654
轻触侧栏按钮

278
00:15:20,687 --> 00:15:22,656
将显示侧边列

279
00:15:22,689 --> 00:15:25,926
该侧边列显示在详细信息列的上方
并使其下方变暗

280
00:15:27,294 --> 00:15:30,230
通常 当空间受限时

281
00:15:30,264 --> 00:15:32,833
两列分频浏览
更倾向于仅展示详细信息列

282
00:15:32,866 --> 00:15:35,002
因为详细信息列经常比侧边列

283
00:15:35,035 --> 00:15:37,871
显示更重要的信息

284
00:15:37,905 --> 00:15:39,806
如果你想自定义此行为

285
00:15:39,840 --> 00:15:42,042
你可以始终优先选择

286
00:15:42,075 --> 00:15:44,578
带有 prominentDetail 导航
分屏浏览样式的

287
00:15:44,611 --> 00:15:46,113
详细信息列或用平衡的

288
00:15:46,146 --> 00:15:48,649
NavigationSplitView 样式
来平衡权重

289
00:15:48,682 --> 00:15:53,020
NavigationSplitView 还支持三列布局

290
00:15:53,053 --> 00:15:55,422
有三列时 在侧边列

291
00:15:55,455 --> 00:15:59,059
和详细信息列中间还有一列
称为 内容列

292
00:15:59,092 --> 00:16:02,829
如果你使用过 UIKit
你或许知道这是补充列

293
00:16:02,863 --> 00:16:06,133
在横向 显示内容和详细信息列

294
00:16:06,166 --> 00:16:09,269
并且可以切换侧边列

295
00:16:09,303 --> 00:16:13,307
点击工具栏按钮后
详细信息列会滑出

296
00:16:13,340 --> 00:16:16,810
为侧边列和内容列腾出空间

297
00:16:16,844 --> 00:16:19,813
纵向仅显示详细信息列

298
00:16:19,847 --> 00:16:23,083
并点击工具栏按钮 显示内容列

299
00:16:23,116 --> 00:16:26,520
从那里 再次点击会显示侧边列

300
00:16:26,553 --> 00:16:29,556
侧边和内容两列都覆盖了详细信息列

301
00:16:31,124 --> 00:16:33,861
一般来说 我推荐
对三列分屏浏览坚持使用

302
00:16:33,894 --> 00:16:36,663
自动样式
因为它可以充分利用可用空间

303
00:16:36,697 --> 00:16:40,467
并且专门用于更大的显示器

304
00:16:40,501 --> 00:16:43,804
就像两列分屏浏览一样
三列分屏浏览可以折叠成

305
00:16:43,837 --> 00:16:46,540
尺寸紧凑类型的 stack

306
00:16:46,573 --> 00:16:48,575
现在我已经讲述了
分屏浏览的基础知识

307
00:16:48,609 --> 00:16:51,411
现在是时候
在位置 App 中添加一个了

308
00:16:51,445 --> 00:16:52,980
这是内容视图

309
00:16:53,013 --> 00:16:56,116
我创建了一个 NavigationSplitView
这里有两列

310
00:16:56,149 --> 00:16:57,951
第一列是侧边列

311
00:16:57,985 --> 00:17:00,354
第二列是详细信息列

312
00:17:00,387 --> 00:17:03,657
详细信息列由侧边列的链接填充

313
00:17:03,690 --> 00:17:04,958
但如果没有显示任何内容

314
00:17:04,992 --> 00:17:08,629
则会显示 select a place 的占位符

315
00:17:10,597 --> 00:17:13,700
这是占位符的屏幕截图 非常棒

316
00:17:13,734 --> 00:17:17,204
这里使用的是自动样式
横向显示侧边列

317
00:17:17,237 --> 00:17:20,174
纵向隐藏

318
00:17:20,207 --> 00:17:24,678
点击侧边列中的某一行
在详细信息列中就会显示该行详情

319
00:17:24,711 --> 00:17:28,182
当使用侧拉时 列会自动折叠

320
00:17:28,215 --> 00:17:30,217
这只是冰山一角

321
00:17:30,250 --> 00:17:32,753
这里还有很多
令人兴奋的导航添加功能

322
00:17:32,786 --> 00:17:35,455
包括对状态恢复的更好的支持

323
00:17:35,489 --> 00:17:38,859
深度链接 甚至更丰富的程式控制

324
00:17:38,892 --> 00:17:42,896
我再次建议你检看导航指南讲座

325
00:17:44,364 --> 00:17:47,034
我已在 App 中构建了
很棒的 iPad 功能

326
00:17:47,067 --> 00:17:50,671
很高兴能找到一些安静的阅读场所

327
00:17:50,704 --> 00:17:53,640
希望我能很快
赶上读书俱乐部的进度

328
00:17:53,674 --> 00:17:56,410
在本期讲座中
我已经介绍了如何利用表格进行

329
00:17:56,443 --> 00:17:58,345
丰富的数据展示

330
00:17:58,378 --> 00:18:01,281
如何管理复杂的选择交互

331
00:18:01,315 --> 00:18:03,984
以及如何利用分屏浏览避免模态

332
00:18:05,485 --> 00:18:07,221
请记得查看相关讲座

333
00:18:07,254 --> 00:18:10,724
并优化你的 SwiftUI app
充分利用 iPad 的强大功能

334
00:18:11,992 --> 00:18:13,727
谢谢大家

335
00:18:13,760 --> 00:18:17,764
♪ ♪

