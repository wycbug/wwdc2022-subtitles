1
00:00:09,309 --> 00:00:15,082
Sam Lazarus: 大家好 我叫 Sam
是 SwiftUI 团队的一名工程师

2
00:00:15,115 --> 00:00:18,852
在设计 SwiftUI 时
我们一直致力于

3
00:00:18,886 --> 00:00:21,421
依照明确定义的原则
和渐进式呈现做决策

4
00:00:21,455 --> 00:00:26,260
今天我们将着重强调其中一点
渐进式呈现

5
00:00:26,293 --> 00:00:30,430
在 SwiftUI 团队中
我们花了很多时间

6
00:00:30,464 --> 00:00:34,501
思考并构建新的 API
但你可能没有意识到

7
00:00:34,535 --> 00:00:37,037
当你在构建一个可复用构件

8
00:00:37,070 --> 00:00:38,572
或抽象时

9
00:00:38,605 --> 00:00:41,808
你也是一名 API 设计师

10
00:00:41,842 --> 00:00:46,413
在这次谈话中 我们想揭开
我们设计过程的帷幔

11
00:00:46,446 --> 00:00:49,683
分享我们对
渐进式呈现的了解

12
00:00:49,716 --> 00:00:54,021
这样 下一次你在构建可复用构件
或抽象时

13
00:00:54,054 --> 00:00:56,056
就可以使用一样新的工具

14
00:00:57,457 --> 00:01:00,661
让我们先来聊一聊

15
00:01:00,694 --> 00:01:02,462
渐进式呈现到底是什么吧

16
00:01:02,496 --> 00:01:06,934
其实这并不是 API 设计
所独有的

17
00:01:06,967 --> 00:01:12,406
事实上 你可以在最常见的
macOS UI 保存对话框中

18
00:01:12,439 --> 00:01:13,974
看到它的使用

19
00:01:14,875 --> 00:01:16,810
当你第一次看见保存对话框时

20
00:01:16,844 --> 00:01:20,647
它已经为你增添了一个默认位置

21
00:01:20,681 --> 00:01:25,786
此外 对话框里还有一个下拉列表

22
00:01:25,819 --> 00:01:29,957
其中包含一些常见的位置以便选择

23
00:01:29,990 --> 00:01:34,728
最后 如果你需要浏览文件系统
以找到正确的路径

24
00:01:34,761 --> 00:01:40,667
可以展开对话框
以显示更复杂但功能更强大的 UI

25
00:01:40,701 --> 00:01:45,572
这包含了不同层次的复杂性
可以在需要时显示

26
00:01:45,606 --> 00:01:51,345
这与我们希望通过 API
提供的体验是相同的

27
00:01:51,378 --> 00:01:55,349
这些代码相当于提供了
良好的UI体验

28
00:01:55,382 --> 00:01:58,418
使你的 API 使用感变好

29
00:02:00,053 --> 00:02:03,090
作为开发者 我们习惯于

30
00:02:03,123 --> 00:02:07,160
从编写代码的角度来查看代码：
也就是代码声明的位置

31
00:02:07,194 --> 00:02:09,997
但为了让代码更好使用

32
00:02:10,030 --> 00:02:13,033
我们必须从一个不同的角度来看

33
00:02:13,066 --> 00:02:15,068
也就是代码实际使用的地方

34
00:02:15,102 --> 00:02:17,337
我们称其为调用端

35
00:02:19,173 --> 00:02:22,509
而渐进式呈现
就是通过 API 的设计

36
00:02:22,543 --> 00:02:27,314
使调用端的复杂性
随着用例的复杂性而增长

37
00:02:28,515 --> 00:02:32,486
一个理想的 API 应当
既简洁 易操作

38
00:02:32,519 --> 00:02:35,923
又足够适应强大的用例

39
00:02:37,257 --> 00:02:40,961
这对开发者很有利

40
00:02:40,994 --> 00:02:45,799
首先 这最大程度上缩减了
首次构建和运行所需的时间

41
00:02:45,832 --> 00:02:49,336
使你能够更快使用 API

42
00:02:49,369 --> 00:02:53,907
这也降低了代码的学习曲线

43
00:02:53,941 --> 00:02:58,145
防止 API 因与所有用例无关的概念
陷入停滞

44
00:02:59,479 --> 00:03:02,950
最后 它创造了一个紧密的反馈循环

45
00:03:02,983 --> 00:03:05,853
通过渐进式呈现的 API

46
00:03:05,886 --> 00:03:10,357
你可以一点一点地添加内容
查看每一步创建的东西

47
00:03:11,391 --> 00:03:16,263
所有这些因素使 App 开发
成为了一个快速优化循环

48
00:03:16,296 --> 00:03:19,066
而不是单一的大规模前期投入

49
00:03:20,634 --> 00:03:24,104
因此渐进式呈现
是一盏有用的指路明灯

50
00:03:24,137 --> 00:03:28,809
但我们该如何设计特定的 API
使它们采用这一原则呢

51
00:03:28,842 --> 00:03:34,481
在 SwiftUI 团队
我们首先考虑了常见用例

52
00:03:34,515 --> 00:03:37,184
为了逐步展开功能

53
00:03:37,217 --> 00:03:40,087
我们需要确定什么是简单用例

54
00:03:41,088 --> 00:03:44,291
我们还致力于提供智能默认值

55
00:03:44,324 --> 00:03:49,096
以便常见用例
能只列出所需的内容

56
00:03:49,129 --> 00:03:52,199
接下来 我们的目标是
优化调用端

57
00:03:52,232 --> 00:03:56,537
确保调用端的每个字符
都有目的

58
00:03:56,570 --> 00:03:59,540
最后 我们要设计 API

59
00:03:59,573 --> 00:04:03,477
确保它们能整合各个部分
而不是枚举可能性

60
00:04:04,344 --> 00:04:08,982
让我们来看看
SwiftUI 上的一些例子

61
00:04:09,016 --> 00:04:12,920
从我们如何考虑常见用例开始

62
00:04:12,953 --> 00:04:17,291
在这方面 SwiftUI
做得特别好的一处是标签

63
00:04:18,492 --> 00:04:22,162
例如 当创建按钮时 我们要求你

64
00:04:22,196 --> 00:04:24,131
为按钮提供一个标签

65
00:04:24,164 --> 00:04:27,768
大多数情况下 这个标签只是文本

66
00:04:27,801 --> 00:04:31,238
用来描述按钮的作用
而 SwiftUI 为你提供了

67
00:04:31,271 --> 00:04:33,540
一个简洁的拼写方法

68
00:04:33,574 --> 00:04:35,876
但如果你想进一步自定义按钮

69
00:04:35,909 --> 00:04:38,145
SwiftUI 也
提供另一个重载函数

70
00:04:38,178 --> 00:04:40,614
即将任意视图作为标签

71
00:04:41,815 --> 00:04:44,618
这使你能通过这个简单的控件

72
00:04:44,651 --> 00:04:47,221
构建复杂的功能

73
00:04:47,254 --> 00:04:51,225
但是由于这个 API 仔细
考虑了它的常见用例

74
00:04:51,258 --> 00:04:55,262
99% 的情况下 你只需要简单版本

75
00:04:56,930 --> 00:05:00,767
这个标签模式
在 SwiftUI 中随处可见

76
00:05:00,801 --> 00:05:03,704
我说随处可见是认真的

77
00:05:04,671 --> 00:05:07,708
我们在整个框架中

78
00:05:07,741 --> 00:05:10,010
都考虑了常见用例

79
00:05:10,043 --> 00:05:14,081
接下来 我们看看提供智能默认值

80
00:05:14,114 --> 00:05:16,850
为了简化常见用例

81
00:05:16,884 --> 00:05:19,052
我们要为所有
没有明确指定的东西

82
00:05:19,086 --> 00:05:22,189
提供智能默认值

83
00:05:22,222 --> 00:05:26,627
这里最好的例子就是
SwiftUI 中最常用的

84
00:05:26,660 --> 00:05:28,595
API 之一

85
00:05:28,629 --> 00:05:29,730
Text

86
00:05:30,464 --> 00:05:34,034
Text 是智能默认值一个很好的例子

87
00:05:34,067 --> 00:05:37,804
你可能已经编写了
数百次这样的代码

88
00:05:37,838 --> 00:05:41,308
在编写时你没有考虑
所有不必指定的内容

89
00:05:42,309 --> 00:05:45,913
有了这段代码
SwiftUI 将通过在应用包中

90
00:05:45,946 --> 00:05:48,849
查找带有环境语言的本地化字符串

91
00:05:48,882 --> 00:05:50,784
来本地化文本

92
00:05:50,817 --> 00:05:53,720
它会自动适应当前的配色方案

93
00:05:53,754 --> 00:05:56,857
直接支持深色模式

94
00:05:56,890 --> 00:06:00,761
它会根据当前的
辅助功能动态类型大小

95
00:06:00,794 --> 00:06:03,964
自动缩放文本

96
00:06:04,831 --> 00:06:07,100
我们之前也提到过这些行为

97
00:06:07,134 --> 00:06:10,337
但文本在幕后做了更多的事情

98
00:06:11,905 --> 00:06:14,308
例如 两个文本并排放入栈中

99
00:06:14,341 --> 00:06:19,179
文本之间的距离将按当前上下文

100
00:06:19,213 --> 00:06:22,583
自动调整为正确行间距

101
00:06:23,383 --> 00:06:26,787
所有这些行为都可以人为指定

102
00:06:26,820 --> 00:06:30,424
但 SwiftUI 的智能默认设置
意味着当它们与你的用例无关时

103
00:06:30,457 --> 00:06:33,427
它们不会出现在调用端

104
00:06:34,695 --> 00:06:39,533
Text 是这样一个例子
它的最简案例是极其简化的

105
00:06:39,566 --> 00:06:43,337
但智能默认值适用于
所有类型的调用端

106
00:06:43,370 --> 00:06:45,305
以工具栏为例

107
00:06:45,339 --> 00:06:49,643
这是一个工具栏 上面有一堆按钮

108
00:06:49,676 --> 00:06:52,846
如果不明确指定它们的位置

109
00:06:52,880 --> 00:06:57,184
工具栏按钮会根据平台惯例放置

110
00:06:57,217 --> 00:07:01,388
在 macOS 上
它们会出现在工具栏的前缘

111
00:07:01,421 --> 00:07:04,958
但在 iOS 上
它们会出现在

112
00:07:04,992 --> 00:07:07,261
导航栏的后缘

113
00:07:07,294 --> 00:07:11,565
最后 在 watchOS 上
只出现第一个项目

114
00:07:11,598 --> 00:07:14,201
固定在导航栏下面

115
00:07:14,234 --> 00:07:17,704
这种方法在大多数情况下都很有效

116
00:07:17,738 --> 00:07:20,040
但如果你确实需要更多的控件

117
00:07:20,073 --> 00:07:23,744
我们也提供了额外的 API
明确指定

118
00:07:23,777 --> 00:07:25,712
项目的放置位置

119
00:07:25,746 --> 00:07:28,749
同样 如果需要 你可以进行自定义

120
00:07:28,782 --> 00:07:32,085
但是智能默认值可以处理大多数情况

121
00:07:33,420 --> 00:07:37,357
参照常见用例并提供智能默认值

122
00:07:37,391 --> 00:07:42,529
可以创造一些非常棒的体验
但如果这些 API 使用感较差

123
00:07:42,563 --> 00:07:46,200
或不完善 它可能会破坏整体效果

124
00:07:46,233 --> 00:07:50,604
这就引出了我们的最后一条策略
优化调用端

125
00:07:50,637 --> 00:07:54,808
说到这一点 我们看看
另一个 API 即 Table

126
00:07:55,909 --> 00:08:00,013
多列表格是功能非常丰富的控件

127
00:08:00,047 --> 00:08:03,684
需要配置的东西很多 功能也很多

128
00:08:03,717 --> 00:08:06,920
但是大多数表格要简单得多

129
00:08:06,954 --> 00:08:09,056
也不需要所有这些功能

130
00:08:09,089 --> 00:08:13,594
我们希望表格能够处理
这种更复杂的行为

131
00:08:13,627 --> 00:08:16,897
而它最详细的格式
已经做到了这点

132
00:08:16,930 --> 00:08:19,099
它支持排序

133
00:08:19,132 --> 00:08:24,838
包含丰富单元格内容的
多列 分段行等等

134
00:08:25,906 --> 00:08:28,342
但我们也希望在更常见的情况下

135
00:08:28,375 --> 00:08:30,777
提供出色的体验感

136
00:08:30,811 --> 00:08:33,614
所以 我们看看这个简单表格的

137
00:08:33,647 --> 00:08:35,382
完整代码

138
00:08:35,415 --> 00:08:38,819
并看看我们
如何优化它的调用端

139
00:08:38,852 --> 00:08:42,389
首先 我们拆分一下这个例子

140
00:08:42,422 --> 00:08:46,527
表格首先指定
如何为每一行生成数据

141
00:08:48,128 --> 00:08:52,099
在这里 我将枚举当前正在读的
每一本书

142
00:08:52,132 --> 00:08:56,136
并为每一本书创建一个表行

143
00:08:56,170 --> 00:09:01,775
接下来 它会指定如何
用每一行的数据填充列

144
00:09:01,808 --> 00:09:06,180
在这里 我创建了
一个标题列和一个作者列

145
00:09:08,448 --> 00:09:13,587
它还会用绑定来排序次序

146
00:09:13,620 --> 00:09:16,323
以允许用户单击
表列 header 时更改排序

147
00:09:18,158 --> 00:09:22,529
最后 我添加了一些代码

148
00:09:22,563 --> 00:09:24,998
以在排序次序发生变化时
重新对表数据排序

149
00:09:25,032 --> 00:09:27,734
这有很多的信息 我们看看

150
00:09:27,768 --> 00:09:32,072
该如何优化这个调用端
以真正实现渐进式呈现

151
00:09:33,240 --> 00:09:38,145
最常见的一个用例与行有关

152
00:09:38,178 --> 00:09:43,083
大多数时候
行字段就像这个例子中一样

153
00:09:43,116 --> 00:09:47,120
一个集合上有一个 ForEach
为每项提供一个表行

154
00:09:48,655 --> 00:09:51,859
开发人员不需要
自己循环所有这些内容

155
00:09:51,892 --> 00:09:56,964
SwiftUI 提供了一个方便的功能
在底层处理这些内容

156
00:09:56,997 --> 00:09:59,900
通过将集合直接传递到表格

157
00:09:59,933 --> 00:10:03,504
可以在幕后完成 ForEach 行为

158
00:10:03,537 --> 00:10:10,010
极大地简化了我们的调用端
但这还可以进一步简化

159
00:10:10,043 --> 00:10:12,279
其它常见用例有什么呢

160
00:10:12,312 --> 00:10:13,947
大多数时候

161
00:10:13,981 --> 00:10:15,582
当我想在表格中显示的一个值
是字符串时

162
00:10:15,616 --> 00:10:19,753
我会直接使用文本在列中显示它

163
00:10:20,721 --> 00:10:23,156
这种情况下 我们也会优化调用端

164
00:10:25,058 --> 00:10:27,961
只要值路径指向一个字符串

165
00:10:27,995 --> 00:10:31,832
我们就允许省略
与 TableColumn 关联的视图

166
00:10:32,933 --> 00:10:38,172
这是另一个重要的简化
但仍有更多需要优化的部分

167
00:10:38,205 --> 00:10:41,875
调用端中有一些信息
并不是所有表格

168
00:10:41,909 --> 00:10:46,079
都需要关注的 那就是排序次序

169
00:10:46,113 --> 00:10:50,350
表格最简单的用例和排序完全无关

170
00:10:50,384 --> 00:10:53,320
因此 我们也提供了一个
本身不涉及

171
00:10:53,353 --> 00:10:55,355
排序的表格版本

172
00:10:55,389 --> 00:10:59,660
这就引出了我们的最后一次迭代
简洁多了

173
00:10:59,693 --> 00:11:03,764
这个 call site 的每个字符
都有一个明确的目的

174
00:11:03,797 --> 00:11:08,702
为了做到这点 我们每一步
都问了自己两个关键问题

175
00:11:08,735 --> 00:11:14,074
“我们应该为哪些
最常见的用例提供便利”

176
00:11:14,107 --> 00:11:19,680
以及“什么信息总是必要的”

177
00:11:19,713 --> 00:11:22,916
这些指导性的问题
可以很好地帮助你

178
00:11:22,950 --> 00:11:26,587
优化 call sites
但要谨慎应用

179
00:11:26,620 --> 00:11:29,857
如果不仔细考虑它们
对 API 的影响

180
00:11:29,890 --> 00:11:31,758
可能会把你引入歧途

181
00:11:31,792 --> 00:11:37,464
这就引出了我们的最终策略
组合 而非枚举

182
00:11:37,497 --> 00:11:40,501
进一步说明这一点
我们来谈谈 SwiftUI

183
00:11:40,534 --> 00:11:44,471
布局系统一个部分的设计：Stack

184
00:11:44,505 --> 00:11:46,907
特别是 HStack

185
00:11:46,940 --> 00:11:51,144
首先 我们想想 HStack 的

186
00:11:51,178 --> 00:11:52,746
关键信息是什么

187
00:11:52,779 --> 00:11:57,451
它需要知道栈中应该有什么内容

188
00:11:57,484 --> 00:12:01,788
以及这些内容
应该如何在栈中排列

189
00:12:01,822 --> 00:12:05,692
我们已经有视图生成器
来指定 HStack 的内容

190
00:12:05,726 --> 00:12:08,529
所以我们要专注于排列

191
00:12:08,562 --> 00:12:10,964
回到我们强调的指导性问题

192
00:12:10,998 --> 00:12:15,402
在 HStack 中排列元素时
最常见的用例是什么

193
00:12:15,435 --> 00:12:19,606
我有时想显示一个像这样的栈

194
00:12:19,640 --> 00:12:23,944
它会从前端开始
一个接一个地显示盒子

195
00:12:25,045 --> 00:12:28,715
另一种常见的情况是希望元素居中

196
00:12:28,749 --> 00:12:31,451
最后 我可能想把元素

197
00:12:31,485 --> 00:12:32,886
向尾部对齐

198
00:12:34,388 --> 00:12:39,526
VStack 已经有了一个
与此类似的 API 即对齐

199
00:12:39,560 --> 00:12:42,396
所以创建一个类似的 enum

200
00:12:42,429 --> 00:12:45,532
来排列栈中的元素似乎很吸引人

201
00:12:45,566 --> 00:12:48,135
这支持我们提到的所有使用情况

202
00:12:48,168 --> 00:12:52,706
通过指定 HStack 的排列
我可以选择前对齐

203
00:12:52,739 --> 00:12:57,277
尾对齐 或居中排列
这取决于我想要什么

204
00:12:57,311 --> 00:13:01,114
但如果我现在想均匀地间隔元素

205
00:13:01,148 --> 00:13:04,284
或者只在元素之间

206
00:13:04,318 --> 00:13:08,322
或最后一个元素之前设置间隔呢

207
00:13:08,355 --> 00:13:10,190
这开始变得格外混乱

208
00:13:10,224 --> 00:13:13,293
但更重要的是 这是不可持续的

209
00:13:13,327 --> 00:13:16,997
我必须为我们想要的每个行为
添加一个 enum 案例

210
00:13:17,030 --> 00:13:20,534
而我们可能无法把
所有有用的案例考虑周全

211
00:13:20,567 --> 00:13:23,203
当你发现自己在列举常见情况

212
00:13:23,237 --> 00:13:25,973
而不是为它们提供方便时

213
00:13:26,006 --> 00:13:29,843
试着把你的 API 分解成
可以构建解决方案的

214
00:13:29,877 --> 00:13:34,014
可组合块
组合 而非枚举

215
00:13:35,449 --> 00:13:41,154
在栈的例子中
SwiftUI 提供了 Spacer

216
00:13:41,188 --> 00:13:45,626
让你将它与栈的元素组合
以构建我们列举的所有间距方案

217
00:13:45,659 --> 00:13:50,397
诸如此类
这也是今天这一 API 的起源

218
00:13:51,798 --> 00:13:55,068
为渐进式呈现设计最佳体验

219
00:13:55,102 --> 00:13:57,604
不仅仅在于最小化调用端

220
00:13:57,638 --> 00:14:02,109
还在于仔细思考
该如何缩放调用端

221
00:14:02,142 --> 00:14:05,946
以处理所有用例
在这种情况下是通过组合

222
00:14:07,614 --> 00:14:11,451
当你编写代码时
同样仔细考虑自己创建的组件

223
00:14:11,485 --> 00:14:15,789
可能会非常有帮助

224
00:14:15,822 --> 00:14:20,627
回顾一下 首先是考虑常见用例

225
00:14:20,661 --> 00:14:23,997
通过应用渐进式呈现
你编写的代码

226
00:14:24,031 --> 00:14:27,601
会在最常见的用例中
节省你的时间

227
00:14:27,634 --> 00:14:31,371
智能默认值将意味着
你不必考虑这些

228
00:14:31,405 --> 00:14:33,740
常见用例的细节

229
00:14:33,774 --> 00:14:36,410
努力优化你构建的调用端

230
00:14:36,443 --> 00:14:37,945
会允许你快速迭代

231
00:14:38,645 --> 00:14:41,415
最后 利用组合

232
00:14:41,448 --> 00:14:46,386
可以让你构建足够灵活的 API
以适应它们的所有用例

233
00:14:47,521 --> 00:14:51,558
因为你是一名 API 设计师
你可以将这些经验

234
00:14:51,592 --> 00:14:53,694
应用到你每天编写的代码中

235
00:14:53,727 --> 00:14:56,063
无论它是为别人设计的

236
00:14:56,096 --> 00:14:57,664
还是只是自己使用的

237
00:14:58,465 --> 00:14:59,967
谢谢观看

238
00:15:00,000 --> 00:15:02,102
[古怪的音乐]

