1
00:00:00,267 --> 00:00:03,337
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,337 --> 00:00:09,910
♪

3
00:00:09,910 --> 00:00:11,812
Lais Minchillo：
嗨 我叫 Lais

4
00:00:11,812 --> 00:00:13,847
David Silver：我是 David
我们将为您介绍

5
00:00:13,847 --> 00:00:17,885
今年 钱包
和 Apple Pay 的新功能

6
00:00:17,885 --> 00:00:20,521
我们在 2014 年
推出了 Apple Pay

7
00:00:20,521 --> 00:00:23,657
为在实体店 在线商店和 App 内进行

8
00:00:23,657 --> 00:00:27,928
快速 安全 私密的支付
设定了新的基准

9
00:00:27,928 --> 00:00:31,231
从那时起 我们在全球范围内
推广了 Apple Pay

10
00:00:31,231 --> 00:00:35,202
Apple Pay 现已在
72 个国家和地区提供服务

11
00:00:35,202 --> 00:00:38,739
每天处理超过一百万笔交易

12
00:00:38,739 --> 00:00:42,042
今天 我们将为
钱包和 Apple Pay

13
00:00:42,042 --> 00:00:43,710
引入令人兴奋的新功能和 API

14
00:00:43,710 --> 00:00:45,812
Lais 会为您具体介绍

15
00:00:45,812 --> 00:00:47,181
Lais ：谢谢您 David

16
00:00:47,181 --> 00:00:50,284
让我们来看看这场讲座的主要议程

17
00:00:50,284 --> 00:00:53,921
首先 我们将聊一聊快速更新

18
00:00:53,921 --> 00:00:56,823
我们增加了在单笔交易中

19
00:00:56,823 --> 00:00:59,293
向多个商户支付的支持

20
00:00:59,293 --> 00:01:02,663
我们还大大改善了
包括订阅服务在内的

21
00:01:02,663 --> 00:01:05,299
自动支付的支持

22
00:01:05,299 --> 00:01:07,467
通过订单跟踪 您可以增强

23
00:01:07,467 --> 00:01:10,737
客户的购后体验

24
00:01:10,737 --> 00:01:14,107
最后 David 将聊一聊
用钱包中的 ID

25
00:01:14,107 --> 00:01:17,311
进行身份验证

26
00:01:17,311 --> 00:01:20,147
我们要先分享一些
令人振奋的更新内容

27
00:01:20,147 --> 00:01:23,250
iPhone 上的 Tap to Pay
于今年早些时候发布

28
00:01:23,250 --> 00:01:27,120
并在美国 iOS 15.4 平台上发布

29
00:01:27,120 --> 00:01:29,990
iPhone 上的 Tap to Pay
提供了一种安全 私密 便捷的

30
00:01:29,990 --> 00:01:33,126
非接触式支付方式

31
00:01:33,126 --> 00:01:35,696
您可以轻松地将它
集成到您的 App 中

32
00:01:35,696 --> 00:01:39,366
无缝且安全地接收非接触式支付

33
00:01:39,366 --> 00:01:41,168
这种支付方式
包括 Apple Pay

34
00:01:41,168 --> 00:01:43,504
非接触式信用卡和借记卡

35
00:01:43,504 --> 00:01:45,639
和其他数字钱包

36
00:01:45,639 --> 00:01:46,907
只需在 iPhone 上轻触一下

37
00:01:46,907 --> 00:01:49,009
交易就能完成

38
00:01:49,009 --> 00:01:51,044
无需额外的硬件

39
00:01:51,044 --> 00:01:53,146
或支付终端

40
00:01:53,146 --> 00:01:55,582
同时 在 macOS 13 中

41
00:01:55,582 --> 00:01:58,886
我们重新设计了
Apple Pay 的体验

42
00:01:58,886 --> 00:02:01,321
去年 iOS 的付款表单重新设计

43
00:02:01,321 --> 00:02:02,756
取得了巨大的成功

44
00:02:02,756 --> 00:02:06,627
今年我们将为 macOS
引入类似的体验

45
00:02:06,627 --> 00:02:09,029
我们使用了 SwiftUI
来重新设计

46
00:02:09,029 --> 00:02:11,365
从而让我们
为 macOS 与 iOS

47
00:02:11,365 --> 00:02:13,700
同时引入了新功能

48
00:02:13,700 --> 00:02:16,370
我们今天介绍的
所有 Apple Pay 功能

49
00:02:16,370 --> 00:02:19,640
在 Mac 上也支持

50
00:02:19,640 --> 00:02:23,110
我们将引入
新的 SwiftUI API

51
00:02:23,110 --> 00:02:26,446
在您的
SwiftUI App 中集成

52
00:02:26,446 --> 00:02:29,283
“添加到 Apple 钱包”
或 “Apple Pay” 按钮会更容易

53
00:02:29,283 --> 00:02:31,652
这些新的 API 将大大减少

54
00:02:31,652 --> 00:02:33,921
您需要编写的代码量

55
00:02:33,921 --> 00:02:36,056
让我们看看如何添加按钮

56
00:02:36,056 --> 00:02:39,193
以提示用户添加航空通票

57
00:02:39,193 --> 00:02:41,962
首先 创建航空通票

58
00:02:41,962 --> 00:02:45,365
您应该处理好未成功加载的情况

59
00:02:45,365 --> 00:02:47,901
例如 航空通票数据不正确

60
00:02:47,901 --> 00:02:51,338
或未正确签名 就可能发生这种情况

61
00:02:51,338 --> 00:02:56,109
接下来 使用通票数组调用
AddPassToWalletButton

62
00:02:56,109 --> 00:02:59,479
在这个例子中 只有一个元素的数组

63
00:02:59,479 --> 00:03:02,983
但是同一个按钮上可以有多个通票

64
00:03:02,983 --> 00:03:05,919
结果作为 Bool 传入
您可以根据

65
00:03:05,919 --> 00:03:08,488
用户是否添加了通票
来保存 记录或触发

66
00:03:08,488 --> 00:03:12,025
App 中的其他操作

67
00:03:12,025 --> 00:03:15,162
在此示例中 我将它保存到状态变量

68
00:03:15,162 --> 00:03:16,630
这样就完成了

69
00:03:16,630 --> 00:03:19,600
您还可以在一组最小值中

70
00:03:19,600 --> 00:03:21,935
自定义按钮的大小和样式

71
00:03:21,935 --> 00:03:28,642
这是默认尺寸
宽 250 高 50

72
00:03:28,642 --> 00:03:30,911
您也可以把按钮变宽

73
00:03:32,513 --> 00:03:33,881
或变高

74
00:03:35,883 --> 00:03:37,284
以上就是如何
在 SwiftUI 中添加

75
00:03:37,284 --> 00:03:40,854
“添加到 Apple 钱包”按钮

76
00:03:40,854 --> 00:03:45,192
接下来 看看如何添加
“使用 Apple Pay 支付”按钮

77
00:03:45,192 --> 00:03:47,394
首先 使用 PKPaymentRequest 类

78
00:03:47,394 --> 00:03:49,863
创建一个支付请求

79
00:03:49,863 --> 00:03:52,900
在上面设置您通常的配置

80
00:03:52,900 --> 00:03:57,037
然后创建一个
authorizationChange 方法

81
00:03:57,037 --> 00:03:59,006
这两个部分完成后

82
00:03:59,006 --> 00:04:01,742
就可以添加代码来显示按钮

83
00:04:01,742 --> 00:04:04,344
添加对
PayWithApplePayButton 的调用

84
00:04:04,344 --> 00:04:07,915
传入标签 paymentRequest 对象

85
00:04:07,915 --> 00:04:10,784
和 authorizationChange 方法

86
00:04:10,784 --> 00:04:13,086
如果要处理前设备
不支持 Apple Pay 的情况

87
00:04:13,086 --> 00:04:16,657
通过当前设备 您可以传入回退视图

88
00:04:16,657 --> 00:04:18,525
就像“添加航空通票”按钮一样

89
00:04:18,525 --> 00:04:23,463
您同样可以自定义其大小和样式

90
00:04:23,463 --> 00:04:26,700
总共有 17 个不同的标签

91
00:04:26,700 --> 00:04:28,635
因此 您能够自定义支付按钮

92
00:04:28,635 --> 00:04:31,371
以与您的用例保持一致

93
00:04:31,371 --> 00:04:38,645
这些适用于
iOS iPadOS macOS 和 watchOS

94
00:04:38,645 --> 00:04:42,950
接下来 再来看看多商户支付

95
00:04:42,950 --> 00:04:46,286
在 iOS 16 中
我们引入了在同一笔交易中

96
00:04:46,286 --> 00:04:48,922
为各个不同商户

97
00:04:48,922 --> 00:04:50,724
单独请求交易令牌的功能

98
00:04:50,724 --> 00:04:53,894
这种功能对于在线市场

99
00:04:53,894 --> 00:04:56,597
旅行预订和票务服务等很有帮助

100
00:04:56,597 --> 00:04:59,199
我们来详细看看这个例子

101
00:04:59,199 --> 00:05:01,935
想象一下
Allison 正在计划一次旅行

102
00:05:01,935 --> 00:05:04,505
她访问一家旅行社网站

103
00:05:04,505 --> 00:05:06,073
网站方便地为她提供了

104
00:05:06,073 --> 00:05:08,141
客户需要预订的一切

105
00:05:08,141 --> 00:05:12,412
机票 酒店住宿和汽车租赁

106
00:05:12,412 --> 00:05:16,049
Allison 总共
只需要支付 500 美元

107
00:05:16,049 --> 00:05:18,085
Allison 向
旅行社网站提供了

108
00:05:18,085 --> 00:05:20,454
她完整的信用卡信息

109
00:05:20,454 --> 00:05:23,257
现在 您可能会认为旅行社

110
00:05:23,257 --> 00:05:26,293
将从 Allison 的信用卡
扣除 500 美元

111
00:05:26,293 --> 00:05:29,196
然后支付给其他相关公司

112
00:05:29,196 --> 00:05:31,865
但通常情况下 旅行社只需

113
00:05:31,865 --> 00:05:34,434
简单地将信用卡信息传递给每家公司

114
00:05:34,434 --> 00:05:38,605
让各家公司进行各自的收费

115
00:05:38,605 --> 00:05:40,741
这行么做得通 但是

116
00:05:40,741 --> 00:05:42,676
把她的信用卡信息泄露出去

117
00:05:42,676 --> 00:05:46,413
对 Allison 的隐私
和安全不利

118
00:05:46,413 --> 00:05:49,750
现在 有了新的多商户支付 API

119
00:05:49,750 --> 00:05:52,019
就可以为交易中涉及的每个商户

120
00:05:52,019 --> 00:05:55,355
请求支付令牌

121
00:05:55,355 --> 00:05:57,157
有了支付令牌

122
00:05:57,157 --> 00:06:00,327
各家公司可以
分别向 Allison 收取

123
00:06:00,327 --> 00:06:03,263
她授权的相关金额

124
00:06:03,263 --> 00:06:05,933
Allison 现在可以预订
并支付旅行费用

125
00:06:05,933 --> 00:06:09,269
同时也能享受
Apple Pay 提供的

126
00:06:09,269 --> 00:06:12,005
隐私和安全优势

127
00:06:12,005 --> 00:06:14,541
付款表已经更新 能够向客户显示

128
00:06:14,541 --> 00:06:18,345
交易中涉及的子商户明细

129
00:06:18,345 --> 00:06:20,314
客户可以点击“总金额”

130
00:06:20,314 --> 00:06:22,549
前往到付款摘要

131
00:06:22,549 --> 00:06:25,052
摘要中 客户可以看到涉及到交易的

132
00:06:25,052 --> 00:06:27,521
所有商户的分类

133
00:06:27,521 --> 00:06:30,591
以及每个商户授权的金额

134
00:06:30,591 --> 00:06:32,392
现在 让我们看看如何在应用中

135
00:06:32,392 --> 00:06:35,529
添加多商户支付

136
00:06:35,529 --> 00:06:37,764
首先 使用 PKPaymentRequest 类

137
00:06:37,764 --> 00:06:40,234
创建一个支付请求

138
00:06:40,234 --> 00:06:43,203
在上面设置您通常的配置

139
00:06:43,203 --> 00:06:48,342
然后 为您的付款
添加汇总项目 包括总额

140
00:06:48,342 --> 00:06:50,978
接下来 使用新的
PKPaymentTokenContext 类

141
00:06:50,978 --> 00:06:54,414
为交易中涉及的每个额外商户

142
00:06:54,414 --> 00:06:58,385
创建一个支付令牌 context

143
00:06:58,385 --> 00:07:01,121
提供每个商户的详细信息

144
00:07:01,121 --> 00:07:04,424
以及为每个商户授权的金额

145
00:07:04,424 --> 00:07:09,463
最后 在支付请求上
设置支付令牌 contexts

146
00:07:09,463 --> 00:07:11,632
请记住 所有

147
00:07:11,632 --> 00:07:14,168
支付令牌
context 的金额总和

148
00:07:14,168 --> 00:07:17,070
必须小于或等于

149
00:07:17,070 --> 00:07:19,506
支付请求本身的总金额

150
00:07:19,506 --> 00:07:23,043
此外 在 App 中
为商家请求支付令牌时

151
00:07:23,043 --> 00:07:26,013
您应该始终为同一个商户

152
00:07:26,013 --> 00:07:28,882
使用相同的外部标识符

153
00:07:28,882 --> 00:07:30,918
要在网页上采用

154
00:07:30,918 --> 00:07:32,553
多商户支付的 Apple Pay

155
00:07:32,553 --> 00:07:36,657
请查看 Apple Pay JS API 文档

156
00:07:36,657 --> 00:07:39,159
接下来看一看

157
00:07:39,159 --> 00:07:41,962
我们对自动支付的改进

158
00:07:41,962 --> 00:07:45,732
在 iOS 16 中 我们引入了

159
00:07:45,732 --> 00:07:48,702
用户可以通过钱包应用查看和管理

160
00:07:48,702 --> 00:07:50,671
他们设置的自动向商家支付的功能

161
00:07:50,671 --> 00:07:51,738
在这个版本中

162
00:07:51,738 --> 00:07:54,641
我们支持两种类型的自动支付

163
00:07:54,641 --> 00:07:57,044
定期自动扣除 其中包括

164
00:07:57,044 --> 00:08:00,547
订阅 分期付款或定期计费

165
00:08:00,547 --> 00:08:02,583
和自动充值支付

166
00:08:02,583 --> 00:08:05,419
例如商店卡余额充值

167
00:08:05,419 --> 00:08:08,222
我们将引入新的 API
以让您在提出支付请求时

168
00:08:08,222 --> 00:08:12,125
向客户请求设置自动支付

169
00:08:12,125 --> 00:08:15,562
我们还推出了
Apple Pay 商户令牌

170
00:08:15,562 --> 00:08:19,533
这是一种与客户的 Apple ID 绑定的
新型支付令牌

171
00:08:19,533 --> 00:08:22,169
可以帮助您在现有基础上

172
00:08:22,169 --> 00:08:24,438
更可靠地向客户收费

173
00:08:24,438 --> 00:08:27,040
我们来详细看一下
Apple Pay 商户令牌

174
00:08:27,040 --> 00:08:29,543
看看它们是如何发挥作用的

175
00:08:29,543 --> 00:08:32,446
想象一下 Julie 正在用
iPhone 上的 Apple Pay

176
00:08:32,446 --> 00:08:34,982
支付读书俱乐部的会员费

177
00:08:34,982 --> 00:08:37,351
读书俱乐部提出付款请求

178
00:08:37,351 --> 00:08:39,553
当 Julie 授权付款时

179
00:08:39,553 --> 00:08:41,922
读书俱乐部收到付款令牌

180
00:08:41,922 --> 00:08:44,525
每个月 俱乐部都可以用付款令牌

181
00:08:44,525 --> 00:08:46,527
向 Julie 收取会员资格费用

182
00:08:46,527 --> 00:08:49,796
此付款令牌
链接到 Julie 的设备

183
00:08:49,796 --> 00:08:51,865
用于授权支付

184
00:08:51,865 --> 00:08:55,235
但如果 Julie 买了一台
新的 iPhone 会怎样？

185
00:08:55,235 --> 00:08:57,738
有了新的自动支付功能

186
00:08:57,738 --> 00:08:59,640
如果 Julie 的支付网络支持

187
00:08:59,640 --> 00:09:01,642
俱乐部会将收到

188
00:09:01,642 --> 00:09:04,545
Apple Pay 商户令牌

189
00:09:04,545 --> 00:09:07,848
此支付令牌与 Julie 的
Apple ID 绑定

190
00:09:07,848 --> 00:09:09,650
而不是与她的 iPhone 绑定

191
00:09:09,650 --> 00:09:14,221
这样就能更好地保证正在进行的授权

192
00:09:14,221 --> 00:09:16,823
也就是说 如果
Julie 升级了 iPhone

193
00:09:16,823 --> 00:09:18,759
或重置了她当前的手机

194
00:09:18,759 --> 00:09:21,595
读书俱乐部依旧能可靠地

195
00:09:21,595 --> 00:09:23,997
向 Julie 收取
每月的会员资格费用

196
00:09:23,997 --> 00:09:26,667
如果您接受 Apple Pay
进行这些类型的付款

197
00:09:26,667 --> 00:09:30,003
采用自动支付是一个好主意
能够确保

198
00:09:30,003 --> 00:09:32,973
您可以持续可靠地向客户收费

199
00:09:32,973 --> 00:09:36,510
且能避免服务中的任何中断

200
00:09:36,510 --> 00:09:38,979
我们在这个版本中支持的

201
00:09:38,979 --> 00:09:41,982
第一种自动支付方式是定期自动扣除

202
00:09:41,982 --> 00:09:45,219
定期自动扣除的金额
可以是固定或可变的

203
00:09:45,219 --> 00:09:47,354
按定期计划收取

204
00:09:47,354 --> 00:09:51,158
如每周 每月或每年收费

205
00:09:51,158 --> 00:09:53,560
这些付款可以在特定日期结束

206
00:09:53,560 --> 00:09:57,064
也可以一直持续到取消

207
00:09:57,064 --> 00:10:01,568
我们也支持试用期或优惠期

208
00:10:01,568 --> 00:10:03,971
定期自动扣除可以完美用于

209
00:10:03,971 --> 00:10:06,273
订阅 分期付款计划

210
00:10:06,273 --> 00:10:08,509
和定期计费

211
00:10:08,509 --> 00:10:11,011
让我们看看如何在 App 中

212
00:10:11,011 --> 00:10:14,548
用自动支付设置定期自动扣除

213
00:10:14,548 --> 00:10:17,184
首先使用
PKRecurringPaymentSummaryItem 类

214
00:10:17,184 --> 00:10:19,219
指定自动扣除的金额

215
00:10:19,219 --> 00:10:22,656
和持续时间

216
00:10:22,656 --> 00:10:24,157
对于定期自动扣除

217
00:10:24,157 --> 00:10:27,127
您可以同时指定常规计费周期

218
00:10:27,127 --> 00:10:30,998
也可以指定优惠期或试用期

219
00:10:30,998 --> 00:10:34,401
您可以使用
startDate 和 endDate 属性

220
00:10:34,401 --> 00:10:36,970
来指示试用期何时结束

221
00:10:36,970 --> 00:10:40,474
常规计费周期何时开始

222
00:10:40,474 --> 00:10:43,710
接下来 使用新的
PKRecurringPaymentRequest 类

223
00:10:43,710 --> 00:10:47,514
创建一个定期自动扣除请求

224
00:10:47,514 --> 00:10:49,816
提供付款说明

225
00:10:49,816 --> 00:10:51,785
正常计费周期

226
00:10:51,785 --> 00:10:54,788
以及前往网页的管理 URL

227
00:10:54,788 --> 00:10:57,891
客户可以在这个页面上更新或删除

228
00:10:57,891 --> 00:10:59,927
定期自动扣除服务

229
00:10:59,927 --> 00:11:03,430
您还可以选择提供试用计费期

230
00:11:03,430 --> 00:11:05,766
以及计费协议文本

231
00:11:05,766 --> 00:11:09,303
以帮助向客户解释付款条款

232
00:11:09,303 --> 00:11:13,874
最后 您可以选择
提供令牌通知 URL

233
00:11:13,874 --> 00:11:16,910
如果发布了令牌
您的服务器可以接收

234
00:11:16,910 --> 00:11:19,780
关于 Apple Pay
商家支付令牌的

235
00:11:19,780 --> 00:11:21,415
生命周期

236
00:11:21,415 --> 00:11:23,951
例如 如果卡颁发者或用户

237
00:11:23,951 --> 00:11:27,688
删除令牌 您可以收到通知

238
00:11:27,688 --> 00:11:30,057
有关商户令牌生命周期通知的

239
00:11:30,057 --> 00:11:32,025
更多信息

240
00:11:32,025 --> 00:11:36,930
请参阅 Apple Pay 商户令牌
管理 API 文档

241
00:11:36,930 --> 00:11:40,300
最后 在 paymentRequest 对象上

242
00:11:40,300 --> 00:11:42,336
设置定期自动扣除请求

243
00:11:42,336 --> 00:11:45,606
关于汇总项目 简要说明一下
您的定期自动扣除

244
00:11:45,606 --> 00:11:48,575
不会自动添加到付款请求的

245
00:11:48,575 --> 00:11:49,776
汇总项目上

246
00:11:49,776 --> 00:11:54,081
因此 请务必将定期自动扣除的项
添加到汇总项数组中

247
00:11:54,081 --> 00:11:56,016
支付请求的总额

248
00:11:56,016 --> 00:11:57,451
应该是向客户收取的

249
00:11:57,451 --> 00:11:59,353
第一笔金额

250
00:11:59,353 --> 00:12:02,089
所以在这个例子中 总金额设置为

251
00:12:02,089 --> 00:12:03,957
显示试用期的金额

252
00:12:03,957 --> 00:12:07,794
因为这是向客户收取的第一笔金额

253
00:12:07,794 --> 00:12:09,530
付款表单将向客户显示

254
00:12:09,530 --> 00:12:11,965
定期自动扣除的详细信息

255
00:12:11,965 --> 00:12:14,301
他们可以点击“账单详情”部分

256
00:12:14,301 --> 00:12:17,137
进一步阅读

257
00:12:17,137 --> 00:12:20,307
接下来是我们在这个版本中支持的

258
00:12:20,307 --> 00:12:22,075
第二种自动支付方式

259
00:12:22,075 --> 00:12:24,278
自动充值支付

260
00:12:24,278 --> 00:12:25,646
通过这种付款方式

261
00:12:25,646 --> 00:12:27,581
每当余额低于

262
00:12:27,581 --> 00:12:30,584
一定阈值金额时

263
00:12:30,584 --> 00:12:32,853
就会自动为余额充值

264
00:12:32,853 --> 00:12:35,622
自动充值支付非常适合

265
00:12:35,622 --> 00:12:39,459
商店卡充值和预付余额之类的付款

266
00:12:39,459 --> 00:12:42,596
要请求设置自动充值支付

267
00:12:42,596 --> 00:12:46,033
首先使用新的
PKAutomaticReloadPaymentSummaryItem 类

268
00:12:46,033 --> 00:12:51,238
指定充值和阈值金额

269
00:12:51,238 --> 00:12:55,209
接下来 使用新的
PKAutomaticReloadPaymentRequest 类

270
00:12:55,209 --> 00:12:59,580
创建一个自动充值支付请求

271
00:12:59,580 --> 00:13:02,916
传入支付描述 账单

272
00:13:02,916 --> 00:13:04,518
和管理 URL

273
00:13:04,518 --> 00:13:06,820
和前文定期自动扣除部分一样

274
00:13:06,820 --> 00:13:10,157
您还可以选择提供计费协议文本

275
00:13:10,157 --> 00:13:13,660
和一个令牌通知 URL

276
00:13:13,660 --> 00:13:16,830
最后 在支付请求对象上

277
00:13:16,830 --> 00:13:19,066
设置自动充值支付请求

278
00:13:19,066 --> 00:13:22,436
同样 请确保在汇总项目中包含

279
00:13:22,436 --> 00:13:24,137
自动充值支付项

280
00:13:24,137 --> 00:13:27,941
并适当设置支付请求的总额

281
00:13:27,941 --> 00:13:31,044
关于在网络页面上
使用 Apple Pay 自动支付

282
00:13:31,044 --> 00:13:35,249
查看 Apple Pay JS API 文档

283
00:13:35,249 --> 00:13:37,551
这是您客户的付款表单

284
00:13:37,551 --> 00:13:41,855
自动充值支付是这样显示的

285
00:13:41,855 --> 00:13:44,224
最后 当您在应用中采用自动支付时

286
00:13:44,224 --> 00:13:47,194
您需要记住以下几点

287
00:13:47,194 --> 00:13:50,230
以便为客户提供最佳体验

288
00:13:50,230 --> 00:13:52,165
记住要包括自动付款的汇总项目

289
00:13:52,165 --> 00:13:56,470
因为这些项目不会自动添加

290
00:13:56,470 --> 00:13:59,039
付款请求的总金额应该是

291
00:13:59,039 --> 00:14:02,342
将向客户收取的第一笔金额

292
00:14:02,342 --> 00:14:05,179
计费协议文本应当简短

293
00:14:05,179 --> 00:14:09,516
付款单将仅显示前 500 个字符

294
00:14:09,516 --> 00:14:12,452
计费协议文本不应当取代

295
00:14:12,452 --> 00:14:14,988
您的正常账单和法律协议

296
00:14:14,988 --> 00:14:16,557
是否遵守当地的定期自动扣除法规

297
00:14:16,557 --> 00:14:19,226
取决于您的主张

298
00:14:19,226 --> 00:14:22,129
如果您要向客户展示法律协议

299
00:14:22,129 --> 00:14:24,231
请先向客户展示法律协议

300
00:14:24,231 --> 00:14:27,167
再展示付款单

301
00:14:27,167 --> 00:14:30,070
在单笔交易中

302
00:14:30,070 --> 00:14:32,439
您只能请求一种类型的自动付款

303
00:14:32,439 --> 00:14:34,975
此外 自动支付不能用于

304
00:14:34,975 --> 00:14:37,811
多商户支付

305
00:14:37,811 --> 00:14:40,881
最后 如果您希望接收

306
00:14:40,881 --> 00:14:44,251
Apple Pay 商户令牌的
生命周期通知

307
00:14:44,251 --> 00:14:47,387
请务必提供令牌通知 URL

308
00:14:47,387 --> 00:14:50,924
并在服务器上采用

309
00:14:50,924 --> 00:14:52,392
Apple Pay 商户令牌
管理 API

310
00:14:52,392 --> 00:14:54,328
我们认为您
会喜欢这些新的 API

311
00:14:54,328 --> 00:14:57,197
也会享受 Apple Pay
商户令牌带来的好处

312
00:14:57,197 --> 00:14:58,999
以上是我们的一些合作伙伴

313
00:14:58,999 --> 00:15:03,537
他们也将要支持自动支付

314
00:15:03,537 --> 00:15:06,106
Apple Pay 商户令牌
将得到

315
00:15:06,106 --> 00:15:10,010
American Express Discover
Mastercard 和 Visa 的支持

316
00:15:10,010 --> 00:15:14,314
未来还将支持其他支付网络

317
00:15:14,314 --> 00:15:16,783
我们也将引入订单跟踪

318
00:15:16,783 --> 00:15:20,254
以提升购后体验

319
00:15:20,254 --> 00:15:24,458
iOS 16 新增了订单跟踪功能

320
00:15:24,458 --> 00:15:26,894
以便用户跟踪与商家下的订单

321
00:15:26,894 --> 00:15:29,296
现在 钱包能提供直观的概览

322
00:15:29,296 --> 00:15:32,599
展示正在进行中的订单
最近完成的订单

323
00:15:32,599 --> 00:15:34,301
和历史订单

324
00:15:34,301 --> 00:15:38,105
现在展示的是
正在进行中的烘焙食品订单

325
00:15:38,105 --> 00:15:42,242
这个订单仍在处理中
稍后再谈这个话题

326
00:15:42,242 --> 00:15:46,013
现在 我想在
Pet Avenue 给我的猫

327
00:15:46,013 --> 00:15:47,581
买一些玩具和配饰

328
00:15:47,581 --> 00:15:50,284
我选择使用
Apple Pay 结账

329
00:15:50,284 --> 00:15:52,486
在我授权付款后不久

330
00:15:52,486 --> 00:15:55,923
我收到一条通知
在钱包中跟踪我的订单

331
00:15:55,923 --> 00:15:58,125
点击该通知

332
00:15:58,125 --> 00:16:00,394
可以看到订单的详细信息

333
00:16:00,394 --> 00:16:02,629
我可以检查当前状态

334
00:16:02,629 --> 00:16:04,264
可以看到订单状态

335
00:16:04,264 --> 00:16:06,900
包括物流运输和跟踪信息

336
00:16:06,900 --> 00:16:09,803
以及我订购的订单项列表

337
00:16:09,803 --> 00:16:13,974
接下来 我有多种联系方式
可以联系 Pet Avenue

338
00:16:13,974 --> 00:16:18,679
检查付款信息
然后返回 Pet Avenue App

339
00:16:18,679 --> 00:16:21,114
好了
想象一下 Pet Avenue

340
00:16:21,114 --> 00:16:25,385
处理新订单的速度非常快
他们刚刚运送了我的物品

341
00:16:25,385 --> 00:16:27,754
Pet Avenue 发货后

342
00:16:27,754 --> 00:16:30,390
他们已更新了可用信息

343
00:16:30,390 --> 00:16:33,193
我可以看到状态更改为“在路上”

344
00:16:33,193 --> 00:16:36,363
预计到货日期为 6 月 10 日

345
00:16:36,363 --> 00:16:38,398
页面还包含一条自定义消息

346
00:16:38,398 --> 00:16:41,668
以及货件的跟踪信息

347
00:16:41,668 --> 00:16:43,570
哦 还记得我的烘焙食品吗？

348
00:16:43,570 --> 00:16:46,273
我刚收到通知 他们可以取货了

349
00:16:46,273 --> 00:16:48,008
让我们来看一下

350
00:16:48,008 --> 00:16:50,611
我订购了自提的烘焙食品

351
00:16:50,611 --> 00:16:52,913
我已经可以取货了 太好了

352
00:16:52,913 --> 00:16:55,682
Bake My Breath Away
提供了我的取货窗口

353
00:16:55,682 --> 00:16:57,184
取货说明

354
00:16:57,184 --> 00:16:59,853
和取货时需出示的条形码

355
00:16:59,853 --> 00:17:03,524
我们已经知道了
订单跟踪与 Apple Pay 无缝衔接

356
00:17:03,524 --> 00:17:06,293
让我们看看如何将订单跟踪

357
00:17:06,293 --> 00:17:08,962
集成到客户体验中

358
00:17:08,962 --> 00:17:10,998
要开始订单跟踪

359
00:17:10,998 --> 00:17:13,734
首先 您必须在开发者帐户中

360
00:17:13,734 --> 00:17:15,769
创建一个
Order Type ID

361
00:17:15,769 --> 00:17:19,673
Order Type ID
将您的组织标识为

362
00:17:19,673 --> 00:17:22,142
提供订单信息的实体

363
00:17:22,142 --> 00:17:24,912
您可以注册多个
Order Type ID

364
00:17:24,912 --> 00:17:26,980
例如 代表多个商家

365
00:17:26,980 --> 00:17:29,883
提供订单信息

366
00:17:29,883 --> 00:17:32,986
然后 创建一个
Order Type ID 证书

367
00:17:32,986 --> 00:17:35,689
您将使用证书来构建

368
00:17:35,689 --> 00:17:38,158
订单包和更新订单

369
00:17:38,158 --> 00:17:41,228
订单以订单包的形式分发

370
00:17:41,228 --> 00:17:44,665
订单包包括订单的

371
00:17:44,665 --> 00:17:46,033
所有元数据和信息

372
00:17:46,033 --> 00:17:48,702
订单包可以代表广泛的场景

373
00:17:48,702 --> 00:17:53,106
包括运输 取货和多重履行订单

374
00:17:53,106 --> 00:17:55,776
订单包也包括图像

375
00:17:55,776 --> 00:17:58,679
比如您的徽标和行式项目图片

376
00:17:58,679 --> 00:18:00,447
您还可以添加本地化

377
00:18:00,447 --> 00:18:03,951
以支持不同范围的客户

378
00:18:03,951 --> 00:18:06,787
每个订单包都必须经过加密签名

379
00:18:06,787 --> 00:18:08,956
以验证订单包来源

380
00:18:08,956 --> 00:18:10,691
一切就绪后

381
00:18:10,691 --> 00:18:14,094
订单包被压缩以进行分发

382
00:18:14,094 --> 00:18:15,696
请查看这个讲座附带的

383
00:18:15,696 --> 00:18:17,297
示例订单包

384
00:18:17,297 --> 00:18:19,399
有关订单包的更多信息

385
00:18:19,399 --> 00:18:22,236
请参阅开发人员文档

386
00:18:22,236 --> 00:18:25,839
将订单添加到 钱包
可与 Apple Pay 无缝协作

387
00:18:25,839 --> 00:18:28,041
当您的客户授权付款时

388
00:18:28,041 --> 00:18:31,445
您的应用或网页将接收到支付信息

389
00:18:31,445 --> 00:18:34,848
然后将支付信息
发送到服务器进行处理

390
00:18:34,848 --> 00:18:37,551
如果支付信息处理成功

391
00:18:37,551 --> 00:18:41,221
您的服务器会创建
一个订单和一些元数据

392
00:18:41,221 --> 00:18:43,790
然后 服务器返回订单细节

393
00:18:43,790 --> 00:18:47,528
到 App 或网页 以显示结果

394
00:18:47,528 --> 00:18:50,998
订单详细信息使设备能够以异步方式

395
00:18:50,998 --> 00:18:53,333
从服务器请求订单

396
00:18:53,333 --> 00:18:57,371
然后 服务器将订单包返回给设备

397
00:18:57,371 --> 00:18:59,373
当服务器创建订单时

398
00:18:59,373 --> 00:19:01,408
分配一个 Order ID

399
00:19:01,408 --> 00:19:04,478
这个 ID 在 Order Type ID 命名空间中
不可与其他重复

400
00:19:04,478 --> 00:19:08,582
您的服务器还必须生成
安全的身份验证令牌

401
00:19:08,582 --> 00:19:12,653
身份验证令牌是共享密钥
是订单详细信息的一部分

402
00:19:12,653 --> 00:19:15,455
当设备请求订单时

403
00:19:15,455 --> 00:19:17,858
将使用令牌来验证这个设备

404
00:19:17,858 --> 00:19:19,293
让我们来看一个

405
00:19:19,293 --> 00:19:22,129
返回支付授权结果的例子

406
00:19:22,129 --> 00:19:24,331
当您的客户授权付款时

407
00:19:24,331 --> 00:19:27,568
App 将付款信息发送到服务器

408
00:19:27,568 --> 00:19:29,937
并要求服务器创建一个订单

409
00:19:29,937 --> 00:19:32,940
请检查服务器结果是否表示成功

410
00:19:32,940 --> 00:19:36,043
并处理服务器返回的任何错误

411
00:19:36,043 --> 00:19:39,279
如果服务器结果确实表明成功

412
00:19:39,279 --> 00:19:41,181
则使用适当的授权结果

413
00:19:41,181 --> 00:19:44,051
完成付款

414
00:19:44,051 --> 00:19:46,253
要返回包含订单详细信息的

415
00:19:46,253 --> 00:19:47,988
支付授权结果

416
00:19:47,988 --> 00:19:51,625
首先 从服务器结果中
提取订单详细信息

417
00:19:51,625 --> 00:19:55,829
然后创建一个
PKPaymentOrderDetails 对象

418
00:19:55,829 --> 00:19:59,266
这个对象带有
Order Type ID 或 Order ID

419
00:19:59,266 --> 00:20:03,504
到服务器的 URL
和身份验证令牌

420
00:20:03,504 --> 00:20:06,740
将 PKPaymentOrderDetails 对象
分配到

421
00:20:06,740 --> 00:20:12,212
PKPaymentAuthorizationResult 上的
新 orderDetails 属性

422
00:20:12,212 --> 00:20:13,614
这样就完成了

423
00:20:13,614 --> 00:20:17,217
您也可以在网页上使用
订单详细信息完成付款

424
00:20:17,217 --> 00:20:22,189
和刚才一样
从服务器结果中提取订单详细信息

425
00:20:22,189 --> 00:20:24,458
然后在完成支付的数据中

426
00:20:24,458 --> 00:20:27,794
列入订单细节

427
00:20:27,794 --> 00:20:29,530
要更新订单

428
00:20:29,530 --> 00:20:31,965
创建一个指示支持

429
00:20:31,965 --> 00:20:34,201
自动更新的订单包

430
00:20:34,201 --> 00:20:36,069
添加订单后

431
00:20:36,069 --> 00:20:38,872
设备将注册订单的更新

432
00:20:38,872 --> 00:20:42,976
您的服务器必须存储有关注册的信息

433
00:20:42,976 --> 00:20:45,979
以后 当服务器更新订单时

434
00:20:45,979 --> 00:20:49,216
使用注册信息通知

435
00:20:49,216 --> 00:20:52,519
已注册更新订单的设备

436
00:20:52,519 --> 00:20:55,155
当设备收到推送通知时

437
00:20:55,155 --> 00:20:58,759
设备将再次向您的服务器请求订单

438
00:20:58,759 --> 00:21:01,428
然后 服务器将更新后的订单包

439
00:21:01,428 --> 00:21:03,630
返回给设备

440
00:21:03,630 --> 00:21:05,232
只有您和您的客户

441
00:21:05,232 --> 00:21:07,267
才可知道客户订购了什么

442
00:21:07,267 --> 00:21:10,270
我们在设计订单跟踪时
考虑到了客户隐私

443
00:21:10,270 --> 00:21:12,973
订单信息直接在

444
00:21:12,973 --> 00:21:15,509
设备和服务器之间交换

445
00:21:15,509 --> 00:21:18,078
订单通过 iCloud 同步时

446
00:21:18,078 --> 00:21:20,247
内容是端到端加密的

447
00:21:20,247 --> 00:21:21,915
请遵循这些做法

448
00:21:21,915 --> 00:21:24,718
以为客户提供最好的体验

449
00:21:24,718 --> 00:21:27,721
将您的应用与您提供的订单关联起来

450
00:21:27,721 --> 00:21:30,991
如果您的应用提供通知并已安装应用

451
00:21:30,991 --> 00:21:34,027
您可以禁用订单跟踪通知

452
00:21:34,027 --> 00:21:37,698
这么做可以防止重复通知

453
00:21:37,698 --> 00:21:40,901
利用您对客户偏好的了解

454
00:21:40,901 --> 00:21:44,204
只提供相关的本地化内容

455
00:21:44,204 --> 00:21:46,874
请注意订单包的大小

456
00:21:46,874 --> 00:21:48,375
尽量减小订单包

457
00:21:48,375 --> 00:21:51,044
以降低昂贵的网络成本

458
00:21:51,044 --> 00:21:52,379
当您更新订单时

459
00:21:52,379 --> 00:21:56,216
及时通知已注册更新的设备

460
00:21:56,216 --> 00:22:00,187
钱包中的订单
应与订单的实际状态相匹配

461
00:22:00,187 --> 00:22:05,025
还要确保检查 HIG
以进行订单跟踪

462
00:22:05,025 --> 00:22:07,794
平台可以使订单跟踪的集成

463
00:22:07,794 --> 00:22:09,162
更加简单

464
00:22:09,162 --> 00:22:13,000
我们很高兴地宣布
Shopify 及 Narvar 和 Route

465
00:22:13,000 --> 00:22:15,469
将在今秋支持订单跟踪

466
00:22:15,469 --> 00:22:18,172
请留意未来几个月

467
00:22:18,172 --> 00:22:19,840
更多支持订单跟踪的平台

468
00:22:19,840 --> 00:22:21,842
订单跟踪是增强客户

469
00:22:21,842 --> 00:22:24,945
购后体验的好方法

470
00:22:24,945 --> 00:22:26,580
通过自动更新

471
00:22:26,580 --> 00:22:28,649
您的客户将能及时了解

472
00:22:28,649 --> 00:22:31,018
他们订单的最新状态

473
00:22:31,018 --> 00:22:33,954
我们相信您的客户会喜欢这种体验

474
00:22:33,954 --> 00:22:36,723
我们期待能尽快向您订购产品

475
00:22:36,723 --> 00:22:39,259
接下来 David 将继续讲座

476
00:22:39,259 --> 00:22:41,061
David：谢谢 Lais

477
00:22:41,061 --> 00:22:44,364
我非常高兴能与大家聊一聊

478
00:22:44,364 --> 00:22:48,302
我们在 iOS 16 的钱包中
添加了 ID 的新功能

479
00:22:48,302 --> 00:22:52,940
今年早些时候 我们在 iOS 15.4 中
推出了钱包中的 ID

480
00:22:52,940 --> 00:22:55,309
美国境内支持这个功能的各州

481
00:22:55,309 --> 00:22:58,679
用户能将驾照或身份证添加到钱包

482
00:22:58,679 --> 00:23:01,982
钱包中的 ID 是由

483
00:23:01,982 --> 00:23:04,151
发行实体身份证的机构发行

484
00:23:04,151 --> 00:23:07,421
在美国 就是各州的机动车管理局

485
00:23:07,421 --> 00:23:10,324
或同等机构

486
00:23:10,324 --> 00:23:14,661
在 iOS 16 中
我们增加了一个新的 API

487
00:23:14,661 --> 00:23:17,931
允许 App 和 App Clips
从钱包中的 ID 请求信息

488
00:23:17,931 --> 00:23:21,635
以验证用户的年龄或身份

489
00:23:21,635 --> 00:23:24,104
您的 App 将请求信息

490
00:23:24,104 --> 00:23:26,807
用户会审查并批准请求

491
00:23:26,807 --> 00:23:29,343
然后 App 会将响应发送到服务器

492
00:23:29,343 --> 00:23:32,246
进行解密和验证

493
00:23:32,246 --> 00:23:34,181
您可以从用户 ID

494
00:23:34,181 --> 00:23:35,782
请求许多数据元素

495
00:23:35,782 --> 00:23:39,753
包括他们的姓名、地址

496
00:23:39,753 --> 00:23:42,155
出生日期、照片

497
00:23:42,155 --> 00:23:43,757
也叫肖像

498
00:23:43,757 --> 00:23:46,627
颁发身份证件的颁发机构

499
00:23:46,627 --> 00:23:49,997
身份证号码和有效期

500
00:23:49,997 --> 00:23:52,599
以及 如果有的话
用户的的身份证件

501
00:23:52,599 --> 00:23:54,668
授予的驾驶特权

502
00:23:54,668 --> 00:23:58,705
ID 的常见的用例
是验证用户的年龄

503
00:23:58,705 --> 00:24:02,643
查看实体身份证
能够看到用户出生日期

504
00:24:02,643 --> 00:24:04,978
但要验证用户年龄

505
00:24:04,978 --> 00:24:08,115
具体出生日期是不必要的

506
00:24:08,115 --> 00:24:10,617
如果要验证我的年龄
实际上不需要知道

507
00:24:10,617 --> 00:24:12,986
我出生的确切日期或年份

508
00:24:12,986 --> 00:24:14,755
甚至不需要知道我多少岁

509
00:24:14,755 --> 00:24:17,724
只需要知道我是否达到年龄标准

510
00:24:17,724 --> 00:24:21,495
使用钱包中的 ID
您可以直接验证年龄

511
00:24:21,495 --> 00:24:23,964
您的应用可以请求布尔数据元素

512
00:24:23,964 --> 00:24:27,100
表明用户是否超过一定年龄

513
00:24:27,100 --> 00:24:29,269
这种验证年龄的方式

514
00:24:29,269 --> 00:24:33,507
比查看具体出生日期更保护隐私

515
00:24:33,507 --> 00:24:36,777
当您的应用调用 API 时
用户会收到一张表单

516
00:24:36,777 --> 00:24:39,379
显示您在请求什么信息

517
00:24:39,379 --> 00:24:41,081
表单还会显示您是否打算

518
00:24:41,081 --> 00:24:42,549
存储这些信息

519
00:24:42,549 --> 00:24:44,818
以及您打算存储多长时间

520
00:24:44,818 --> 00:24:47,120
这样 用户可以更明智地决定

521
00:24:47,120 --> 00:24:49,823
是否与您的 App 共享信息

522
00:24:49,823 --> 00:24:52,092
用户使用 Face ID
或 Touch ID 明确批准之前

523
00:24:52,092 --> 00:24:56,330
设备不会共享信息

524
00:24:56,330 --> 00:24:58,832
您收到的响应仅包含

525
00:24:58,832 --> 00:25:00,200
您请求的元素

526
00:25:00,200 --> 00:25:02,503
其他身份验证机制

527
00:25:02,503 --> 00:25:04,938
比如扫描实体身份证

528
00:25:04,938 --> 00:25:07,274
会共享身份证上的所有信息

529
00:25:07,274 --> 00:25:09,710
把共享信息限制在您需要的范围内

530
00:25:09,710 --> 00:25:12,946
钱包中的 ID
更能保护用户的隐私

531
00:25:12,946 --> 00:25:15,148
并减少您需要在服务器上储存的

532
00:25:15,148 --> 00:25:18,752
敏感信息数量

533
00:25:18,752 --> 00:25:21,655
响应由 ID 的颁发机构签名

534
00:25:21,655 --> 00:25:23,557
这样就可以直接验证

535
00:25:23,557 --> 00:25:26,727
响应中的信息是否真实

536
00:25:26,727 --> 00:25:29,229
请注意 ID 是由颁发机构创建

537
00:25:29,229 --> 00:25:32,399
但在调用 API 时
颁发机构并不参与

538
00:25:32,399 --> 00:25:34,935
颁发机构不知道用户何时共享信息

539
00:25:34,935 --> 00:25:39,206
也不知道用户向谁共享了信息

540
00:25:39,206 --> 00:25:42,009
要使用 API 您需要通过

541
00:25:42,009 --> 00:25:44,912
开发者帐户请求授权

542
00:25:44,912 --> 00:25:46,747
然后 您需要设置商户 ID

543
00:25:46,747 --> 00:25:48,815
和加密证书

544
00:25:48,815 --> 00:25:51,852
这个过程与使用 Apple Pay
设置应用内支付

545
00:25:51,852 --> 00:25:53,253
非常相似

546
00:25:53,253 --> 00:25:58,125
稍后我们将详细讨论
如何使用 ID 和证书

547
00:25:58,125 --> 00:26:01,428
现在 我们来看看验证流程

548
00:26:01,428 --> 00:26:04,298
概括地说 包括四个步骤

549
00:26:04,298 --> 00:26:07,968
首先 您的应用将调用
PassKit 框架中的 API

550
00:26:07,968 --> 00:26:11,772
并指定您正在请求的信息

551
00:26:11,772 --> 00:26:13,440
然后 系统将显示一个表单

552
00:26:13,440 --> 00:26:16,410
提示用户批准请求

553
00:26:16,410 --> 00:26:18,612
用户通过请求后 您的 App

554
00:26:18,612 --> 00:26:21,114
将收到一个加密的响应

555
00:26:21,114 --> 00:26:23,817
然后 应用会将该响应传递给服务器

556
00:26:23,817 --> 00:26:27,187
进行解密和验证

557
00:26:27,187 --> 00:26:32,125
首先 来看看如何使用
PassKit 中的 API

558
00:26:32,125 --> 00:26:34,661
如果您的应用使用 SwiftUI
您应该使用

559
00:26:34,661 --> 00:26:37,965
VerifyIdentityWithWalletButton
SwiftUI 视图

560
00:26:37,965 --> 00:26:39,666
这里会显示一个按钮

561
00:26:39,666 --> 00:26:43,103
按下时触发身份验证流程

562
00:26:43,103 --> 00:26:46,840
就像“使用 Apple Pay 支付”
和“添加航空通票到钱包”按钮一样

563
00:26:46,840 --> 00:26:50,344
“使用钱包验证身份”按钮
提供了一个熟悉的

564
00:26:50,344 --> 00:26:54,181
一致的
使用 API 的 App 体验

565
00:26:54,181 --> 00:26:56,250
有四种不同的标签供您选择

566
00:26:56,250 --> 00:26:58,652
以显示适合您的用例的按钮

567
00:26:58,652 --> 00:27:00,854
按钮会根据可用空间自动切换

568
00:27:00,854 --> 00:27:05,926
单行和多行的按钮

569
00:27:05,926 --> 00:27:07,427
创建按钮时

570
00:27:07,427 --> 00:27:10,898
您需要指定一个
PKIdentityRequest 对象

571
00:27:10,898 --> 00:27:13,667
这个对象描述您希望请求的信息

572
00:27:13,667 --> 00:27:15,536
以及应该如何返回它

573
00:27:15,536 --> 00:27:18,772
让我们来看看如何创建按钮

574
00:27:18,772 --> 00:27:19,907
首先创建一个

575
00:27:19,907 --> 00:27:22,843
PKIdentityDriversLicenseDescriptor

576
00:27:22,843 --> 00:27:24,478
它描述了您需要的

577
00:27:24,478 --> 00:27:26,046
数据元素

578
00:27:26,046 --> 00:27:28,482
使用
addElements 方法

579
00:27:28,482 --> 00:27:29,716
指定您想请求的元素

580
00:27:29,716 --> 00:27:32,419
以及您是否打算存储元素

581
00:27:32,419 --> 00:27:35,389
您可以多次调用
addElements 方法

582
00:27:35,389 --> 00:27:37,191
指定具有不同的存储意图的

583
00:27:37,191 --> 00:27:39,226
不同的元素集

584
00:27:39,226 --> 00:27:42,429
在这个例子中 我调用了两次

585
00:27:42,429 --> 00:27:45,365
首先 添加一个
“年龄至少 18 岁”元素

586
00:27:45,365 --> 00:27:48,368
这个元素不会被存储

587
00:27:48,368 --> 00:27:51,305
然后 再次调用
addElements 方法

588
00:27:51,305 --> 00:27:54,641
来请求用户的名字 姓氏和肖像

589
00:27:54,641 --> 00:27:58,345
所有元素都可以存储长达 30 天

590
00:27:58,345 --> 00:28:03,317
然后描述符进入
PKIdentityRequest

591
00:28:03,317 --> 00:28:07,187
下一步是指定要使用的商户标识符

592
00:28:07,187 --> 00:28:08,755
商户标识符表示

593
00:28:08,755 --> 00:28:11,558
API 响应将加密到的

594
00:28:11,558 --> 00:28:13,427
加密证书

595
00:28:13,427 --> 00:28:15,629
您将通过您的开发者帐户

596
00:28:15,629 --> 00:28:19,766
配置商家标识符及其加密证书

597
00:28:19,766 --> 00:28:22,202
最后 您需要指定一个随机数

598
00:28:22,202 --> 00:28:23,937
它将绑定到

599
00:28:23,937 --> 00:28:25,439
从 API 接收的响应

600
00:28:25,439 --> 00:28:27,174
这是一项重要的安全功能

601
00:28:27,174 --> 00:28:29,376
用于防止响应重放

602
00:28:29,376 --> 00:28:32,613
并将其绑定到特定的用户会话

603
00:28:32,613 --> 00:28:35,349
具体如何管理随机数

604
00:28:35,349 --> 00:28:37,651
取决于您自己的安全需求

605
00:28:37,651 --> 00:28:40,654
通常 它来自您的服务器

606
00:28:40,654 --> 00:28:42,856
因为稍后 您的服务器将负责执行

607
00:28:42,856 --> 00:28:45,459
随机数是有效的

608
00:28:45,459 --> 00:28:47,060
设置所有这些属性后

609
00:28:47,060 --> 00:28:50,364
PKIdentityRequest
就准备好了

610
00:28:50,364 --> 00:28:52,733
现在 我们再回到按钮部分

611
00:28:52,733 --> 00:28:55,002
如果身份​​验证可用

612
00:28:55,002 --> 00:28:57,004
这个按钮将显示在您的 App 中

613
00:28:57,004 --> 00:28:59,673
点击它将启动与您的请求的

614
00:28:59,673 --> 00:29:02,075
身份验证流程

615
00:29:02,075 --> 00:29:04,745
如果身份验证不可用

616
00:29:04,745 --> 00:29:08,348
则将显示您指定的回退视图

617
00:29:08,348 --> 00:29:11,418
例如 如果这款 iPhone 上的
钱包中没有 ID

618
00:29:11,418 --> 00:29:12,953
就会发生这种情况

619
00:29:12,953 --> 00:29:14,254
您可以使用回退视图

620
00:29:14,254 --> 00:29:18,192
提供其他方式来验证身份

621
00:29:18,192 --> 00:29:20,994
我们假设身份验证是可用的

622
00:29:20,994 --> 00:29:22,930
用户点击按钮

623
00:29:22,930 --> 00:29:25,832
系统会显示一张表单
上面有您的请求

624
00:29:25,832 --> 00:29:27,768
其中包括您请求的元素

625
00:29:27,768 --> 00:29:30,137
以及您存储元素的意图

626
00:29:30,137 --> 00:29:33,774
用户可以通过 Face ID
或 Touch ID 批准请求

627
00:29:33,774 --> 00:29:37,110
或不批准并关闭表单

628
00:29:37,110 --> 00:29:39,379
然后您的代码将收到一个结果对象

629
00:29:39,379 --> 00:29:42,950
其中包含请求的结果

630
00:29:42,950 --> 00:29:46,820
如果请求受到批准
您将收到成功结果

631
00:29:46,820 --> 00:29:49,556
结果带有一个包含加密响应的

632
00:29:49,556 --> 00:29:51,558
PKIdentityDocument 对象

633
00:29:51,558 --> 00:29:53,193
App 将发送给服务器

634
00:29:53,193 --> 00:29:56,897
进行解密和验证

635
00:29:56,897 --> 00:29:58,899
如果请求不成功

636
00:29:58,899 --> 00:30:00,934
您会收到一个失败的结果

637
00:30:00,934 --> 00:30:02,302
最常见的失败原因

638
00:30:02,302 --> 00:30:04,271
是请求未获批准

639
00:30:04,271 --> 00:30:07,608
在这种情况下
您将收到“取消”的错误

640
00:30:07,608 --> 00:30:10,277
以上就是 VerifyIdentityWithWalletButton

641
00:30:10,277 --> 00:30:12,646
SwiftUI 版本的 API

642
00:30:12,646 --> 00:30:14,248
您可以用它来显示按钮

643
00:30:14,248 --> 00:30:16,650
用按钮启动身份验证流程

644
00:30:16,650 --> 00:30:19,853
并请求钱包中的 ID 信息

645
00:30:19,853 --> 00:30:22,289
如果您的应用中
没有使用 SwiftUI

646
00:30:22,289 --> 00:30:24,791
您还可以使用
PKIdentityButton

647
00:30:24,791 --> 00:30:27,794
和 PKIdentityAuthorizationController 类

648
00:30:27,794 --> 00:30:31,098
来完成相同的流程

649
00:30:31,098 --> 00:30:34,535
好了 现在您请求到了信息

650
00:30:34,535 --> 00:30:36,803
用户批准了请求

651
00:30:36,803 --> 00:30:38,705
App 向服务器发送了

652
00:30:38,705 --> 00:30:40,240
加密的响应

653
00:30:40,240 --> 00:30:42,643
现在 我们来看看服务器需要做什么

654
00:30:42,643 --> 00:30:46,513
来解密和验证响应

655
00:30:46,513 --> 00:30:49,183
我只会大致地略微聊聊这个话题

656
00:30:49,183 --> 00:30:53,220
那么 请查看开发人员文档
以获取更多详细信息

657
00:30:53,220 --> 00:30:56,190
响应格式使用多个国际标准

658
00:30:56,190 --> 00:30:58,592
所以我强烈建议您

659
00:30:58,592 --> 00:31:01,495
也熟悉这些标准

660
00:31:01,495 --> 00:31:03,096
您将收到的响应数据

661
00:31:03,096 --> 00:31:06,099
位于 CBOR 编码的加密信封中

662
00:31:06,099 --> 00:31:10,237
CBOR
RFC 8949 中定义的数据格式

663
00:31:10,237 --> 00:31:11,638
类似于 JSON

664
00:31:11,638 --> 00:31:14,474
但使用二进制数据对对象进行编码

665
00:31:14,474 --> 00:31:16,677
加密信封包含解密过程

666
00:31:16,677 --> 00:31:18,612
所需的元数据

667
00:31:18,612 --> 00:31:21,715
连同加密数据本身

668
00:31:21,715 --> 00:31:24,318
数据使用 HPKE 加密

669
00:31:24,318 --> 00:31:28,021
HPKE 是 RFC 9180 中
定义的加密方案

670
00:31:28,021 --> 00:31:32,025
您的服务器将使用私钥解密数据

671
00:31:32,025 --> 00:31:35,329
解密后 您将获得
一个 mdoc 响应对象

672
00:31:35,329 --> 00:31:39,366
mdoc 响应的定义
在 ISO 18013 第 5 部分

673
00:31:39,366 --> 00:31:44,004
这是移动驾驶执照
和州 ID 的 ISO 标准

674
00:31:44,004 --> 00:31:46,640
mdoc 响应对象包含

675
00:31:46,640 --> 00:31:48,575
您请求的数据元素

676
00:31:48,575 --> 00:31:51,078
还包括许多服务器需要验证的

677
00:31:51,078 --> 00:31:52,713
安全特性

678
00:31:52,713 --> 00:31:55,415
以确保响应是真实的

679
00:31:55,415 --> 00:31:57,684
请注意 您的服务器将执行解密

680
00:31:57,684 --> 00:31:59,586
和验证服务器本身

681
00:31:59,586 --> 00:32:02,589
Apple 服务器
和发行机构的服务器

682
00:32:02,589 --> 00:32:04,324
都不会参与其中

683
00:32:04,324 --> 00:32:06,059
在讨论解密

684
00:32:06,059 --> 00:32:07,528
和响应验证之前

685
00:32:07,528 --> 00:32:09,997
我们需要讨论会话记录

686
00:32:09,997 --> 00:32:13,133
这是一个 CBOR 结构
它将响应负载绑定到

687
00:32:13,133 --> 00:32:16,170
来自特定 App 的特定请求

688
00:32:16,170 --> 00:32:18,772
您的服务器将需要构建此结构

689
00:32:18,772 --> 00:32:23,043
并在解密和验证期间使用它

690
00:32:23,043 --> 00:32:26,480
会话记录包含您之前在
PKIdentityRequest 中

691
00:32:26,480 --> 00:32:29,683
使用的同一个随机数和商户 ID

692
00:32:29,683 --> 00:32:32,186
以及您的开发团队的团队 ID

693
00:32:32,186 --> 00:32:35,255
以及您的加密证书的公钥的

694
00:32:35,255 --> 00:32:37,758
SHA256 散列

695
00:32:37,758 --> 00:32:39,493
在构建会话记录时

696
00:32:39,493 --> 00:32:41,795
服务器应该检查您正在使用的输入

697
00:32:41,795 --> 00:32:43,063
都是有效的

698
00:32:43,063 --> 00:32:45,632
这意味着随机数不应该已经被使用

699
00:32:45,632 --> 00:32:47,968
而应该被绑定到当前用户

700
00:32:47,968 --> 00:32:50,070
其他值应该与您的开发者帐户上

701
00:32:50,070 --> 00:32:52,272
所期望的值相匹配

702
00:32:52,272 --> 00:32:55,576
现在我们来聊聊解密加密数据

703
00:32:55,576 --> 00:32:57,911
您需要刚刚创建的会话记录

704
00:32:57,911 --> 00:33:01,281
以及来自加密信封的元数据

705
00:33:01,281 --> 00:33:03,851
您还需要个人密钥

706
00:33:03,851 --> 00:33:04,952
这是与您之前

707
00:33:04,952 --> 00:33:07,788
在开发者帐户中

708
00:33:07,788 --> 00:33:09,456
设置的证书相对应的个人密钥

709
00:33:09,456 --> 00:33:12,292
为保护用户信息的机密性

710
00:33:12,292 --> 00:33:15,262
您需要确保个人密钥保持私有

711
00:33:15,262 --> 00:33:17,164
安全存储在您的服务器上

712
00:33:17,164 --> 00:33:19,333
并且永远不要储存在 App 中

713
00:33:19,333 --> 00:33:21,602
如果您的个人密钥泄露

714
00:33:21,602 --> 00:33:25,873
请立即撤销开发者帐户中的证书

715
00:33:25,873 --> 00:33:27,941
解密加密数据后

716
00:33:27,941 --> 00:33:30,110
您将收到一个 mdoc 响应对象

717
00:33:30,110 --> 00:33:32,279
包含两个加密签名

718
00:33:32,279 --> 00:33:34,481
以及您要求的数据元素

719
00:33:34,481 --> 00:33:37,351
您需要检查
mdoc 响应中的两个签名

720
00:33:37,351 --> 00:33:39,853
然后才能使用它的数据元素

721
00:33:39,853 --> 00:33:42,923
首先 您需要检查颁发者签名

722
00:33:42,923 --> 00:33:45,092
这是用户 ID 颁发机构的

723
00:33:45,092 --> 00:33:46,960
签名

724
00:33:46,960 --> 00:33:48,462
通过检查这个签名

725
00:33:48,462 --> 00:33:50,664
您正在验证响应中的数据

726
00:33:50,664 --> 00:33:52,699
来自真正的发证机关

727
00:33:52,699 --> 00:33:54,601
并且没有被篡改

728
00:33:54,601 --> 00:33:57,538
您应该检查签名不仅是有效的

729
00:33:57,538 --> 00:34:01,275
而且签名是由
您信任的颁发者证书签署的

730
00:34:01,275 --> 00:34:03,844
查看文档 了解关于
钱包中 ID 使用的

731
00:34:03,844 --> 00:34:07,781
颁发者证书的更多详细信息

732
00:34:07,781 --> 00:34:11,018
接下来 您需要验证设备签名

733
00:34:11,018 --> 00:34:13,053
这是由用户 iPhone 的
Secure Element 中的

734
00:34:13,053 --> 00:34:15,956
密钥创建的签名

735
00:34:15,956 --> 00:34:18,158
这说明您收到的回复来自

736
00:34:18,158 --> 00:34:20,627
发卡机构最初发给您 ID 的

737
00:34:20,627 --> 00:34:22,996
那台 iPhone

738
00:34:22,996 --> 00:34:25,732
在这里 您需要再次使用会话记录

739
00:34:25,732 --> 00:34:29,970
以及颁发者签名所涵盖的一些信息

740
00:34:29,970 --> 00:34:32,406
最后 可以使用请求的

741
00:34:32,406 --> 00:34:33,907
数据元素了

742
00:34:33,907 --> 00:34:35,409
在没有首先验证颁发者
和设备签名之前

743
00:34:35,409 --> 00:34:38,712
永远不要使用这些元素

744
00:34:38,712 --> 00:34:41,715
否则您不知道您收到的数据

745
00:34:41,715 --> 00:34:44,117
是否真实

746
00:34:44,117 --> 00:34:46,620
完成所有这些步骤后 就完成了

747
00:34:46,620 --> 00:34:48,755
您的应用已经请求了信息

748
00:34:48,755 --> 00:34:52,693
并且您的服务器已经解密
并验证了响应

749
00:34:52,693 --> 00:34:55,262
您可能想知道如果
在钱包中没有 ID

750
00:34:55,262 --> 00:34:57,264
如何测试您的设置

751
00:34:57,264 --> 00:35:01,435
我们提供了一些机制来帮助您

752
00:35:01,435 --> 00:35:04,271
首先 您可以在
iOS 模拟器中测试

753
00:35:04,271 --> 00:35:07,241
模拟器中的 API
将返回一个模拟响应

754
00:35:07,241 --> 00:35:09,643
测试的响应类似于真实的响应

755
00:35:09,643 --> 00:35:12,980
但没有真正的签名

756
00:35:12,980 --> 00:35:15,482
同样 您可以使用测试配置文件

757
00:35:15,482 --> 00:35:18,018
在真正的 iPhone 上
接收模拟响应

758
00:35:18,018 --> 00:35:21,321
哪怕 iPhone 上的钱包中
没有 ID 也可以做到

759
00:35:21,321 --> 00:35:24,958
关于如何执行这项操作的
更多详细信息 请参阅文档

760
00:35:24,958 --> 00:35:26,693
请注意 您的服务器不应该将

761
00:35:26,693 --> 00:35:30,497
像处理真实响应一样处理模拟响应

762
00:35:30,497 --> 00:35:32,966
要帮助您设置服务器

763
00:35:32,966 --> 00:35:36,170
文档中还有一个示例响应

764
00:35:36,170 --> 00:35:41,441
以及解密和验证所需要的一切

765
00:35:41,441 --> 00:35:44,378
这就是在 iOS 16 中
使用钱包中 ID

766
00:35:44,378 --> 00:35:47,181
进行身份验证的方式

767
00:35:47,181 --> 00:35:49,950
我们讨论了如何
在您的应用中使用 API

768
00:35:49,950 --> 00:35:52,085
如何处理服务器上的响应

769
00:35:52,085 --> 00:35:54,888
以及如何测试您的设置

770
00:35:54,888 --> 00:35:57,624
Lais：今年我们为
钱包和 Apple Pay

771
00:35:57,624 --> 00:35:59,393
推出了很多很棒的新功能

772
00:35:59,393 --> 00:36:01,762
新功能包括多商户支付

773
00:36:01,762 --> 00:36:04,364
改进了对自动支付的支持

774
00:36:04,364 --> 00:36:07,568
订单跟踪和身份验证

775
00:36:07,568 --> 00:36:09,436
请查看开发者文档

776
00:36:09,436 --> 00:36:10,804
以了解更多信息

777
00:36:10,804 --> 00:36:14,975
David：感谢您的收看
希望您在 WWDC 体验愉快

778
00:36:14,975 --> 00:36:19,079
♪

