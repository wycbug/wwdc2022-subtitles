1
00:00:00,167 --> 00:00:03,003
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,003 --> 00:00:09,977
♪

3
00:00:09,977 --> 00:00:14,281
Devin Clary：嗨 我是
Messages 团队的工程师 Devin

4
00:00:14,281 --> 00:00:17,017
Lance Parker：我是 Lance
也是 Messages 团队工程师

5
00:00:17,017 --> 00:00:20,053
Devin：欢迎收看
“集成使用您的自定义协作 App

6
00:00:20,053 --> 00:00:22,222
与 Messages ”

7
00:00:22,222 --> 00:00:24,625
协作以会话为起点

8
00:00:24,625 --> 00:00:27,227
在 iOS 16 和 macOS Ventura 中

9
00:00:27,227 --> 00:00:29,897
您可将您 App 的自定义协作体验

10
00:00:29,897 --> 00:00:32,466
直接带入会话结构

11
00:00:32,466 --> 00:00:36,870
本次视频 我们首先
为您介绍协作的生命周期

12
00:00:36,870 --> 00:00:38,438
其次 我们将向您展示如何准备

13
00:00:38,438 --> 00:00:42,809
通过 Messages 共享
App 的协作内容

14
00:00:42,809 --> 00:00:45,879
再次 我们将为您详细讲解如何

15
00:00:45,879 --> 00:00:49,650
及时验证接收者的访问
以及响应参与者的变化

16
00:00:49,650 --> 00:00:52,619
以上所有均不涉及隐私问题

17
00:00:52,619 --> 00:00:55,355
最后 我们将
向您展示您的 App 如何

18
00:00:55,355 --> 00:00:59,293
在 Message 会话中
直接发布有关内容的通知

19
00:00:59,293 --> 00:01:00,928
假设您的 App

20
00:01:00,928 --> 00:01:03,263
已具备协作基础设施

21
00:01:03,263 --> 00:01:06,066
并且已经采用了通用链接

22
00:01:06,066 --> 00:01:08,268
我们将以“将 SharedWithYou
添加到您的 App 中”

23
00:01:08,268 --> 00:01:09,870
和“利用 Messages
增强协作体验”中

24
00:01:09,870 --> 00:01:14,575
介绍的某些概念为基础

25
00:01:14,575 --> 00:01:16,677
首先 我来介绍一下

26
00:01:16,677 --> 00:01:18,979
自定义协作消息的生命周期

27
00:01:18,979 --> 00:01:21,515
说明该 API 如何让您的用户

28
00:01:21,515 --> 00:01:24,818
更加快速地开始协作

29
00:01:24,818 --> 00:01:26,987
当用户决定通过 Messages

30
00:01:26,987 --> 00:01:29,756
在您的 App 中共享协作时

31
00:01:29,756 --> 00:01:33,427
您首先应创建表达内容的元数据

32
00:01:33,427 --> 00:01:36,463
元数据包括用户在发送消息前

33
00:01:36,463 --> 00:01:37,965
可配置的共享选项

34
00:01:37,965 --> 00:01:41,301
以及可由您定义的其他属性

35
00:01:41,301 --> 00:01:43,971
接下来 您将元数据提供给共享表

36
00:01:43,971 --> 00:01:46,039
或拖放

37
00:01:46,039 --> 00:01:48,375
这可让内容草稿暂存

38
00:01:48,375 --> 00:01:51,144
在 Messages 撰写字段中

39
00:01:51,144 --> 00:01:55,215
协作需要由通用链接表示

40
00:01:55,215 --> 00:01:57,918
可立即创建 但最好推迟到

41
00:01:57,918 --> 00:02:00,721
消息发送之前再创建

42
00:02:00,721 --> 00:02:02,422
您 App 的链接创建
由所选的共享选项或接收者决定

43
00:02:02,422 --> 00:02:05,325
如在 Messages
撰写字段中配置的那样

44
00:02:05,325 --> 00:02:08,395
则该条件适合用

45
00:02:08,395 --> 00:02:11,365
用户选择接收者和分享选项

46
00:02:11,365 --> 00:02:14,201
并点击发送按钮

47
00:02:14,201 --> 00:02:15,569
在发送消息前

48
00:02:15,569 --> 00:02:17,971
Messages 要求
您的 App 提供通用链接

49
00:02:17,971 --> 00:02:21,575
以及独立于设备的内容标识符

50
00:02:21,575 --> 00:02:23,877
利用该标识符
Messages 提供了一组

51
00:02:23,877 --> 00:02:26,747
代表该特定协作消息

52
00:02:26,747 --> 00:02:29,917
接收者的加密身份

53
00:02:29,917 --> 00:02:31,685
您的 App 稍后会利用这组身份

54
00:02:31,685 --> 00:02:34,087
允许接收者在其任意设备上

55
00:02:34,087 --> 00:02:38,725
立即打开链接

56
00:02:38,725 --> 00:02:41,261
您的 App 还会将
这组身份存储在服务器上

57
00:02:41,261 --> 00:02:44,364
并将其与共享内容相关联

58
00:02:44,364 --> 00:02:46,033
一旦您的 App 完成该步骤

59
00:02:46,033 --> 00:02:50,470
消息就会被发送给接收者

60
00:02:50,470 --> 00:02:53,440
现在 接收设备上会发生以下情况

61
00:02:53,440 --> 00:02:56,009
我们的目的是立即验证访问权限

62
00:02:56,009 --> 00:02:59,913
将接收者身份
与您服务器上的帐户配对

63
00:02:59,913 --> 00:03:01,682
当接收者打开链接时

64
00:03:01,682 --> 00:03:04,351
您的 App 会收到
打开 URL 的调用

65
00:03:04,351 --> 00:03:08,388
收到其他链接也是如此

66
00:03:08,388 --> 00:03:10,090
当您的 App 检测到某个用户帐户

67
00:03:10,090 --> 00:03:12,326
无权访问该文档时

68
00:03:12,326 --> 00:03:15,262
它就会查询系统 获取

69
00:03:15,262 --> 00:03:18,866
由接收设备加密签名的用户身份证明

70
00:03:18,866 --> 00:03:20,901
您的 App 会发送
签名后的身份证明

71
00:03:20,901 --> 00:03:23,871
至您的服务器进行验证

72
00:03:23,871 --> 00:03:26,373
如果签名有效 服务器会对该证明

73
00:03:26,373 --> 00:03:28,308
与发送设备先前提供的身份证明

74
00:03:28,308 --> 00:03:30,310
做比较

75
00:03:30,310 --> 00:03:33,213
如果匹配
您的服务器就会授予该用户帐户

76
00:03:33,213 --> 00:03:35,215
访问权限

77
00:03:35,215 --> 00:03:36,717
这样一来 接收者就可

78
00:03:36,717 --> 00:03:39,419
即时安全地访问内容

79
00:03:39,419 --> 00:03:42,022
无需交换帐户信息！

80
00:03:42,022 --> 00:03:45,826
这就是协作消息的生命周期！

81
00:03:45,826 --> 00:03:47,561
下面我们来进一步了解

82
00:03:47,561 --> 00:03:51,198
用于启动协作的 API

83
00:03:51,198 --> 00:03:55,169
系统需要某些关于协作的元数据

84
00:03:55,169 --> 00:03:56,970
为此 您要在
SharedWithYou 框架中

85
00:03:56,970 --> 00:04:01,575
使用一个名为
SWCollaborationMetadata 的新类

86
00:04:01,575 --> 00:04:05,012
您需为该类配置属性

87
00:04:05,012 --> 00:04:08,148
如内容标题 即本地标识符

88
00:04:08,148 --> 00:04:10,851
用于在内容共享前参考

89
00:04:10,851 --> 00:04:13,220
又如发起者名称和帐户句柄

90
00:04:13,220 --> 00:04:14,788
用于为用户正在共享的账户

91
00:04:14,788 --> 00:04:16,890
增加透明度

92
00:04:16,890 --> 00:04:21,528
以及默认共享选项 供用户配置

93
00:04:21,528 --> 00:04:23,330
以下是创建元数据对象

94
00:04:23,330 --> 00:04:27,034
及配置其属性的方法

95
00:04:27,034 --> 00:04:31,104
利用以字符串初始化的
SWLocalCollaborationIdentifier

96
00:04:31,104 --> 00:04:33,874
创建本地标识符

97
00:04:33,874 --> 00:04:36,143
该字符串只需供您的 App

98
00:04:36,143 --> 00:04:41,114
在本地识别内容 无需跨设备识别

99
00:04:41,114 --> 00:04:43,183
使用本地标识符初始化一个

100
00:04:43,183 --> 00:04:47,020
新的元数据实例

101
00:04:47,020 --> 00:04:52,025
使用基础框架中的
PersonNameComponents

102
00:04:52,025 --> 00:04:54,628
设置内容标题 发起者账号句柄

103
00:04:54,628 --> 00:04:57,164
及其名称

104
00:04:57,164 --> 00:04:59,566
句柄和名称仅在本地显示

105
00:04:59,566 --> 00:05:04,371
这样用户就可以确认其共享帐户

106
00:05:04,371 --> 00:05:07,474
接下来
设置 defaultShareOptions

107
00:05:07,474 --> 00:05:08,942
展示具体操作之前

108
00:05:08,942 --> 00:05:12,012
我先讲一下选项工作的方式

109
00:05:12,012 --> 00:05:14,548
共享选项是用户在 Messages 协作

110
00:05:14,548 --> 00:05:18,252
或共享表上配置的设置

111
00:05:18,252 --> 00:05:20,621
用户选择的选项将在发送消息之前

112
00:05:20,621 --> 00:05:23,323
提供给您

113
00:05:23,323 --> 00:05:25,325
共享选项可能包含的设置有

114
00:05:25,325 --> 00:05:27,694
谁可对协作进行编辑

115
00:05:27,694 --> 00:05:32,199
或谁有权访问内容

116
00:05:32,199 --> 00:05:34,768
您可用一些类来定义选项

117
00:05:34,768 --> 00:05:38,238
比如从 SWCollaborationOption 开始

118
00:05:38,238 --> 00:05:39,640
选项取决于分组方式

119
00:05:39,640 --> 00:05:42,209
它代表单个开关

120
00:05:42,209 --> 00:05:46,280
或某个设置的互斥值

121
00:05:46,280 --> 00:05:48,715
选项有一个标题和一个标识符

122
00:05:48,715 --> 00:05:53,921
两者要么选中要么不选

123
00:05:53,921 --> 00:05:58,091
有两个类来表示一组选项

124
00:05:58,091 --> 00:06:00,060
即 SWCollaborationOptionsGroup

125
00:06:00,060 --> 00:06:04,198
和 SWCollaborationOptionsPickerGroup

126
00:06:04,198 --> 00:06:06,767
您可用
SWCollaborationOptionsGroup

127
00:06:06,767 --> 00:06:09,269
表示开关的集合

128
00:06:09,269 --> 00:06:11,905
同时用
SWCollaborationOptionsPickerGroup

129
00:06:11,905 --> 00:06:16,610
表示设置的互斥值

130
00:06:16,610 --> 00:06:19,246
最后 SWCollaborationShareOptions

131
00:06:19,246 --> 00:06:21,682
定义了全套选项组

132
00:06:21,682 --> 00:06:25,252
可在元数据的
defaultShareOptions 属性上设置

133
00:06:25,252 --> 00:06:29,489
您还可以提供摘要字符串来描述选项

134
00:06:29,489 --> 00:06:31,658
描述完选项类

135
00:06:31,658 --> 00:06:34,661
我再来向您展示使用方法

136
00:06:34,661 --> 00:06:38,765
这个代码定义了两个选项组

137
00:06:38,765 --> 00:06:41,368
第一组用标识符和

138
00:06:41,368 --> 00:06:43,937
两个可能的选项初始化

139
00:06:43,937 --> 00:06:45,973
标识符是任意字符串

140
00:06:45,973 --> 00:06:50,711
稍后可用于识别用户选择了哪个选项

141
00:06:50,711 --> 00:06:52,145
由于是选择器组合

142
00:06:52,145 --> 00:06:54,915
因此各个选项互斥

143
00:06:54,915 --> 00:06:56,884
该组代表内容权限设置

144
00:06:56,884 --> 00:07:00,787
即读写或只读

145
00:07:00,787 --> 00:07:06,093
然后 默认选择该组的第一个选项

146
00:07:06,093 --> 00:07:11,231
标题设置为描述该组的字符串

147
00:07:11,231 --> 00:07:13,667
第二个选项组以同样的方式初始化

148
00:07:13,667 --> 00:07:16,203
也包含两个选项

149
00:07:16,203 --> 00:07:18,305
但因该选项组为通用选项组

150
00:07:18,305 --> 00:07:19,673
用户可以配置

151
00:07:19,673 --> 00:07:23,710
是否独立允许提及和评论

152
00:07:23,710 --> 00:07:26,547
最后 这两个选项组可用于初始化

153
00:07:26,547 --> 00:07:30,184
SWCollaborationShareOptions 实例

154
00:07:30,184 --> 00:07:34,454
随后在元数据上设置该实例

155
00:07:34,454 --> 00:07:37,090
接下来 根据用户分享内容的方式

156
00:07:37,090 --> 00:07:39,626
将元数据提供给共享表

157
00:07:39,626 --> 00:07:42,362
或拖放

158
00:07:42,362 --> 00:07:46,033
如果您的 App 用的是 SwiftUI
SWCollaborationMetadata

159
00:07:46,033 --> 00:07:49,536
就可与新的 ShareLink API 兼容

160
00:07:49,536 --> 00:07:52,105
观看“Meet Transferable”
和“SwiftUI 的新功能”

161
00:07:52,105 --> 00:07:58,245
即可了解有关
Transferable 和 ShareLink 的更多信息

162
00:07:58,245 --> 00:08:00,814
我们来看
在 SwiftUI 的代理模式上

163
00:08:00,814 --> 00:08:05,552
支持协作有多么简单！

164
00:08:05,552 --> 00:08:08,288
从 Transferable 模型对象中
设置一个

165
00:08:08,288 --> 00:08:10,090
ProxyRepresentation

166
00:08:10,090 --> 00:08:15,395
来返回协作元数据实例

167
00:08:15,395 --> 00:08:16,630
然后从一个视图中

168
00:08:16,630 --> 00:08:22,836
使用该模型对象初始化 ShareLink

169
00:08:22,836 --> 00:08:26,673
对于 UIKit 和 AppKit App
您可使用 NSItemProvider

170
00:08:26,673 --> 00:08:28,408
支持分享

171
00:08:28,408 --> 00:08:31,011
且 SWCollaborationMetadata 符合

172
00:08:31,011 --> 00:08:33,780
NSItemProviderReading 和 Writing

173
00:08:33,780 --> 00:08:36,216
所以您只需用 itemProvider

174
00:08:36,216 --> 00:08:39,853
注册一个元数据实例 以支持协作

175
00:08:39,853 --> 00:08:41,255
还有个好方法是

176
00:08:41,255 --> 00:08:43,757
注册多个内容表示

177
00:08:43,757 --> 00:08:47,528
便于支持多个渠道分享

178
00:08:47,528 --> 00:08:49,596
例如 如果您提供了文件表示

179
00:08:49,596 --> 00:08:52,232
Messages 会自动
提供将内容以副本发送

180
00:08:52,232 --> 00:08:55,969
这个选项

181
00:08:55,969 --> 00:08:58,672
您可将 NSItemProvider API 与

182
00:08:58,672 --> 00:09:03,477
iOS 和 iPadOS 上的
UIActivityViewController 和 UIDragItem

183
00:09:03,477 --> 00:09:08,282
以及 macOS 上的
NSSharingServicePicker 结合使用

184
00:09:08,282 --> 00:09:12,519
以下是在 iOS 上
使用共享表进行设置的方法

185
00:09:12,519 --> 00:09:16,190
创建一个 NSItemProvider 实例

186
00:09:16,190 --> 00:09:18,091
注册此前提到的

187
00:09:18,091 --> 00:09:19,826
协作元数据

188
00:09:19,826 --> 00:09:25,032
将可见性设置为系统上的所有进程

189
00:09:25,032 --> 00:09:27,734
用 itemProvider 初始化

190
00:09:27,734 --> 00:09:30,604
UIActivityItemsConfiguration

191
00:09:30,604 --> 00:09:32,973
然后用同样的配置初始化

192
00:09:32,973 --> 00:09:36,043
UIActivityViewController

193
00:09:36,043 --> 00:09:40,948
最后 展示视图控制器

194
00:09:40,948 --> 00:09:44,918
支持拖放也同样简单

195
00:09:44,918 --> 00:09:46,186
初始化 NSItemProvider

196
00:09:46,186 --> 00:09:50,591
并以相同方式注册元数据

197
00:09:50,591 --> 00:09:53,360
然后使用 itemProvider 创建一个

198
00:09:53,360 --> 00:09:58,565
UIDragItem 以便
与拖放 API 一起使用

199
00:09:58,565 --> 00:10:03,237
API 与 macOS 上的
共享弹出框类似

200
00:10:03,237 --> 00:10:06,573
再次设置 itemProvider

201
00:10:06,573 --> 00:10:08,242
这一次 需用它来初始化

202
00:10:08,242 --> 00:10:11,879
NSSharingServicePicker

203
00:10:11,879 --> 00:10:17,184
然后显示涉及目标视图的选择器

204
00:10:17,184 --> 00:10:20,621
macOS 上的拖放
可利用的是 NSPasteboardItem

205
00:10:20,621 --> 00:10:22,823
而非 NSItemProvider

206
00:10:22,823 --> 00:10:24,625
为提供支持 SharedWithYou

207
00:10:24,625 --> 00:10:29,329
要导出一个 NSPasteboardItem 扩展

208
00:10:29,329 --> 00:10:31,865
使用该扩展 直接在一个新的

209
00:10:31,865 --> 00:10:34,835
NSPasteboardItem
实例上设置协作元数据

210
00:10:34,835 --> 00:10:39,106
以支持拖放

211
00:10:39,106 --> 00:10:40,641
以上就是在 Messages 中

212
00:10:40,641 --> 00:10:45,746
设置您的协作内容草稿的全部操作！

213
00:10:45,746 --> 00:10:47,981
接下来 当用户点击发送按钮时

214
00:10:47,981 --> 00:10:52,553
系统会协调您的 App 以设置共享

215
00:10:52,553 --> 00:10:54,388
该操作通过一个名为

216
00:10:54,388 --> 00:10:57,391
SWCollaborationCoordinator
的新类实现

217
00:10:57,391 --> 00:11:00,194
SWCollaborationCoordinator
是一个单例模式

218
00:11:00,194 --> 00:11:03,230
意味着有一个全局共享实例

219
00:11:03,230 --> 00:11:05,499
该共享实例通过您定义的名为

220
00:11:05,499 --> 00:11:09,336
actionHandler 的委托来协调协作

221
00:11:09,336 --> 00:11:11,138
为确保您的 App 始终可用于

222
00:11:11,138 --> 00:11:12,806
协调合作

223
00:11:12,806 --> 00:11:15,175
它会适时在后台启动

224
00:11:15,175 --> 00:11:17,678
所以您应在启动后尽快注册委托

225
00:11:17,678 --> 00:11:22,182
并立即处理操作 避免超时

226
00:11:22,182 --> 00:11:24,251
以下是在您的 App 完成启动后

227
00:11:24,251 --> 00:11:28,021
设置协作协调器的方法

228
00:11:28,021 --> 00:11:30,257
通过共享属性访问

229
00:11:30,257 --> 00:11:33,594
单例模式协调器实例

230
00:11:33,594 --> 00:11:34,828
然后 在 App 委托的

231
00:11:34,828 --> 00:11:36,964
didFinishLaunchingWithOptions 方法中

232
00:11:36,964 --> 00:11:38,265
将 actionHandler 属性

233
00:11:38,265 --> 00:11:39,800
设置为符合

234
00:11:39,800 --> 00:11:44,371
SWCollaborationActionHandler
协议的对象

235
00:11:44,371 --> 00:11:46,874
操作处理程序协议使用了一个

236
00:11:46,874 --> 00:11:49,176
名为 SWAction 的新类

237
00:11:49,176 --> 00:11:53,814
SWActions 代表
您的 App 需要执行的操作

238
00:11:53,814 --> 00:11:56,116
操作完成后会标记为完成

239
00:11:56,116 --> 00:11:59,019
否则会标记为失败

240
00:11:59,019 --> 00:12:01,088
您的 App 需要处理的第一个操作

241
00:12:01,088 --> 00:12:03,924
就是启动协作

242
00:12:03,924 --> 00:12:05,559
SWStartCollaborationAction

243
00:12:05,559 --> 00:12:08,595
包含您此前设置的协作元数据

244
00:12:08,595 --> 00:12:12,299
元数据由用户
选择的共享选项进行更新

245
00:12:12,299 --> 00:12:14,234
完成必要设置后

246
00:12:14,234 --> 00:12:17,037
您可使用通用链接和

247
00:12:17,037 --> 00:12:18,972
一个独立于设备的标识符

248
00:12:18,972 --> 00:12:20,974
完成协作启动操作

249
00:12:20,974 --> 00:12:23,277
如果您启动操作失败

250
00:12:23,277 --> 00:12:26,013
消息就会取消发送

251
00:12:26,013 --> 00:12:28,282
以下是使用示例服务器请求

252
00:12:28,282 --> 00:12:32,219
处理启动操作的方法

253
00:12:32,219 --> 00:12:34,288
首先 检索本地标识符

254
00:12:34,288 --> 00:12:36,023
和来自操作元数据属性的

255
00:12:36,023 --> 00:12:40,227
用户所选的共享选项

256
00:12:40,227 --> 00:12:42,796
使用标识符和选项设置服务器请求

257
00:12:42,796 --> 00:12:47,334
以准备协作

258
00:12:47,334 --> 00:12:50,170
然后 将请求发送到服务器

259
00:12:50,170 --> 00:12:54,508
此示例使用了异步等待功能

260
00:12:54,508 --> 00:12:56,977
最后用通用链接以及响应中的

261
00:12:56,977 --> 00:13:01,715
设备独立标识符来完成操作

262
00:13:01,715 --> 00:13:03,116
如若出现错误

263
00:13:03,116 --> 00:13:05,953
则消息取消发送 操作失败

264
00:13:05,953 --> 00:13:07,955
如果启动操作成功

265
00:13:07,955 --> 00:13:10,224
系统会向您的 App
发送第二个操作

266
00:13:10,224 --> 00:13:13,093
用于更新协作参与者

267
00:13:13,093 --> 00:13:15,462
SWUpdateCollaborationParticipantsAction

268
00:13:15,462 --> 00:13:17,664
包含参与者的

269
00:13:17,664 --> 00:13:19,867
加密身份

270
00:13:19,867 --> 00:13:22,469
该身份来自上一步启动操作完成后

271
00:13:22,469 --> 00:13:26,840
得到的协作标识符

272
00:13:26,840 --> 00:13:28,475
请将与内容相关的身份

273
00:13:28,475 --> 00:13:30,878
存储在您的服务器上

274
00:13:30,878 --> 00:13:32,880
您将使用这些数据在接收设备上

275
00:13:32,880 --> 00:13:35,382
验证访问权限

276
00:13:35,382 --> 00:13:36,950
最后 操作完成后

277
00:13:36,950 --> 00:13:40,587
会在 Messages 中发送通用链接

278
00:13:40,587 --> 00:13:42,089
这个例子展示了

279
00:13:42,089 --> 00:13:45,025
如何处理更新参与者操作

280
00:13:45,025 --> 00:13:46,593
检索来自操作元数据的

281
00:13:46,593 --> 00:13:49,162
协作标识符所使用的方法

282
00:13:49,162 --> 00:13:50,731
在处理启动操作时

283
00:13:50,731 --> 00:13:54,001
就得到了您填写的标识符

284
00:13:54,001 --> 00:13:57,204
接下来 利用该操作的
addedIdentities 属性

285
00:13:57,204 --> 00:14:01,074
可检索参与者数据
并将其存储在您的服务器上

286
00:14:01,074 --> 00:14:05,112
每个身份都有一个
称为根哈希的 Data 属性

287
00:14:05,112 --> 00:14:06,713
这是您应存储在服务器上的数据

288
00:14:06,713 --> 00:14:09,316
稍后会用到

289
00:14:09,316 --> 00:14:10,784
Lance 将为您详细介绍

290
00:14:10,784 --> 00:14:16,190
Verifying Access
部分中有关此属性的内容

291
00:14:16,190 --> 00:14:18,425
设置另一个服务器请求 这次是将

292
00:14:18,425 --> 00:14:20,394
参与者添加到具有

293
00:14:20,394 --> 00:14:23,931
目标标识符的协作中

294
00:14:23,931 --> 00:14:26,667
和之前一样
将请求发送到您的服务器

295
00:14:26,667 --> 00:14:29,503
要么操作完成 要么操作失败

296
00:14:29,503 --> 00:14:34,474
这次 操作失败后不会有任何参数

297
00:14:34,474 --> 00:14:36,443
既然您已经设置好协作

298
00:14:36,443 --> 00:14:39,546
您的 App 就已万事俱备
可授予信息接收者

299
00:14:39,546 --> 00:14:42,049
即时访问权限

300
00:14:42,049 --> 00:14:44,818
接下来就由 Lance
为您介绍具体操作方法！

301
00:14:44,818 --> 00:14:47,254
Lance：谢谢 Devin 在这个部分

302
00:14:47,254 --> 00:14:49,690
我将展示如何利用

303
00:14:49,690 --> 00:14:52,125
您上一步存储在服务器上的身份数据

304
00:14:52,125 --> 00:14:56,330
向接收者提供即时访问

305
00:14:56,330 --> 00:14:58,999
SWPersonIdentity 上的
rootHash 属性

306
00:14:58,999 --> 00:15:02,135
通常用来做此验证

307
00:15:02,135 --> 00:15:05,939
rootHash 是唯一用于识别

308
00:15:05,939 --> 00:15:08,942
参与者设备的安全值

309
00:15:08,942 --> 00:15:11,044
为进行验证

310
00:15:11,044 --> 00:15:14,214
您需要了解如何计算根哈希值

311
00:15:14,214 --> 00:15:16,884
我来为您一一解释

312
00:15:16,884 --> 00:15:18,952
发送协作消息时

313
00:15:18,952 --> 00:15:24,591
实际上是单独发送到每个人的设备

314
00:15:24,591 --> 00:15:26,493
Messages 利用加密公钥

315
00:15:26,493 --> 00:15:29,563
识别每个设备

316
00:15:29,563 --> 00:15:31,465
由于只允许

317
00:15:31,465 --> 00:15:35,135
在这组设备上进行访问 才会从

318
00:15:35,135 --> 00:15:39,973
每个接收者注册的
一组公钥中得到根哈希值

319
00:15:39,973 --> 00:15:42,576
根哈希值是一个数据结构的根节点

320
00:15:42,576 --> 00:15:45,078
该结构叫做梅克尔树

321
00:15:45,078 --> 00:15:47,581
梅克尔树是一棵二叉树

322
00:15:47,581 --> 00:15:51,785
通过执行一系列散列操作建造而成

323
00:15:51,785 --> 00:15:54,621
为了根据用户公钥推导出其身份

324
00:15:54,621 --> 00:15:59,459
这些公钥就被视为梅克尔树的叶子

325
00:15:59,459 --> 00:16:02,629
梅克尔树中使用的散列算法确保

326
00:16:02,629 --> 00:16:07,901
根节点只能从这组公钥中计算出来

327
00:16:07,901 --> 00:16:11,839
本示例中 该用户有三台设备

328
00:16:11,839 --> 00:16:15,175
三个公钥

329
00:16:15,175 --> 00:16:18,278
对您的 App 所提供的
每个协作标识符来说

330
00:16:18,278 --> 00:16:19,847
以上公钥都是唯一的

331
00:16:19,847 --> 00:16:24,318
用的都是一个称为密钥多样化的程序

332
00:16:24,318 --> 00:16:28,055
为了防止追踪用户注册的设备数量

333
00:16:28,055 --> 00:16:31,959
这组公钥用随机密钥填充至一定大小

334
00:16:31,959 --> 00:16:34,628
梅克尔树的叶节点由散列

335
00:16:34,628 --> 00:16:38,432
填充的一组多样化密钥集合创建

336
00:16:38,432 --> 00:16:41,969
SHA256 算法用于该树的

337
00:16:41,969 --> 00:16:44,171
散列操作

338
00:16:44,171 --> 00:16:47,407
然后 将每对叶节点连接起来

339
00:16:47,407 --> 00:16:51,945
散列运算得出其父节点

340
00:16:51,945 --> 00:16:56,049
在父节点上重复此过程

341
00:16:56,049 --> 00:17:00,654
并再次重复至仅剩一个根节点

342
00:17:00,654 --> 00:17:03,790
这个根哈希值仅用于表示

343
00:17:03,790 --> 00:17:09,897
该接收者在其设备上的身份

344
00:17:09,897 --> 00:17:12,566
请注意 根哈希值可用

345
00:17:12,566 --> 00:17:17,204
一棵完整梅克尔树
上的节点子集合生成

346
00:17:17,204 --> 00:17:20,741
这棵树中的根哈希值只需用

347
00:17:20,741 --> 00:17:25,145
哈希值 H4 7 和 11

348
00:17:25,145 --> 00:17:29,316
以及多样化的公钥 P3 即可再现

349
00:17:29,316 --> 00:17:35,689
首先 对公钥进行散列运算
得到缺失的叶节点 H3

350
00:17:35,689 --> 00:17:39,893
使用 H3 和 H4 生成 H8

351
00:17:39,893 --> 00:17:44,698
使用给定的
H7 节点和 H8 生成 H10

352
00:17:44,698 --> 00:17:49,970
最后 H10
和 H11 生成根哈希值

353
00:17:49,970 --> 00:17:53,207
需要注意的是
无需重建整棵梅克尔树

354
00:17:53,207 --> 00:17:55,776
您就可证明公钥 P3 可用于生成

355
00:17:55,776 --> 00:17:59,646
给定的根哈希值

356
00:17:59,646 --> 00:18:01,782
执行此操作所需的节点子集称为

357
00:18:01,782 --> 00:18:05,352
proof of inclusion

358
00:18:05,352 --> 00:18:08,255
您的 App 打开通用链接后

359
00:18:08,255 --> 00:18:10,490
验证就开始了

360
00:18:10,490 --> 00:18:12,092
为此 您首先需要检查

361
00:18:12,092 --> 00:18:15,028
该链接为可协作状态

362
00:18:15,028 --> 00:18:18,498
SWCollaborationHighlight
表示协作链接

363
00:18:18,498 --> 00:18:22,503
可在 SWHighlightCenter 中检索

364
00:18:22,503 --> 00:18:24,071
使用该链接

365
00:18:24,071 --> 00:18:28,742
生成 proof of inclusion

366
00:18:28,742 --> 00:18:31,311
为了表示 proof of inclusion

367
00:18:31,311 --> 00:18:35,349
可使用一个名为
SWPersonIdentityProof 的类

368
00:18:35,349 --> 00:18:37,551
为执行验证 您首先要生成

369
00:18:37,551 --> 00:18:40,554
该对象以及加密签名

370
00:18:40,554 --> 00:18:43,090
发送到您的服务器

371
00:18:43,090 --> 00:18:46,326
使用 getSignedIdentityProof 方法

372
00:18:46,326 --> 00:18:48,862
在 SWHighlightCenter 上检索证明

373
00:18:48,862 --> 00:18:51,732
这需要一个
SWCollaborationHighlight

374
00:18:51,732 --> 00:18:57,404
以及一些要由设备签名的任意数据

375
00:18:57,404 --> 00:19:00,841
使用签名确保请求无法被

376
00:19:00,841 --> 00:19:05,913
不良行为者重现以访问您的协作

377
00:19:05,913 --> 00:19:09,149
数据可能是您从服务器上请求的挑战

378
00:19:09,149 --> 00:19:13,187
或设备上生成的随机数值

379
00:19:13,187 --> 00:19:16,557
此示例使用挑战方法讲解

380
00:19:16,557 --> 00:19:19,459
URL 传递给您 App 上的

381
00:19:19,459 --> 00:19:22,196
UIApplicationDelegate 方法

382
00:19:22,196 --> 00:19:24,064
该 URL 是与协作有关的

383
00:19:24,064 --> 00:19:28,235
通用链接

384
00:19:28,235 --> 00:19:31,004
该 URL 用于从

385
00:19:31,004 --> 00:19:36,910
SWHighlightCenter
获取相关 SWCollaborationHighlight

386
00:19:36,910 --> 00:19:39,913
接下来 我将向我的服务器请求挑战

387
00:19:39,913 --> 00:19:41,915
并将我得到的数据

388
00:19:41,915 --> 00:19:46,720
和高亮部分一起传递给
SWHighlightCenter 上的

389
00:19:46,720 --> 00:19:50,190
getSignedIdentityProof 方法

390
00:19:50,190 --> 00:19:53,627
此方法会返回签名后的身份证明

391
00:19:53,627 --> 00:19:55,429
稍后我将与您讨论服务器

392
00:19:55,429 --> 00:19:58,532
验证该数据的操作

393
00:19:58,532 --> 00:20:03,036
现在我可以将签名后的证明
发送到我的服务器进行验证

394
00:20:03,036 --> 00:20:09,176
最后 我用该结果更新用户界面

395
00:20:09,176 --> 00:20:11,545
App 将证明连同公钥和

396
00:20:11,545 --> 00:20:16,717
签名数据发送到服务器

397
00:20:16,717 --> 00:20:18,519
该数据使用
P-256 椭圆曲线上的

398
00:20:18,519 --> 00:20:23,056
椭圆曲线数字签名算法进行签名

399
00:20:23,056 --> 00:20:27,294
用 SHA256 作为哈希函数

400
00:20:27,294 --> 00:20:29,496
用身份证明中的公钥

401
00:20:29,496 --> 00:20:32,933
验证数据上的签名

402
00:20:32,933 --> 00:20:35,035
您可用最常用的加密库

403
00:20:35,035 --> 00:20:38,572
做到这一点

404
00:20:38,572 --> 00:20:40,574
验证签名后

405
00:20:40,574 --> 00:20:43,410
您可信任该身份证明是由

406
00:20:43,410 --> 00:20:46,980
与该公钥相关的设备发送

407
00:20:46,980 --> 00:20:52,252
接下来 您可使用
身份证明重新计算根哈希值

408
00:20:52,252 --> 00:20:55,322
用我们之前看过的梅克尔树为例

409
00:20:55,322 --> 00:20:59,826
可了解 SWPersonIdentityProof
中包含的内容

410
00:20:59,826 --> 00:21:04,031
我们来用它来
重建梅克尔树的根哈希值

411
00:21:04,031 --> 00:21:06,934
公钥是 P3

412
00:21:06,934 --> 00:21:12,005
包含哈希值 H4 7 和 11

413
00:21:12,005 --> 00:21:15,008
本地密钥索引为 2 表示

414
00:21:15,008 --> 00:21:19,112
树中公钥的位置

415
00:21:19,112 --> 00:21:21,582
以下示例展示了从证明上的属性

416
00:21:21,582 --> 00:21:26,286
重构一个根哈希值的方式

417
00:21:26,286 --> 00:21:28,322
递归算法在处理树数据结构时

418
00:21:28,322 --> 00:21:32,759
效果很好 因此我在这里使用此算法

419
00:21:32,759 --> 00:21:37,831
初次调用时 传入公钥的哈希值

420
00:21:37,831 --> 00:21:44,538
包含哈希集和和公钥索引

421
00:21:44,538 --> 00:21:49,009
接下来 第一个包含哈希被导出

422
00:21:49,009 --> 00:21:51,712
检查公钥索引以查看密钥是否

423
00:21:51,712 --> 00:21:56,483
位于其他密钥的左侧或右侧

424
00:21:56,483 --> 00:21:58,785
选定的哈希值按正确的顺序

425
00:21:58,785 --> 00:22:03,090
连接起来 然后进行散列

426
00:22:03,090 --> 00:22:06,527
接下来 inclusionHashes
数组中的消费节点

427
00:22:06,527 --> 00:22:09,029
被移除 其余的被传递给

428
00:22:09,029 --> 00:22:14,134
同一函数的递归调用

429
00:22:14,134 --> 00:22:16,236
公钥索引也一起更新

430
00:22:16,236 --> 00:22:20,807
以便为树中的下一个节点做好准备

431
00:22:20,807 --> 00:22:23,410
通过这个简单的函数
您可以快速计算

432
00:22:23,410 --> 00:22:28,549
给定身份证明的根哈希值

433
00:22:28,549 --> 00:22:31,185
服务器现在可以
检查这个生成的根哈希值

434
00:22:31,185 --> 00:22:33,987
是否位于发送时上传的文档所有者的

435
00:22:33,987 --> 00:22:36,390
根哈希列表中

436
00:22:36,390 --> 00:22:38,926
哈希值存在于已知哈希列表中

437
00:22:38,926 --> 00:22:42,563
因此服务器
可以授予对文档的访问权限

438
00:22:42,563 --> 00:22:46,266
现在您可放心授予
对文档的访问权限！

439
00:22:46,266 --> 00:22:49,736
回顾一下您验证身份所需的步骤

440
00:22:49,736 --> 00:22:51,972
首先 在处理其通用链接时

441
00:22:51,972 --> 00:22:55,442
为您的内容查找协作高亮部分

442
00:22:55,442 --> 00:22:59,746
其次 签署某些数据
并检索 proof of inclusion

443
00:22:59,746 --> 00:23:04,017
将签名后的数据和
证明发送到您的服务器

444
00:23:04,017 --> 00:23:07,588
验证数据上的签名

445
00:23:07,588 --> 00:23:11,525
使用 proof of inclusion
生成根哈希值

446
00:23:11,525 --> 00:23:14,862
最后 将根哈希值和与该内容相关的

447
00:23:14,862 --> 00:23:19,833
已知身份列表进行比较

448
00:23:19,833 --> 00:23:22,135
现在您已经了解了
有关验证您的协作链接

449
00:23:22,135 --> 00:23:24,505
访问权限的所有信息
我再来介绍一下

450
00:23:24,505 --> 00:23:28,308
如何使用 Messages
协调参与者更改

451
00:23:28,308 --> 00:23:31,144
当 Messages 组中的
参与者发生变化

452
00:23:31,144 --> 00:23:33,747
且该组处于协作状态时

453
00:23:33,747 --> 00:23:37,284
用户可以选择将更改传至您的 App

454
00:23:37,284 --> 00:23:40,354
就传在消息线程中的横幅上

455
00:23:40,354 --> 00:23:42,856
在此情况下
您的 App 会收到另一个

456
00:23:42,856 --> 00:23:46,193
SWUpdateCollaborationParticipantsAction

457
00:23:46,193 --> 00:23:50,564
其中包含添加和移除了的身份

458
00:23:50,564 --> 00:23:53,567
您将使用在设置
协作时编写的相同代码

459
00:23:53,567 --> 00:23:55,435
来处理此操作

460
00:23:55,435 --> 00:24:00,040
但您还需要处理被移除的参与者

461
00:24:00,040 --> 00:24:02,743
关于移除操作
只需查找与被移除身份

462
00:24:02,743 --> 00:24:06,947
相关的任何账户 撤销其访问权限

463
00:24:06,947 --> 00:24:09,249
如果还没有关联帐户

464
00:24:09,249 --> 00:24:12,886
只需从数据库中删除根哈希值

465
00:24:12,886 --> 00:24:14,188
这就是实现

466
00:24:14,188 --> 00:24:19,226
Devin 之前
提到的更新参与者的操作

467
00:24:19,226 --> 00:24:20,394
这个例子使用

468
00:24:20,394 --> 00:24:24,965
操作上的移除身份属性

469
00:24:24,965 --> 00:24:28,836
并将其传递给
类似的删除 API 请求

470
00:24:28,836 --> 00:24:33,073
请注意 此代码仅处理已移除的身份

471
00:24:33,073 --> 00:24:34,908
但一个完整的操作应该可以处理

472
00:24:34,908 --> 00:24:38,579
已添加和已移除的身份

473
00:24:38,579 --> 00:24:42,482
以上就是您处理
参与者更改时所需的全部操作！

474
00:24:42,482 --> 00:24:45,819
最后 当对协作进行更改时

475
00:24:45,819 --> 00:24:48,322
您的 App 会
发布有关这些更改的通知

476
00:24:48,322 --> 00:24:50,924
直接显示在 Messages 中

477
00:24:50,924 --> 00:24:53,126
接下来这部分我会为大家介绍

478
00:24:53,126 --> 00:24:55,295
几种通知支持的类型

479
00:24:55,295 --> 00:24:57,130
通知在共享链接的

480
00:24:57,130 --> 00:25:01,134
对话中显示为横幅

481
00:25:01,134 --> 00:25:03,937
横幅包括对更改内容的描述

482
00:25:03,937 --> 00:25:07,574
以及变更人信息

483
00:25:07,574 --> 00:25:09,810
在这个对话中
Charlie 对“烘焙食谱”文档

484
00:25:09,810 --> 00:25:12,779
进行了编辑

485
00:25:12,779 --> 00:25:14,581
点击显示按钮可直接将其

486
00:25:14,581 --> 00:25:17,518
与内容联系起来

487
00:25:17,518 --> 00:25:19,887
为了表示通知
SharedWithYou 框架

488
00:25:19,887 --> 00:25:24,424
有一个名为
SWHighlightEvent 的协议

489
00:25:24,424 --> 00:25:27,227
使用从 SWHighlightCenter API 检索的

490
00:25:27,227 --> 00:25:31,732
SWHighlights 初始化高亮事件

491
00:25:31,732 --> 00:25:36,203
Messages 可支持以下几类事件

492
00:25:36,203 --> 00:25:40,240
内容更新或评论的更改事件

493
00:25:40,240 --> 00:25:44,244
参与者加入或离开时的成员关系事件

494
00:25:44,244 --> 00:25:49,449
在协作中提及用户时的提及事件

495
00:25:49,449 --> 00:25:54,021
以及内容被移动
或删除时的持久性事件

496
00:25:54,021 --> 00:25:56,657
以下示例展示如何对协作编辑

497
00:25:56,657 --> 00:25:59,760
发布更改事件

498
00:25:59,760 --> 00:26:02,162
使用高亮中心 API

499
00:26:02,162 --> 00:26:03,931
为目标标识符

500
00:26:03,931 --> 00:26:06,099
检索协作高亮部分

501
00:26:06,099 --> 00:26:09,770
请记住 此标识符是您在

502
00:26:09,770 --> 00:26:13,173
协作启动期间定义的
因此您的 App 应该有此标识符

503
00:26:13,173 --> 00:26:17,110
以便在进行内容更改时使用

504
00:26:17,110 --> 00:26:21,748
接下来 创建一个高亮更改事件实例

505
00:26:21,748 --> 00:26:23,750
初始化器有高亮

506
00:26:23,750 --> 00:26:25,953
和一个触发器枚举值

507
00:26:25,953 --> 00:26:30,123
在本例中 将其设置为编辑类型

508
00:26:30,123 --> 00:26:32,860
最后 再次使用高亮中心

509
00:26:32,860 --> 00:26:36,196
发布该事件的通知

510
00:26:36,196 --> 00:26:39,299
类似地 对于会员资格变更

511
00:26:39,299 --> 00:26:41,101
会发布会员资格事件

512
00:26:41,101 --> 00:26:44,204
这次是传递 addedCollaborator

513
00:26:44,204 --> 00:26:49,176
或 removedCollaborator
触发器类型

514
00:26:49,176 --> 00:26:52,346
接下来
如果您的 App 支持用户提及

515
00:26:52,346 --> 00:26:55,182
您可以发布提及事件

516
00:26:55,182 --> 00:26:56,817
利用被提及用户的

517
00:26:56,817 --> 00:27:00,087
根哈希值初始化个人身份

518
00:27:00,087 --> 00:27:02,623
请您回顾一下 您在验证访问权限时

519
00:27:02,623 --> 00:27:07,761
用您 App 中的用户帐户
关联了一个人的身份

520
00:27:07,761 --> 00:27:11,431
然后 以同样的方式发布提及事件

521
00:27:11,431 --> 00:27:15,636
这次是将被提及身份作为参数传递

522
00:27:15,636 --> 00:27:17,804
此通知在 Messages 中

523
00:27:17,804 --> 00:27:21,842
仅显示给被提及用户

524
00:27:21,842 --> 00:27:24,545
最后 当内容被移动 重命名

525
00:27:24,545 --> 00:27:29,750
或删除时 使用持久性事件类型

526
00:27:29,750 --> 00:27:32,119
在此 以重命名触发器类型为例

527
00:27:32,119 --> 00:27:37,791
表示用户更改了内容的名称

528
00:27:37,791 --> 00:27:41,161
这就是您的 App
能通知协作者的方式

529
00:27:41,161 --> 00:27:46,233
以上都将在 Messages 中得到更新

530
00:27:46,233 --> 00:27:48,101
Devin：这样一来 您就可以

531
00:27:48,101 --> 00:27:50,671
通过以下几个步骤将您 App 的

532
00:27:50,671 --> 00:27:52,773
协作体验与消息结合起来

533
00:27:52,773 --> 00:27:55,676
即设置要协作共享的内容

534
00:27:55,676 --> 00:27:58,645
以加密方式验证参与者的访问权限

535
00:27:58,645 --> 00:28:00,781
追踪参与者变化

536
00:28:00,781 --> 00:28:03,784
并在 Messages 中
发布通知将您的用户

537
00:28:03,784 --> 00:28:06,553
与内容联系起来

538
00:28:06,553 --> 00:28:07,955
请务必观看

539
00:28:07,955 --> 00:28:11,258
“使用 Messages 增强协作体验”的视频

540
00:28:11,258 --> 00:28:13,193
了解您可为协作显示的

541
00:28:13,193 --> 00:28:15,996
新 UI 元素

542
00:28:15,996 --> 00:28:18,298
Lance：我们迫不及待地
想与您的 App 开始协作了！

543
00:28:18,298 --> 00:28:20,968
Devin 和 Lance
您的加密签名协作伙伴

544
00:28:20,968 --> 00:28:22,336
Devin：感谢收看！

545
00:28:22,336 --> 00:28:25,939
♪

