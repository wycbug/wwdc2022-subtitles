1
00:00:00,334 --> 00:00:07,341
♪ ♪

2
00:00:09,309 --> 00:00:11,545
Yi Liu: 大家好 我是 Yi

3
00:00:11,578 --> 00:00:13,814
大家好 我是 Dominik

4
00:00:13,847 --> 00:00:16,283
我们是 GPU 软件工程师

5
00:00:16,316 --> 00:00:20,287
Yi: 今天 Dominik 和我
将和大家讨论今年我们在

6
00:00:20,320 --> 00:00:23,690
Metal Ray Tracing API 中
增加的性能增强和功能

7
00:00:23,724 --> 00:00:27,060
以帮助您最大限度地提高
光线追踪 App 的性能

8
00:00:27,094 --> 00:00:30,731
光线追踪 App 可以模拟
在场景间反射的

9
00:00:30,764 --> 00:00:33,000
单个光线

10
00:00:33,033 --> 00:00:36,570
这被用于游戏和离线渲染的场景中

11
00:00:36,603 --> 00:00:41,975
以产生逼真的反射 阴影
全局光照等效果

12
00:00:42,009 --> 00:00:44,545
这需要模拟大量光线

13
00:00:44,578 --> 00:00:47,814
因此性能对于这些 App 至关重要

14
00:00:47,848 --> 00:00:51,585
幸运的是 Metal 内置了针对所有

15
00:00:51,618 --> 00:00:54,388
Apple 设备优化的光线追踪支持

16
00:00:54,421 --> 00:00:57,357
让我们简要回顾下光线追踪
在 Metal 中的工作原理

17
00:00:57,391 --> 00:01:01,662
Metal 光线追踪 API 可用于
如计算或片元函数等

18
00:01:01,695 --> 00:01:05,265
着色器函数

19
00:01:05,299 --> 00:01:09,503
我们首先产生一些光线
将它们发射到场景中

20
00:01:09,536 --> 00:01:13,473
接下来 我们创建一个相交处理对象
并用它来检查

21
00:01:13,507 --> 00:01:18,011
我们的光线和场景中的
几何形体之间的交点

22
00:01:18,045 --> 00:01:21,114
稍后 我将介绍今年

23
00:01:21,148 --> 00:01:24,418
为加快相交搜索而添加的一些新功能

24
00:01:24,451 --> 00:01:26,920
此过程依赖于一种特殊的数据结构

25
00:01:26,954 --> 00:01:29,056
它叫做加速结构

26
00:01:29,089 --> 00:01:32,292
它也表示场景中的几何形体

27
00:01:32,326 --> 00:01:36,129
今天我还将谈谈几个关于加速结构的

28
00:01:36,163 --> 00:01:38,732
新功能和性能改进

29
00:01:38,765 --> 00:01:41,835
相交处理返回一个交点结果对象

30
00:01:41,869 --> 00:01:45,038
描述每条光线所命中的图元

31
00:01:45,072 --> 00:01:50,711
交点结果用于产生
写入输出图像的颜色

32
00:01:50,744 --> 00:01:53,514
它也可以用来产生额外的光线

33
00:01:53,547 --> 00:01:55,749
这些光线会再次经过这个过程

34
00:01:55,782 --> 00:01:58,485
我们可以多次重复这个过程

35
00:01:58,519 --> 00:02:01,054
只要我们想模拟
光线在场景中反射的效果

36
00:02:01,088 --> 00:02:05,392
如果您想了解更多有关
Metal 光线追踪 API 的基础知识

37
00:02:05,425 --> 00:02:09,796
我建议您看看我们之前的 WWDC 讲座

38
00:02:09,830 --> 00:02:14,334
我们首先在 WWDC20 上引入了
Metal 光线追踪 API

39
00:02:14,368 --> 00:02:19,139
去年 我们引入了
包括支持运动模糊在内的新功能

40
00:02:19,173 --> 00:02:22,576
今天我们要讨论三件事

41
00:02:22,609 --> 00:02:26,680
首先 我将介绍一些新功能

42
00:02:26,713 --> 00:02:29,082
这些功能有助于提高您的 App 中
光线追踪的性能

43
00:02:30,817 --> 00:02:33,954
接下来 我将介绍我们添加到

44
00:02:33,987 --> 00:02:36,323
加速结构 API 中的改进和功能

45
00:02:38,258 --> 00:02:40,994
最后 Dominik 将介绍用于光线追踪的

46
00:02:41,028 --> 00:02:43,897
GPU 工具的改进

47
00:02:43,931 --> 00:02:46,266
今年 我们添加了三个新功能

48
00:02:46,300 --> 00:02:48,802
旨在提高光线追踪性能

49
00:02:48,836 --> 00:02:51,004
或者简化您的代码

50
00:02:51,038 --> 00:02:54,708
它们分别是逐图元数据
从相交函数表中

51
00:02:54,741 --> 00:02:56,844
获取缓冲区的能力

52
00:02:56,877 --> 00:02:59,980
以及间接指令缓冲区对
光线追踪的支持

53
00:03:01,949 --> 00:03:04,484
我们先说说逐图元数据

54
00:03:04,518 --> 00:03:08,956
App 通常具有与其场景中的
图元相关联的数据

55
00:03:08,989 --> 00:03:12,559
例如顶点颜色 法线和纹理坐标

56
00:03:13,894 --> 00:03:16,296
今年 我们添加了在加速结构中

57
00:03:16,330 --> 00:03:21,235
直接为每个图元
存储少量数据的功能

58
00:03:21,268 --> 00:03:25,305
访问这些数据时可以更少使用
内存间接寻址和碰到缓存缺失

59
00:03:25,339 --> 00:03:27,374
从而提高性能

60
00:03:27,407 --> 00:03:31,645
这也减少了存储复杂的
辅助数据结构的需要

61
00:03:31,678 --> 00:03:35,883
这些数据结构通常是查找
与图元相关的数据所必需的

62
00:03:37,184 --> 00:03:38,785
我们来看一个例子

63
00:03:39,853 --> 00:03:42,823
Alpha 测试是一种用于在不增加

64
00:03:42,856 --> 00:03:47,127
三角形计数的情况下
增加透明几何形体复杂性的技术

65
00:03:47,160 --> 00:03:51,064
在这种技术中 映射到三角形上的
纹理的 alpha 通道

66
00:03:51,098 --> 00:03:55,435
用于确定光线是应该
击中三角形还是继续发射

67
00:03:56,670 --> 00:03:59,573
要实现这一点 就需要配置相交处理

68
00:03:59,606 --> 00:04:03,477
以便在射线击中三角形时
调用自定义相交函数

69
00:04:04,645 --> 00:04:08,982
最终目标是从与三角形关联的
纹理中采样

70
00:04:09,016 --> 00:04:13,187
并测试 alpha 值是否允许
光线继续穿过图元

71
00:04:13,220 --> 00:04:16,757
要达到这个目的 您需要两条信息

72
00:04:16,790 --> 00:04:20,093
纹理对象和 UV 坐标

73
00:04:20,127 --> 00:04:22,829
在 alpha 测试的典型实现中

74
00:04:22,863 --> 00:04:25,832
您需要访问 Metal 设备内存中的

75
00:04:25,866 --> 00:04:29,002
多个中间缓冲区才能获得此信息

76
00:04:30,370 --> 00:04:34,341
首先 将与图元关联的纹理

77
00:04:34,374 --> 00:04:36,410
存储在某种材质结构中

78
00:04:37,878 --> 00:04:41,081
几种材料将被装入缓冲区

79
00:04:41,114 --> 00:04:45,052
存储每个图元的材质结构
是不切实际的

80
00:04:45,085 --> 00:04:48,856
因为它们可能非常大
并且可能有很多图元

81
00:04:48,889 --> 00:04:52,125
相反 您只需要将每个图元的材料 ID

82
00:04:52,159 --> 00:04:56,630
存储在缓冲区中
并使用它们查找材料

83
00:04:56,663 --> 00:05:00,200
接下来 要计算 UV
您就需要从另一个缓冲区加载

84
00:05:00,234 --> 00:05:04,104
每个顶点的 UV 并对其进行插值

85
00:05:04,137 --> 00:05:07,875
最后 假设您使用的是
实例化几何形体

86
00:05:07,908 --> 00:05:12,279
您可能希望每个实例
都有自己的材质和 UV 映射

87
00:05:12,312 --> 00:05:14,848
为支持这一点 您可以将

88
00:05:14,882 --> 00:05:19,119
指向 UV 和材质 ID 缓冲区的指针
存储在实例数据缓冲区中

89
00:05:19,152 --> 00:05:22,556
为函数添加另一个间接级别

90
00:05:22,589 --> 00:05:26,827
这种方法要求您维护一个
相当复杂的缓冲区设置

91
00:05:26,860 --> 00:05:31,798
并涉及许多层的间接关系
以获得您需要的数据

92
00:05:31,832 --> 00:05:33,901
这也可能导致缓存丢失

93
00:05:33,934 --> 00:05:37,371
从而对性能产生负面影响

94
00:05:37,404 --> 00:05:40,908
我们看看实现此图表所需的代码

95
00:05:40,941 --> 00:05:44,278
然后 我将展示如何使用

96
00:05:44,311 --> 00:05:46,180
逐图元数据逐步简化它

97
00:05:46,213 --> 00:05:50,817
这是 alpha 测试相交函数的原始实现

98
00:05:50,851 --> 00:05:54,922
当光线击中经过 alpha 测试的三角形时
该函数就会被调用

99
00:05:54,955 --> 00:05:58,859
该函数从内存加载实例数据开始

100
00:05:58,892 --> 00:06:02,896
这个缓冲区包含指向 UV 的指针
和实例使用的

101
00:06:02,930 --> 00:06:04,464
材料缓冲区

102
00:06:04,498 --> 00:06:07,267
接下来 该函数从 UV 缓冲区

103
00:06:07,301 --> 00:06:10,237
加载 UV 坐标 并对其进行插值

104
00:06:10,270 --> 00:06:12,105
这又是一个内存加载

105
00:06:12,139 --> 00:06:15,976
然后 该函数从另一个缓冲区
加载材质索引

106
00:06:16,009 --> 00:06:18,445
最后 该函数加载材质

107
00:06:18,478 --> 00:06:20,681
并对相应的纹理进行采样

108
00:06:20,714 --> 00:06:24,051
此时 函数得到所需的 alpha 值

109
00:06:24,084 --> 00:06:26,086
可以将其与阈值进行比较

110
00:06:26,119 --> 00:06:29,656
现在 我将展示如何使用逐图元数据

111
00:06:29,690 --> 00:06:33,327
来简化这段代码并提高其性能

112
00:06:33,360 --> 00:06:35,829
您可以直接在加速结构中只存储

113
00:06:35,863 --> 00:06:38,198
相交函数需要的每个逐图元数据

114
00:06:38,232 --> 00:06:41,702
而不是使用复杂的

115
00:06:41,735 --> 00:06:45,405
多层间接缓冲区设置

116
00:06:45,439 --> 00:06:47,941
在此示例中 您可以为每个图元

117
00:06:47,975 --> 00:06:51,645
创建一个包含纹理和 UV 坐标的结构

118
00:06:51,678 --> 00:06:54,815
在构建加速结构时提供该数据

119
00:06:54,848 --> 00:06:57,384
当光线击中图元时

120
00:06:57,417 --> 00:07:00,254
相交函数只接收指向该数据的指针

121
00:07:00,287 --> 00:07:03,190
您可以在逐图元数据中
存储任何需要的内容

122
00:07:03,223 --> 00:07:07,327
但较小的存储量
将有助于获得最佳性能

123
00:07:07,361 --> 00:07:10,597
我将从相交函数的输入开始

124
00:07:10,631 --> 00:07:13,901
可以访问所有这些数据让你在实现时

125
00:07:13,934 --> 00:07:15,869
获得很大的灵活性

126
00:07:15,903 --> 00:07:19,406
但也会增加 GPU 上的
寄存器使用量

127
00:07:19,439 --> 00:07:22,676
有了逐图元数据 而不是整个缓冲区

128
00:07:22,709 --> 00:07:26,146
您只需要访问图元数据指针

129
00:07:26,180 --> 00:07:30,317
这是您直接存储在加速结构中的数据

130
00:07:30,350 --> 00:07:34,354
在这种情况下
每个图元都有自己的纹理对象

131
00:07:34,388 --> 00:07:36,757
和所有顶点的 UV

132
00:07:36,790 --> 00:07:41,461
接下来是对全局材质缓冲区
和实例数据缓冲区的加载

133
00:07:41,495 --> 00:07:43,063
这两个您都不需要

134
00:07:43,096 --> 00:07:47,467
相反 您可以从每个逐图元数据指针
加载一次

135
00:07:47,501 --> 00:07:51,004
这是此函数中唯一需要的
设备内存访问

136
00:07:51,038 --> 00:07:52,606
接下来是 UV

137
00:07:52,639 --> 00:07:56,343
您可以简单地访问嵌入在
逐图元数据结构中的数据

138
00:07:56,376 --> 00:08:01,014
而不是对实例数据
获取的指针解引用

139
00:08:01,048 --> 00:08:04,785
代码中的更改很细微
但对性能很重要

140
00:08:04,818 --> 00:08:07,721
因为不涉及额外的内存加载

141
00:08:07,754 --> 00:08:10,424
最后 还有材料属性

142
00:08:10,457 --> 00:08:13,794
由于所需材质的唯一部分是纹理

143
00:08:13,827 --> 00:08:15,729
因此可以在逐图元数据结构中

144
00:08:15,762 --> 00:08:18,098
直接对图元的纹理进行编码

145
00:08:18,131 --> 00:08:20,767
这意味着您不再需要访问

146
00:08:20,801 --> 00:08:22,936
材料和材料索引缓冲区

147
00:08:22,970 --> 00:08:24,972
您可以直接使用纹理

148
00:08:25,005 --> 00:08:28,442
而无需支付额外的内存解引用成本

149
00:08:28,475 --> 00:08:31,178
这就是使用逐图元数据时

150
00:08:31,211 --> 00:08:33,313
相交代码的简单程度

151
00:08:33,347 --> 00:08:35,916
所有代价高昂的内存访问

152
00:08:35,949 --> 00:08:39,486
都被图元数据指针的一次加载所取代

153
00:08:39,520 --> 00:08:43,524
最重要的是 代码更简单 更易理解

154
00:08:44,224 --> 00:08:47,160
接下来 我将展示如何在加速结构中

155
00:08:47,194 --> 00:08:49,363
存储图元数据

156
00:08:49,396 --> 00:08:53,233
您需要先执行此操作
然后才能通过相交函数访问它

157
00:08:53,267 --> 00:08:55,369
您需要在加速结构

158
00:08:55,402 --> 00:08:57,804
几何形体描述符中设置几个字段

159
00:08:57,838 --> 00:09:01,008
首先 设置存储数据的 Metal 缓冲区

160
00:09:01,041 --> 00:09:05,345
接下来 指定将为每个图元
存储的数据的大小

161
00:09:05,379 --> 00:09:07,814
如果数据没有在缓冲区中紧凑打包

162
00:09:07,848 --> 00:09:10,284
或者没有从缓冲区的开头开始

163
00:09:10,317 --> 00:09:13,287
您还可以指定步进和偏移量

164
00:09:13,320 --> 00:09:17,591
否则 这些默认值为 0
因此不需要设置它们

165
00:09:17,624 --> 00:09:20,527
您已经了解了如何在相交函数中

166
00:09:20,561 --> 00:09:21,828
使用逐图元数据

167
00:09:21,862 --> 00:09:24,398
它只是作为指针传递给函数

168
00:09:24,431 --> 00:09:28,402
但这还不是全部 您可以在
任何需要的地方访问这些数据

169
00:09:28,435 --> 00:09:32,306
这包括由交叉点返回的最终相交结果

170
00:09:32,339 --> 00:09:36,844
如果使用相交查询
候选相交和提交相交的

171
00:09:36,877 --> 00:09:39,746
图元数据也是可用的

172
00:09:39,780 --> 00:09:43,116
这意味着除了相交测试之外

173
00:09:43,150 --> 00:09:45,319
您还可以使用逐图元数据进行着色

174
00:09:45,352 --> 00:09:48,021
通过减少内存访问和间接访问的数量

175
00:09:48,055 --> 00:09:50,657
逐图元数据可以提高

176
00:09:50,691 --> 00:09:54,828
相交代码和着色代码的性能

177
00:09:54,862 --> 00:09:58,265
事实上 我们在自己的
一个测试 App 中发现

178
00:09:58,298 --> 00:10:03,704
使用逐图元数据可以使性能
提高 10% 到 16%

179
00:10:03,737 --> 00:10:05,472
我们期待您的尝试

180
00:10:05,506 --> 00:10:08,008
看看您能在性能和代码质量方面

181
00:10:08,041 --> 00:10:11,712
获得怎样的改进

182
00:10:11,745 --> 00:10:14,748
今年 我们还为 Metal 着色语言

183
00:10:14,781 --> 00:10:18,952
添加了另一个方便的功能
以帮助您简化光线追踪内核

184
00:10:18,986 --> 00:10:22,322
App 通常将同一组绑定

185
00:10:22,356 --> 00:10:26,593
传递给它们的相交函数
和主光线追踪内核

186
00:10:26,627 --> 00:10:29,530
例如 我们的光线追踪示例代码

187
00:10:29,563 --> 00:10:32,065
使用相交函数来渲染球体

188
00:10:32,099 --> 00:10:35,068
此相交函数访问

189
00:10:35,102 --> 00:10:37,471
包含每个球体信息的资源缓冲区

190
00:10:37,504 --> 00:10:40,174
为了将此缓冲区传递给相交函数

191
00:10:40,207 --> 00:10:43,477
App 将缓冲区绑定到相交函数表

192
00:10:43,510 --> 00:10:48,315
然而 主光线追踪内核还需要
访问资源缓冲区

193
00:10:48,348 --> 00:10:50,851
因此 App 也将缓冲区绑定到那里

194
00:10:50,884 --> 00:10:53,554
今年 Metal 着色语言允许访问

195
00:10:53,587 --> 00:10:57,191
绑定到相交函数表的缓冲区

196
00:10:57,224 --> 00:10:59,726
有了这个新功能 您可以省去

197
00:10:59,760 --> 00:11:03,797
为内核绑定缓冲区的操作 从而直接

198
00:11:03,830 --> 00:11:05,699
从相交函数表中访问它

199
00:11:05,732 --> 00:11:08,468
您可以通过调用相交函数表上的

200
00:11:08,502 --> 00:11:11,839
get_buffer 方法
并提供其指针类型来实现这一点

201
00:11:11,872 --> 00:11:15,642
您还可以通过函数类型
来访问可见的函数表

202
00:11:15,676 --> 00:11:20,180
间接指令缓冲区允许您在 GPU 上
独立地对 GPU 进行编码

203
00:11:20,214 --> 00:11:24,618
代表着 GPU 驱动管线的
基本元素

204
00:11:24,651 --> 00:11:26,653
要想了解间接指令缓冲区

205
00:11:26,687 --> 00:11:29,756
和 GPU 驱动渲染的更多信息
建议您观看

206
00:11:29,790 --> 00:11:33,894
WWDC 2019 的讲座
“Modern rendering with Metal”

207
00:11:33,927 --> 00:11:37,464
在间接指令缓冲区中
启用光线追踪支持很容易

208
00:11:37,497 --> 00:11:40,601
您所要做的就是在描述符上

209
00:11:40,634 --> 00:11:42,069
设置 supportRayTracing 标志

210
00:11:42,102 --> 00:11:46,139
间接指令缓冲区发送图形和计算函数

211
00:11:46,173 --> 00:11:50,344
因此您可以像往常一样
轻松地从这些函数使用光线追踪

212
00:11:50,377 --> 00:11:53,881
这是我们今年添加的
所有新功能的概要

213
00:11:53,914 --> 00:11:58,218
用来帮助您在 App 中
获得更好的光线追踪性能

214
00:11:58,252 --> 00:12:01,755
接下来 我们来谈谈加速结构

215
00:12:01,788 --> 00:12:04,424
我们已经实现了几项性能改进

216
00:12:04,458 --> 00:12:08,228
并增加了专注于构建加速结构的功能

217
00:12:08,262 --> 00:12:10,631
让我们回顾一下它们的用途

218
00:12:10,664 --> 00:12:13,033
加速结构是加速

219
00:12:13,066 --> 00:12:15,802
光线追踪过程的数据结构

220
00:12:15,836 --> 00:12:18,805
它们通过递归划分空间来实现这一点

221
00:12:18,839 --> 00:12:23,343
这样我们可以快速找到哪些三角形
可能与光线相交

222
00:12:23,377 --> 00:12:25,412
为了支持构建复杂场景

223
00:12:25,445 --> 00:12:28,549
Metal 支持两种类型的加速结构

224
00:12:28,582 --> 00:12:31,518
基本加速结构和实例加速结构

225
00:12:31,552 --> 00:12:34,221
单个的几何图形使用

226
00:12:34,254 --> 00:12:36,690
基本加速结构来表示

227
00:12:36,723 --> 00:12:40,194
它们可以是一些简单的形状
比如平面或者立方体

228
00:12:40,227 --> 00:12:44,398
也可以是一些更复杂的形状
比如球体或者三角网格

229
00:12:44,431 --> 00:12:48,635
您可以使用实例加速结构
来创建更复杂的场景

230
00:12:48,669 --> 00:12:51,338
实例加速结构创建

231
00:12:51,371 --> 00:12:53,140
基本加速结构的副本

232
00:12:53,173 --> 00:12:58,078
首先 为场景中的每个对象
定义变换矩阵

233
00:12:58,111 --> 00:13:01,014
然后 使用变换矩阵数组

234
00:13:01,048 --> 00:13:02,916
和基本加速结构

235
00:13:02,950 --> 00:13:05,619
构建实例加速结构

236
00:13:05,652 --> 00:13:09,823
这就是如何使用加速结构
来构建静态场景的方法

237
00:13:09,857 --> 00:13:12,659
接下来 让我们看看
像游戏这样的动态 App

238
00:13:12,693 --> 00:13:15,128
将如何使用加速结构

239
00:13:16,196 --> 00:13:18,131
我们从头开始

240
00:13:18,165 --> 00:13:19,933
在第一次启动游戏

241
00:13:19,967 --> 00:13:22,970
或加载新关卡时
您需要完成几个任务

242
00:13:23,003 --> 00:13:27,674
这包括加载模型和纹理等常规任务

243
00:13:27,708 --> 00:13:31,612
使用光线追踪 还需要为将要使用的

244
00:13:31,645 --> 00:13:34,515
所有模型构建基本加速结构

245
00:13:34,548 --> 00:13:37,951
我们建议您在加载时
构建尽可能多的

246
00:13:37,985 --> 00:13:42,189
基本加速结构
以节省主渲染循环的时间

247
00:13:42,222 --> 00:13:44,391
您可以根据需要使用实例加速结构

248
00:13:44,424 --> 00:13:48,529
在场景中添加或移除这些对象

249
00:13:48,562 --> 00:13:51,765
一旦您的 App 完成加载
就会进入主循环

250
00:13:51,798 --> 00:13:54,868
每一帧 它都使用光栅化

251
00:13:54,902 --> 00:13:58,438
光线追踪和后期处理的组合
来渲染场景

252
00:13:58,472 --> 00:14:01,041
然而 由于游戏是动态的

253
00:14:01,074 --> 00:14:05,045
您可能需要更新一些加速结构

254
00:14:05,078 --> 00:14:08,348
这通常包括修整一些形变

255
00:14:08,382 --> 00:14:11,518
或动画模型 如为角色蒙皮

256
00:14:11,552 --> 00:14:14,688
修整现有的加速结构比完全重建

257
00:14:14,721 --> 00:14:18,859
要快得多
所以我们建议在这种情况下使用它

258
00:14:18,892 --> 00:14:22,563
您还应该对实例加速结构
进行完全重建

259
00:14:22,596 --> 00:14:26,500
这是必要的 因为自上一帧以来

260
00:14:26,533 --> 00:14:30,504
对象可能已从场景中添加或移除
或者它们可能已显著移动

261
00:14:30,537 --> 00:14:33,974
在这种情况下
完全重新构建是可行的

262
00:14:34,007 --> 00:14:35,576
因为只有一个实例加速结构

263
00:14:35,609 --> 00:14:39,246
而且通常只包含几千个对象

264
00:14:39,279 --> 00:14:43,483
今年 我们改进了
所有这些场景的性能

265
00:14:43,517 --> 00:14:46,253
首先 Apple 芯片上的加速结构

266
00:14:46,286 --> 00:14:49,957
构建速度现在提高了 2.3 倍

267
00:14:49,990 --> 00:14:53,427
其次 修整速度也快了 38%

268
00:14:54,428 --> 00:14:58,832
这意味着加载时间
和每帧开销都减少了

269
00:14:58,866 --> 00:15:00,534
但还有更好的

270
00:15:00,567 --> 00:15:03,370
一些 App 可以构建数百
甚至数千个

271
00:15:03,403 --> 00:15:05,606
小型基本加速结构

272
00:15:05,639 --> 00:15:08,475
这些小的构建
单独没有足够多的工作

273
00:15:08,509 --> 00:15:13,547
来填充 GPU
会导致 GPU 利用率长期处于低水平

274
00:15:13,580 --> 00:15:16,450
因此 现在只要有可能

275
00:15:16,483 --> 00:15:19,520
在 Apple 芯片上就会自动
并行执行多个构建

276
00:15:19,553 --> 00:15:22,322
并行运行使得构建速度

277
00:15:22,356 --> 00:15:24,224
提高了 2.8 倍

278
00:15:24,258 --> 00:15:26,426
这进一步减少了加载时间

279
00:15:26,460 --> 00:15:28,395
这不仅仅适用于构建

280
00:15:28,428 --> 00:15:31,365
它适用于所有加速结构操作

281
00:15:31,398 --> 00:15:34,134
包括压缩和修整

282
00:15:34,168 --> 00:15:37,504
因此您的每帧开销也会减少

283
00:15:37,538 --> 00:15:39,840
您需要遵循一些指导原则

284
00:15:39,873 --> 00:15:43,043
以确保您能够从这种优化中受益

285
00:15:43,076 --> 00:15:46,780
下面是一个构建加速结构数组的例子

286
00:15:46,813 --> 00:15:49,850
要并行执行构建 您需要确保在

287
00:15:49,883 --> 00:15:53,387
多个构建操作中使用
相同的加速结构指令编码器

288
00:15:53,420 --> 00:15:58,492
此外 使用相同临时缓冲区
的构建不能并行运行

289
00:15:58,525 --> 00:16:02,396
因此 您需要确保依次通过
一个小的临时缓冲区池

290
00:16:02,429 --> 00:16:06,033
而不是为每个构建
使用相同的临时缓冲区

291
00:16:07,234 --> 00:16:09,369
这些都是我们为构建

292
00:16:09,403 --> 00:16:12,606
加速结构所做的性能改进

293
00:16:12,639 --> 00:16:14,675
我们还增加了三个新功能

294
00:16:14,708 --> 00:16:18,212
使构建加速结构更加容易和有效

295
00:16:19,546 --> 00:16:24,284
它们支持额外的顶点格式 变换矩阵

296
00:16:24,318 --> 00:16:26,954
和在堆上分配的加速结构

297
00:16:29,089 --> 00:16:32,326
我们从顶点格式开始

298
00:16:32,359 --> 00:16:35,596
常见的性能优化是对顶点数据

299
00:16:35,629 --> 00:16:39,166
使用量化或降低精度的格式

300
00:16:39,199 --> 00:16:41,468
从而降低内存使用

301
00:16:41,502 --> 00:16:44,137
今年 您可以从各种

302
00:16:44,171 --> 00:16:46,607
顶点格式构建加速结构

303
00:16:46,640 --> 00:16:50,577
这包括半精度浮点格式

304
00:16:50,611 --> 00:16:53,981
平面几何图形的两分量顶点格式

305
00:16:54,014 --> 00:16:57,584
以及所有常见的规格化整数格式

306
00:16:57,618 --> 00:17:00,687
以前 加速度结构需要

307
00:17:00,721 --> 00:17:04,191
三分量 全精度浮点顶点数据

308
00:17:04,224 --> 00:17:07,427
在本例中 App 具有

309
00:17:07,461 --> 00:17:10,097
半精度顶点格式的顶点数据

310
00:17:10,130 --> 00:17:14,067
为了构建加速结构
需要将这些数据解包

311
00:17:14,101 --> 00:17:16,537
并复制到临时缓冲区中

312
00:17:16,570 --> 00:17:18,605
有了新的顶点格式功能

313
00:17:18,639 --> 00:17:21,808
加速结构构建现在可以使用

314
00:17:21,842 --> 00:17:24,111
任何受支持的格式的顶点数据

315
00:17:24,144 --> 00:17:27,281
而不需要创建临时副本

316
00:17:27,314 --> 00:17:29,850
设置顶点格式再简单不过了

317
00:17:29,883 --> 00:17:34,121
您所需要做的就是
设置几何描述符上的属性

318
00:17:34,154 --> 00:17:37,357
接下来 我们来谈谈变换矩阵

319
00:17:37,391 --> 00:17:40,227
此功能是对新顶点格式的补充

320
00:17:40,260 --> 00:17:42,629
因此您可以在构建加速结构之前

321
00:17:42,663 --> 00:17:45,199
对顶点数据进行预变换

322
00:17:45,232 --> 00:17:47,701
例如 您可能希望使用它们来

323
00:17:47,734 --> 00:17:51,505
解包以规格化格式存储的复杂网格

324
00:17:51,538 --> 00:17:54,808
让我们来看看这个场景中的
小熊猫模型

325
00:17:54,842 --> 00:17:58,712
为了规范化几何图形
以使用我们的压缩格式之一

326
00:17:58,745 --> 00:18:01,715
需要获取网格 计算其边界

327
00:18:01,748 --> 00:18:04,952
然后将其缩放到 0 到 1 的范围

328
00:18:04,985 --> 00:18:09,189
然后 您可以使用一种规范化的
整数顶点格式来存储网格

329
00:18:09,223 --> 00:18:13,760
从而减少它在磁盘
和内存中占用的空间

330
00:18:13,794 --> 00:18:17,598
在运行时 您可以提供一个矩阵

331
00:18:17,631 --> 00:18:21,134
将每个顶点缩放和偏移到最终位置

332
00:18:21,168 --> 00:18:25,038
应用该矩阵以获取原始模型

333
00:18:25,072 --> 00:18:28,509
现在 我们来了解一下
如何通过变换矩阵

334
00:18:28,542 --> 00:18:30,611
来建立加速结构

335
00:18:30,644 --> 00:18:33,714
首先创建变换缓冲区

336
00:18:33,747 --> 00:18:38,519
一种方法是创建一个
包含缩放和偏移变换矩阵的

337
00:18:38,552 --> 00:18:41,889
MTLPackedFloat4x3 对象

338
00:18:41,922 --> 00:18:46,193
然后 创建一个
足以容纳矩阵的 Metal Buffer

339
00:18:46,226 --> 00:18:49,796
最后 将矩阵复制到缓冲区

340
00:18:49,830 --> 00:18:52,666
接下来 设置加速结构

341
00:18:52,699 --> 00:18:55,536
首先 创建三角形几何描述符

342
00:18:55,569 --> 00:18:58,705
然后 指定变换矩阵缓冲区

343
00:18:58,739 --> 00:19:01,575
最后是缓冲区偏移量

344
00:19:01,608 --> 00:19:05,179
这就是设置转换矩阵所需的全部操作

345
00:19:05,212 --> 00:19:09,550
这些矩阵还可以用于
组合简单的加速结构

346
00:19:09,583 --> 00:19:11,985
以提高光线追踪的性能

347
00:19:12,019 --> 00:19:14,188
让我们看一个示例场景

348
00:19:14,221 --> 00:19:19,092
在这里 长方体和球体
都是相对简单的网格

349
00:19:19,126 --> 00:19:22,729
这提供了一个在场景的前端

350
00:19:22,763 --> 00:19:25,566
优化加速结构的机会

351
00:19:25,599 --> 00:19:28,535
关注实例加速结构 光线击中的

352
00:19:28,569 --> 00:19:32,272
每个实例都会产生间接消耗

353
00:19:32,306 --> 00:19:34,441
变换光线 然后从实例

354
00:19:34,474 --> 00:19:38,412
切换到基本加速结构是有成本的

355
00:19:38,445 --> 00:19:42,316
这种情况更常发生在
实例重叠的情况下

356
00:19:42,349 --> 00:19:44,151
若要减少实例数

357
00:19:44,184 --> 00:19:46,954
可以生成同时包含长方体和球体的

358
00:19:46,987 --> 00:19:50,591
单个基本加速结构

359
00:19:50,624 --> 00:19:53,427
为此 可以为每个对象创建
一个几何描述符

360
00:19:53,460 --> 00:19:57,397
每个对象都有自己的变换矩阵

361
00:19:57,431 --> 00:20:00,834
生成的基本加速结构

362
00:20:00,868 --> 00:20:05,606
是实例加速结构中的单个实例
包含长方体和球体

363
00:20:05,639 --> 00:20:09,309
这会产生性能更好的加速结构

364
00:20:09,343 --> 00:20:11,378
让我们看看如何在代码中设置它

365
00:20:12,779 --> 00:20:16,416
首先定义球体几何描述符

366
00:20:16,450 --> 00:20:20,721
接下来 像往常一样
为基本加速结构设置顶点缓冲区

367
00:20:20,754 --> 00:20:24,024
索引缓冲区和其他属性

368
00:20:24,057 --> 00:20:26,927
不同之处在于 您还可以指定包含

369
00:20:26,960 --> 00:20:30,797
用于复制球体的变换矩阵的
变换缓冲区

370
00:20:32,466 --> 00:20:35,502
对于长方体
有多个几何描述符

371
00:20:35,536 --> 00:20:38,372
共享一个顶点和索引缓冲区

372
00:20:38,405 --> 00:20:42,609
您只需为每个副本
指定不同的转换缓冲区

373
00:20:42,643 --> 00:20:47,114
最后 在为基本加速结构
创建描述符时

374
00:20:47,147 --> 00:20:49,750
添加所有的几何描述符

375
00:20:49,783 --> 00:20:52,419
这将生成一个基本加速结构

376
00:20:52,452 --> 00:20:56,123
您可以通过实体变换
将其实例化到场景中

377
00:20:56,156 --> 00:20:59,393
与单独的加速结构相比
这种基本加速结构的

378
00:20:59,426 --> 00:21:03,330
构建时间更短 并且相交速度更快

379
00:21:04,998 --> 00:21:08,502
最后 加速结构的堆分配

380
00:21:08,535 --> 00:21:11,605
是我们最需要的功能之一

381
00:21:11,638 --> 00:21:14,041
有了这个功能 您现在可以

382
00:21:14,074 --> 00:21:16,577
更好地控制加速结构分配

383
00:21:16,610 --> 00:21:20,047
它还允许您在分配之间
重复使用堆内存

384
00:21:20,080 --> 00:21:23,250
避免了昂贵的缓冲区分配

385
00:21:23,283 --> 00:21:27,054
使用实例加速结构时
堆还可以通过减少

386
00:21:27,087 --> 00:21:31,525
对 useResource: 方法的调用
来帮助提高性能

387
00:21:31,558 --> 00:21:33,794
回到示例场景

388
00:21:33,827 --> 00:21:36,430
实例加速结构间接引用了

389
00:21:36,463 --> 00:21:39,132
基本加速结构

390
00:21:39,166 --> 00:21:42,870
这意味着每次您想要使用
带有指令编码器的实例加速结构时

391
00:21:42,903 --> 00:21:46,507
需要为每个基本加速结构

392
00:21:46,540 --> 00:21:49,243
调用 useResource: 方法

393
00:21:49,276 --> 00:21:52,346
对于大型场景
每次使用实例加速结构时

394
00:21:52,379 --> 00:21:56,116
可能需要数千次调用 useResource:

395
00:21:56,149 --> 00:21:58,852
面对如此多的 useResource: 调用

396
00:21:58,886 --> 00:22:02,656
您可以调用 useResources: 来减少
API 调用的数量

397
00:22:02,689 --> 00:22:06,260
但您仍需维护一个加速结构的数组

398
00:22:06,293 --> 00:22:09,062
Metal 仍需依次通过这个数组

399
00:22:09,096 --> 00:22:11,064
相反 您可以从同一个堆中

400
00:22:11,098 --> 00:22:14,668
分配所有这些基本加速结构

401
00:22:14,701 --> 00:22:17,704
当您想要使用实例加速结构时

402
00:22:17,738 --> 00:22:20,874
您可以简单地调用 useHeap: 方法

403
00:22:20,908 --> 00:22:24,077
来引用所有的基本加速结构

404
00:22:24,111 --> 00:22:27,147
我们只需将对 useResource: 的调用

405
00:22:27,181 --> 00:22:29,816
替换为对 useHeap: 的单个调用

406
00:22:29,850 --> 00:22:32,186
就能使 App 的性能得到提升

407
00:22:32,219 --> 00:22:35,455
让我们看看如何从堆中分配加速结构

408
00:22:35,489 --> 00:22:39,793
您可以通过在堆上调用一个
以加速结构描述符为输入的方法

409
00:22:39,826 --> 00:22:43,197
直接分配一个加速结构

410
00:22:43,230 --> 00:22:46,066
如果不使用描述符进行分配

411
00:22:46,099 --> 00:22:49,703
Metal 设备将确定
从堆中分配加速结构的

412
00:22:49,736 --> 00:22:52,606
大小和对齐要求

413
00:22:52,639 --> 00:22:55,309
通过提供描述符或加速结构大小

414
00:22:55,342 --> 00:22:59,012
您可以从 Metal 设备获得此信息

415
00:22:59,046 --> 00:23:01,148
一旦确定了最终大小

416
00:23:01,181 --> 00:23:04,351
就可以从堆中分配加速结构

417
00:23:04,384 --> 00:23:07,621
在使用堆时 有几个注意事项

418
00:23:07,654 --> 00:23:12,025
首先 记住调用 useHeap:
使堆中的所有加速结构

419
00:23:12,059 --> 00:23:15,596
在光线追踪过程中保持驻留

420
00:23:15,629 --> 00:23:20,734
其次 默认情况下 Metal 不会
追踪您从堆中分配的资源

421
00:23:20,767 --> 00:23:23,570
您可以选择加入资源风险追踪

422
00:23:23,604 --> 00:23:27,407
也可以手动管理自己的同步

423
00:23:27,441 --> 00:23:31,512
您可以使用 MTLFence
在指令编码器之间进行同步

424
00:23:31,545 --> 00:23:35,215
使用 MTLEvent
在指令缓冲区之间进行同步

425
00:23:35,249 --> 00:23:38,352
这些都是今年
Metal 光线追踪 API 中的

426
00:23:38,385 --> 00:23:40,921
新功能和性能改进

427
00:23:40,954 --> 00:23:43,991
接下来 Dominik 将谈一下 Xcode 的

428
00:23:44,024 --> 00:23:47,294
Metal 工具的改进
它将提高您在开发

429
00:23:47,327 --> 00:23:49,196
光线追踪 App 时的效率

430
00:23:49,229 --> 00:23:50,964
谢谢 Yi

431
00:23:50,998 --> 00:23:54,401
在 Xcode 14 中有很多
对 Metal 工具的增强

432
00:23:54,434 --> 00:23:57,104
但在这里 我想强调的是一些

433
00:23:57,137 --> 00:24:00,674
在开发光线追踪 App 时
特别有用的工具

434
00:24:01,642 --> 00:24:04,678
从 Metal 调试器开始 我将介绍

435
00:24:04,711 --> 00:24:09,583
加速结构查看器
着色器性能分析和着色器调试的改进

436
00:24:10,551 --> 00:24:14,388
最后 我会介绍运行时着色器验证

437
00:24:16,523 --> 00:24:21,161
首先 我们来看看
加速结构查看器

438
00:24:21,195 --> 00:24:25,999
Metal 调试器中的
加速结构查看器

439
00:24:26,033 --> 00:24:29,169
能够使您非常详细地检查
组成加速结构的

440
00:24:29,203 --> 00:24:32,573
所有几何形体和所有网格的实例

441
00:24:34,141 --> 00:24:37,744
Xcode 14 现在支持调试

442
00:24:37,778 --> 00:24:41,982
带有基本或实例运动的加速结构
并支持使用检查器

443
00:24:42,015 --> 00:24:46,954
对每个图元数据进行可视化的
新高亮模式

444
00:24:46,987 --> 00:24:48,722
我们来看看它们的表现

445
00:24:49,523 --> 00:24:52,593
如果您正在使用带有运动的加速结构

446
00:24:52,626 --> 00:24:55,095
现在在底部栏中会有一个拖拽条

447
00:24:55,128 --> 00:24:58,899
用于查看您在不同时间点的加速结构

448
00:24:58,932 --> 00:25:02,135
在拖拽条的右边是一个“播放”按钮

449
00:25:02,169 --> 00:25:05,339
您可以用它来循环播放动画

450
00:25:05,372 --> 00:25:08,976
现在我将展示如何在您的加速结构中

451
00:25:09,009 --> 00:25:11,144
检查单个图元

452
00:25:11,178 --> 00:25:15,516
如果您正在使用新的逐图元数据 API
这将特别有用

453
00:25:15,549 --> 00:25:19,853
这里有一个相应的新的高亮模式

454
00:25:19,887 --> 00:25:23,790
图元高亮显示模式
允许您访问所有图元数据

455
00:25:25,292 --> 00:25:29,296
并允许您选择特定的图元
进行详细检查

456
00:25:30,631 --> 00:25:34,468
在左侧边栏中
可以找到数据行旁边的箭头

457
00:25:35,736 --> 00:25:38,438
单击箭头将显示一个弹出窗口

458
00:25:38,472 --> 00:25:41,308
其中显示了该图元的相应数据

459
00:25:41,341 --> 00:25:44,178
加速结构查看器的这些新增功能

460
00:25:44,211 --> 00:25:47,581
确保您可以完全访问

461
00:25:47,614 --> 00:25:51,952
构成加速结构的所有组件
包括每个图元

462
00:25:51,985 --> 00:25:55,522
接下来 我们来谈谈
Shader Profiler 的改进

463
00:25:55,556 --> 00:26:00,160
Shader Profiler 可让您
深入了解着色器的性能

464
00:26:00,194 --> 00:26:03,297
提供每条管道执行计时成本

465
00:26:03,330 --> 00:26:07,968
在 Apple GPU 上
它在源代码级别提供了更高的粒度

466
00:26:08,001 --> 00:26:13,240
显示了分布在指令类别中的
每行执行成本

467
00:26:13,273 --> 00:26:17,477
在 Xcode 14 中
对 GPU 捕获做性能分析已更新的

468
00:26:17,511 --> 00:26:22,516
支持相交函数 可见函数和动态库

469
00:26:23,884 --> 00:26:28,388
这里我们有一个使用相交函数的
光线追踪内核

470
00:26:28,422 --> 00:26:31,091
现在 您可以在相交函数中

471
00:26:31,124 --> 00:26:33,861
查看逐行分析的结果

472
00:26:33,894 --> 00:26:36,496
这包括构成成本的

473
00:26:36,530 --> 00:26:38,365
指令类别的细目

474
00:26:41,969 --> 00:26:45,005
分析可见函数的工作方式相同

475
00:26:46,306 --> 00:26:49,409
同样 现在可以从链接的动态库中

476
00:26:49,443 --> 00:26:53,180
获取着色器代码的详细性能分析信息

477
00:26:53,213 --> 00:26:56,283
有了这些附加功能 您现在就可以对

478
00:26:56,316 --> 00:26:59,953
管道的性能进行全面分解
直至每一行代码

479
00:27:02,122 --> 00:27:04,024
接下来再来谈谈 Shader Debugger

480
00:27:04,057 --> 00:27:05,158
Shader Debugger 为调试

481
00:27:05,192 --> 00:27:07,528
着色器代码的正确性

482
00:27:07,561 --> 00:27:10,397
提供了一个独特而高效的工作流程

483
00:27:10,430 --> 00:27:13,634
像 Shader Profiler 一样
我们还扩展了

484
00:27:13,667 --> 00:27:17,271
对链接函数
和动态库的调试支持

485
00:27:17,304 --> 00:27:19,806
这里有一个光线追踪内核
它调用了

486
00:27:19,840 --> 00:27:24,011
一个通过可见函数表
传递进来的链接可见函数

487
00:27:27,247 --> 00:27:30,250
现在您可以一直追踪内核的执行

488
00:27:30,284 --> 00:27:32,920
直到可见函数代码

489
00:27:32,953 --> 00:27:36,123
以验证代码的行为是否符合预期

490
00:27:37,257 --> 00:27:41,195
同样 这也适用于调试动态库

491
00:27:41,228 --> 00:27:45,265
您还可以从管线链接的

492
00:27:45,299 --> 00:27:47,134
已执行动态库跳入跳出

493
00:27:47,167 --> 00:27:48,802
有了这些附加功能 现在您可以

494
00:27:48,836 --> 00:27:51,104
全面了解着色器在管道中的

495
00:27:51,138 --> 00:27:54,141
链接函数和库的执行情况了

496
00:27:55,943 --> 00:27:59,379
现在 在捕获并跳转到
Shader Debugger 之前

497
00:27:59,413 --> 00:28:03,050
最好在运行时启用着色器验证

498
00:28:05,686 --> 00:28:10,324
着色器验证是在 GPU 上
诊断运行时错误的一种很好的方法

499
00:28:10,357 --> 00:28:14,027
可以捕获诸如超出限制的内存访问

500
00:28:14,061 --> 00:28:16,463
空纹理读取等问题

501
00:28:16,496 --> 00:28:20,534
要在 Xcode 中启用着色器验证
只需转到

502
00:28:20,567 --> 00:28:24,037
“Edit Scheme” 对话框
选择 “Run” 操作

503
00:28:24,071 --> 00:28:28,775
并在 “diagnostics” 选项卡下
勾选 “Shader Validation” 复选框

504
00:28:28,809 --> 00:28:31,044
这样就可以了

505
00:28:31,078 --> 00:28:34,748
在 Metal 3 中
我们添加了栈溢出检测

506
00:28:34,781 --> 00:28:36,350
这将帮助您快速发现

507
00:28:36,383 --> 00:28:40,220
可能导致未定义行为的问题

508
00:28:40,254 --> 00:28:43,524
我将快速阐述 Metal 着色器中的

509
00:28:43,557 --> 00:28:45,726
函数堆栈和栈溢出问题

510
00:28:45,759 --> 00:28:48,795
调用堆栈是设备内存中的一个区域

511
00:28:48,829 --> 00:28:53,267
Metal 在其中存储
着色器函数中使用的本地数据值

512
00:28:53,300 --> 00:28:56,103
如果被调用的函数在编译时是未知的

513
00:28:56,136 --> 00:28:58,405
Metal 需要您的帮助

514
00:28:58,438 --> 00:29:01,642
来估计堆栈所需的内存量

515
00:29:01,675 --> 00:29:05,345
对编译时未知函数的调用示例

516
00:29:05,379 --> 00:29:08,448
可能是光线追踪相交函数

517
00:29:08,482 --> 00:29:11,051
如果您在使用自定义相交函数

518
00:29:11,084 --> 00:29:16,123
则应将最大调用堆栈深度设置为 1
以便为其分配空间

519
00:29:16,156 --> 00:29:19,826
这是默认值 因此无需执行其他操作

520
00:29:19,860 --> 00:29:24,231
但如果您使用函数表调用可见函数

521
00:29:24,264 --> 00:29:28,302
这是编译时未知函数调用的
另一个示例

522
00:29:28,335 --> 00:29:31,038
如果从相交函数执行这样的调用

523
00:29:31,071 --> 00:29:34,708
如本例中所示
那么调用堆栈将有两层之深

524
00:29:36,376 --> 00:29:39,813
另一个例子是调用动态库

525
00:29:39,847 --> 00:29:43,250
和使用函数指针调用本地函数

526
00:29:43,283 --> 00:29:47,020
在本例中
我们的调用堆栈有四个层级

527
00:29:47,054 --> 00:29:48,789
其中包含对不同类型函数的

528
00:29:48,822 --> 00:29:51,625
嵌套调用
这些函数在编译着色器时无法解析

529
00:29:51,658 --> 00:29:55,095
要正确配置 Metal
以分配正确的内存量

530
00:29:55,128 --> 00:29:59,633
您需要自己指定最大调用堆栈深度 4

531
00:29:59,666 --> 00:30:02,469
重要的是要记住 当程序的

532
00:30:02,503 --> 00:30:05,772
最大调用堆栈深度设置得太低时

533
00:30:05,806 --> 00:30:09,843
就可能会发生 Stack Overflow
从而导致未定义的行为

534
00:30:09,877 --> 00:30:13,313
但如果您在运行时
启用了

535
00:30:13,347 --> 00:30:15,582
这种情况就会被及早发现

536
00:30:15,616 --> 00:30:20,254
您会在 Xcode 中看到
栈溢出发生的信息

537
00:30:20,287 --> 00:30:22,856
然后 您可以修复着色器代码

538
00:30:22,890 --> 00:30:26,560
或在管道描述符中
调整最大堆栈调用深度

539
00:30:26,593 --> 00:30:30,297
Xcode 14 中
Metal 工具的所有这些新改进

540
00:30:30,330 --> 00:30:33,133
确保您对光线追踪 App 的

541
00:30:33,166 --> 00:30:37,304
性能和正确性有更全面的了解

542
00:30:37,337 --> 00:30:40,340
有关如何充分利用 Metal 工具

543
00:30:40,374 --> 00:30:43,243
进行调试和分析的更多信息
请查看以下其他讲座

544
00:30:45,412 --> 00:30:48,782
本期讲座旨在最大限度地
提高您的 App 的

545
00:30:48,815 --> 00:30:50,284
Metal 光线追踪性能

546
00:30:50,317 --> 00:30:52,953
我们讨论了如何使用
逐图元数据等新功能

547
00:30:52,986 --> 00:30:57,558
来提高性能并简化代码

548
00:30:57,591 --> 00:31:00,627
我们还讲述了使构建加速结构

549
00:31:00,661 --> 00:31:04,097
比以往任何时候都更快 更方便的

550
00:31:04,131 --> 00:31:05,832
优化技术和功能

551
00:31:05,866 --> 00:31:09,236
最后 我们介绍了 Xcode 14 中

552
00:31:09,269 --> 00:31:11,405
Metal 工具的所有新的增强功能

553
00:31:11,438 --> 00:31:14,107
这些功能将在开发过程中
为您提供更深入的见解

554
00:31:14,141 --> 00:31:15,809
齐: 感谢观看

