1
00:00:00,000 --> 00:00:03,003
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,003 --> 00:00:09,810
♪

3
00:00:09,810 --> 00:00:11,545
Angela Laar：大家好 我是 Angela

4
00:00:11,545 --> 00:00:13,413
Becca Royal-Gordon：我是 Becca

5
00:00:13,413 --> 00:00:15,415
Angela：欢迎关注 Swift 的新功能！

6
00:00:15,415 --> 00:00:17,317
今天我们很高兴能给您介绍一下

7
00:00:17,317 --> 00:00:21,154
Swift 5.7 中所有优秀的新功能

8
00:00:21,154 --> 00:00:22,956
我们今天要讲的许多事情都体现了

9
00:00:22,956 --> 00:00:28,195
Swift 的目标 即让
您的开发工作生活更轻松

10
00:00:28,195 --> 00:00:29,429
我们将研究新工具

11
00:00:29,429 --> 00:00:31,732
以帮助您自定义工作流程

12
00:00:31,732 --> 00:00:35,569
并介绍一些令人惊叹的根本性改进

13
00:00:35,569 --> 00:00:38,772
然后我们将讨论
最新的 Swift 并发模型

14
00:00:38,772 --> 00:00:43,243
以及通往 Swift 6 的道路
包括全线程安全

15
00:00:43,243 --> 00:00:44,912
Becca：最后我会介绍

16
00:00:44,912 --> 00:00:47,447
一些使 Swift
更易于读写的语言改进

17
00:00:47,447 --> 00:00:50,784
包括更简洁、更简单的泛型

18
00:00:50,784 --> 00:00:54,688
和强大的新字符串处理工具

19
00:00:54,688 --> 00:00:57,424
Angela：但首先 让我们先谈谈

20
00:00:57,424 --> 00:01:01,228
让 Swift 如此特别的原因之一

21
00:01:01,228 --> 00:01:02,763
那就是所有开发者

22
00:01:02,763 --> 00:01:05,499
Swift 之所以能如此迅速的扩张

23
00:01:05,499 --> 00:01:08,268
要归功于开发者的付出和贡献

24
00:01:08,268 --> 00:01:11,038
社区参与是 Swift 的核心

25
00:01:11,038 --> 00:01:14,174
我们于去年发布了

26
00:01:14,174 --> 00:01:16,210
docC 文档生成工具

27
00:01:16,210 --> 00:01:19,446
并于今年面向社区
提供更多 Swift 计划

28
00:01:19,446 --> 00:01:23,150
并且开源了 Swift.org 网站

29
00:01:23,150 --> 00:01:24,651
要开源运作起来最好

30
00:01:24,651 --> 00:01:28,889
需要有活跃的社区来引领

31
00:01:28,889 --> 00:01:31,592
我们一直在服务器端上的 Swift
和 Swift 多样性项目中

32
00:01:31,592 --> 00:01:34,528
以工作组的方式来管理

33
00:01:34,528 --> 00:01:36,196
并为对特定领域感兴趣的

34
00:01:36,196 --> 00:01:38,732
社区成员提供支持

35
00:01:38,732 --> 00:01:40,400
效果一直很显著

36
00:01:40,400 --> 00:01:42,336
所以我们启动了两个新的工作组

37
00:01:42,336 --> 00:01:44,171
一个用于在 Swift 网站的迭代

38
00:01:44,171 --> 00:01:46,340
并使其更像是一种社区资源

39
00:01:46,340 --> 00:01:49,409
另一个用于 C++ 互用性

40
00:01:49,409 --> 00:01:54,581
以设计改变在 C++ 和 Swift
之间的模型

41
00:01:54,581 --> 00:01:57,551
当我们冒险进入新领域时

42
00:01:57,551 --> 00:02:00,020
我们都需要来自社区内的成员的支持

43
00:02:00,020 --> 00:02:02,856
作为其中的一部分
Swift 多样性工作组

44
00:02:02,856 --> 00:02:05,792
去年推出了 Swift 导师计划

45
00:02:05,792 --> 00:02:07,427
该计划为那些不知道如何开始

46
00:02:07,427 --> 00:02:09,563
或想加深
其在特定领域的专业知识的人

47
00:02:09,563 --> 00:02:11,398
提供了为所有工作组领域

48
00:02:11,398 --> 00:02:15,869
做出贡献的途径

49
00:02:15,869 --> 00:02:18,805
去年的计划取得了巨大的成功

50
00:02:18,805 --> 00:02:21,708
有很多感兴趣的学员慕名而来

51
00:02:21,708 --> 00:02:25,913
因此我们创建了
41 个一对一指导小组

52
00:02:25,913 --> 00:02:29,082
鉴于其取得了巨大成功

53
00:02:29,082 --> 00:02:30,617
此计划将在第二年继续开展

54
00:02:30,617 --> 00:02:32,419
我们希望所有感兴趣的人都能

55
00:02:32,419 --> 00:02:35,656
加入此计划 但要做到这一点

56
00:02:35,656 --> 00:02:38,792
我们需要大家 即正在听课的
优秀且且经验丰富的开发人员

57
00:02:38,792 --> 00:02:40,827
愿意分享广博知识

58
00:02:40,827 --> 00:02:42,763
并建立新联系的人员

59
00:02:42,763 --> 00:02:45,599
因为导师计划不仅仅涉及代码

60
00:02:45,599 --> 00:02:49,002
还涉及在社区内建立关系

61
00:02:49,002 --> 00:02:52,005
一点点指导就可以产生持久的影响

62
00:02:52,005 --> 00:02:54,641
我有真凭实据

63
00:02:54,641 --> 00:02:58,045
去年 Amrit 参加了导师计划

64
00:02:58,045 --> 00:03:00,848
并专注于编译器和语言设计

65
00:03:00,848 --> 00:03:02,749
开始时 Amrit 只是感到好奇

66
00:03:02,749 --> 00:03:06,019
最终却真得做出了贡献

67
00:03:06,019 --> 00:03:09,056
进入一个新领域并不容易

68
00:03:09,056 --> 00:03:12,092
即便如此 她还是找到了成功之路

69
00:03:12,092 --> 00:03:14,828
并感到受到了鼓舞
想要做出更多贡献

70
00:03:14,828 --> 00:03:16,230
像许多其他人一样

71
00:03:16,230 --> 00:03:19,499
这次经历为 Amrit 打开了一扇门

72
00:03:19,499 --> 00:03:22,202
除了编译器和语言设计

73
00:03:22,202 --> 00:03:26,340
去年还有很多重点领域

74
00:03:26,340 --> 00:03:28,008
从技术写作和测试

75
00:03:28,008 --> 00:03:30,744
到为 Swift 软件包做贡献

76
00:03:30,744 --> 00:03:33,080
今年 我们增加了更多领域

77
00:03:33,080 --> 00:03:36,116
新主题将层出不穷

78
00:03:36,116 --> 00:03:39,253
如果您在此列表中
没有看到您感兴趣的内容

79
00:03:39,253 --> 00:03:42,256
您仍然可以在申请表格中提出

80
00:03:42,256 --> 00:03:45,425
另一点是 今年的计划将为初学者

81
00:03:45,425 --> 00:03:48,262
提供全年导师服务

82
00:03:48,262 --> 00:03:50,731
以帮助能力不足

83
00:03:50,731 --> 00:03:54,735
但十分想参与的人

84
00:03:54,735 --> 00:03:56,503
如果您想申请

85
00:03:56,503 --> 00:03:58,238
或者只是想了解更多内容

86
00:03:58,238 --> 00:04:00,474
请查看最新的 Swift 博客文章

87
00:04:00,474 --> 00:04:02,809
在那里 您可以找到重点学员的

88
00:04:02,809 --> 00:04:05,512
详细描述链接

89
00:04:05,512 --> 00:04:08,048
导师计划只是 Swift 多样性

90
00:04:08,048 --> 00:04:10,717
中的其中一项举措

91
00:04:10,717 --> 00:04:12,553
要了解有关导师计划的更多信息

92
00:04:12,553 --> 00:04:14,755
以及关于 Swift 多样性的工作

93
00:04:14,755 --> 00:04:17,691
您可以访问 Swift.org/diversity

94
00:04:17,691 --> 00:04:20,494
为了进一步打开大门
我们想尽量让您

95
00:04:20,494 --> 00:04:24,965
可以轻松地使用 Swift 和现有资源！

96
00:04:24,965 --> 00:04:27,868
我们简化了适用于 Linux 平台的

97
00:04:27,868 --> 00:04:29,269
Swift 工具链分发流程

98
00:04:29,269 --> 00:04:32,072
方式是添加
对 Linux 包格式的支持

99
00:04:32,072 --> 00:04:33,941
现在您可以
使用新原生工具链安装器

100
00:04:33,941 --> 00:04:37,110
直接从 Swift.org 下载

101
00:04:37,110 --> 00:04:40,380
Amazon Linux 2 和 CentOS 7 的 RPM

102
00:04:40,380 --> 00:04:42,115
这些工具链是实验性的

103
00:04:42,115 --> 00:04:45,419
所以请一定在 Swift.org 论坛上分享反馈

104
00:04:45,419 --> 00:04:48,155
Swift 主要用于构建 App

105
00:04:48,155 --> 00:04:52,626
然而 Swift 的愿景
一直是成为可扩展的工具

106
00:04:52,626 --> 00:04:54,661
力求适用于从高级脚本

107
00:04:54,661 --> 00:04:57,531
到裸机环境的所有情况

108
00:04:57,531 --> 00:04:58,932
为了鼓励将 Swift 用于

109
00:04:58,932 --> 00:05:01,235
以前从未使用过的地方

110
00:05:01,235 --> 00:05:04,171
Swift 今年经历了一些重大变化

111
00:05:04,171 --> 00:05:05,706
使标准库更小

112
00:05:05,706 --> 00:05:08,442
以适用于独立的
静态链接的二进制文件

113
00:05:08,442 --> 00:05:09,943
我们放弃了依赖

114
00:05:09,943 --> 00:05:12,446
外部 Unicode 支持库

115
00:05:12,446 --> 00:05:17,384
而是用更快的原生实现来替代

116
00:05:17,384 --> 00:05:20,187
在事件驱动型服务器
解决方案上运行时

117
00:05:20,187 --> 00:05:22,756
更小、更快的二进制文件好处颇多

118
00:05:22,756 --> 00:05:24,925
默认情况下 您会
在 Linux 上获得静态链接

119
00:05:24,925 --> 00:05:28,595
以更好地
支持服务器的容器化部署

120
00:05:28,595 --> 00:05:30,531
这种尺寸减小使 Swift 适合

121
00:05:30,531 --> 00:05:32,432
于受限的环境

122
00:05:32,432 --> 00:05:33,634
这让我们可以在 Apple 的

123
00:05:33,634 --> 00:05:36,270
Secure Enclave Processor 中使用它

124
00:05:36,270 --> 00:05:38,739
Swift 适用于从 App 到服务器

125
00:05:38,739 --> 00:05:41,675
一直到受限处理器的各种场合

126
00:05:41,675 --> 00:05:46,713
将它们联系在一起的是软件包生态系统

127
00:05:46,713 --> 00:05:48,782
今年 Swift 软件包的新功能

128
00:05:48,782 --> 00:05:50,584
会让您的生活更美好

129
00:05:50,584 --> 00:05:55,656
首先 Swift Package Manager 引入了 TOFU

130
00:05:55,656 --> 00:05:58,592
这不是指那个美味的小吃

131
00:05:58,592 --> 00:06:01,929
TOFU 是首字母缩写词
代表首次使用时的信任

132
00:06:01,929 --> 00:06:04,231
这是一种新的安全协议

133
00:06:04,231 --> 00:06:06,066
会在首次下载软件时

134
00:06:06,066 --> 00:06:08,468
记录一个包的指纹

135
00:06:08,468 --> 00:06:11,038
后续下载将验证此指纹

136
00:06:11,038 --> 00:06:14,675
如果指纹不同则报错

137
00:06:14,675 --> 00:06:17,377
这只是内置于软件包生态系统核心的

138
00:06:17,377 --> 00:06:20,147
信任和安全性的一个例子

139
00:06:20,147 --> 00:06:23,383
可帮助您自信地使用它

140
00:06:23,383 --> 00:06:26,353
对于 Swift 开发人员来说

141
00:06:26,353 --> 00:06:28,288
指令插件是改进工作流程的好方法

142
00:06:28,288 --> 00:06:30,657
它们是提供更多可扩展的

143
00:06:30,657 --> 00:06:32,926
且安全的构建工具的第一步

144
00:06:32,926 --> 00:06:35,963
指令插件可用于文档生成

145
00:06:35,963 --> 00:06:38,632
源代码重新格式化等

146
00:06:38,632 --> 00:06:41,068
使用 Swift
您就不必在 Shell 脚本中

147
00:06:41,068 --> 00:06:44,438
编写自动化内容
并维护单独的工作流程

148
00:06:44,438 --> 00:06:46,907
想想开源格式化程序和静态检查工具

149
00:06:46,907 --> 00:06:50,644
现在所有这些开源工具
都可以在 Xcode

150
00:06:50,644 --> 00:06:53,947
和 Swift Package Manager 中找到

151
00:06:53,947 --> 00:06:57,050
指令插件是开源工具和

152
00:06:57,050 --> 00:06:58,819
Swift Package Manager 之间的粘合剂

153
00:06:58,819 --> 00:07:01,054
Swift 项目接纳
开源社区的开发者工具

154
00:07:01,054 --> 00:07:03,957
与您的自动化

155
00:07:03,957 --> 00:07:06,693
工作流程无缝整合

156
00:07:06,693 --> 00:07:09,296
docC 是将文档集成到

157
00:07:09,296 --> 00:07:10,697
您的源代码中的优秀工具

158
00:07:10,697 --> 00:07:14,735
在 Objective-C 和 C 支持的帮助下

159
00:07:14,735 --> 00:07:16,537
今年它更加完善了 让我们看看

160
00:07:16,537 --> 00:07:19,072
使用 docC 创建插件都需要什么

161
00:07:19,072 --> 00:07:20,908
插件只是简单的 Swift 代码

162
00:07:20,908 --> 00:07:23,110
您可以通过创建符合指令插入

163
00:07:23,110 --> 00:07:25,479
协议的结构体来定义插件

164
00:07:25,479 --> 00:07:28,015
然后您只需添加一个函数来告诉

165
00:07:28,015 --> 00:07:30,250
您的插件您要调用哪个工具即可

166
00:07:30,250 --> 00:07:34,454
这个函数就是我们要调用 docC 的地方

167
00:07:34,454 --> 00:07:37,291
一旦您定义了您的插件 它就可以通过

168
00:07:37,291 --> 00:07:39,026
Swift PM 命令行界面

169
00:07:39,026 --> 00:07:40,928
和 Xcode 作为菜单项使用了

170
00:07:40,928 --> 00:07:44,364
现在我们可以告诉 Swift PM 生成文档

171
00:07:44,364 --> 00:07:48,569
它知道要将此操作传递给 docC 可执行文件

172
00:07:48,569 --> 00:07:50,337
还不止于此

173
00:07:50,337 --> 00:07:54,241
还有第二个称为构建工具插件的插件

174
00:07:54,241 --> 00:07:56,376
这些插件是允许您

175
00:07:56,376 --> 00:07:59,246
在构建过程中添加额外的步骤的包

176
00:07:59,246 --> 00:08:01,381
实现构建工具插件时

177
00:08:01,381 --> 00:08:02,983
将为构建系统创建一个指令

178
00:08:02,983 --> 00:08:05,085
以在沙盒中执行

179
00:08:05,085 --> 00:08:06,787
它们不同于指令插件

180
00:08:06,787 --> 00:08:09,089
您可以随时直接执行

181
00:08:09,089 --> 00:08:11,225
并且可以被授予显式权限

182
00:08:11,225 --> 00:08:13,994
以更改包中的文件

183
00:08:13,994 --> 00:08:16,997
构建工具插件可用于源代码生成

184
00:08:16,997 --> 00:08:20,234
或特殊类型文件的自定义处理

185
00:08:20,234 --> 00:08:23,570
在使用构建工具插件时
包布局是这样的

186
00:08:23,570 --> 00:08:25,839
在这个例子中 plugin.Swift

187
00:08:25,839 --> 00:08:27,608
是实施包插件目标的

188
00:08:27,608 --> 00:08:29,142
Swift 脚本

189
00:08:29,142 --> 00:08:33,480
该插件被视为 Swift 可执行文件

190
00:08:33,480 --> 00:08:35,482
并且编写插件的方法与编写

191
00:08:35,482 --> 00:08:38,852
Swift 可执行文件的方法是相同的

192
00:08:38,852 --> 00:08:40,654
要实现插件
您可以定义一组构建指令

193
00:08:40,654 --> 00:08:43,457
它们告诉构建系统

194
00:08:43,457 --> 00:08:46,560
要运行什么可执行指令

195
00:08:46,560 --> 00:08:48,295
以及预期有什么输出

196
00:08:48,295 --> 00:08:50,631
包插件通过您的软件包提供

197
00:08:50,631 --> 00:08:53,367
可扩展的安全解决方案

198
00:08:53,367 --> 00:08:55,702
要详细了解插件的工作原理

199
00:08:55,702 --> 00:08:58,705
以及如何实现自己的插件

200
00:08:58,705 --> 00:09:00,207
请观看“认识 Swift 包插件”

201
00:09:00,207 --> 00:09:03,410
和“创建 Swift 包插件”这两门课程

202
00:09:03,410 --> 00:09:05,546
随着您使用的软件包越来越多

203
00:09:05,546 --> 00:09:08,682
您可能遇到过模块冲突

204
00:09:08,682 --> 00:09:10,284
那是两个单独的包

205
00:09:10,284 --> 00:09:12,786
用同样的名称定义一个模块

206
00:09:12,786 --> 00:09:14,321
为了解决这种问题

207
00:09:14,321 --> 00:09:19,226
Swift 5.7 引入了模块消歧

208
00:09:19,226 --> 00:09:22,896
模块消歧是一种功能

209
00:09:22,896 --> 00:09:26,900
它允许您从
定义模块包的外部重命名模块

210
00:09:26,900 --> 00:09:28,902
在我们的 Stunning App 中

211
00:09:28,902 --> 00:09:31,905
我们引入了
两个都定义了 Logging 模块的包

212
00:09:31,905 --> 00:09:33,140
因此发生了冲突

213
00:09:33,140 --> 00:09:35,909
要为我们的 Stunning App 解决此问题

214
00:09:35,909 --> 00:09:38,545
您只需要在包清单的依赖关系部分

215
00:09:38,545 --> 00:09:42,950
添加 moduleAliases 关键字即可

216
00:09:42,950 --> 00:09:44,718
这样您就可以用两个不同的名字

217
00:09:44,718 --> 00:09:46,520
区分之前拥有

218
00:09:46,520 --> 00:09:49,456
相同名称的模块了

219
00:09:49,456 --> 00:09:53,560
Swift 5.7 带来了
一些惊人的性能改进

220
00:09:53,560 --> 00:09:56,129
让我们先看看构建时间

221
00:09:56,129 --> 00:09:58,699
去年 我们告诉大家我们如何重写了

222
00:09:58,699 --> 00:10:00,634
Swift Driver 它被用于协调

223
00:10:00,634 --> 00:10:04,104
在 Swift 中 Swift 源代码的编译工作

224
00:10:04,104 --> 00:10:05,372
去年的重构

225
00:10:05,372 --> 00:10:07,140
解锁了一些非常重要的变化

226
00:10:07,140 --> 00:10:09,443
让构建速度大幅提升

227
00:10:09,443 --> 00:10:11,612
现在可将驱动程序直接在

228
00:10:11,612 --> 00:10:13,747
Xcode 构建系统中作为框架调用

229
00:10:13,747 --> 00:10:16,316
而不是作为单独的可执行文件

230
00:10:16,316 --> 00:10:18,452
这让它可以更紧密地与构建系统

231
00:10:18,452 --> 00:10:22,623
一起协调构建让诸如并行化之类的
方式成为可能

232
00:10:22,623 --> 00:10:25,125
如果您喜欢听到关于快速构建的内容

233
00:10:25,125 --> 00:10:26,894
您可以在观看

234
00:10:26,894 --> 00:10:31,031
“深入探索 Xcode 构建中的并行”

235
00:10:31,031 --> 00:10:33,133
为了向您展示构建速度有多快

236
00:10:33,133 --> 00:10:36,003
让我们看一些示例
以了解构建我们经常使用的

237
00:10:36,003 --> 00:10:39,306
用 Swift 编写的工具需要多长时间

238
00:10:39,306 --> 00:10:41,842
在 10 核 iMac 上 改进程度

239
00:10:41,842 --> 00:10:46,580
从 5% 一直到 25% 不等

240
00:10:46,580 --> 00:10:49,883
接下来
类型检查的速度也有所改进

241
00:10:49,883 --> 00:10:52,586
今年 我们改进了类型检查器的性能

242
00:10:52,586 --> 00:10:56,156
方式是重新实现泛型系统的关键部分

243
00:10:56,156 --> 00:10:58,192
即根据协议和 where 子句

244
00:10:58,192 --> 00:11:00,727
计算函数签名的部分

245
00:11:00,727 --> 00:11:03,530
在旧的实现中 随着引入越来越多的协议

246
00:11:03,530 --> 00:11:07,167
时间和内存使用会指数级增加

247
00:11:07,167 --> 00:11:10,871
例如在这里 我们有一组复杂的协议

248
00:11:10,871 --> 00:11:13,340
它们定义了一个坐标系

249
00:11:13,340 --> 00:11:16,577
以及许多关联类型的范型要求

250
00:11:16,577 --> 00:11:20,714
以前需要 17 秒来检查此代码

251
00:11:20,714 --> 00:11:24,218
但现在
Swift 5.7 中 此例能够

252
00:11:24,218 --> 00:11:28,889
显着加快类型检查 耗时不足一秒钟

253
00:11:28,889 --> 00:11:32,826
我们还有一些
同样令人印象深刻的运行时间改进

254
00:11:32,826 --> 00:11:36,630
在 Swift 5.7 之前
我们看到 iOS 上的 App 启动时

255
00:11:36,630 --> 00:11:39,633
的协议检查最多需要四秒钟

256
00:11:39,633 --> 00:11:42,970
每次我们启动 App 时
都需要计算协议

257
00:11:42,970 --> 00:11:44,771
这导致添加的协议越多

258
00:11:44,771 --> 00:11:46,740
启动时间更长

259
00:11:46,740 --> 00:11:48,709
现在协议被存入了高速缓冲存储器

260
00:11:48,709 --> 00:11:50,644
根据 App 的编写方式

261
00:11:50,644 --> 00:11:52,679
以及使用了多少协议

262
00:11:52,679 --> 00:11:55,716
这可能意味着
在 iOS 16 上运行时

263
00:11:55,716 --> 00:11:58,051
某些 App 的启动时间减少了一半

264
00:11:58,051 --> 00:12:01,221
“优化 App 大小和运行时性能”课程

265
00:12:01,221 --> 00:12:03,357
将深入探讨如何在您自己的 App 中

266
00:12:03,357 --> 00:12:07,160
利用这些改进

267
00:12:07,160 --> 00:12:09,630
现在是时候讲讲大家

268
00:12:09,630 --> 00:12:12,332
感兴趣的内容了

269
00:12:12,332 --> 00:12:15,903
去年我们推出了新的并发模型

270
00:12:15,903 --> 00:12:19,439
结合 Actor 和 async/await

271
00:12:19,439 --> 00:12:23,410
这对您的 App 并发架构

272
00:12:23,410 --> 00:12:25,078
产生了变革性的影响

273
00:12:25,078 --> 00:12:29,516
async/await 和 Actor 比回调

274
00:12:29,516 --> 00:12:31,718
和手动队列管理更安全、更容易

275
00:12:31,718 --> 00:12:34,221
今年我们进一步充实了模型

276
00:12:34,221 --> 00:12:37,424
将数据竞争安全放在首位

277
00:12:37,424 --> 00:12:39,560
因为并发对于改进 App 代码库

278
00:12:39,560 --> 00:12:41,929
而言是如此重要和不可或缺

279
00:12:41,929 --> 00:12:44,431
我们将这些改变向后部署

280
00:12:44,431 --> 00:12:48,202
到  iOS 13 和 macOS Catalina

281
00:12:48,202 --> 00:12:50,504
为了部署到较旧的操作系统

282
00:12:50,504 --> 00:12:54,208
您的 App 为较久的 OS 捆绑了

283
00:12:54,208 --> 00:12:55,976
Swift 5.5 并发系统运行时间副本

284
00:12:55,976 --> 00:12:58,178
这类似于在 ABI 稳定之前

285
00:12:58,178 --> 00:13:01,915
将 Swift 向后部署到操作系统中

286
00:13:01,915 --> 00:13:05,152
接下来我们将这个模型
推向了新的方向

287
00:13:05,152 --> 00:13:06,587
我们引入了语言功能

288
00:13:06,587 --> 00:13:08,522
和配套软件包

289
00:13:08,522 --> 00:13:12,759
首先让我们谈谈避免数据竞争

290
00:13:12,759 --> 00:13:14,027
在我开始讲解之前

291
00:13:14,027 --> 00:13:15,729
我可能应该退一步

292
00:13:15,729 --> 00:13:18,498
谈谈 Swift 的重要功能之一是

293
00:13:18,498 --> 00:13:20,868
默认的内存安全

294
00:13:20,868 --> 00:13:23,871
Swift 用户不能做
产生无法预测行为的事情

295
00:13:23,871 --> 00:13:25,072
就像在正在修改一个数值时

296
00:13:25,072 --> 00:13:27,574
读取数值

297
00:13:27,574 --> 00:13:31,278
在此例中 我们删除了数组中

298
00:13:31,278 --> 00:13:33,447
与同一数组计数匹配的所有数字

299
00:13:33,447 --> 00:13:36,183
最初 数组的计数是 3

300
00:13:36,183 --> 00:13:38,986
所以我们将从数组中删除 3

301
00:13:38,986 --> 00:13:41,955
但是这样操作之后 计数将变成 2

302
00:13:41,955 --> 00:13:44,525
我们是否从数组中删除 3 和 2

303
00:13:44,525 --> 00:13:46,527
还是只删除 3 呢？

304
00:13:46,527 --> 00:13:48,328
答案是都不是

305
00:13:48,328 --> 00:13:50,163
Swift 会阻止您这样做

306
00:13:50,163 --> 00:13:52,866
因为在修改数组时

307
00:13:52,866 --> 00:13:55,435
访问数组的计数是不安全的

308
00:13:55,435 --> 00:13:58,839
我们的目标是
为线程安全做类似的处理

309
00:13:58,839 --> 00:14:00,073
我们设想一种语言
它可以在默认情况下

310
00:14:00,073 --> 00:14:03,377
消除低级别的数据竞争

311
00:14:03,377 --> 00:14:06,380
换句话说 我们要防止可能会导致

312
00:14:06,380 --> 00:14:09,216
不可预测的行为的并发错误

313
00:14:09,216 --> 00:14:10,951
另一个例子如下

314
00:14:10,951 --> 00:14:14,621
我们使用同样数字的数组
创建了一个后台任务

315
00:14:14,621 --> 00:14:17,224
将 0 附加到数组中

316
00:14:17,224 --> 00:14:20,561
然后我们删除数组的最后一个元素

317
00:14:20,561 --> 00:14:23,063
但是等等
是在附加 0 之前还是之后

318
00:14:23,063 --> 00:14:26,567
删除最后一个元素呢？

319
00:14:26,567 --> 00:14:29,670
答案还是都不是

320
00:14:29,670 --> 00:14:32,406
Swift 会阻止您这样做

321
00:14:32,406 --> 00:14:34,308
因为未通过类似 Actor 等同步访问

322
00:14:34,308 --> 00:14:38,679
在后台任务的修改数组是不安全的

323
00:14:38,679 --> 00:14:42,749
Actor 是消除数据竞争的第一步

324
00:14:42,749 --> 00:14:45,185
今年我们完善了并发模型

325
00:14:45,185 --> 00:14:49,122
离最终目标更进了一步

326
00:14:49,122 --> 00:14:52,326
您可以把每个 Actor
想象成一个独立的小岛

327
00:14:52,326 --> 00:14:56,096
与并发海洋中的其他一切隔离开来

328
00:14:56,096 --> 00:14:58,799
但是当不同的线程想要查询

329
00:14:58,799 --> 00:15:03,003
每个独立 Actor 存储的
信息时会发生什么呢？

330
00:15:03,003 --> 00:15:06,073
我们将在“使用 Swift
并发消除数据竞争”

331
00:15:06,073 --> 00:15:10,644
课程中进一步探讨这一点

332
00:15:10,644 --> 00:15:14,014
从默认内存安全到线程安全

333
00:15:14,014 --> 00:15:16,850
这是 Swift 6 的目标

334
00:15:16,850 --> 00:15:19,052
为此 我们首先用新语言功能

335
00:15:19,052 --> 00:15:21,522
改进了去年的并发模型

336
00:15:21,522 --> 00:15:23,123
我刚才提到了

337
00:15:23,123 --> 00:15:24,992
第二件事我还没有提到

338
00:15:24,992 --> 00:15:26,693
就是新的安全检查可选项

339
00:15:26,693 --> 00:15:30,163
它可识别潜在的数据竞争

340
00:15:30,163 --> 00:15:32,866
您可以通过在构建设置中启用它

341
00:15:32,866 --> 00:15:36,203
尝试更严格的并发检查

342
00:15:36,203 --> 00:15:38,372
我们再来看看 Actor

343
00:15:38,372 --> 00:15:41,642
我们可以采用
这个 Actor 隔离的概念

344
00:15:41,642 --> 00:15:44,545
并进一步推广到分布式 Actor

345
00:15:44,545 --> 00:15:47,314
分布式 Actor
将这些岛屿放在不同的机器上

346
00:15:47,314 --> 00:15:49,249
它们之间有网络相连

347
00:15:49,249 --> 00:15:52,186
这种新语言功能使开发

348
00:15:52,186 --> 00:15:54,354
分布式系统变得更加简单

349
00:15:54,354 --> 00:15:56,590
假设您要创建一个游戏 App

350
00:15:56,590 --> 00:15:59,426
您现在可以
轻松地用 Swift 编写后端

351
00:15:59,426 --> 00:16:02,396
在这里 分布式 Actor
就像是一个 Actor

352
00:16:02,396 --> 00:16:04,831
但它可能在另一台机器上

353
00:16:04,831 --> 00:16:07,501
在此示例中
我们将看到计算机玩家

354
00:16:07,501 --> 00:16:11,271
通过它维护用户玩游戏期间的游戏状态

355
00:16:11,271 --> 00:16:14,174
也可以将 distributed 关键字添加到函数中

356
00:16:14,174 --> 00:16:15,843
我们预计需要为远程机器

357
00:16:15,843 --> 00:16:19,580
上的 Actor 上调用该函数

358
00:16:19,580 --> 00:16:22,449
让我们添加另一个
名为 endOfRound 的函数

359
00:16:22,449 --> 00:16:26,386
它通过遍历玩家对象
在玩家上调用 makeMove

360
00:16:26,386 --> 00:16:28,922
其中一些玩家
可能是本地的或远程的

361
00:16:28,922 --> 00:16:30,023
但我们不必管

362
00:16:30,023 --> 00:16:33,026
是哪个玩家

363
00:16:33,026 --> 00:16:35,429
它与常规 Actor 调用的唯一区别是

364
00:16:35,429 --> 00:16:38,198
因为网络错误

365
00:16:38,198 --> 00:16:40,234
分布式 Actor 调用可能会失败

366
00:16:40,234 --> 00:16:41,969
如果发生网络故障

367
00:16:41,969 --> 00:16:44,438
Actor 方法会抛出一个错误

368
00:16:44,438 --> 00:16:46,273
所以 您需要在 Swift 中添加

369
00:16:46,273 --> 00:16:49,109
所需的 try 关键字

370
00:16:49,109 --> 00:16:52,412
以及常规的 await 关键字

371
00:16:52,412 --> 00:16:54,414
基于这些核心语言原语

372
00:16:54,414 --> 00:16:57,417
我们还构建了一个
开源分布式 Actor 包

373
00:16:57,417 --> 00:16:59,753
它专注于通过 Swift 构建服务器端

374
00:16:59,753 --> 00:17:02,589
集群分布式系统

375
00:17:02,589 --> 00:17:05,225
该软件包包括一个
使用 SwiftNIO 并实现了

376
00:17:05,225 --> 00:17:09,196
SWIM 共识协议的集成网络层

377
00:17:09,196 --> 00:17:11,598
以管理整个集群的状态

378
00:17:11,598 --> 00:17:13,634
“认识 Swift 中的
分布式 Actor” 课程

379
00:17:13,634 --> 00:17:15,569
将详细介绍如何构建

380
00:17:15,569 --> 00:17:19,473
具有这些新功能的分布式系统

381
00:17:19,473 --> 00:17:23,076
我们还推出了一套新的开源算法

382
00:17:23,076 --> 00:17:27,114
为处理 AsyncSequence 时的常见操作

383
00:17:27,114 --> 00:17:29,516
提供简单的开箱即用解决方案

384
00:17:29,516 --> 00:17:32,152
它与 Swift 5.5 一起发布

385
00:17:32,152 --> 00:17:34,154
将这些 API 作为一个软件包发布

386
00:17:34,154 --> 00:17:37,558
为开发人员提供了跨平台

387
00:17:37,558 --> 00:17:40,761
和跨操作系统版本部署的灵活性

388
00:17:40,761 --> 00:17:44,631
有几种方法可以组合多个异步序列

389
00:17:44,631 --> 00:17:47,367
并将值分组到各个集合中

390
00:17:47,367 --> 00:17:49,036
这些只是此包中

391
00:17:49,036 --> 00:17:51,071
包含的一些算法

392
00:17:51,071 --> 00:17:53,941
查看 “认识 Swift 异步算法“ 讲座

393
00:17:53,941 --> 00:17:58,111
了解如何使用这个强大的新 API

394
00:17:58,111 --> 00:18:00,647
但并发系统还包含一个方面

395
00:18:00,647 --> 00:18:02,516
就是性能

396
00:18:02,516 --> 00:18:04,818
今年我们对 Actor 进行了优化

397
00:18:04,818 --> 00:18:08,655
Actor 现在首先执行
优先级最高的工作

398
00:18:08,655 --> 00:18:10,457
并通过与操作系统调度程序

399
00:18:10,457 --> 00:18:12,292
继续进行深度整合

400
00:18:12,292 --> 00:18:15,429
该模型内置了预防优先级反转功能

401
00:18:15,429 --> 00:18:20,300
所以不太重要的工作
不会阻止优先级更高的工作

402
00:18:20,300 --> 00:18:23,070
过去我们很难想象

403
00:18:23,070 --> 00:18:26,073
App 中并发系统对性能的影响

404
00:18:26,073 --> 00:18:31,411
但是现在我们有了一个很棒的新工具

405
00:18:31,411 --> 00:18:34,081
Instruments 中
新的 Swift Concurrency 视图

406
00:18:34,081 --> 00:18:36,717
可以帮助您调查性能问题

407
00:18:36,717 --> 00:18:39,553
Swift Tasks 和 Swift Actors 工具

408
00:18:39,553 --> 00:18:42,689
提供一整套工具来帮助您呈现

409
00:18:42,689 --> 00:18:46,159
并优化并发代码

410
00:18:46,159 --> 00:18:49,096
在顶部 Swift Tasks Instrument

411
00:18:49,096 --> 00:18:52,132
提供实用统计信息

412
00:18:52,132 --> 00:18:54,835
包括同时运行的任务数量

413
00:18:54,835 --> 00:18:58,005
在那个时间点之前创建的任务总数

414
00:18:58,005 --> 00:18:59,873
在此窗口的下半部分

415
00:18:59,873 --> 00:19:03,777
您可以看到所谓的 Task Forest

416
00:19:03,777 --> 00:19:06,213
它提供了图形化表示

417
00:19:06,213 --> 00:19:07,981
展示了结构化并发代码中的

418
00:19:07,981 --> 00:19:11,552
任务之间的父子关系

419
00:19:11,552 --> 00:19:13,520
这只是 Swift Actor Instrument

420
00:19:13,520 --> 00:19:16,990
的详细视图之一

421
00:19:16,990 --> 00:19:19,493
要了解如何使用这个令人兴奋的新工具

422
00:19:19,493 --> 00:19:20,961
请查看

423
00:19:20,961 --> 00:19:24,198
“Swift 并发系统可视化和优化”讲座

424
00:19:24,198 --> 00:19:26,867
并且不要忘记尝试这些新软件包

425
00:19:26,867 --> 00:19:29,703
请大胆地在论坛上告诉我们使用情况

426
00:19:29,703 --> 00:19:32,005
现在我们请 Becca 来谈谈

427
00:19:32,005 --> 00:19:36,143
对 Swift 语言可用性的诸多改进

428
00:19:36,143 --> 00:19:38,412
Becca：语言是工具

429
00:19:38,412 --> 00:19:40,547
关于工具有一些有意思的事情

430
00:19:40,547 --> 00:19:42,850
工具真得可以影响您建造的东西

431
00:19:42,850 --> 00:19:44,952
当您只有一把锤子时

432
00:19:44,952 --> 00:19:48,121
您会用钉子而不是螺丝来建造东西

433
00:19:48,121 --> 00:19:50,858
即使您有全套工具

434
00:19:50,858 --> 00:19:52,659
如果您的锤子
有一个又大又防滑的把手

435
00:19:52,659 --> 00:19:55,662
而您的螺丝刀是塑料的 很难握住

436
00:19:55,662 --> 00:19:58,098
您可能仍然倾向于用钉子建造

437
00:19:58,098 --> 00:20:00,000
语言也是如此

438
00:20:00,000 --> 00:20:02,503
如果 Swift 有一个工具
能很好地表达事物

439
00:20:02,503 --> 00:20:05,205
人们就会更频繁地使用它

440
00:20:05,205 --> 00:20:07,541
Swift 用于表达您希望代码做什么

441
00:20:07,541 --> 00:20:11,512
的工具在许多方面都有所改进

442
00:20:11,512 --> 00:20:13,580
其中一些更改是

443
00:20:13,580 --> 00:20:15,415
让您常做的事更加便利

444
00:20:15,415 --> 00:20:18,785
例如 在等号两边添加相同名称的

445
00:20:18,785 --> 00:20:22,155
if let 是非常常见的

446
00:20:22,155 --> 00:20:24,091
毕竟 对于展开的值

447
00:20:24,091 --> 00:20:25,592
可能没有比给可选值取的名字

448
00:20:25,592 --> 00:20:28,562
更好的名字了

449
00:20:28,562 --> 00:20:30,097
但是当名字真的很长的时候

450
00:20:30,097 --> 00:20:33,100
这种重复就会变得麻烦

451
00:20:33,100 --> 00:20:35,736
您可能会想缩写这个名字

452
00:20:35,736 --> 00:20:39,106
但是随后您的代码变得模棱两可

453
00:20:39,106 --> 00:20:41,375
如果您稍后重命名可选变量

454
00:20:41,375 --> 00:20:45,245
缩写可能不会被同步

455
00:20:45,245 --> 00:20:47,781
Swift 5.7 为这种模式引入了一种

456
00:20:47,781 --> 00:20:49,650
全新的简便方法

457
00:20:49,650 --> 00:20:51,018
如果您展开一个可选值

458
00:20:51,018 --> 00:20:53,520
并希望展开的值具有相同的名称

459
00:20:53,520 --> 00:20:55,789
只需删除右边的代码即可

460
00:20:55,789 --> 00:20:58,492
Swift 会假设名称是一样的

461
00:20:58,492 --> 00:21:00,761
当然 这种方式同样适用于 guard

462
00:21:00,761 --> 00:21:04,031
甚至 while

463
00:21:04,031 --> 00:21:06,834
我们还查看了当您做了细微更改

464
00:21:06,834 --> 00:21:09,203
某个功能突然停止工作的地方

465
00:21:09,203 --> 00:21:11,371
例如 Swift 总是能够根据

466
00:21:11,371 --> 00:21:13,941
单语句闭包内编写的代码推导出

467
00:21:13,941 --> 00:21:16,543
一个调用将返回什么类型

468
00:21:16,543 --> 00:21:19,513
在这个 compactMap 调用中
闭包返回 parseLine

469
00:21:19,513 --> 00:21:22,449
并且 parseLine 函数
返回了一个 MailmapEntry

470
00:21:22,449 --> 00:21:25,352
Swift 可以推导出 entries 应该是

471
00:21:25,352 --> 00:21:30,190
一个 MailmapEntry 的数组

472
00:21:30,190 --> 00:21:32,159
这现在适用于具有多个语句

473
00:21:32,159 --> 00:21:35,362
或控制流功能的更复杂的闭包

474
00:21:35,362 --> 00:21:37,598
所以您可以使用 do-catch 或 if…else

475
00:21:37,598 --> 00:21:39,800
或只是添加一个 print 调用

476
00:21:39,800 --> 00:21:43,303
而无需手动指定闭包的结果类型

477
00:21:43,303 --> 00:21:45,973
我们关注的另一件事是那些并未

478
00:21:45,973 --> 00:21:49,576
真正标示任何实际危险的危险标志

479
00:21:49,576 --> 00:21:52,913
Swift 非常注重类型和内存安全

480
00:21:52,913 --> 00:21:54,448
为了不让您犯错

481
00:21:54,448 --> 00:21:56,016
它绝对不会在不同指针类型的指针之间自动转换

482
00:21:56,016 --> 00:21:58,318
也不会在原始指针和

483
00:21:58,318 --> 00:22:01,321
类型化指针之间自动转换

484
00:22:01,321 --> 00:22:02,923
这与 C 非常不同

485
00:22:02,923 --> 00:22:05,259
C 允许某些转换

486
00:22:05,259 --> 00:22:07,995
例如 您可以更改带符号类型的指针

487
00:22:07,995 --> 00:22:11,732
或将任何指针转换为 char*
以将其作为字节访问

488
00:22:11,732 --> 00:22:15,402
这不违反任何 C 指针规则

489
00:22:15,402 --> 00:22:17,771
但有时这些指针行为的差异会

490
00:22:17,771 --> 00:22:22,042
在 C API 导入 Swift 时会出现问题

491
00:22:22,042 --> 00:22:24,178
最初的开发者在设计
API 时可能有轻微的不匹配

492
00:22:24,178 --> 00:22:26,079
这些不匹配在 C 语言中
可以通过自动转换来处理

493
00:22:26,079 --> 00:22:30,784
但在 Swift 中却是错误

494
00:22:30,784 --> 00:22:33,120
在 Swift 中
将一种类型的指针

495
00:22:33,120 --> 00:22:35,989
当作不同类型来访问是非常危险的

496
00:22:35,989 --> 00:22:39,393
所以您必须明确地描述您在做什么

497
00:22:39,393 --> 00:22:41,161
但如果我们向 C 传递指针
这一切都毫无意义

498
00:22:41,161 --> 00:22:43,830
因为在 C 中

499
00:22:43,830 --> 00:22:47,501
指针不匹配是完全合法的

500
00:22:47,501 --> 00:22:50,170
所以在这种情况下
我们把一件非常简单的事情

501
00:22:50,170 --> 00:22:52,639
当作危险的事情来对待

502
00:22:52,639 --> 00:22:55,976
这很重要
因为 Swift 既重视类型安全

503
00:22:55,976 --> 00:23:00,047
它还重视对 C 系列代码的轻松访问

504
00:23:00,047 --> 00:23:01,815
这就是为什么 C
和 Objective-C 的互操作

505
00:23:01,815 --> 00:23:05,085
如此丰富和无缝
为什么 Swift 项目

506
00:23:05,085 --> 00:23:08,255
组建了 Angela
在前面提到的 C++ 工作组

507
00:23:08,255 --> 00:23:11,592
开始构建为 C++ 提供同样强大的互用性

508
00:23:11,592 --> 00:23:13,460
我们不想让使用这样的 C 函数

509
00:23:13,460 --> 00:23:16,763
变得非常痛苦
这种痛苦是可以避免的

510
00:23:16,763 --> 00:23:18,565
所以 Swift 制定了一套单独的规则

511
00:23:18,565 --> 00:23:21,435
用于调用导入的函数和方法

512
00:23:21,435 --> 00:23:24,171
它允许在 C 中合法的指针转换

513
00:23:24,171 --> 00:23:26,974
即使它们通常在 Swift 中是不合法的

514
00:23:26,974 --> 00:23:31,512
这样您的 Swift 代码
就可以无缝地使用这些 API

515
00:23:31,512 --> 00:23:33,747
到目前为止 我们已经讨论了对

516
00:23:33,747 --> 00:23:35,415
您已经拥有的工具的一些小的改进

517
00:23:35,415 --> 00:23:38,151
今年 Swift 中还新增了一个全新工具

518
00:23:38,151 --> 00:23:41,588
用于从字符串中提取信息

519
00:23:41,588 --> 00:23:43,390
这里有一个函数 可以从一个字符串中

520
00:23:43,390 --> 00:23:45,092
解析出一些信息

521
00:23:45,092 --> 00:23:46,593
这种任务对于 Swift 来说

522
00:23:46,593 --> 00:23:48,795
一直有点难

523
00:23:48,795 --> 00:23:51,798
您得反复搜索、分割和切片

524
00:23:51,798 --> 00:23:54,768
直到您得到您想要的

525
00:23:54,768 --> 00:23:56,570
当人们注意到这一点时

526
00:23:56,570 --> 00:23:58,705
他们往往会关注一些小事

527
00:23:58,705 --> 00:24:00,741
比如操纵字符串索引有多冗长

528
00:24:00,741 --> 00:24:03,877
但我认为这有点忽略了大局

529
00:24:03,877 --> 00:24:06,747
因为即使我们改变了这个语法

530
00:24:06,747 --> 00:24:09,183
它也不能帮助您
回答您提出的基本问题

531
00:24:09,183 --> 00:24:12,386
当您查看此代码时

532
00:24:12,386 --> 00:24:15,389
传入它的行变量究竟是什么样子的？

533
00:24:15,389 --> 00:24:18,458
它想拆开什么样的字符串？

534
00:24:18,458 --> 00:24:20,661
如果您凝视它足够长的时间
您可能会意识到

535
00:24:20,661 --> 00:24:23,530
它正在解析 mailmap 的简化版本

536
00:24:23,530 --> 00:24:25,732
即您放入 git 存储库的

537
00:24:25,732 --> 00:24:29,069
以更正之前提交的
开发人员姓名的文件

538
00:24:29,069 --> 00:24:31,839
但是通过搜索和切片来提取这些信息

539
00:24:31,839 --> 00:24:35,843
太复杂了 很难弄清楚

540
00:24:35,843 --> 00:24:38,345
您执着于如何分割字符串

541
00:24:38,345 --> 00:24:42,316
以至于忘记了那个字符串是什么

542
00:24:42,316 --> 00:24:45,953
问题不在于这两种表达方式

543
00:24:45,953 --> 00:24:48,355
问题是整个事情

544
00:24:48,355 --> 00:24:49,890
我们需要打破这一切

545
00:24:49,890 --> 00:24:52,092
并用更好的东西代替它

546
00:24:52,092 --> 00:24:54,494
我们需要一种不同的方法

547
00:24:54,494 --> 00:24:56,964
在这种方法中 您的代码可以描述出

548
00:24:56,964 --> 00:24:58,832
您想要匹配的字符串

549
00:24:58,832 --> 00:25:01,602
语言会说明如何去做

550
00:25:01,602 --> 00:25:05,772
是一种声明性方法
而不是强制性方法

551
00:25:05,772 --> 00:25:10,811
在 Swift 5.7 中 您现在可以
通过编写正则表达式来做到这一点

552
00:25:10,811 --> 00:25:14,214
正则表达式是
一种描述字符串中模式的方法

553
00:25:14,214 --> 00:25:16,717
50 多年来 语言和工具

554
00:25:16,717 --> 00:25:18,619
允许开发人员编以紧凑

555
00:25:18,619 --> 00:25:21,588
且信息丰富的语法写正则表达式

556
00:25:21,588 --> 00:25:24,491
开发者中的一些人
已在 Xcode 查找栏中使用过它们

557
00:25:24,491 --> 00:25:26,426
在 grep 等指令行工具中

558
00:25:26,426 --> 00:25:29,096
在 Foundation 的
NSRegularExpression 类

559
00:25:29,096 --> 00:25:31,465
或其他编程语言中

560
00:25:31,465 --> 00:25:34,501
Swift 的正则表达式字面量
现在支持该语法

561
00:25:34,501 --> 00:25:37,971
它的工作原理
就像在任何其他开发工具中一样

562
00:25:37,971 --> 00:25:40,174
但是开发者中的一些人以前没用过正则表达式

563
00:25:40,174 --> 00:25:42,843
您可能会问：“那是真正的代码吗？

564
00:25:42,843 --> 00:25:46,280
还是一只猫从键盘上乱踩出来的？”

565
00:25:46,280 --> 00:25:47,948
我不会责备您

566
00:25:47,948 --> 00:25:50,450
正则表达式字面量
是用符号和助记符编写的

567
00:25:50,450 --> 00:25:53,720
您必须记住才能阅读它们

568
00:25:53,720 --> 00:25:55,189
对于懂这种语言的人来说

569
00:25:55,189 --> 00:25:56,823
即使是
这个正则表达式中最粗糙的部分

570
00:25:56,823 --> 00:25:59,259
比如和开发者名字匹配的部分

571
00:25:59,259 --> 00:26:02,763
只是几个简单匹配规则的组合

572
00:26:02,763 --> 00:26:06,767
但要把很多行为
塞进 11 个字符里是很难的

573
00:26:06,767 --> 00:26:10,204
正则表达式字面量非常紧凑
即使是经验丰富的开发人员

574
00:26:10,204 --> 00:26:13,407
有时需要一些时间
来理解一个复杂的表达式

575
00:26:13,407 --> 00:26:15,809
但是如果您能写出
同样的匹配规则

576
00:26:15,809 --> 00:26:18,946
只是用词汇而不是符号？

577
00:26:18,946 --> 00:26:21,915
这似乎更容易理解

578
00:26:21,915 --> 00:26:23,150
其实放在一起

579
00:26:23,150 --> 00:26:26,887
您会得到一些看起来
很像 SwiftUI 的东西

580
00:26:26,887 --> 00:26:30,290
这将是很好的
替代正则表达式的文字 不是吗？

581
00:26:30,290 --> 00:26:33,460
所以 Swift 支持它是一件好事！

582
00:26:33,460 --> 00:26:35,329
RegexBuilder 库提供了一个全新的

583
00:26:35,329 --> 00:26:39,066
SwiftUI 风格的正则表达式语言

584
00:26:39,066 --> 00:26:42,236
更易于使用
并且比传统语法更具可读性

585
00:26:42,236 --> 00:26:44,671
它可以做
与正则表达式文字相同的事情

586
00:26:44,671 --> 00:26:47,341
但它用您能理解或查阅的语言

587
00:26:47,341 --> 00:26:50,177
描述了它的行为

588
00:26:50,177 --> 00:26:52,279
而不是用您必须记住的符号和缩写

589
00:26:52,279 --> 00:26:54,414
正则表达式构建器非常适合初学者

590
00:26:54,414 --> 00:26:57,150
但它的功能不仅仅适合初学者

591
00:26:57,150 --> 00:26:59,253
它具有强大的功能

592
00:26:59,253 --> 00:27:01,622
远远超过了正则表达式字面量

593
00:27:01,622 --> 00:27:03,457
首先您可以把正则表达式

594
00:27:03,457 --> 00:27:05,993
变成一个可重用的正则表达式组件

595
00:27:05,993 --> 00:27:08,495
就像您可以把 SwiftUI 视图层次

596
00:27:08,495 --> 00:27:10,597
变成一个视图一样

597
00:27:10,597 --> 00:27:12,833
您可以使用构建器语法创建的

598
00:27:12,833 --> 00:27:14,768
其他正则表达式中的这些组件

599
00:27:14,768 --> 00:27:17,404
您甚至可以让它们递归

600
00:27:17,404 --> 00:27:19,740
正则表达式构建器还支持将

601
00:27:19,740 --> 00:27:22,142
一些 Swift 类型
直接放入正则表达式中

602
00:27:22,142 --> 00:27:24,111
例如 字符串文字只匹配

603
00:27:24,111 --> 00:27:28,549
里面的确切文本 不需要特殊的转义

604
00:27:28,549 --> 00:27:30,217
您还可以使用在正则表达式生成器

605
00:27:30,217 --> 00:27:32,352
中的正则表达式字面量

606
00:27:32,352 --> 00:27:34,388
所以您可以
在正则表达式构建器清晰度

607
00:27:34,388 --> 00:27:38,559
和正则表达式字面量的
简洁性之间取得平衡

608
00:27:38,559 --> 00:27:41,662
其他类型 比如这个
Foundation 日期格式风格

609
00:27:41,662 --> 00:27:44,531
可以将自定义解析逻辑
与正则表达式构建器集成

610
00:27:44,531 --> 00:27:48,702
甚至在捕获数据之前
将其转换为更丰富的类型

611
00:27:48,702 --> 00:27:50,838
最后 无论您使用哪种语法

612
00:27:50,838 --> 00:27:54,141
正则表达式支持很多有用的匹配方法

613
00:27:54,141 --> 00:27:58,212
以及易于使用的强类型捕获

614
00:27:58,212 --> 00:28:00,113
对于那些惴惴不安的

615
00:28:00,113 --> 00:28:02,382
痴迷于正则表达式的人来说

616
00:28:02,382 --> 00:28:05,219
Swift Regex
使用全新的开源匹配引擎

617
00:28:05,219 --> 00:28:06,353
具有可与最先进的正则表达式实现

618
00:28:06,353 --> 00:28:09,623
相匹配的功能集

619
00:28:09,623 --> 00:28:13,193
字面量语法与 Unicode 正则表达式标准兼容

620
00:28:13,193 --> 00:28:16,263
它具有不同寻常的 Unicode 正确性级别

621
00:28:16,263 --> 00:28:19,166
例如 点默认匹配整个字符

622
00:28:19,166 --> 00:28:22,970
不是 Unicode.Scalar 或 UTF-8 字节

623
00:28:22,970 --> 00:28:25,172
要使用 Swift Regex 您的 App 需要在

624
00:28:25,172 --> 00:28:28,008
在内置 Swift Regex 引擎的 OS 上运行

625
00:28:28,008 --> 00:28:32,212
比如 macOS 13 或 iOS 16

626
00:28:32,212 --> 00:28:34,515
Swift Regex 是一门完整的语言

627
00:28:34,515 --> 00:28:36,416
嗯 真的是两种语言

628
00:28:36,416 --> 00:28:38,819
所以还有很多内容要讲

629
00:28:38,819 --> 00:28:40,787
“Swift 正则表达式简介”

630
00:28:40,787 --> 00:28:43,156
“深入了解 Swift 正则表达式”

631
00:28:43,156 --> 00:28:46,793
将为您提供
更多关于其用途的详细信息

632
00:28:46,793 --> 00:28:48,028
最后 我们在一个地方

633
00:28:48,028 --> 00:28:50,464
对现有的工具进行了全面的检查

634
00:28:50,464 --> 00:28:53,200
并进行了大量的修改来改进它们

635
00:28:53,200 --> 00:28:56,270
那就是在泛型和协议中

636
00:28:56,270 --> 00:28:58,105
为了向您展示这些工具是如何改进的

637
00:28:58,105 --> 00:29:00,474
我需要举一个协议示例

638
00:29:00,474 --> 00:29:02,209
假设您正在
编写一个 git 客户端

639
00:29:02,209 --> 00:29:05,846
而且您必须
以两种不同的方式表示邮件映射

640
00:29:05,846 --> 00:29:08,949
当您显示提交时
您使用字典类型

641
00:29:08,949 --> 00:29:11,585
快速查找名称

642
00:29:11,585 --> 00:29:13,954
但是当您让用户编辑邮件映射时

643
00:29:13,954 --> 00:29:16,156
您使用数组类型

644
00:29:16,156 --> 00:29:18,859
按照其原来的顺序来保留条目

645
00:29:18,859 --> 00:29:20,627
您有一个叫做 Mailmap 的协议

646
00:29:20,627 --> 00:29:22,329
它们都符合这个协议

647
00:29:22,329 --> 00:29:26,700
因此您的邮件映射解析器
可将条目添加到任一类型

648
00:29:26,700 --> 00:29:28,502
但是解析器可以通过两种方式

649
00:29:28,502 --> 00:29:30,704
使用 Mailmap 协议

650
00:29:30,704 --> 00:29:31,939
我写了两个不同的版本

651
00:29:31,939 --> 00:29:34,575
addEntries 函数来加以说明

652
00:29:34,575 --> 00:29:36,176
但实际上有点难解释

653
00:29:36,176 --> 00:29:37,477
它们的不同之处

654
00:29:37,477 --> 00:29:41,615
因为 Swift 对两种不同的事物
使用相同的语法

655
00:29:41,615 --> 00:29:45,352
看起来 “Mailmap” 这个词
在这里意味着一件事

656
00:29:45,352 --> 00:29:47,754
但它在这里的意思略有不同

657
00:29:50,290 --> 00:29:53,060
当您命名协议是用在在继承列表

658
00:29:53,060 --> 00:29:56,463
泛型参数列表 泛型一致性约束

659
00:29:56,463 --> 00:29:58,198
或不透明的结果类型中时

660
00:29:58,198 --> 00:30:01,902
它的意思是一个符合这个协议的实例

661
00:30:01,902 --> 00:30:04,371
但在变量类型 泛型变元

662
00:30:04,371 --> 00:30:06,373
泛型同类型约束

663
00:30:06,373 --> 00:30:08,709
或函数参数或结果类型中

664
00:30:08,709 --> 00:30:10,978
它实际上的意思是

665
00:30:10,978 --> 00:30:14,615
“一个包含符合此协议的实例的容器”

666
00:30:14,615 --> 00:30:16,416
这种区别很重要 因为容器

667
00:30:16,416 --> 00:30:20,254
通常使用更多空间
需要更多时间来操作

668
00:30:20,254 --> 00:30:22,022
并不具备里面的

669
00:30:22,022 --> 00:30:24,391
实例的所有能力

670
00:30:24,391 --> 00:30:25,993
但是您使用容器的地方

671
00:30:25,993 --> 00:30:28,362
和不使用容器的地方看起来很像

672
00:30:28,362 --> 00:30:31,164
所以很难弄清楚您是否正在使用容器

673
00:30:31,164 --> 00:30:34,801
Swift 5.7 修复了这个疏忽

674
00:30:34,801 --> 00:30:36,370
当您使用包含一个

675
00:30:36,370 --> 00:30:38,238
符合类型的容器之一时

676
00:30:38,238 --> 00:30:41,975
Swift 希望您能写入 any 关键字

677
00:30:41,975 --> 00:30:45,879
这在 Swift 5.7 之前
有效的代码中不是强制性的

678
00:30:45,879 --> 00:30:47,948
但我们鼓励您这样做

679
00:30:47,948 --> 00:30:50,717
您会在生成的界面
和错误消息中看到它

680
00:30:50,717 --> 00:30:53,620
即使您没有明确写出来

681
00:30:53,620 --> 00:30:55,622
所以在右侧的列中写入所有

682
00:30:55,622 --> 00:30:58,825
这些内容的首选方式
是带有 any 关键字

683
00:30:58,825 --> 00:31:00,761
这样您就能知道

684
00:31:00,761 --> 00:31:03,564
您是不是在使用其中一个容器

685
00:31:03,564 --> 00:31:05,332
在此例中 any 关键字标记了参数之一

686
00:31:05,332 --> 00:31:07,835
更容易解释

687
00:31:07,835 --> 00:31:10,337
这两个函数的区别

688
00:31:10,337 --> 00:31:14,074
addEntries1 将 Mailmap 作为泛型类型

689
00:31:14,074 --> 00:31:17,277
addEntries2 将其视为 any 类型

690
00:31:17,277 --> 00:31:18,879
并且当您遇到 any 类型的限制之一时

691
00:31:18,879 --> 00:31:20,380
错误消息也更容易

692
00:31:20,380 --> 00:31:23,450
解释发生了什么

693
00:31:23,450 --> 00:31:26,453
例如这个 mergeMailmaps 函数视图将

694
00:31:26,453 --> 00:31:30,390
一个 any Mailmap 传递
给泛型 Mailmap 参数

695
00:31:30,390 --> 00:31:31,592
这曾经产生错误

696
00:31:31,592 --> 00:31:34,494
说 Mailmap 与它自己不符

697
00:31:34,494 --> 00:31:37,764
这似乎有点自相矛盾

698
00:31:37,764 --> 00:31:40,000
但是现在我们有了 any 类型的概念

699
00:31:40,000 --> 00:31:42,803
我们就可以
更清楚地解释正在发生的事情

700
00:31:42,803 --> 00:31:44,872
问题是 any Mailmap

701
00:31:44,872 --> 00:31:47,107
是包含 Maimap 的容器

702
00:31:47,107 --> 00:31:49,943
不符合 Mailmap 协议

703
00:31:49,943 --> 00:31:51,745
但容器是您试图传递的东西

704
00:31:51,745 --> 00:31:55,015
并且它不适合泛型参数

705
00:31:55,015 --> 00:31:57,551
如果要在此处传递容器内的实例

706
00:31:57,551 --> 00:32:00,654
您必须以某种方式打开容器

707
00:32:00,654 --> 00:32:04,491
取出里面的 Mailmap 然后传递它

708
00:32:04,491 --> 00:32:08,462
但实际上 在这种简单的情况下

709
00:32:08,462 --> 00:32:10,631
Swift 会为您做这件事

710
00:32:10,631 --> 00:32:13,467
打开容器 取出里面的实例

711
00:32:13,467 --> 00:32:16,103
并将其传递给泛型参数

712
00:32:16,103 --> 00:32:17,704
所以您不会再经常

713
00:32:17,704 --> 00:32:19,640
看到这个错误信息了

714
00:32:19,640 --> 00:32:21,275
还有一个更令人兴奋的

715
00:32:21,275 --> 00:32:23,877
对 any 类型的改进

716
00:32:23,877 --> 00:32:26,880
以前协议不能用作 any 类型

717
00:32:26,880 --> 00:32:30,784
如果它使用 Self 类型或具有关联类型

718
00:32:30,784 --> 00:32:32,920
甚至只是符合一个协议

719
00:32:32,920 --> 00:32:34,888
比如 Equatable

720
00:32:34,888 --> 00:32:38,492
但在 Swift 5.7 中

721
00:32:38,492 --> 00:32:39,793
这个错误

722
00:32:39,793 --> 00:32:42,496
消失了

723
00:32:42,496 --> 00:32:44,298
很多开发者都在为此苦苦挣扎

724
00:32:44,298 --> 00:32:47,501
所以我们很高兴能从源头上修复它

725
00:32:47,501 --> 00:32:50,370
现在对于像 Mailmap
这样的协议来说 这足够令人兴奋

726
00:32:50,370 --> 00:32:52,573
但还不止于此

727
00:32:52,573 --> 00:32:55,642
因为即使是
非常复杂的协议 比如 Collection

728
00:32:55,642 --> 00:32:58,278
也可以用作 any 类型

729
00:32:58,278 --> 00:33:00,247
您甚至可以指定元素类型

730
00:33:00,247 --> 00:33:04,251
这要归功于
一个名为“主关联类型”的新功能

731
00:33:04,251 --> 00:33:05,419
很多关联类型

732
00:33:05,419 --> 00:33:08,722
基本上只是实现细节

733
00:33:08,722 --> 00:33:11,058
您通常不会关心集合为其索引

734
00:33:11,058 --> 00:33:13,927
迭代器或子序列使用哪种类型

735
00:33:13,927 --> 00:33:16,897
您只需要使用它支持的类型

736
00:33:16,897 --> 00:33:20,067
但它的 Element 就不同了

737
00:33:20,067 --> 00:33:21,935
您可能并不一定关心

738
00:33:21,935 --> 00:33:23,804
集合究竟使用哪种元素类型

739
00:33:23,804 --> 00:33:25,772
但您可能要用元素做点什么

740
00:33:25,772 --> 00:33:29,877
所以您需要约束它们或返回它们等等

741
00:33:29,877 --> 00:33:32,012
当您有像 Element 这样
几乎每个协议的用户

742
00:33:32,012 --> 00:33:35,249
都会关心的关联类型时

743
00:33:35,249 --> 00:33:37,017
您可以将其名称放在协议名称之后

744
00:33:37,017 --> 00:33:41,255
用尖括号括上
以使其成为主关联类型

745
00:33:41,255 --> 00:33:43,724
这样您就可以用尖括号语法

746
00:33:43,724 --> 00:33:46,660
来限制协议的的主关联类型

747
00:33:46,660 --> 00:33:49,596
在可以在写协议名称的
任何地方都添加尖括号

748
00:33:49,596 --> 00:33:52,165
包括在任何 Collection 中

749
00:33:52,165 --> 00:33:54,902
现在 开发者中的一些人
可能正在看这种类型

750
00:33:54,902 --> 00:33:57,271
并想“等一下

751
00:33:57,271 --> 00:33:59,640
是不是已经有一个
叫做 AnyCollection 的东西

752
00:33:59,640 --> 00:34:03,844
一起运行并且 Any 是大写的了？”

753
00:34:03,844 --> 00:34:06,380
您是对的 是有的！

754
00:34:06,380 --> 00:34:09,650
旧的 AnyCollection
是一个去类型包装器

755
00:34:09,650 --> 00:34:12,085
它是一个作用
与 any 类型相同的

756
00:34:12,085 --> 00:34:13,887
手写的结构

757
00:34:13,887 --> 00:34:15,889
不同之处在于
AnyCollection 结构体

758
00:34:15,889 --> 00:34:18,992
只是一行又一行最无聊的模板代码

759
00:34:18,992 --> 00:34:22,629
您在生活中见过的

760
00:34:22,629 --> 00:34:24,131
而 any 类型是一种内置的语言功能

761
00:34:24,131 --> 00:34:26,066
基本上做同样的事情

762
00:34:26,066 --> 00:34:27,601
是免费的！

763
00:34:27,601 --> 00:34:29,436
现在 为了向后兼容

764
00:34:29,436 --> 00:34:31,338
AnyCollection 结构体将继续存在
因为它有

765
00:34:31,338 --> 00:34:34,875
一些 any 类型无法完全匹配的功能

766
00:34:34,875 --> 00:34:36,777
但如果您的代码中
有自己的去类型包装器

767
00:34:36,777 --> 00:34:40,047
您可能想看看
是否可以使用内置的 any 类型

768
00:34:40,047 --> 00:34:44,284
而不是通过容器类或闭包重新实现它们

769
00:34:44,284 --> 00:34:47,921
或甚至只是用类型别名替换它们

770
00:34:47,921 --> 00:34:51,458
所以 Swift 极大地
改进了 any 类型

771
00:34:51,458 --> 00:34:52,993
它引入了 any 关键字

772
00:34:52,993 --> 00:34:55,596
这样您就可以看到您在哪里使用它们

773
00:34:55,596 --> 00:34:58,866
它允许您将它们传递给泛型变元

774
00:34:58,866 --> 00:35:01,101
它取消了使许多协议不能

775
00:35:01,101 --> 00:35:03,504
与之一起使用的限制

776
00:35:03,504 --> 00:35:04,605
它甚至可以让您约束

777
00:35:04,605 --> 00:35:08,442
any 类型的主关联类型

778
00:35:08,442 --> 00:35:10,511
但即使有了所有这些改进

779
00:35:10,511 --> 00:35:13,480
any 类型仍然有限制

780
00:35:13,480 --> 00:35:16,517
例如 即使您现在
可以使用 any Mailmap

781
00:35:16,517 --> 00:35:18,852
当 Mailmap 符合 Equatable 时

782
00:35:18,852 --> 00:35:21,622
您仍然不能对它们使用等于运算符

783
00:35:21,622 --> 00:35:24,258
因为等于运算符需要两个 Mailmap

784
00:35:24,258 --> 00:35:27,461
具有相同的具体类型

785
00:35:27,461 --> 00:35:30,030
但当您使用两个 any Mailmap 时
并不能保证这一点

786
00:35:30,030 --> 00:35:32,599
所以即使 Swift 对 any 类型做了很多改进

787
00:35:32,599 --> 00:35:34,735
它们在能力和性能方面

788
00:35:34,735 --> 00:35:37,971
仍然有不可忽视的限制

789
00:35:37,971 --> 00:35:41,008
这就是为什么很多时候
您不应该使用它们

790
00:35:41,008 --> 00:35:43,377
而应该改用泛型

791
00:35:43,377 --> 00:35:46,013
那么让我们回到
addEntries 的两个版本

792
00:35:46,013 --> 00:35:48,015
并运用这种智慧

793
00:35:48,015 --> 00:35:50,651
两个版本的功能完全相同

794
00:35:50,651 --> 00:35:53,287
但最上面的那个使用泛型类型

795
00:35:53,287 --> 00:35:56,757
底部的使用 any 类型

796
00:35:56,757 --> 00:35:59,159
泛型版本可能会更有效

797
00:35:59,159 --> 00:36:02,829
本领更大 所以您应该使用泛型版本

798
00:36:02,829 --> 00:36:05,599
但您可能很想使用 any 类型

799
00:36:05,599 --> 00:36:08,735
因为它们更容易读写

800
00:36:08,735 --> 00:36:10,003
要编写泛型版本

801
00:36:10,003 --> 00:36:12,439
您需要声明两个泛型类型名称

802
00:36:12,439 --> 00:36:14,641
约束它们

803
00:36:14,641 --> 00:36:18,745
最后使用这些泛型类型名称
作为参数类型

804
00:36:18,745 --> 00:36:21,481
与写 “any Collection”
和 “any Mailmap” 相比

805
00:36:21,481 --> 00:36:23,417
这简直令人筋疲力尽

806
00:36:23,417 --> 00:36:27,387
因此尽管有缺点
您还是很想使用 any 类型

807
00:36:27,387 --> 00:36:30,190
但这和我之前说的一样

808
00:36:30,190 --> 00:36:32,192
用锤子代替螺丝刀

809
00:36:32,192 --> 00:36:34,728
因为锤子有一个又大又防滑的把手

810
00:36:34,728 --> 00:36:37,264
您不应该做出这样的选择

811
00:36:37,264 --> 00:36:40,100
所以 Swift 让泛型变得更容易使用

812
00:36:40,100 --> 00:36:42,169
和 any 类型一样

813
00:36:42,169 --> 00:36:44,938
如果泛型参数只用在一个地方

814
00:36:44,938 --> 00:36:48,442
您现在可以
用关键字 some 作为速记写法

815
00:36:48,442 --> 00:36:50,844
它甚至支持主要的关联类型

816
00:36:50,844 --> 00:36:53,180
所以您可以用更容易理解的代码

817
00:36:53,180 --> 00:36:55,849
接受所有邮件映射条目集合

818
00:36:55,849 --> 00:36:57,217
在您的工具箱里

819
00:36:57,217 --> 00:37:00,354
没有理由再避免使用泛型了

820
00:37:00,354 --> 00:37:02,890
如果您可以在泛型和 any 类型之间进行选择

821
00:37:02,890 --> 00:37:05,192
泛型将同样易于使用

822
00:37:05,192 --> 00:37:07,995
只写 “some” 而不是 “any” 即可

823
00:37:07,995 --> 00:37:11,198
所以您不妨使用
最好的工具来完成这项工作

824
00:37:11,198 --> 00:37:13,166
我只是讲解了协议和泛型

825
00:37:13,166 --> 00:37:15,068
变更的一些皮毛

826
00:37:15,068 --> 00:37:17,171
为了深入了解

827
00:37:17,171 --> 00:37:19,106
并介绍所有 Swift 泛型功能

828
00:37:19,106 --> 00:37:21,341
今年我们还有两场讲座

829
00:37:21,341 --> 00:37:23,010
即“拥抱 Swift 泛型”

830
00:37:23,010 --> 00:37:25,345
和“在 Swift 中设计协议接口”

831
00:37:28,182 --> 00:37:29,550
现在 Angela 和我差不多介绍了

832
00:37:29,550 --> 00:37:31,785
二十多个 Swift 更改

833
00:37:31,785 --> 00:37:35,255
我们在这次课程中
还有很多没讲到的内容

834
00:37:35,255 --> 00:37:38,692
这些变化中的每一个都

835
00:37:38,692 --> 00:37:41,562
经过了确定标准、提议、审查

836
00:37:41,562 --> 00:37:43,430
并在 Swift 论坛的
Evolution 板上被公开接受

837
00:37:43,430 --> 00:37:45,899
所有这些都是
在 Apple 以外的社区成员

838
00:37:45,899 --> 00:37:48,836
的帮助下成形和得以实现的

839
00:37:48,836 --> 00:37:52,706
如果您是这些人中的一员
感谢各位开发者

840
00:37:52,706 --> 00:37:55,075
让 Swift 5.7 成为一个伟大的版本

841
00:37:55,075 --> 00:37:57,211
如果您想帮助决定接下来的事情

842
00:37:57,211 --> 00:38:02,216
访问 Swift.org/contributing
以了解如何参与

843
00:38:02,216 --> 00:38:03,350
感谢您付出的时间

844
00:38:03,350 --> 00:38:04,952
Angela：编码快乐

845
00:38:06,987 --> 00:38:08,755
[大笑]

846
00:38:08,755 --> 00:38:12,826
♪

