1
00:00:00,000 --> 00:00:03,837
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,837 --> 00:00:09,977
♪

3
00:00:09,977 --> 00:00:12,613
欢迎收看本期视频 本期主题是

4
00:00:12,613 --> 00:00:13,614
采用声明式设备管理

5
00:00:13,614 --> 00:00:15,249
我叫 Cyrus Daboo

6
00:00:15,249 --> 00:00:18,352
是设备管理团队的工程师

7
00:00:18,352 --> 00:00:21,421
本期视频 我将讲述声明式设备管理

8
00:00:21,421 --> 00:00:24,458
加入了哪些激动人心的新功能

9
00:00:24,458 --> 00:00:26,760
在 WWDC 21 大会上

10
00:00:26,760 --> 00:00:30,531
我的同事 Melissa 简要介绍
声明式设备管理

11
00:00:30,531 --> 00:00:33,400
通过这一管理
Apple 设备的新模式

12
00:00:33,400 --> 00:00:37,337
Melissa 表达了
对 MDM 协议本身的全新展望

13
00:00:37,337 --> 00:00:39,239
从其介绍 我们知道了

14
00:00:39,239 --> 00:00:41,508
声明式设备管理功能的强大之处

15
00:00:41,508 --> 00:00:45,412
声明式管理能够
使设备自治 并获得主动

16
00:00:45,412 --> 00:00:47,147
设备自治指的是

17
00:00:47,147 --> 00:00:49,716
设备能够对自身状态变化做出反应

18
00:00:49,716 --> 00:00:52,452
随即无需服务器提示

19
00:00:52,452 --> 00:00:54,788
就能将管理逻辑应用于自己

20
00:00:54,788 --> 00:00:56,290
而设备获得主动意味着

21
00:00:56,290 --> 00:00:58,859
发生重要的状态更改时

22
00:00:58,859 --> 00:01:01,862
服务器可通过状态通道收到异步报告

23
00:01:01,862 --> 00:01:06,166
避免服务器轮询设备

24
00:01:06,166 --> 00:01:07,901
声明式设备管理数据模型

25
00:01:07,901 --> 00:01:10,704
包含两个关键要素

26
00:01:10,704 --> 00:01:13,173
即 声明和状态

27
00:01:13,173 --> 00:01:16,510
声明包括激活函数与谓词

28
00:01:16,510 --> 00:01:20,113
配置 资产 和管理类型

29
00:01:20,113 --> 00:01:24,518
状态包括状态项和状态报告

30
00:01:24,518 --> 00:01:26,987
让我们花点时间说说其重要之处

31
00:01:26,987 --> 00:01:28,856
以及 这对您和您产品的用户组织

32
00:01:28,856 --> 00:01:32,092
都意味着什么

33
00:01:32,092 --> 00:01:34,061
我们创造这项技术的目的是

34
00:01:34,061 --> 00:01:36,897
为了支持新的复杂管理策略

35
00:01:36,897 --> 00:01:40,567
改善设备托管用户的整体体验

36
00:01:40,567 --> 00:01:44,771
为 IT 管理员
减少重复和繁琐的任务

37
00:01:44,771 --> 00:01:47,307
让设备自我驱动

38
00:01:47,307 --> 00:01:50,043
自主管理

39
00:01:50,043 --> 00:01:53,647
如果您是
设备管理解决方案的开发人员

40
00:01:53,647 --> 00:01:56,083
采用声明式 可以让您的服务器

41
00:01:56,083 --> 00:01:58,719
减轻体量 增强反应性

42
00:01:58,719 --> 00:02:00,721
而且 声明式数据模型

43
00:02:00,721 --> 00:02:03,957
能够更紧密地映射到组织结构

44
00:02:03,957 --> 00:02:08,495
也就是说 设备更改会更加简明直观

45
00:02:08,495 --> 00:02:11,265
状态报告包含多样的反馈渠道

46
00:02:11,265 --> 00:02:14,935
使服务器能够更密切地监控设备

47
00:02:14,935 --> 00:02:17,204
并提供相关信息

48
00:02:17,204 --> 00:02:19,740
这种报告方式 更及时 更可靠

49
00:02:19,740 --> 00:02:22,242
不必像轮询设备那样

50
00:02:22,242 --> 00:02:24,478
采用各种复杂策略

51
00:02:24,478 --> 00:02:27,080
综上 声明式管理能够简化开发工作

52
00:02:27,080 --> 00:02:30,417
使您能够专注于设备管理功能

53
00:02:30,417 --> 00:02:33,053
将价值增加在刀刃上

54
00:02:33,053 --> 00:02:37,391
并为客户创建符合喜好的解决方案

55
00:02:37,391 --> 00:02:39,293
如果您是 IT 管理员

56
00:02:39,293 --> 00:02:41,762
如果采用声明式管理

57
00:02:41,762 --> 00:02:44,498
您会对设备是否
处于预期状态更有信心

58
00:02:44,498 --> 00:02:47,234
如果设备并非处于预期状态

59
00:02:47,234 --> 00:02:48,936
所有敏感的组织数据

60
00:02:48,936 --> 00:02:51,972
也会处于被保护的安全状态

61
00:02:51,972 --> 00:02:55,943
即使丢失与服务器的连接也不必担心

62
00:02:55,943 --> 00:03:00,113
声明式管理中的状态报告

63
00:03:00,113 --> 00:03:02,850
提供了来自设备的关键反馈

64
00:03:02,850 --> 00:03:04,918
能够减少网络带宽等资源的占用

65
00:03:04,918 --> 00:03:07,187
进而提高管理员的效率

66
00:03:07,187 --> 00:03:09,223
如果您是组织用户

67
00:03:09,223 --> 00:03:11,592
声明式管理
可以提升设备管理的响应性

68
00:03:11,592 --> 00:03:14,862
增强可靠性 使数据打通更加高效

69
00:03:14,862 --> 00:03:16,430
缩短恢复时间

70
00:03:16,430 --> 00:03:20,167
并更好地获得组织支持

71
00:03:20,167 --> 00:03:22,135
考虑到所有这些好处

72
00:03:22,135 --> 00:03:25,205
再加上我们都知道

73
00:03:25,205 --> 00:03:28,909
未来协议特征必将侧重于
声明式设备管理

74
00:03:28,909 --> 00:03:30,677
对您来说

75
00:03:30,677 --> 00:03:33,013
在现有产品中采用声明式设备管理

76
00:03:33,013 --> 00:03:36,383
显得愈发重要

77
00:03:36,383 --> 00:03:39,386
如果您希望
进一步了解声明式设备管理

78
00:03:39,386 --> 00:03:41,455
以及采用步骤

79
00:03:41,455 --> 00:03:46,326
请务必观看
WWDC 21 讲座视频

80
00:03:46,326 --> 00:03:49,363
在此版本中
我们将重点放在了三个领域上

81
00:03:49,363 --> 00:03:52,633
扩大声明式设备管理的范围

82
00:03:52,633 --> 00:03:57,304
增强状态报告 以及增强谓词

83
00:03:57,304 --> 00:03:59,439
让我们先来说说

84
00:03:59,439 --> 00:04:02,543
扩大声明式设备管理的范围

85
00:04:02,543 --> 00:04:05,078
声明式设备管理在刚推出时

86
00:04:05,078 --> 00:04:08,749
只有用户注册模式的 iOS
可以支持

87
00:04:08,749 --> 00:04:11,485
现在 声明式设备管理可用于

88
00:04:11,485 --> 00:04:15,355
所有 MDM 支持的注册类型

89
00:04:15,355 --> 00:04:17,024
例如 包括受监督设备在内的

90
00:04:17,024 --> 00:04:19,893
自动设备注册

91
00:04:19,893 --> 00:04:21,795
基于个人资料的注册

92
00:04:21,795 --> 00:04:25,465
以及基于个人资料和帐户的用户注册

93
00:04:25,465 --> 00:04:28,402
现在 共享 iPad 也同样适用

94
00:04:28,402 --> 00:04:30,938
声明式设备管理

95
00:04:30,938 --> 00:04:34,474
iOS 16 的用户
可以通过“设置”

96
00:04:34,474 --> 00:04:38,545
在 MDM 配置文件
详细信息视图中找到配置

97
00:04:38,545 --> 00:04:41,748
点击配置行可查看

98
00:04:41,748 --> 00:04:44,852
活动配置相关的详细信息

99
00:04:44,852 --> 00:04:47,354
还有 我很高兴能在此宣布

100
00:04:47,354 --> 00:04:49,656
现在 MDM 支持的每个平台

101
00:04:49,656 --> 00:04:53,227
都能够使用声明式设备管理

102
00:04:53,227 --> 00:04:56,997
macOS Ventura
支持声明式管理

103
00:04:56,997 --> 00:05:01,435
macOS 支持的
所有 MDM 注册类型皆适用

104
00:05:01,435 --> 00:05:04,938
tvOS 16 也支持声明式管理

105
00:05:04,938 --> 00:05:08,509
所有 MDM 设备注册
类型也都适用

106
00:05:08,509 --> 00:05:10,310
在操作系统支持的情况下

107
00:05:10,310 --> 00:05:12,446
凡是在 iOS 上可用的

108
00:05:12,446 --> 00:05:14,248
声明和状态集

109
00:05:14,248 --> 00:05:18,852
在 macOS
和 tvOS 也同样适用

110
00:05:18,852 --> 00:05:21,889
macOS 的配置部分显示在

111
00:05:21,889 --> 00:05:24,191
MDM 配置文件详细信息视图中

112
00:05:24,191 --> 00:05:26,894
可以查看活动配置

113
00:05:26,894 --> 00:05:30,430
tvOS 也是如此 其配置部分

114
00:05:30,430 --> 00:05:34,635
显示在 MDM 配置文件
详细信息视图中

115
00:05:34,635 --> 00:05:36,336
最后需要注意的是

116
00:05:36,336 --> 00:05:39,006
macOS 和
共享 iPad 设备

117
00:05:39,006 --> 00:05:41,375
都有两个 MDM 通道

118
00:05:41,375 --> 00:05:44,745
即 设备通道和用户通道

119
00:05:44,745 --> 00:05:46,446
设备通道允许管理

120
00:05:46,446 --> 00:05:47,981
设备级状态

121
00:05:47,981 --> 00:05:50,217
用户通道则针对管理

122
00:05:50,217 --> 00:05:52,419
特定用户的状态

123
00:05:52,419 --> 00:05:55,322
要在任何通道上使用声明式设备管理

124
00:05:55,322 --> 00:05:58,392
都必须为该通道单独启用

125
00:05:58,392 --> 00:06:01,228
也就是必须在相应的频道上

126
00:06:01,228 --> 00:06:03,664
分别发送声明式管理命令

127
00:06:03,664 --> 00:06:07,100
此外 声明性设备管理的状态报告

128
00:06:07,100 --> 00:06:09,870
也会单独为各通道生成

129
00:06:09,870 --> 00:06:14,374
同样需要分别监控

130
00:06:14,374 --> 00:06:19,847
接下来是第二个重点领域：状态报告

131
00:06:19,847 --> 00:06:23,116
让我们快速回顾一下状态报告

132
00:06:23,116 --> 00:06:26,486
这指的是
设备可以逐步向服务器报告状态

133
00:06:26,486 --> 00:06:29,022
订阅状态项

134
00:06:29,022 --> 00:06:32,092
设备通过跟踪来自服务器的成功响应

135
00:06:32,092 --> 00:06:34,461
来确保状态更新无误

136
00:06:34,461 --> 00:06:36,730
而遇到网络或其他问题时

137
00:06:36,730 --> 00:06:39,233
也不会错过更新

138
00:06:39,233 --> 00:06:42,503
设备通过状态报告获得了主动

139
00:06:42,503 --> 00:06:45,606
服务器不必再为了观察状态变化

140
00:06:45,606 --> 00:06:47,741
而不断轮询设备

141
00:06:47,741 --> 00:06:51,645
在 iOS 15 中
我们引入了一组状态项

142
00:06:51,645 --> 00:06:54,348
以适应各种设备属性 例如模型类型

143
00:06:54,348 --> 00:06:56,917
和各操作系统版本

144
00:06:56,917 --> 00:07:01,054
本次我们将在三个方面扩展状态

145
00:07:01,054 --> 00:07:02,923
密码状态

146
00:07:02,923 --> 00:07:05,359
通过配置安装的帐户

147
00:07:05,359 --> 00:07:08,896
和 MDM 安装 App

148
00:07:08,896 --> 00:07:12,232
我们从密码状态开始说起

149
00:07:12,232 --> 00:07:16,803
在 iOS 15 中
我们引入了密码策略配置

150
00:07:16,803 --> 00:07:20,474
当用户更改密码时

151
00:07:20,474 --> 00:07:22,643
策略的应用和密码合规

152
00:07:22,643 --> 00:07:24,478
可能存在一定时间差

153
00:07:24,478 --> 00:07:28,148
MDM 密码策略配置文件也是如此

154
00:07:28,148 --> 00:07:31,652
因此 MDM 服务器必须轮询设备

155
00:07:31,652 --> 00:07:34,021
才能确定密码什么时候合规

156
00:07:34,021 --> 00:07:36,089
但如果应用了新的
声明式设备管理密码状态项

157
00:07:36,089 --> 00:07:40,794
就没有必要这样做了

158
00:07:40,794 --> 00:07:43,897
我们添加了两个状态项

159
00:07:43,897 --> 00:07:48,836
passcode.is-compliant
和 passcode.is-present

160
00:07:48,836 --> 00:07:51,338
合规性用于指示密码是否符合

161
00:07:51,338 --> 00:07:54,741
通过 MDM 文件或配置应用的

162
00:07:54,741 --> 00:07:57,211
所有密码策略

163
00:07:57,211 --> 00:07:59,546
这些状态项具有布尔值

164
00:07:59,546 --> 00:08:01,481
能够反映那些可通过 MDM 查询

165
00:08:01,481 --> 00:08:05,452
检索到的等价属性

166
00:08:05,452 --> 00:08:08,856
让我们探索一个典型的服务器行为

167
00:08:08,856 --> 00:08:12,359
一般来说 组织都会在设备上

168
00:08:12,359 --> 00:08:14,061
应用安全敏感状态

169
00:08:14,061 --> 00:08:17,364
例如 只允许 VPN
或 Wi-Fi 配置文件

170
00:08:17,364 --> 00:08:21,001
访问受保护的网络

171
00:08:21,001 --> 00:08:23,837
而在设备启用该状态必须有个前提

172
00:08:23,837 --> 00:08:26,907
那就是存在强密码策略

173
00:08:26,907 --> 00:08:31,078
且密码符合该策略

174
00:08:31,078 --> 00:08:33,780
在传统的 MDM 中
当用户更改密码时

175
00:08:33,780 --> 00:08:37,184
服务器必须先发送密码策略配置文件

176
00:08:37,184 --> 00:08:39,586
然后轮询设备

177
00:08:39,586 --> 00:08:41,455
等待密码合规

178
00:08:41,455 --> 00:08:44,558
最初密码可能不合规

179
00:08:44,558 --> 00:08:48,195
导致无法发送
Wi-Fi 配置文件

180
00:08:48,195 --> 00:08:50,764
最后 用户更改密码

181
00:08:50,764 --> 00:08:52,599
才能使其合规

182
00:08:52,599 --> 00:08:54,134
接着 服务器在下一次轮询中

183
00:08:54,134 --> 00:08:57,337
检测到更改后的合规状态

184
00:08:57,337 --> 00:09:01,108
确定可以发送
Wi-Fi 配置文件

185
00:09:01,108 --> 00:09:04,444
然后才能将其安装在设备上

186
00:09:04,444 --> 00:09:06,947
声明式设备管理的激活函数谓词

187
00:09:06,947 --> 00:09:10,350
能够被密码的合规状态触发

188
00:09:10,350 --> 00:09:13,520
因此免去了服务器轮询

189
00:09:13,520 --> 00:09:15,622
服务器将密码策略
和 Wi-Fi 配置文件

190
00:09:15,622 --> 00:09:18,859
作为配置同时发送

191
00:09:18,859 --> 00:09:21,962
且 Wi-Fi 配置绑定于

192
00:09:21,962 --> 00:09:25,199
基于密码合规性的激活函数

193
00:09:25,199 --> 00:09:27,835
可以立即激活密码配置

194
00:09:27,835 --> 00:09:31,205
并应用强大的密码策略

195
00:09:31,205 --> 00:09:34,007
密码可能在最开始显示不合规

196
00:09:34,007 --> 00:09:36,910
导致激活谓词求值为假

197
00:09:36,910 --> 00:09:40,347
Wi-Fi 配置保持未激活状态

198
00:09:40,347 --> 00:09:44,551
等到用户更新密码 使其合规后

199
00:09:44,551 --> 00:09:47,821
会触发对激活函数的重新求值

200
00:09:47,821 --> 00:09:50,591
这时候 谓词求值就会为真

201
00:09:50,591 --> 00:09:54,628
并激活 Wi-Fi 配置

202
00:09:54,628 --> 00:09:58,365
以上过程完全不需要服务器的干预

203
00:09:58,365 --> 00:10:01,034
甚至也不需要

204
00:10:01,034 --> 00:10:03,670
和现存服务器进行连接

205
00:10:03,670 --> 00:10:06,273
而当配置激活时

206
00:10:06,273 --> 00:10:09,176
服务器会自动从设备获取状态报告

207
00:10:09,176 --> 00:10:11,845
因此 服务器知道何时发生变化

208
00:10:11,845 --> 00:10:14,748
以上过程说明了我们成功地

209
00:10:14,748 --> 00:10:17,751
将业务逻辑从服务器移动到设备

210
00:10:17,751 --> 00:10:19,319
并避免轮询的过程

211
00:10:19,319 --> 00:10:24,291
设备行为也能够因此
变得更灵敏 更可靠

212
00:10:24,291 --> 00:10:27,895
现在 让我们转向帐户状态

213
00:10:27,895 --> 00:10:31,398
在 iOS 15 中
我们引入了账户配置

214
00:10:31,398 --> 00:10:34,968
以在设备上安装各种类型的帐户

215
00:10:34,968 --> 00:10:37,538
通常都是组织帐户

216
00:10:37,538 --> 00:10:41,008
用来授予用户访问组织数据的权限

217
00:10:41,008 --> 00:10:44,044
能够知道账户合适成功安装

218
00:10:44,044 --> 00:10:45,812
以及账户处于什么状态

219
00:10:45,812 --> 00:10:47,548
对管理员来说是很有用的功能

220
00:10:47,548 --> 00:10:51,451
方便管理员支持可能遇到问题的用户

221
00:10:51,451 --> 00:10:55,722
此版本为邮件 日历和其他帐户类型

222
00:10:55,722 --> 00:10:58,325
添加了八个帐户状态项

223
00:10:58,325 --> 00:11:01,261
请注意 该状态仅会报告

224
00:11:01,261 --> 00:11:03,063
通过配置安装的帐户

225
00:11:03,063 --> 00:11:05,666
且手动创建的帐户

226
00:11:05,666 --> 00:11:08,969
或通过 MDM 配置文件
安装的账户也不适用

227
00:11:08,969 --> 00:11:11,104
每个新的状态项

228
00:11:11,104 --> 00:11:13,073
都和帐户配置类型对应

229
00:11:13,073 --> 00:11:16,043
对于接收和发送邮件的帐户

230
00:11:16,043 --> 00:11:18,345
其状态会被分别报告

231
00:11:18,345 --> 00:11:22,249
每个新的状态项
使用不同类型的 JSON 对象

232
00:11:22,249 --> 00:11:26,253
来表示对应账户类型的状态

233
00:11:26,253 --> 00:11:29,556
以下是接收邮件状态项

234
00:11:29,556 --> 00:11:32,993
和订阅日历状态项的示例

235
00:11:32,993 --> 00:11:36,063
对于状态项对象数组中的对象

236
00:11:36,063 --> 00:11:39,600
标识符键的值是唯一标识符

237
00:11:39,600 --> 00:11:42,002
稍后会详细介绍

238
00:11:42,002 --> 00:11:44,872
声明标识符键的值

239
00:11:44,872 --> 00:11:46,773
匹配安装帐户的配置文件的

240
00:11:46,773 --> 00:11:49,343
标识符属性值

241
00:11:49,343 --> 00:11:51,211
更易于交叉引用

242
00:11:51,211 --> 00:11:55,415
状态项对象及其相关配置

243
00:11:55,415 --> 00:11:57,851
这两个键始终存在于

244
00:11:57,851 --> 00:12:01,188
所有类型的帐户状态项对象中

245
00:12:01,188 --> 00:12:03,790
其余键则针对特定帐户类型

246
00:12:03,790 --> 00:12:06,960
例如 邮件服务器的主机名和端口

247
00:12:06,960 --> 00:12:11,164
或已订阅日历的日历链接

248
00:12:11,164 --> 00:12:15,469
此版本引入了值为数组的状态项

249
00:12:15,469 --> 00:12:17,704
支持报告一个或多个

250
00:12:17,704 --> 00:12:19,473
同类型帐户

251
00:12:19,473 --> 00:12:22,809
这样的数组值具有特殊行为

252
00:12:22,809 --> 00:12:25,712
数组中的每一项
都是一个 JSON 对象

253
00:12:25,712 --> 00:12:30,083
其模式和用于单个数组中
所有对象的相同

254
00:12:30,083 --> 00:12:32,986
每个对象类型都有一个标识符键

255
00:12:32,986 --> 00:12:35,822
作为在数组内定位对象

256
00:12:35,822 --> 00:12:37,424
的主键

257
00:12:37,424 --> 00:12:38,859
还有其他键

258
00:12:38,859 --> 00:12:42,196
与所报告的基本状态类型相关联

259
00:12:42,196 --> 00:12:44,498
为了能够前向兼容

260
00:12:44,498 --> 00:12:47,467
未来操作系统版本中可能添加的键

261
00:12:47,467 --> 00:12:52,506
您的服务器必须能够接受
数组对象中的未知键

262
00:12:52,506 --> 00:12:55,075
为了性能考虑

263
00:12:55,075 --> 00:12:57,211
凡是数组值的更改

264
00:12:57,211 --> 00:13:01,181
都会基于单个对象逐步报告到服务器

265
00:13:01,181 --> 00:13:02,716
让我们来看个例子

266
00:13:02,716 --> 00:13:05,886
看看这个新功能是如何工作的

267
00:13:05,886 --> 00:13:07,187
在这个例子中

268
00:13:07,187 --> 00:13:09,756
服务器向设备发送了

269
00:13:09,756 --> 00:13:10,991
两个邮件账户配置

270
00:13:10,991 --> 00:13:14,228
由于两个账户都处于活动状态

271
00:13:14,228 --> 00:13:16,330
因此设备上存在着两个邮件帐户

272
00:13:16,330 --> 00:13:18,465
服务器现在发送信号

273
00:13:18,465 --> 00:13:21,001
订阅邮件帐户状态项

274
00:13:21,001 --> 00:13:23,203
订阅激活后

275
00:13:23,203 --> 00:13:25,239
会收集帐户状态

276
00:13:25,239 --> 00:13:29,209
且设备会向服务器发送状态报告

277
00:13:29,209 --> 00:13:32,546
状态报告将包括在状态数组中的

278
00:13:32,546 --> 00:13:34,214
两个帐户状态对象

279
00:13:34,214 --> 00:13:35,849
使服务器能对设备当前内容

280
00:13:35,849 --> 00:13:38,852
有全面的了解

281
00:13:38,852 --> 00:13:42,089
每个数组对象都有不同的标识符

282
00:13:42,089 --> 00:13:44,124
处理完这份报告后

283
00:13:44,124 --> 00:13:46,660
服务器储存着两个邮件帐户的状态

284
00:13:46,660 --> 00:13:49,530
和设备上的内容一致

285
00:13:49,530 --> 00:13:52,132
当服务器通过发送新配置

286
00:13:52,132 --> 00:13:55,802
以在设备上添加邮件帐户时
设备上的状态项

287
00:13:55,802 --> 00:13:58,906
在其数组值中添加了一个新对象

288
00:13:58,906 --> 00:14:03,143
又向服务器发送了一份状态报告

289
00:14:03,143 --> 00:14:05,712
该报告仅反映了新项目

290
00:14:05,712 --> 00:14:08,615
由于标识符键的值

291
00:14:08,615 --> 00:14:10,350
与服务器已知的都不匹配

292
00:14:10,350 --> 00:14:15,155
服务器因此可以推断出
该标识符来自新帐户

293
00:14:15,155 --> 00:14:16,623
处理完这份报告后

294
00:14:16,623 --> 00:14:19,359
服务器储存着三个邮件帐户的状态

295
00:14:19,359 --> 00:14:21,929
两个初始账户和一个新账户

296
00:14:21,929 --> 00:14:25,933
依旧与设备内容完全一致

297
00:14:25,933 --> 00:14:27,901
当账户状态发生变化时

298
00:14:27,901 --> 00:14:31,705
例如当用户切换邮件
或便笺启用状态时

299
00:14:31,705 --> 00:14:33,440
设备上的状态项

300
00:14:33,440 --> 00:14:36,643
将在其数组值中增加一个更新对象

301
00:14:36,643 --> 00:14:41,014
于是状态报告再次被发送到服务器

302
00:14:41,014 --> 00:14:43,517
且仅报告更改的项目

303
00:14:43,517 --> 00:14:46,320
在这个例子中 用户关闭了账户中的

304
00:14:46,320 --> 00:14:47,921
便笺功能

305
00:14:47,921 --> 00:14:49,923
标识符键的值

306
00:14:49,923 --> 00:14:52,159
和服务器储存的其中之一相匹配

307
00:14:52,159 --> 00:14:54,962
所以 服务器可以推断出这是

308
00:14:54,962 --> 00:14:56,330
一次现有帐户的更新

309
00:14:56,330 --> 00:14:57,531
然后

310
00:14:57,531 --> 00:15:00,434
服务器用新对象替换了

311
00:15:00,434 --> 00:15:02,769
现有的状态项数组对象

312
00:15:02,769 --> 00:15:04,438
处理完这份报告后

313
00:15:04,438 --> 00:15:07,074
服务器储存着三个邮件帐户的状态

314
00:15:07,074 --> 00:15:09,943
其中之一经历了更改

315
00:15:09,943 --> 00:15:13,080
从设备中删除帐户配置时

316
00:15:13,080 --> 00:15:14,615
设备上的状态项

317
00:15:14,615 --> 00:15:17,684
会被打上相应的对象标记 以示删除

318
00:15:17,684 --> 00:15:21,788
又一份状态报告被发送到服务器

319
00:15:21,788 --> 00:15:24,258
仅报告已删除的项目

320
00:15:24,258 --> 00:15:25,859
为了表示删除

321
00:15:25,859 --> 00:15:29,429
数组项对象仅包含两个键

322
00:15:29,429 --> 00:15:30,998
首先是 标识符键

323
00:15:30,998 --> 00:15:33,767
其值与服务器已有的值相匹配

324
00:15:33,767 --> 00:15:37,471
其次是删除键 其值被设置为真

325
00:15:37,471 --> 00:15:40,374
有了这两个键 服务器就能够

326
00:15:40,374 --> 00:15:44,511
通过删除现有项目来更新设备状态

327
00:15:44,511 --> 00:15:46,380
处理完这份报告后

328
00:15:46,380 --> 00:15:49,216
服务器只储存着两个邮件帐户的状态

329
00:15:49,216 --> 00:15:52,953
和设备现状完全一致

330
00:15:52,953 --> 00:15:55,923
关于状态报告 我还有最后一点要说

331
00:15:55,923 --> 00:15:59,226
设备会限制状态报告的发送速率

332
00:15:59,226 --> 00:16:01,528
以避免性能出现问题

333
00:16:01,528 --> 00:16:04,565
在最长为 1 分钟的时间间隔内

334
00:16:04,565 --> 00:16:07,334
设备会整合状态项的更改

335
00:16:07,334 --> 00:16:10,571
再向服务器发送状态报告

336
00:16:10,571 --> 00:16:13,006
也就是说 设备状态的报告速度虽快

337
00:16:13,006 --> 00:16:15,676
却不是即时的

338
00:16:15,676 --> 00:16:17,544
接下来 让我们换个方向

339
00:16:17,544 --> 00:16:20,514
看看该如何解决
长期存在的 MDM 瓶颈

340
00:16:20,514 --> 00:16:24,051
即 监控 App 安装状态

341
00:16:24,051 --> 00:16:28,822
MDM 服务器通常需要
在设备上安装 App

342
00:16:28,822 --> 00:16:32,659
才能授权用户访问其
工作或教育所需的工具

343
00:16:32,659 --> 00:16:34,862
通常来说 App 是否安装成功

344
00:16:34,862 --> 00:16:37,998
决定了服务器端的逻辑

345
00:16:37,998 --> 00:16:42,102
所以 MDM 服务器
需要监控 App 安装进度

346
00:16:42,102 --> 00:16:46,106
还要注意用户是否会删除

347
00:16:46,106 --> 00:16:48,876
设备上的托管 App

348
00:16:48,876 --> 00:16:53,146
目前 MDM 服务器可以使用
InstalledApplicationList

349
00:16:53,146 --> 00:16:56,350
或 ManagedApplicationList
命令来轮询设备

350
00:16:56,350 --> 00:16:59,586
以观察 App 安装进度

351
00:16:59,586 --> 00:17:02,089
而我们可以通过让设备主动
向服务器反映应用安装进度

352
00:17:02,089 --> 00:17:06,059
来避免轮询

353
00:17:06,059 --> 00:17:07,327
所需要用到的工具就是

354
00:17:07,327 --> 00:17:12,199
声明式设备管理状态报告

355
00:17:12,199 --> 00:17:15,469
此版本添加了一个
mdm.app 状态项

356
00:17:15,469 --> 00:17:19,139
其值是一个对象数组
每个对象代表一个

357
00:17:19,139 --> 00:17:22,142
已由 MDM 服务器
安装的 App

358
00:17:22,142 --> 00:17:25,612
由于值是数组 所以
其采用的是增量式报告

359
00:17:25,612 --> 00:17:28,115
这一过程我们之前已经描述过了

360
00:17:28,115 --> 00:17:31,985
请注意 即使在受监督的设备上此

361
00:17:31,985 --> 00:17:35,189
也只有 MDM 安装的 App
会被报告

362
00:17:35,189 --> 00:17:38,358
此状态报告包含

363
00:17:38,358 --> 00:17:40,494
已安装完成应用的状态项

364
00:17:40,494 --> 00:17:43,163
对于数组项对象

365
00:17:43,163 --> 00:17:45,599
标识符键是唯一标识符
在这种情况下

366
00:17:45,599 --> 00:17:48,168
标识符键
也是 App 的捆绑标识符

367
00:17:48,168 --> 00:17:51,171
name 键表示 App 的名称

368
00:17:51,171 --> 00:17:54,007
三个 version 键
分别是普通 简要

369
00:17:54,007 --> 00:17:57,044
和外部版本标识符

370
00:17:57,044 --> 00:17:58,912
而 state 键则用于指明

371
00:17:58,912 --> 00:18:02,850
App 当前的安装阶段

372
00:18:02,850 --> 00:18:04,852
这些键的值和

373
00:18:04,852 --> 00:18:07,054
MDM 托管 App 列表
命令响应中的等价项

374
00:18:07,054 --> 00:18:10,190
相互对应

375
00:18:10,190 --> 00:18:13,927
有了这些信息
服务器可以立即识别出

376
00:18:13,927 --> 00:18:18,765
正在报告哪个 App
以及该 App 正处于什么状态

377
00:18:18,765 --> 00:18:22,903
以某个 App 安装时的
数据流为示例

378
00:18:22,903 --> 00:18:25,739
右侧是一台 iOS 16 设备

379
00:18:25,739 --> 00:18:28,575
由 MDM 服务器管理

380
00:18:28,575 --> 00:18:31,979
其服务器已启用了声明式设备管理

381
00:18:31,979 --> 00:18:33,647
并发送了对于
MDM 安装 App 状态项

382
00:18:33,647 --> 00:18:37,050
的状态订阅

383
00:18:37,050 --> 00:18:39,720
服务器下一步要做的是

384
00:18:39,720 --> 00:18:43,223
通过 MDM 命令安装 App

385
00:18:43,223 --> 00:18:46,627
由于是用户注册
安装 App 需要用户批准

386
00:18:46,627 --> 00:18:49,296
所以当设备处理
App 安装命令时

387
00:18:49,296 --> 00:18:52,699
会出现弹窗提示

388
00:18:52,699 --> 00:18:55,869
此时 安装进度暂停

389
00:18:55,869 --> 00:18:58,605
等待用户输入

390
00:18:58,605 --> 00:19:01,542
设备将向服务器发送状态报告

391
00:19:01,542 --> 00:19:05,646
报告内容包括单个
MDM 安装 App 的状态对象

392
00:19:05,646 --> 00:19:10,284
以及 App 的捆绑 ID
和弹窗提示状态

393
00:19:10,284 --> 00:19:13,086
有时候 当用户点击安装按钮

394
00:19:13,086 --> 00:19:16,857
设备随即开始安装 App

395
00:19:16,857 --> 00:19:20,694
随着安装的进行
将发送另一个状态报告

396
00:19:20,694 --> 00:19:23,830
这次将应用状态设置为正在安装

397
00:19:23,830 --> 00:19:28,302
表示正在下载和安装该 App

398
00:19:28,302 --> 00:19:30,537
知道最后 App 完成安装

399
00:19:30,537 --> 00:19:32,706
可以投入使用

400
00:19:32,706 --> 00:19:35,242
此时 将发送另一个状态报告

401
00:19:35,242 --> 00:19:37,444
将应用状态设置为托管

402
00:19:37,444 --> 00:19:41,381
表明 App 已正确安装和管理

403
00:19:41,381 --> 00:19:46,086
现在假设用户
手动删除了设备上的 App

404
00:19:46,086 --> 00:19:48,555
同样 设备将发送状态报告

405
00:19:48,555 --> 00:19:53,260
这次 App 状态将被设置为
托管但已卸载

406
00:19:53,260 --> 00:19:55,896
表明该 App 不再处于安装状态

407
00:19:55,896 --> 00:19:58,498
但仍在设备上

408
00:19:58,498 --> 00:20:00,701
跟踪其管理状态

409
00:20:00,701 --> 00:20:02,836
假设服务器要删除

410
00:20:02,836 --> 00:20:04,771
应用管理状态

411
00:20:04,771 --> 00:20:07,808
为了实现这一点 服务器会向设备

412
00:20:07,808 --> 00:20:09,343
发送 App 删除命令

413
00:20:09,343 --> 00:20:12,312
这样就删除了原本的管理状态

414
00:20:12,312 --> 00:20:14,648
且如果 App 仍然存在

415
00:20:14,648 --> 00:20:17,284
这时也会被删除

416
00:20:17,284 --> 00:20:19,753
接下来 被标记为已从
应用状态数组中移除的 App 对象

417
00:20:19,753 --> 00:20:22,823
将与另一份状态报告一起发送

418
00:20:22,823 --> 00:20:26,727
通过以上说明 我们了解了
新 MDM 状态项的强大功能

419
00:20:26,727 --> 00:20:28,595
它能够帮助提高响应能力

420
00:20:28,595 --> 00:20:30,964
也能增强 App 安装的可靠性

421
00:20:30,964 --> 00:20:35,002
而且简单便捷
只需几个步骤即可实施

422
00:20:35,002 --> 00:20:40,374
接下来 让我们看看
第三个重点领域 谓词

423
00:20:40,374 --> 00:20:43,343
先快速回顾一下激活谓词

424
00:20:43,343 --> 00:20:45,913
激活函数包括一个可选谓词

425
00:20:45,913 --> 00:20:47,981
以确定激活中引用的配置

426
00:20:47,981 --> 00:20:52,119
是否将应用于设备

427
00:20:52,119 --> 00:20:53,854
谓词可以引用状态项

428
00:20:53,854 --> 00:20:57,824
以便测试状态项的值

429
00:20:57,824 --> 00:21:00,594
当谓词中引用的状态项发生更改时

430
00:21:00,594 --> 00:21:03,664
设备将重新处理所有激活函数

431
00:21:03,664 --> 00:21:06,567
重新对所有谓词求值

432
00:21:06,567 --> 00:21:08,402
NSPredicate
即谓词语法

433
00:21:08,402 --> 00:21:10,404
谓词被指定为字符串

434
00:21:10,404 --> 00:21:13,574
记录在 Apple Developer 网站上

435
00:21:13,574 --> 00:21:16,677
为了支持更复杂的谓词表达式

436
00:21:16,677 --> 00:21:19,813
我们扩展了谓词语法

437
00:21:19,813 --> 00:21:23,684
使其更容易检测出表达式中的状态项

438
00:21:23,684 --> 00:21:26,320
在新语法中 状态项名称被放置于

439
00:21:26,320 --> 00:21:30,457
谓词字符串中的
@status 项内

440
00:21:30,457 --> 00:21:33,493
在示例中 序列号状态项

441
00:21:33,493 --> 00:21:35,329
运用使用新语法

442
00:21:35,329 --> 00:21:38,332
出现在谓词表达式中

443
00:21:38,332 --> 00:21:40,267
以前的语法依然有效

444
00:21:40,267 --> 00:21:44,538
但是为了向后兼容
旧语法已被弃用了

445
00:21:44,538 --> 00:21:47,641
所以 请您采用新语法

446
00:21:47,641 --> 00:21:49,576
让我们看看面对状态项数组值时

447
00:21:49,576 --> 00:21:52,012
谓词是如何运作的

448
00:21:52,012 --> 00:21:55,048
正如之前的流程 现在有了状态项值

449
00:21:55,048 --> 00:21:56,884
其指的是帐户的数组

450
00:21:56,884 --> 00:21:59,786
和 MDM
安装 App 的状态项

451
00:21:59,786 --> 00:22:02,523
能够在数组的某个项目上触发激活

452
00:22:02,523 --> 00:22:05,158
会很有帮助

453
00:22:05,158 --> 00:22:08,562
比如说 在设备上安装和管理

454
00:22:08,562 --> 00:22:10,964
具有特定捆绑标识符的 App 时

455
00:22:10,964 --> 00:22:14,568
我们可能需要触发激活

456
00:22:14,568 --> 00:22:16,870
NSPredicate
有一个子查询词条

457
00:22:16,870 --> 00:22:20,240
可用于对数组进行操作

458
00:22:20,240 --> 00:22:23,143
此 NSPredicate
表达式使用的子查询

459
00:22:23,143 --> 00:22:26,813
正针对着 MDM
安装 App 状态项

460
00:22:26,813 --> 00:22:30,984
状态项被用作子查询的第一个参数

461
00:22:30,984 --> 00:22:33,086
第二个参数定义了一个变量

462
00:22:33,086 --> 00:22:35,756
该变量将引用数组的每个元素

463
00:22:35,756 --> 00:22:38,025
第三个参数是谓词表达式

464
00:22:38,025 --> 00:22:42,496
用于测试由该变量标识的每个元素

465
00:22:42,496 --> 00:22:45,399
子查询表达式返回一个
与第三参数中的谓词

466
00:22:45,399 --> 00:22:48,702
相匹配的元素数组

467
00:22:48,702 --> 00:22:51,638
接着 @count 运算符
返回该数组的长度

468
00:22:51,638 --> 00:22:53,774
并且对其长度进行检查

469
00:22:53,774 --> 00:22:57,477
以确定是否存在结果匹配

470
00:22:57,477 --> 00:23:00,447
安装和管理指定的 App 时

471
00:23:00,447 --> 00:23:02,749
该子查询表达式将用一个元素

472
00:23:02,749 --> 00:23:04,451
返回一个数组

473
00:23:04,451 --> 00:23:07,454
此时谓词求值将为真

474
00:23:07,454 --> 00:23:10,357
未安装应用时 子查询表达式

475
00:23:10,357 --> 00:23:12,092
将返回一个空数组

476
00:23:12,092 --> 00:23:15,696
且谓词求值将为假

477
00:23:15,696 --> 00:23:18,232
请注意 为了
在状态项数组对象中引用键

478
00:23:18,232 --> 00:23:21,802
必须使用 @key 扩展项

479
00:23:21,802 --> 00:23:25,839
来确保关键路径被正确处理

480
00:23:25,839 --> 00:23:28,542
新的谓词语法是可扩展的

481
00:23:28,542 --> 00:23:30,978
我们现在说说该怎么使用新语法

482
00:23:30,978 --> 00:23:35,782
来为一种新型数据添加谓词

483
00:23:35,782 --> 00:23:38,418
服务器需要的是
能够更直接地控制谓词求值

484
00:23:38,418 --> 00:23:42,222
以便将复杂的服务器端逻辑

485
00:23:42,222 --> 00:23:45,592
转化为设备上的简单状态变化

486
00:23:45,592 --> 00:23:48,896
并且无需为了实现这些变化

487
00:23:48,896 --> 00:23:51,131
而大量同步配置

488
00:23:51,131 --> 00:23:54,401
举个例子 有这个需求的组织

489
00:23:54,401 --> 00:23:57,237
可能希望在将设备分发给用户时

490
00:23:57,237 --> 00:23:59,072
能够高效 即时地
将设备分配给多个角色

491
00:23:59,072 --> 00:24:03,010
也有可能 该组织需要的是

492
00:24:03,010 --> 00:24:05,646
能够快速分发替换设备

493
00:24:05,646 --> 00:24:07,814
或快速开启设备的安全模式

494
00:24:07,814 --> 00:24:10,517
来保护组织数据

495
00:24:10,517 --> 00:24:13,187
我很高兴能告诉开发者
为了满足以上需求

496
00:24:13,187 --> 00:24:16,356
我们正在添加一个新的声明

497
00:24:16,356 --> 00:24:19,059
以允许服务器在设备上设置任意属性

498
00:24:19,059 --> 00:24:22,329
用于直接激活谓词

499
00:24:22,329 --> 00:24:26,867
这就是新的管理属性声明

500
00:24:26,867 --> 00:24:29,503
该声明由一个 JSON 对象组成

501
00:24:29,503 --> 00:24:33,006
其键名由服务器定义

502
00:24:33,006 --> 00:24:36,643
JSON 对象值可以
是任何 JSON 值类型

503
00:24:36,643 --> 00:24:39,646
包括数组或对象

504
00:24:39,646 --> 00:24:41,582
屏幕上的管理属性声明

505
00:24:41,582 --> 00:24:44,952
包括三个属性 其中姓名和年龄

506
00:24:44,952 --> 00:24:47,254
具有字符串和整数值

507
00:24:47,254 --> 00:24:51,725
而角色属性则是字符串数组

508
00:24:51,725 --> 00:24:54,094
这是一个带有谓词的激活函数

509
00:24:54,094 --> 00:24:56,930
引用了一些管理属性

510
00:24:56,930 --> 00:24:59,967
该函数首先会测试年龄属性

511
00:24:59,967 --> 00:25:03,704
判断其整数值是否
大于 18 或等于 18

512
00:25:03,704 --> 00:25:06,473
接着 该函数会测试角色属性

513
00:25:06,473 --> 00:25:11,578
判断属性数组值中
是否出现字符串“12 年级”

514
00:25:11,578 --> 00:25:12,846
每个属性的引用都使用了

515
00:25:12,846 --> 00:25:15,449
@property 扩展术语

516
00:25:15,449 --> 00:25:19,653
且属性键名称就属于该类术语

517
00:25:19,653 --> 00:25:21,688
虽然可以向设备发送

518
00:25:21,688 --> 00:25:23,290
多个管理属性声明

519
00:25:23,290 --> 00:25:26,693
但所有键名都应该互不重复

520
00:25:26,693 --> 00:25:29,463
如果键名重复 则引用属性时

521
00:25:29,463 --> 00:25:32,466
其值会随机被谓语引用

522
00:25:32,466 --> 00:25:35,836
导致难以预料的结果

523
00:25:35,836 --> 00:25:39,473
所以 请避免使用重复的键名

524
00:25:39,473 --> 00:25:43,076
让我们来看一个使用案例

525
00:25:43,076 --> 00:25:45,412
该系统由一所学校采用

526
00:25:45,412 --> 00:25:48,649
学校里有很多教师 这点不用多说

527
00:25:48,649 --> 00:25:52,886
这所学校分为两个学部
高年部和低年部

528
00:25:52,886 --> 00:25:57,324
每个学部都有自己的校区
和独立 Wi-Fi 网络

529
00:25:57,324 --> 00:25:59,860
部分教师是 IT 管理员

530
00:25:59,860 --> 00:26:02,896
需要访问共享邮件帐户

531
00:26:02,896 --> 00:26:05,632
其中部分教师兼任体育教练

532
00:26:05,632 --> 00:26:07,501
需要为体育比赛制定时间表

533
00:26:07,501 --> 00:26:10,370
订阅日历

534
00:26:10,370 --> 00:26:13,841
因此 一名教师可能
可以扮演四种不同的角色

535
00:26:13,841 --> 00:26:16,844
有时甚至需要身兼多职

536
00:26:16,844 --> 00:26:19,079
而每个角色都有一组配置

537
00:26:19,079 --> 00:26:22,015
添加到设备时

538
00:26:22,015 --> 00:26:25,419
必须按设备分配的角色区分

539
00:26:25,419 --> 00:26:28,889
让我们以两位教师为例

540
00:26:28,889 --> 00:26:30,891
一号教师在低年部任教

541
00:26:30,891 --> 00:26:33,427
兼任体育教练

542
00:26:33,427 --> 00:26:39,299
二号教师在高年部任教
同时是一名 IT 管理员

543
00:26:39,299 --> 00:26:41,068
传统的 MDM 服务器

544
00:26:41,068 --> 00:26:44,171
该如何处理这样的用例呢？

545
00:26:44,171 --> 00:26:46,640
一般来说 在完成设备配置之前

546
00:26:46,640 --> 00:26:48,342
传统服务器必须先

547
00:26:48,342 --> 00:26:51,578
等待设备被分配给教师

548
00:26:51,578 --> 00:26:55,249
服务器必须先确定教师的角色

549
00:26:55,249 --> 00:26:59,586
才能确定该如何链接配置文件

550
00:26:59,586 --> 00:27:02,489
接着 服务器必须轮流地在设备上

551
00:27:02,489 --> 00:27:05,158
分别安装配置文件

552
00:27:05,158 --> 00:27:07,995
如果教师改变角色 服务器必须

553
00:27:07,995 --> 00:27:11,331
添加或删除配置文件来匹配新角色

554
00:27:11,331 --> 00:27:14,101
这一过程不仅耗时

555
00:27:14,101 --> 00:27:17,337
还可能导致设备管理系统的重大卡顿

556
00:27:17,337 --> 00:27:19,473
高峰期尤其如此

557
00:27:19,473 --> 00:27:21,875
我们以角色分配完成后的

558
00:27:21,875 --> 00:27:24,411
开学第一天作为案例背景

559
00:27:24,411 --> 00:27:26,747
新的管理属性声明

560
00:27:26,747 --> 00:27:30,017
提供了一个更有效的替代方案

561
00:27:30,017 --> 00:27:32,953
该方案可以在设备上

562
00:27:32,953 --> 00:27:35,956
预加载一整套声明

563
00:27:35,956 --> 00:27:38,325
通过管理属性

564
00:27:38,325 --> 00:27:41,261
可以根据角色触发谓词

565
00:27:41,261 --> 00:27:44,364
来将配置分配给激活函数

566
00:27:44,364 --> 00:27:47,801
设备分配给教师后
服务器只需要发送

567
00:27:47,801 --> 00:27:49,937
一份管理属性声明

568
00:27:49,937 --> 00:27:52,873
以及该教师的角色

569
00:27:52,873 --> 00:27:56,376
来触发激活其角色的配置

570
00:27:56,376 --> 00:27:58,846
这种方法不仅可以将整个服务器

571
00:27:58,846 --> 00:28:01,849
和网络的流量消耗降至最低

572
00:28:01,849 --> 00:28:05,619
还能够使快速更改设备状态更加简便

573
00:28:05,619 --> 00:28:07,955
回到学校的例子

574
00:28:07,955 --> 00:28:11,592
服务器将预加载以下声明集

575
00:28:11,592 --> 00:28:13,994
两个用于为各学部

576
00:28:13,994 --> 00:28:17,364
设置 Wi-Fi 网络的
激活/配置对

577
00:28:17,364 --> 00:28:19,867
一个为 IT 管理员

578
00:28:19,867 --> 00:28:23,003
安装邮件帐户的激活/配置对

579
00:28:23,003 --> 00:28:26,073
最后是一个安装订阅日历的

580
00:28:26,073 --> 00:28:29,343
激活/配置对

581
00:28:29,343 --> 00:28:32,446
每个激活函数都备有一个谓词

582
00:28:32,446 --> 00:28:36,517
用于检测学部或
角色管理属性的函数名称

583
00:28:36,517 --> 00:28:39,386
最初在未分配的设备上加载时

584
00:28:39,386 --> 00:28:44,191
所有谓词都为假
因此不会应用任何内容

585
00:28:44,191 --> 00:28:48,428
接下来 让我们看看
分配当天会发生什么

586
00:28:48,428 --> 00:28:50,697
服务器只需要给每位教师

587
00:28:50,697 --> 00:28:52,599
分别创建

588
00:28:52,599 --> 00:28:55,469
管理属性声明

589
00:28:55,469 --> 00:28:59,940
一号教师的角色属性
列出了低学部和体育

590
00:28:59,940 --> 00:29:05,212
二号教师的角色属性
列出了高学部和 IT 管理员

591
00:29:05,212 --> 00:29:07,481
单独向每个分配的设备

592
00:29:07,481 --> 00:29:09,283
发送这些声明时

593
00:29:09,283 --> 00:29:13,420
预加载的激活函数将全部重新求值

594
00:29:13,420 --> 00:29:16,557
在一号教师的设备中

595
00:29:16,557 --> 00:29:20,327
激活了低学部和体育教练的配置

596
00:29:20,327 --> 00:29:23,197
而二号教师的设备

597
00:29:23,197 --> 00:29:27,201
激活了高学部和 IT 管理员配置

598
00:29:27,201 --> 00:29:29,870
只需一个声明即可触发

599
00:29:29,870 --> 00:29:33,440
应用多种配置

600
00:29:33,440 --> 00:29:34,775
最后 让我们再来看看

601
00:29:34,775 --> 00:29:37,644
当教师改变角色时会发生什么

602
00:29:37,644 --> 00:29:40,514
目前为止
在当前已分配角色的基础上

603
00:29:40,514 --> 00:29:43,450
二号教师增加了体育教练的角色

604
00:29:43,450 --> 00:29:45,285
分配给教师的设备中

605
00:29:45,285 --> 00:29:47,921
管理属性声明现已更新

606
00:29:47,921 --> 00:29:50,958
加入了新增角色的名称

607
00:29:50,958 --> 00:29:53,460
当该声明在设备上更新时

608
00:29:53,460 --> 00:29:56,330
所有激活函数都被重新求值

609
00:29:56,330 --> 00:29:58,999
于是 适用于体育教练角色的

610
00:29:58,999 --> 00:30:01,735
订阅日历配置将被启用

611
00:30:01,735 --> 00:30:06,840
同样 只需要一个声明更改就能触发

612
00:30:06,840 --> 00:30:07,975
以上过程说明了

613
00:30:07,975 --> 00:30:10,110
管理属性声明

614
00:30:10,110 --> 00:30:13,514
提供了一种强大的解决方案

615
00:30:13,514 --> 00:30:16,683
能够快捷切换设备配置集

616
00:30:16,683 --> 00:30:18,819
使复杂的服务器端逻辑

617
00:30:18,819 --> 00:30:23,557
能够转化为设备上的简单状态变化

618
00:30:23,557 --> 00:30:25,826
最后 让我们总结一下

619
00:30:25,826 --> 00:30:29,029
我们在 iOS 16 机型 tvOS 16 机型
和 macOS Ventura 上

620
00:30:29,029 --> 00:30:34,501
扩展了声明式设备管理的范围

621
00:30:34,501 --> 00:30:37,404
并且使其适用于所有
MDM 注册用户的适用类型

622
00:30:37,404 --> 00:30:41,175
共享 iPad 也包括在内

623
00:30:41,175 --> 00:30:45,078
因此 所有支持 MDM 的
Apple 设备

624
00:30:45,078 --> 00:30:49,950
都能够支持声明式设备管理

625
00:30:49,950 --> 00:30:53,921
我们为密码 帐户
和 MDM 安装 App

626
00:30:53,921 --> 00:30:56,323
都添加了新的状态项

627
00:30:56,323 --> 00:31:00,360
MDM 安装的 App 状态
为解决 MDM 的关键瓶颈之一

628
00:31:00,360 --> 00:31:03,897
提供了一个很好的解决方案

629
00:31:03,897 --> 00:31:06,800
最后 我们增强了谓词语法

630
00:31:06,800 --> 00:31:10,103
使其更具可扩展性和易于使用

631
00:31:10,103 --> 00:31:13,307
并添加了新的管理属性声明

632
00:31:13,307 --> 00:31:16,009
使得服务器能够更便捷地

633
00:31:16,009 --> 00:31:19,813
将复杂的业务逻辑转移到设备上

634
00:31:19,813 --> 00:31:22,416
是时候让您的产品

635
00:31:22,416 --> 00:31:24,051
采用声明式设备管理了

636
00:31:24,051 --> 00:31:26,286
您将如何运用声明式设备管理

637
00:31:26,286 --> 00:31:28,589
来重新构想设备管理解决方案

638
00:31:28,589 --> 00:31:32,359
我们期待见到您的答案

639
00:31:32,359 --> 00:31:35,629
一如往常 我们期待着您的反馈

640
00:31:35,629 --> 00:31:38,465
感谢收看
请继续享受 WWDC 之旅

641
00:31:38,465 --> 00:31:43,570
♪

