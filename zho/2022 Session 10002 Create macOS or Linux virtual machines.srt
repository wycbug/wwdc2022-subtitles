1
00:00:00,334 --> 00:00:06,340
[欢快的音乐]

2
00:00:09,009 --> 00:00:14,014
大家好 欢迎来到虚拟化课程

3
00:00:14,047 --> 00:00:17,451
这是我们今天的内容

4
00:00:17,484 --> 00:00:22,222
我们将了解如何在 Apple 芯片上

5
00:00:22,256 --> 00:00:24,258
运行 macOS 和 Linux 虚拟机

6
00:00:24,291 --> 00:00:28,896
在本课程结束时
你将能够在自己的 Mac 上操作

7
00:00:28,929 --> 00:00:31,798
这可能有些挑战性 但跟上课程

8
00:00:31,832 --> 00:00:33,567
我们就能实现

9
00:00:33,600 --> 00:00:35,502
以下是今天的内容安排

10
00:00:35,536 --> 00:00:38,739
我们将首先介绍虚拟化技术概述

11
00:00:38,772 --> 00:00:43,744
并了解如何使用 Virtualization 框架
构建虚拟机

12
00:00:43,777 --> 00:00:47,114
然后将深入研究 macOS

13
00:00:47,147 --> 00:00:51,919
我们将了解如何设置 Mac 虚拟机
并为它安装 macOS

14
00:00:51,952 --> 00:00:56,423
最后 我们再来深入研究 Linux

15
00:00:56,456 --> 00:00:58,825
我们将了解如何运行完整的
Linux 发行版

16
00:00:58,859 --> 00:01:01,261
以及一些很酷的新特性

17
00:01:01,295 --> 00:01:03,830
我们从概述开始

18
00:01:03,864 --> 00:01:08,068
我们将首先介绍
支持虚拟化的技术栈

19
00:01:08,101 --> 00:01:10,904
首先是硬件

20
00:01:10,938 --> 00:01:14,608
Apple 芯片拥有能够实现

21
00:01:14,641 --> 00:01:16,143
CPU 和内存虚拟化的特殊硬件

22
00:01:16,176 --> 00:01:20,848
这表示你可以在单个 SoC 上
运行多个操作系统

23
00:01:20,881 --> 00:01:24,084
然后 我们需要软件来利用这个硬件

24
00:01:24,117 --> 00:01:27,421
这是内置于 macOS 内核中的

25
00:01:27,454 --> 00:01:30,424
你不再需要编写内核扩展或者 KEXT

26
00:01:30,457 --> 00:01:32,993
一切都是内置的

27
00:01:33,026 --> 00:01:35,162
要在应用程序中使用这些功能

28
00:01:35,195 --> 00:01:37,698
你可以使用 Hypervisor 框架

29
00:01:37,731 --> 00:01:43,537
Hypervisor 框架是一个底层 API
允许你虚拟化 CPU 和内存

30
00:01:43,570 --> 00:01:46,206
但由于它是一个低级框架

31
00:01:46,240 --> 00:01:50,377
你需要编写虚拟环境的每一处细节

32
00:01:50,410 --> 00:01:53,547
通常 我们想要运行完整的操作系统

33
00:01:53,580 --> 00:01:58,919
因此更高级别的 API
Virtualization 框架应运而生

34
00:01:58,952 --> 00:02:02,022
Virtualization 框架能够创建虚拟机

35
00:02:02,055 --> 00:02:08,061
在 Apple 芯片上运行 macOS
或在 Apple 芯片和 Intel 上运行 Linux

36
00:02:08,095 --> 00:02:11,064
我们今天将集中讨论 Virtualization 框架

37
00:02:11,098 --> 00:02:14,668
在使用 Virtualization 框架时
我们将处理两类对象

38
00:02:14,701 --> 00:02:17,070
第一类是配置对象

39
00:02:17,104 --> 00:02:20,107
它们定义了虚拟机的所有属性

40
00:02:20,140 --> 00:02:22,743
第二类是虚拟机对象

41
00:02:22,776 --> 00:02:27,548
它们抽象化了虚拟机
以及和它们的交互方式

42
00:02:27,581 --> 00:02:31,185
我们先来看配置

43
00:02:31,218 --> 00:02:34,221
配置代表着硬件

44
00:02:34,254 --> 00:02:38,425
创建配置就像在 Apple Store 商店中
配置 Mac 一样

45
00:02:38,458 --> 00:02:42,863
我们要定义需要多少 CPU
多少内存和什么样的设备

46
00:02:42,896 --> 00:02:45,532
我们可以从一个简单的配置开始

47
00:02:45,566 --> 00:02:47,801
添加一个显示器 用来看到内容

48
00:02:47,835 --> 00:02:50,404
再加一个键盘 可以打字

49
00:02:50,437 --> 00:02:53,707
添加一个触控板 就可以与 UI 交互

50
00:02:53,740 --> 00:02:57,211
配置虚拟机就是这样

51
00:02:57,244 --> 00:02:59,313
但由于我们处理的是虚拟机

52
00:02:59,346 --> 00:03:01,515
所以我们将利用代码来完成

53
00:03:01,548 --> 00:03:05,319
我们来看看如何通过 Swift 编写配置

54
00:03:05,352 --> 00:03:07,921
定义硬件非常简单

55
00:03:07,955 --> 00:03:12,025
我们从 VZVirtualMachineConfiguration
这个类型开始

56
00:03:12,059 --> 00:03:15,762
这是所有配置的根对象

57
00:03:15,796 --> 00:03:19,700
然后 我们定义机器应该有多少 CPU

58
00:03:19,733 --> 00:03:22,102
这里我们给出 4 个 CPU

59
00:03:22,135 --> 00:03:24,571
然后 我们设置需要多少内存

60
00:03:24,605 --> 00:03:27,975
这里我们设置为 4GB

61
00:03:28,008 --> 00:03:31,578
最后 我们要定义机器将拥有的设备

62
00:03:31,612 --> 00:03:34,515
这里我们定义了单个存储设备

63
00:03:34,548 --> 00:03:38,952
引导磁盘和一个定点设备 如鼠标

64
00:03:38,986 --> 00:03:40,721
有很多可用的设备

65
00:03:40,754 --> 00:03:44,558
你设置什么取决于你想解决的问题

66
00:03:44,591 --> 00:03:46,059
现在我们了解了配置

67
00:03:46,093 --> 00:03:48,629
它从 VZVirtualMachineConfiguration 开始

68
00:03:48,662 --> 00:03:53,333
我们在上面添加 CPU 内存和设备

69
00:03:53,367 --> 00:03:56,970
接下来 我们来研究虚拟机对象

70
00:03:58,205 --> 00:04:00,874
配置好 Mac 下单之后
我们通过快递收到它

71
00:04:00,908 --> 00:04:03,677
下面就可以拆箱并启动它了

72
00:04:03,710 --> 00:04:06,079
但我们处理的是虚拟机

73
00:04:06,113 --> 00:04:08,515
需要利用代码来完成

74
00:04:08,549 --> 00:04:11,585
我们来看看如何通过 Swift 完成

75
00:04:11,618 --> 00:04:14,688
首先 我们通过配置

76
00:04:14,721 --> 00:04:16,223
创建 VZVirtualMachine 实例

77
00:04:16,256 --> 00:04:20,627
VZVirtualMachine 抽象了
虚拟硬件实例

78
00:04:20,661 --> 00:04:23,397
现在我们有了虚拟机
就可以对其进行操作了

79
00:04:23,430 --> 00:04:27,901
例如在本例中 我们调用 start()
来启动它

80
00:04:27,935 --> 00:04:30,237
我们经常想要与虚拟机交互

81
00:04:30,270 --> 00:04:33,507
因此我们需要其它对象的协助

82
00:04:33,540 --> 00:04:36,410
例如 如果我们想要展示虚拟显示器

83
00:04:36,443 --> 00:04:39,680
可以使用 VZVirtualMachineView
类型的对象

84
00:04:39,713 --> 00:04:41,648
我们先创建一个视图

85
00:04:41,682 --> 00:04:45,619
然后将视图上的 virtualMachine 属性
设置为我们的虚拟机

86
00:04:45,652 --> 00:04:47,154
这样就大功告成了

87
00:04:47,187 --> 00:04:51,525
现在我们可以像使用任何 NSView 一样
使用 VZVirtualMachineView

88
00:04:51,558 --> 00:04:55,395
我们可以将它集成到 App 中
以查看虚拟机的内容

89
00:04:56,964 --> 00:04:59,967
总结一下 我们已经看过了配置

90
00:05:00,000 --> 00:05:03,770
配置是从
VZVirtualMachineConfiguration 开始

91
00:05:03,804 --> 00:05:08,208
我们从中定义 CPU 内存和设备

92
00:05:08,242 --> 00:05:10,878
通过配置 我们创建一个虚拟机

93
00:05:10,911 --> 00:05:13,480
并使用虚拟机对象

94
00:05:13,514 --> 00:05:17,651
我们已经了解了
VZVirtualMachine 抽象了虚拟机本身

95
00:05:17,684 --> 00:05:20,554
VZVirtualMachineView 显示内容

96
00:05:20,587 --> 00:05:23,624
还有其它对象可以协助我们
使用虚拟机

97
00:05:23,657 --> 00:05:26,927
我们已经了解到
该配置为定义虚拟机

98
00:05:26,960 --> 00:05:29,162
提供了很大的灵活性

99
00:05:29,196 --> 00:05:33,667
遗憾的是
没法在一节课涉及太多功能

100
00:05:33,700 --> 00:05:37,437
在本节课中
我们会研究一些核心能力

101
00:05:37,471 --> 00:05:39,873
其它的内容均在文档中

102
00:05:39,907 --> 00:05:42,943
我希望大家查看一下

103
00:05:42,976 --> 00:05:46,647
我们在概述中了解了如何构建虚拟机

104
00:05:46,680 --> 00:05:50,684
现在来研究如何在其中运行
完整的操作系统

105
00:05:50,717 --> 00:05:52,953
我们将从 macOS 开始

106
00:05:52,986 --> 00:05:56,790
Virtualization 框架
在 Apple 芯片上支持 macOS

107
00:05:56,823 --> 00:05:59,126
当我们在 Apple 芯片上
构建 Virtualization 框架时

108
00:05:59,159 --> 00:06:03,163
我们同时开发了
macOS 和 Virtualization 框架

109
00:06:03,197 --> 00:06:05,966
这使得
在虚拟机中运行 macOS 时

110
00:06:05,999 --> 00:06:08,735
效率十分惊人

111
00:06:08,769 --> 00:06:11,038
以下是我们将要了解的内容

112
00:06:11,071 --> 00:06:12,973
首先 我们会研究如何

113
00:06:13,006 --> 00:06:16,376
将虚拟机变成 Mac 虚拟机

114
00:06:16,410 --> 00:06:20,914
然后 我们将研究
在 Mac 虚拟机上安装 macOS 的步骤

115
00:06:20,948 --> 00:06:25,352
接下来 我们还将了解到 macOS 的
一些特殊设备

116
00:06:25,385 --> 00:06:28,822
最后 我们将学习一个
非常重要的实例

117
00:06:28,856 --> 00:06:32,826
在主机系统和 Mac 虚拟机之间
共享文件

118
00:06:34,261 --> 00:06:36,830
我们先从配置开始

119
00:06:36,864 --> 00:06:40,167
我们已经了解了如何搭建通用虚拟机

120
00:06:40,200 --> 00:06:45,706
现在我们想添加一些特殊属性
让其成为 Mac 虚拟机

121
00:06:45,739 --> 00:06:48,976
那么我们如何配置 Mac 虚拟机呢

122
00:06:49,009 --> 00:06:51,879
首先 我们要定义一个特殊的平台

123
00:06:51,912 --> 00:06:55,315
平台是一个对象

124
00:06:55,349 --> 00:06:57,684
它拥有特定类型虚拟机的所有属性

125
00:06:57,718 --> 00:07:02,122
Mac 虚拟机硬件有三个独特的属性

126
00:07:02,155 --> 00:07:04,358
第一个是硬件模型

127
00:07:04,391 --> 00:07:09,196
硬件模型决定了我们需要的
Mac 虚拟机的版本

128
00:07:09,229 --> 00:07:11,265
其次是辅助存储器

129
00:07:11,298 --> 00:07:15,969
它是系统使用的一种非易失性存储器

130
00:07:16,003 --> 00:07:19,239
第三个是虚拟机标识符

131
00:07:19,273 --> 00:07:22,676
它是代表机器的唯一数字

132
00:07:22,709 --> 00:07:26,113
就像每台 Mac 都有
唯一的序列号一样

133
00:07:26,146 --> 00:07:29,883
一旦我们有了平台
就有了所有这些硬件

134
00:07:29,917 --> 00:07:34,621
但还差一点
那就是引导 macOS 的方法

135
00:07:34,655 --> 00:07:36,890
为此 我们将使用一个
特殊的引导加载程序

136
00:07:36,924 --> 00:07:39,126
macOS 引导加载程序

137
00:07:39,159 --> 00:07:43,063
我们来看看
如何在在 Swift 中做到这一切

138
00:07:43,096 --> 00:07:44,932
我们还是从最基本的开始

139
00:07:44,965 --> 00:07:48,635
这段代码是我们在概述中见过的

140
00:07:48,669 --> 00:07:52,506
然后我们创建一个
VZMacPlatformConfiguration

141
00:07:52,539 --> 00:07:56,043
这是我们的虚拟 Mac 平台对象

142
00:07:56,076 --> 00:07:58,011
我们需要一个 Mac 的硬件模型

143
00:07:58,045 --> 00:08:01,315
这里我们使用之前保存的一个

144
00:08:01,348 --> 00:08:03,650
在虚拟机中 辅助存储器

145
00:08:03,684 --> 00:08:06,119
由本地文件系统上的某个文件支持

146
00:08:06,153 --> 00:08:09,957
在这里 我们通过
文件 URL 来初始化辅助存储器

147
00:08:09,990 --> 00:08:13,760
我们从之前保存的一个标识符中

148
00:08:13,794 --> 00:08:15,762
初始化 VZMacMachineIdentifier

149
00:08:15,796 --> 00:08:19,633
对于新的安装
我们还可以创建一个新的标识符

150
00:08:19,666 --> 00:08:23,470
我们已经设置好了三个属性
平台已准备就绪

151
00:08:23,504 --> 00:08:27,107
我们所要做的就是
在配置对象上设置它

152
00:08:27,140 --> 00:08:31,011
得到了硬件
接下来我们要找方法来启动它

153
00:08:31,912 --> 00:08:36,383
为此 我们使用 VZMacBootLoader
来设置引导加载程序

154
00:08:36,416 --> 00:08:38,719
现在我们的机器已准备好启动了

155
00:08:38,752 --> 00:08:43,123
到目前为止 我们所做的
是如何定义虚拟 Mac 以及启动它

156
00:08:43,156 --> 00:08:45,125
但我们仍需要在上面安装软件

157
00:08:45,158 --> 00:08:48,395
这就涉及到安装

158
00:08:48,428 --> 00:08:51,265
安装 macOS 需要三个步骤

159
00:08:51,298 --> 00:08:54,501
首先 我们需要下载一个
带有要安装的

160
00:08:54,535 --> 00:08:56,703
macOS 版本的恢复映像

161
00:08:56,737 --> 00:08:58,939
然后 我们需要创建一个

162
00:08:58,972 --> 00:09:01,942
与 macOS 版本兼容的配置

163
00:09:01,975 --> 00:09:04,645
最后 我们将在兼容的

164
00:09:04,678 --> 00:09:07,114
虚拟机中安装我们的恢复映像

165
00:09:07,147 --> 00:09:10,117
首先 我们需要下载一个恢复映像

166
00:09:10,150 --> 00:09:12,753
你可以从开发者网站下载

167
00:09:12,786 --> 00:09:15,989
但 Virtualization 也可以帮到我们

168
00:09:16,023 --> 00:09:19,927
你可以调用
VZMacOSRestoreImage.latestSupported

169
00:09:19,960 --> 00:09:25,032
为最新稳定版本的 macOS 获取
恢复映像对象

170
00:09:25,065 --> 00:09:29,570
这个对象有我们可以用来
下载文件的 URL 属性

171
00:09:29,603 --> 00:09:32,739
然后 我们希望创建一个
与我们下载的

172
00:09:32,773 --> 00:09:35,409
macOS 版本兼容的虚拟机

173
00:09:35,442 --> 00:09:37,811
这里 Virtualization 也可以帮到我们

174
00:09:37,845 --> 00:09:42,249
我们可以向恢复映像对象询问配置要求

175
00:09:42,282 --> 00:09:44,985
如果恢复映像可以在当前系统上运行

176
00:09:45,018 --> 00:09:47,888
我们会得到一个可以列出需求的对象

177
00:09:47,921 --> 00:09:50,858
从需求中
我们可以得到运行该版本的 macOS

178
00:09:50,891 --> 00:09:52,993
所需的硬件模型

179
00:09:53,026 --> 00:09:55,929
我们已经看过了如何恢复硬件模型

180
00:09:55,963 --> 00:09:58,665
这就是我们如何获得新模型

181
00:09:59,800 --> 00:10:03,470
需求中还包含两个有用的属性

182
00:10:03,504 --> 00:10:07,808
该对象可以告诉我们运行
这个版本的 macOS

183
00:10:07,841 --> 00:10:10,410
需要多少 CPU 和内存

184
00:10:11,345 --> 00:10:14,348
最后 我们准备好开始安装了

185
00:10:14,381 --> 00:10:18,218
我们先从配置中创建一个新的虚拟机

186
00:10:18,252 --> 00:10:20,354
然后创建一个安装程序

187
00:10:20,387 --> 00:10:22,789
安装程序有两个参数

188
00:10:22,823 --> 00:10:25,392
我们创建的兼容虚拟机

189
00:10:25,425 --> 00:10:28,662
和下载恢复映像的路径

190
00:10:28,695 --> 00:10:32,933
现在我们只需调用安装即可
看 我们准备好运行 macOS 了

191
00:10:33,901 --> 00:10:37,104
现在我们可以设置
一个虚拟 Mac 并安装 macOS

192
00:10:37,137 --> 00:10:41,241
我们来看看 Mac 的一些特殊设备

193
00:10:41,275 --> 00:10:44,912
第一个很酷的功能是 GPU 加速

194
00:10:44,945 --> 00:10:48,582
我们创建了一个图像设备
将 GPU 功能

195
00:10:48,615 --> 00:10:50,184
暴露给虚拟 Mac 的

196
00:10:50,217 --> 00:10:53,020
这表示你可以在虚拟机中运行 Metal

197
00:10:53,053 --> 00:10:56,156
并在 macOS 中获得出色的图形性能

198
00:10:56,190 --> 00:10:58,125
我们来看看如何设置它

199
00:10:59,626 --> 00:11:02,496
我们首先创建图形设备配置

200
00:11:02,529 --> 00:11:06,333
在这里 我们将使用
VZMacGraphicsDeviceConfiguration

201
00:11:06,366 --> 00:11:08,402
然后我们要给它一个显示器

202
00:11:08,435 --> 00:11:13,040
我们通过定义其大小
和像素密度来设置显示器

203
00:11:13,073 --> 00:11:15,342
现在我们的设备已经设置好了

204
00:11:15,375 --> 00:11:18,712
像往常一样
我们在主配置对象上设置它

205
00:11:18,745 --> 00:11:22,249
我们将它设置为虚拟机的图形设备

206
00:11:23,383 --> 00:11:26,553
接下来 我们来了解
与 Mac 互动的新设备

207
00:11:26,587 --> 00:11:29,890
在 macOS Ventura 中
我们将 Mac 触控板支持

208
00:11:29,923 --> 00:11:31,558
添加到了虚拟 Mac 中

209
00:11:31,592 --> 00:11:34,127
新的触控板支持

210
00:11:34,161 --> 00:11:37,431
旋转 缩放等手势

211
00:11:37,464 --> 00:11:40,300
这个新设备
采用 macOS 中新的驱动程序

212
00:11:40,334 --> 00:11:42,236
所以要想使用它
在主机系统

213
00:11:42,269 --> 00:11:45,572
和虚拟机中均需要 macOS 13

214
00:11:45,606 --> 00:11:48,208
我们来看看如何设置

215
00:11:48,242 --> 00:11:50,210
很简单

216
00:11:50,244 --> 00:11:54,181
我们创建一个 VZMacTrackpadConfiguration
类型的新对象

217
00:11:54,214 --> 00:11:58,218
然后将其设置为虚拟机上的定点设备

218
00:11:58,252 --> 00:12:03,557
当我们在虚拟 Mac 中使用视图时
可以使用手势

219
00:12:03,590 --> 00:12:06,627
最后 我们来研究一下
大多数人的常见用例

220
00:12:06,660 --> 00:12:10,998
即在主机系统和虚拟机之间共享文件

221
00:12:11,031 --> 00:12:14,635
在 macOS 12 中
我们推出了 Virtio 文件系统设备

222
00:12:14,668 --> 00:12:16,637
在 Linux 上共享文件

223
00:12:16,670 --> 00:12:20,407
在 macOS Ventura 中
我们增加了对 macOS 的支持

224
00:12:20,440 --> 00:12:23,744
你可以选择
想要与虚拟机共享的文件夹

225
00:12:23,777 --> 00:12:26,980
你在主机系统中所做的任何更改

226
00:12:27,014 --> 00:12:29,850
都会立即反应在虚拟机中 反之亦然

227
00:12:29,883 --> 00:12:32,152
我们来看看如何设置

228
00:12:32,186 --> 00:12:37,324
首先 我们创建一个带有我们想要
共享的目录的 VZShareDirectory

229
00:12:37,357 --> 00:12:39,726
然后我们创建一个共享对象

230
00:12:39,760 --> 00:12:43,931
这里我们使用 VZSingleDirectoryShare
来共享单个目录

231
00:12:43,964 --> 00:12:48,802
您也可以用 VZMultipleDirectoryShare
来共享多个目录

232
00:12:48,836 --> 00:12:51,438
现在有了共享
我们需要创建一个设备

233
00:12:51,471 --> 00:12:54,241
但我们将从一个特殊的东西开始

234
00:12:54,274 --> 00:12:56,810
文件系统设备由标记标识

235
00:12:56,844 --> 00:12:59,913
在 macOS Ventura 中
我们添加了一个特殊标记

236
00:12:59,947 --> 00:13:03,217
告诉虚拟机自动装载这个设备

237
00:13:03,250 --> 00:13:07,521
这里 我们使用这个特殊标记
即 macOSGuestAutomountTag

238
00:13:07,554 --> 00:13:11,325
然后我们创建设备
并使用我们的特殊标记

239
00:13:11,358 --> 00:13:14,995
我们从所配置的单个目录设置共享

240
00:13:15,028 --> 00:13:19,266
最后 像往常一样
将设备添加到配置中

241
00:13:19,299 --> 00:13:23,737
最后 我们一起在演示中
查看所有内容

242
00:13:23,770 --> 00:13:26,273
我们从基本配置开始

243
00:13:26,306 --> 00:13:28,342
我们有
VZVirtualMachineConfiguration

244
00:13:28,375 --> 00:13:33,814
它包含 CPU 内存 键盘和磁盘

245
00:13:33,847 --> 00:13:35,449
我们想要一个虚拟 Mac

246
00:13:35,482 --> 00:13:39,086
因此 我们需要从设置平台开始

247
00:13:39,119 --> 00:13:43,524
我们将使用上面定义的
createMacPlatform 来做到这一点

248
00:13:43,557 --> 00:13:46,426
创建虚拟 Mac 的第二步是
引导加载程序

249
00:13:46,460 --> 00:13:49,997
我们需要知道如何启动 macOS 的
引导加载程序

250
00:13:50,030 --> 00:13:52,699
为此 我们将平台的
引导加载程序设置为

251
00:13:52,733 --> 00:13:55,536
VZMacOSBootLoader

252
00:13:55,569 --> 00:13:58,238
接下来 我们要设置设备

253
00:13:58,272 --> 00:14:00,507
我们需要加速图形端口

254
00:14:00,541 --> 00:14:04,711
因此 我们设置一个
VZMacGraphicsConfiguration

255
00:14:04,745 --> 00:14:06,413
我们创建对象

256
00:14:06,446 --> 00:14:09,383
定义显示大小和像素密度

257
00:14:09,416 --> 00:14:12,186
并将其添加到配置中

258
00:14:12,219 --> 00:14:14,755
然后 我们想使用新的触控板

259
00:14:14,788 --> 00:14:17,224
我们所要做的就是将定点设备

260
00:14:17,257 --> 00:14:19,426
设置为 VZMacTrackpadConfiguration

261
00:14:19,459 --> 00:14:20,694
以上就是全部

262
00:14:20,727 --> 00:14:24,765
现在 我们可以启动虚拟机了
但是我们最后再添加一些东西

263
00:14:24,798 --> 00:14:27,134
我们已经看到了如何共享目录

264
00:14:27,167 --> 00:14:29,169
我们来演示一遍

265
00:14:29,203 --> 00:14:32,406
我们首先创建文件系统设备配置

266
00:14:32,439 --> 00:14:37,010
这里 请注意 我们使用特殊标记
将它自动装载到 macOS 中

267
00:14:37,044 --> 00:14:38,879
然后定义我们的共享

268
00:14:38,912 --> 00:14:42,649
这里 使用文件系统上的
路径的单个目录共享

269
00:14:42,683 --> 00:14:46,019
这里 我们将共享
正在编辑的这个项目

270
00:14:47,254 --> 00:14:50,457
将设备添加到配置中
这样就完成了

271
00:14:51,391 --> 00:14:55,128
一切就绪 我们来启动应用程序

272
00:14:55,162 --> 00:14:57,598
因为我们配置了 MacGraphics 设备

273
00:14:57,631 --> 00:15:01,101
VZVirtualMachineView
就会显示内容

274
00:15:01,134 --> 00:15:04,271
这就是我们在窗口中所看到的内容

275
00:15:04,304 --> 00:15:08,008
就是它
我们从头开始配置 macOS

276
00:15:08,041 --> 00:15:11,678
我们可以看到共享目录
和此刻正在编辑的项目

277
00:15:11,712 --> 00:15:14,915
最后 我们来看一下 Linux

278
00:15:14,948 --> 00:15:17,150
Virtualization 框架
早在 macOS Big Sur 中

279
00:15:17,184 --> 00:15:20,020
就已支持 Linux

280
00:15:20,053 --> 00:15:23,357
在 macOS Ventura 中
我们增加了一些非常酷的新特性

281
00:15:23,390 --> 00:15:25,359
我们想和大家分享其中的一些

282
00:15:26,660 --> 00:15:29,830
首先 我们将看到如何在虚拟机中

283
00:15:29,863 --> 00:15:33,066
安装完整的未经修改的
Linux 发行版

284
00:15:33,100 --> 00:15:37,604
然后我们将看到在 Linux 中
添加的显示界面的新设备

285
00:15:37,638 --> 00:15:41,375
最后 我们将看看如何利用 Rosetta 2

286
00:15:41,408 --> 00:15:44,878
在虚拟机中运行 Linux 二进制文件

287
00:15:44,912 --> 00:15:47,181
我们从安装开始

288
00:15:47,214 --> 00:15:49,616
如果我们想在实体机上安装 Linux

289
00:15:49,650 --> 00:15:52,819
首先要下载自带安装程序的 ISO 文件

290
00:15:52,853 --> 00:15:55,923
然后用 ISO 覆盖一个U盘

291
00:15:55,956 --> 00:15:59,893
最后 我们将U盘插入电脑
然后启动

292
00:15:59,927 --> 00:16:03,363
在处理虚拟机时
我们将采用相同的步骤

293
00:16:03,397 --> 00:16:07,868
但我们将使用虚拟U盘
而不是实际U盘

294
00:16:07,901 --> 00:16:09,970
我们来看看它是如何工作的

295
00:16:10,003 --> 00:16:14,775
我们首先从下载的 ISO 文件路径
创建 URL

296
00:16:14,808 --> 00:16:18,779
然后 我们从该文件创建一个
磁盘映像附件

297
00:16:18,812 --> 00:16:24,651
磁盘映像附件代表我们可以
连接到设备上的一块存储

298
00:16:24,685 --> 00:16:28,155
接下来 我们配置一个虚拟存储设备

299
00:16:28,188 --> 00:16:30,624
这里 我们需要 USB 存储

300
00:16:30,657 --> 00:16:35,028
所以我们使用
VZUSBMassStorageDeviceConfiguration

301
00:16:35,062 --> 00:16:37,030
最后 一如既往地

302
00:16:37,064 --> 00:16:39,533
我们在主配置中添加设备

303
00:16:39,566 --> 00:16:42,736
这里 USB 设备出现在
另一个存储设备一旁

304
00:16:42,769 --> 00:16:45,706
也就是我们安装 Linux 的主磁盘

305
00:16:45,739 --> 00:16:49,343
现在我们有了 USB 驱动器
但我们需要启动方法

306
00:16:50,310 --> 00:16:54,081
在 macOS Ventura 中
我们增加了对 EFI 的支持

307
00:16:54,114 --> 00:16:58,952
EFI 是引导 ARM
和 Intel 硬件的行业标准

308
00:16:58,986 --> 00:17:02,556
我们正在为虚拟机提供同样的支持

309
00:17:02,589 --> 00:17:05,259
EFI 具有启动发现机制

310
00:17:05,292 --> 00:17:09,496
能够发现 USB 驱动器上的安装程序

311
00:17:09,530 --> 00:17:13,100
EFI 可以查看每个驱动器
以寻找可以启动的驱动器

312
00:17:13,133 --> 00:17:16,003
它会识别出安装程序
并以此作为开始

313
00:17:16,036 --> 00:17:19,373
安装程序会告诉 EFI
接下来使用什么驱动程序

314
00:17:19,406 --> 00:17:23,577
安装完成后 EFI 就可以
启动 Linux 发行版了

315
00:17:23,610 --> 00:17:26,847
我们来看看
如何在代码中设置 EFI

316
00:17:26,880 --> 00:17:31,018
首先 我们创建一个
VZEFIBootLoader 类型的引导加载程序

317
00:17:31,051 --> 00:17:35,355
EFI 需要非易失性存储器
来存储启动间的信息

318
00:17:35,389 --> 00:17:38,258
这就是所谓的 EFI 可变存储器

319
00:17:38,292 --> 00:17:40,761
有了虚拟机
我们可以通过文件系统上的

320
00:17:40,794 --> 00:17:42,863
某个文件来支持这样的存储器

321
00:17:42,896 --> 00:17:46,033
这里 我们重新创建一个
新的可变存储器

322
00:17:46,066 --> 00:17:47,568
现在 EFI 准备好了

323
00:17:47,601 --> 00:17:51,705
我们只需要在配置中将它设置为
引导加载程序

324
00:17:51,738 --> 00:17:57,010
接下来 我们将研究 Linux 虚拟机的
新功能 图形

325
00:17:57,044 --> 00:18:01,515
在 macOS Ventura 中 我们增加了
对 Virtio GPU 2D 的支持

326
00:18:01,548 --> 00:18:05,285
Virtio GPU 2D 是一个半虚拟化的设备
允许 Linux

327
00:18:05,319 --> 00:18:08,455
为宿主 macOS 提供界面

328
00:18:08,488 --> 00:18:11,325
Linux 呈现内容 将渲染帧提供给

329
00:18:11,358 --> 00:18:14,494
Virtualization 框架
以便可以显示它

330
00:18:14,528 --> 00:18:18,765
你现在可以用 VZVirtualMachineView
在你的 App 中显示这些内容

331
00:18:18,799 --> 00:18:21,201
就像在 macOS 上一样

332
00:18:21,235 --> 00:18:23,237
我们来看看如何设置它

333
00:18:24,571 --> 00:18:28,542
设备设置与我们设置
macOS 时所做的类似

334
00:18:28,575 --> 00:18:32,946
我们首先创建一个
VZVirtioGraphicsDeviceConfiguration

335
00:18:32,980 --> 00:18:36,149
我们需要定义虚拟显示器的大小

336
00:18:36,183 --> 00:18:39,953
在 Virtio 术语中
虚拟显示器是一个 “scanout”

337
00:18:39,987 --> 00:18:44,892
所以我们创建了一个
显示器大小的 scanout

338
00:18:44,925 --> 00:18:48,262
最后 我们将新设备设置为

339
00:18:48,295 --> 00:18:49,963
配置的图形设备

340
00:18:49,997 --> 00:18:54,168
现在我们的虚拟机已经准备好
用 VZVirtualMachineView 来显示内容了

341
00:18:54,201 --> 00:18:58,405
接下来 我们通过演示
来查看所有内容

342
00:18:58,438 --> 00:19:00,040
我们从中断的地方开始

343
00:19:00,073 --> 00:19:03,143
先删除 Mac 特有的代码

344
00:19:03,177 --> 00:19:05,479
然后更改引导的磁盘

345
00:19:05,512 --> 00:19:09,950
我们将路径从 Mac 驱动器
换为 Linux 驱动器

346
00:19:09,983 --> 00:19:12,386
接下来 需要一个引导加载程序

347
00:19:12,419 --> 00:19:16,156
我们用 VZEFIBootLoader
来设置 EFI

348
00:19:16,924 --> 00:19:19,326
首先创建
EFI 引导加载程序对象

349
00:19:19,359 --> 00:19:22,129
然后我们从它的文件中
加载可变存储器

350
00:19:22,162 --> 00:19:27,401
最后 我们在配置中将 EFI
设置为引导加载程序

351
00:19:27,434 --> 00:19:31,238
现在我们可以启动了
不过最好能显示 UI

352
00:19:31,271 --> 00:19:35,008
让我们将 Virtio GPU 添加到配置中

353
00:19:35,042 --> 00:19:36,643
只需创建一个
VZVirtioGraphicsDeviceConfiguration

354
00:19:36,677 --> 00:19:40,013
类型的图形设备

355
00:19:40,047 --> 00:19:43,884
然后我们用虚拟显示器的
大小定义 scanout

356
00:19:43,917 --> 00:19:49,389
我们在配置上将 Virtio GPU
设置为 graphicsDevice

357
00:19:49,423 --> 00:19:52,993
最后就是让鼠标工作

358
00:19:53,026 --> 00:19:56,330
我们只需使用虚拟的
USB 屏幕坐标指示设备

359
00:19:56,363 --> 00:19:58,665
在 Linux 中会出现一个鼠标

360
00:19:58,699 --> 00:20:01,335
好了 这样我们就可以
运行这个项目了

361
00:20:01,368 --> 00:20:04,471
EFI 可以查看磁盘
识别是否可以引导

362
00:20:04,505 --> 00:20:09,977
然后 Linux 通过 Virtio GPU 设备
显示界面内容

363
00:20:10,010 --> 00:20:12,946
我们可以用鼠标与 Linux 交互

364
00:20:12,980 --> 00:20:15,983
最重要的是 我们来看看如何

365
00:20:16,016 --> 00:20:19,119
在 Linux 中使用 Rosetta 2 技术

366
00:20:20,053 --> 00:20:23,490
对于许多人来说
我们喜欢在 Mac 上开发服务

367
00:20:23,524 --> 00:20:25,025
但一旦我们的工作就绪

368
00:20:25,058 --> 00:20:29,162
我们创建的二进制文件
可能需要在 x86 服务器上运行

369
00:20:29,196 --> 00:20:32,332
x86 指令模拟在这方面做得很好

370
00:20:32,366 --> 00:20:35,035
但我们可以做得更好

371
00:20:35,068 --> 00:20:37,204
在 macOS Ventura 中
我们将 Rosetta 2 的强大功能

372
00:20:37,237 --> 00:20:39,673
引入到 Linux 二进制中

373
00:20:40,807 --> 00:20:44,378
Rosetta 2 所做的是在虚拟机中

374
00:20:44,411 --> 00:20:46,446
转译 Linux x86-64 二进制

375
00:20:46,480 --> 00:20:49,750
这表示你可以运行你喜欢的
ARM Linux 发行版

376
00:20:49,783 --> 00:20:53,253
它的 x86-64 App
可以通过 Rosetta 运行

377
00:20:53,287 --> 00:20:54,755
而且很快

378
00:20:54,788 --> 00:20:57,658
这和我们在 Mac 上使用的技术
是一样的

379
00:20:57,691 --> 00:21:00,460
这意味着我们拥有惊人的性能

380
00:21:00,494 --> 00:21:03,530
让我们看看如何使用它

381
00:21:03,564 --> 00:21:07,000
首先 我们需要让 Linux
可以访问 Rosetta

382
00:21:07,034 --> 00:21:11,705
为此 我们使用了与 macOS
相同的文件共享技术

383
00:21:11,738 --> 00:21:15,175
我们使用了一种特殊的对象
而非共享文件夹

384
00:21:15,209 --> 00:21:18,912
也就是
VZLinuxRosettaDirectoryShare

385
00:21:18,946 --> 00:21:24,151
然后我们创建一个共享设备
并设置 Rosetta 目录共享

386
00:21:24,184 --> 00:21:28,455
最后 我们像往常一样
在配置上设置我们的设备

387
00:21:28,488 --> 00:21:32,059
现在我们的虚拟机可以
使用 Rosetta 了

388
00:21:32,092 --> 00:21:35,696
接下来 让我们看看 Linux
如何利用它

389
00:21:36,930 --> 00:21:41,335
在 Linux 中 我们首先
在文件系统中装载共享目录

390
00:21:41,368 --> 00:21:46,240
我们从 Linux 中看到的是可以
转译应用程序的 Rosetta 二进制文件

391
00:21:46,273 --> 00:21:50,511
然后 我们可以使用 update-binfmts
告诉系统使用 Rosetta

392
00:21:50,544 --> 00:21:53,847
处理任何 x86-64 二进制文件

393
00:21:53,881 --> 00:21:55,849
不要担心记不住这个命令

394
00:21:55,883 --> 00:21:58,685
这些全都在文档中

395
00:21:58,719 --> 00:22:00,921
现在 Linux 已经准备就绪

396
00:22:00,954 --> 00:22:05,926
Rosetta 会转译每一个
启动运行的 x86-64 二进制文件

397
00:22:07,361 --> 00:22:11,832
在结束 Linux 部分之前
我们来进行一个大汇总

398
00:22:11,865 --> 00:22:15,602
这里 我们重新安装了一个
完整的 Linux 发行版

399
00:22:15,636 --> 00:22:18,705
我们可以用 Virtio GPU 2D
来显示它的界面

400
00:22:18,739 --> 00:22:22,776
在虚拟机中
我们通过 Rosetta 运行了一个 PHP 服务器

401
00:22:22,809 --> 00:22:26,079
我们可以从 macOS 主机与它连接

402
00:22:27,381 --> 00:22:31,518
我们已经看到
创建虚拟机从未如此简单

403
00:22:31,552 --> 00:22:34,488
利用 Virtualization 框架
你只需要写几行代码

404
00:22:34,521 --> 00:22:37,191
就可以运行虚拟机

405
00:22:37,224 --> 00:22:42,062
我们还看到 虚拟机
在 macOS 上的速度非常快

406
00:22:42,095 --> 00:22:43,931
为了更进一步了解虚拟化

407
00:22:43,964 --> 00:22:47,534
请大家查看代码示例和文档

408
00:22:47,568 --> 00:22:49,603
我和我们的团队迫不及待地

409
00:22:49,636 --> 00:22:51,772
想看到你们如何利用这项技术

410
00:22:51,805 --> 00:22:57,110
[欢快的音乐]

