1
00:00:00,334 --> 00:00:06,340
[欢快的音乐]

2
00:00:09,309 --> 00:00:11,245
David：开发者好
我是 David Wendland

3
00:00:11,278 --> 00:00:14,414
App Store 的商务技术倡导者

4
00:00:14,448 --> 00:00:18,452
今天 我将向您介绍该如何通过
主动识别用户购买记录

5
00:00:18,485 --> 00:00:21,555
包括新记录、当前记录、历史记录
来让您的 App 为顾客提供一流体验

6
00:00:21,588 --> 00:00:25,859
且期间不需要顾客的任何操作

7
00:00:25,893 --> 00:00:30,330
我将介绍如何使用 StoreKit 2
和初版 StoreKit

8
00:00:30,364 --> 00:00:33,100
方便您为所有顾客优化

9
00:00:33,133 --> 00:00:36,003
App 的启用体验

10
00:00:36,036 --> 00:00:39,907
先说说主动 App 内购买项目恢复的定义吧

11
00:00:39,940 --> 00:00:42,309
这指的是当顾客启动您的 App 时

12
00:00:42,342 --> 00:00:45,946
您可以通过使用设备上现成的数据

13
00:00:45,979 --> 00:00:48,582
主动检查交易记录

14
00:00:48,615 --> 00:00:53,420
来确定这是新顾客还是现有顾客

15
00:00:53,453 --> 00:00:56,557
期间不需要顾客进行操作

16
00:00:56,590 --> 00:01:01,328
甚至都不需要
点击“恢复购买”或输入密码

17
00:01:01,361 --> 00:01:04,164
由此 您能够根据
顾客的购买历史和状态

18
00:01:04,198 --> 00:01:07,801
为其定制 App 体验

19
00:01:07,835 --> 00:01:12,039
您的 App 可以为现有顾客
解锁产品或服务

20
00:01:12,072 --> 00:01:16,743
也可以向新顾客推销最新产品

21
00:01:16,777 --> 00:01:18,345
而对于那些曾经订阅的顾客

22
00:01:18,378 --> 00:01:21,815
您可以为其提供订阅优惠
来吸引顾客回归

23
00:01:21,849 --> 00:01:24,418
这就是主动恢复的意义所在

24
00:01:24,451 --> 00:01:27,221
通过 StoreKit 自动为新顾客
现有顾客和既往顾客

25
00:01:27,254 --> 00:01:33,360
在所有设备上自动优化 App 体验

26
00:01:33,393 --> 00:01:35,462
我们来看看这个例子

27
00:01:35,495 --> 00:01:38,232
这个 App 名为“海洋日志”
以它为例

28
00:01:38,265 --> 00:01:40,667
在常见的销售体验中

29
00:01:40,701 --> 00:01:44,304
顾客有几个行为召唤选项可供选择

30
00:01:44,338 --> 00:01:47,107
我可以试着进行 App 内购买

31
00:01:47,140 --> 00:01:50,777
并使用面容 ID 等
生物识别技术进行身份验证

32
00:01:50,811 --> 00:01:52,412
我也可以创建 App 帐户

33
00:01:52,446 --> 00:01:56,250
通过密钥串输入密码来登录帐号

34
00:01:56,283 --> 00:01:58,652
如果我是个活跃订阅者

35
00:01:58,685 --> 00:02:01,388
还可以使用“恢复购买”功能

36
00:02:01,421 --> 00:02:03,757
当活跃订阅者使用新设备时

37
00:02:03,790 --> 00:02:07,427
并不一定知道该选哪个选项

38
00:02:07,461 --> 00:02:10,297
但有了触手可及的数据

39
00:02:10,330 --> 00:02:12,199
加上我们的主动 App 内购买项目恢复最优解

40
00:02:12,232 --> 00:02:15,469
您的 App 可以简化这一流程

41
00:02:16,036 --> 00:02:21,475
也就是说 如果我在新设备上
启动了 App 且我是个活跃订阅者

42
00:02:21,508 --> 00:02:26,013
启动后 无需我进行任何操作
该 App 会自动

43
00:02:26,046 --> 00:02:28,649
主动恢复我的服务内容

44
00:02:28,682 --> 00:02:31,318
因此 请看这里 App 识别出了
我的专业会员订阅

45
00:02:31,351 --> 00:02:34,488
于是加载了我最喜欢的海滩
附上了冲浪条件

46
00:02:34,521 --> 00:02:36,990
并启用了实时摄像功能

47
00:02:37,024 --> 00:02:41,061
这种体验能够
让您的 App 与众不同

48
00:02:41,094 --> 00:02:45,899
我将介绍如何在 iOS 15 及更高版本
上使用 StoreKit 2 实现这种效果

49
00:02:45,933 --> 00:02:49,636
此外 针对
支持旧版本 iOS 的 App

50
00:02:49,670 --> 00:02:51,905
我也将介绍如何使用旧版
StoreKit 和 verifyReceipt 端点

51
00:02:51,939 --> 00:02:55,542
来创造同样出色的体验

52
00:02:55,576 --> 00:02:58,178
背景介绍到此结束 我们进入正题

53
00:02:58,212 --> 00:03:02,149
在本期视频 我将首先详细描述
App 所用的核心顾客产品状态

54
00:03:02,182 --> 00:03:06,019
基于该状态 您的 App
能够使用 StoreKit

55
00:03:06,053 --> 00:03:10,257
基于顾客的 App 内购买记录生成个性化体验

56
00:03:10,290 --> 00:03:14,194
随后我将回顾使用 StoreKit 2
实现该效果的步骤

57
00:03:14,228 --> 00:03:19,132
我会用 StoreKit 演示 App
来完成示例代码

58
00:03:19,166 --> 00:03:21,335
先来看看每种 App 内购买项目类型
的核心顾客产品状态

59
00:03:23,370 --> 00:03:27,975
并查看一些个性化入职体验示例

60
00:03:28,008 --> 00:03:30,711
首先 适用的主动恢复的
App 内购类型包括

61
00:03:30,744 --> 00:03:35,148
非消耗品 非续订类订阅

62
00:03:35,182 --> 00:03:37,217
和自动续期订阅

63
00:03:37,251 --> 00:03:40,454
此类服务都记录在顾客的交易历史中

64
00:03:40,487 --> 00:03:43,056
StoreKit 始终可以调用

65
00:03:43,090 --> 00:03:46,994
因此 您的 App 可以识别
每个顾客帐户中

66
00:03:47,027 --> 00:03:51,298
对每个产品或订阅组的购买状态

67
00:03:51,331 --> 00:03:54,001
当查看顾客产品状态时

68
00:03:54,034 --> 00:03:57,104
我将使用“订阅项”一词来指代

69
00:03:57,137 --> 00:04:01,608
非续订和自动续订订阅

70
00:04:01,642 --> 00:04:05,078
以下是您的 App 可以针对其
进行个性化的三个核心状态

71
00:04:05,112 --> 00:04:08,549
让我们深入观察一下新顾客

72
00:04:08,582 --> 00:04:11,785
该状态表示的是某个已登录
App Store 的 Apple ID 中

73
00:04:11,818 --> 00:04:16,456
没有任何当前或过去的 App 内购买记录

74
00:04:16,490 --> 00:04:21,328
此状态通常也就是
App 的默认销售体验状态

75
00:04:21,361 --> 00:04:25,599
我们的“海洋日志”正在推销
可免费试用一个月的

76
00:04:25,632 --> 00:04:28,268
月度和年度订阅

77
00:04:28,302 --> 00:04:33,307
接下来是第二个核心状态
已购顾客和活跃订阅者

78
00:04:33,340 --> 00:04:36,210
在这种状态下
顾客有一个活跃的交易

79
00:04:36,243 --> 00:04:39,046
且您的 App 有义务授予顾客

80
00:04:39,079 --> 00:04:41,548
访问已购产品或服务的权限

81
00:04:41,582 --> 00:04:44,852
请看这里 “海洋日志”立即
给顾客推送了

82
00:04:44,885 --> 00:04:48,722
顾客偏好的海滩
以及高质量海滩实时镜头

83
00:04:48,755 --> 00:04:53,560
由于服务已主动恢复
购买按钮消失了

84
00:04:53,594 --> 00:04:56,263
对于每个已购产品或有效订阅

85
00:04:56,296 --> 00:05:00,501
其交易都具有
静态且唯一的原始交易 ID

86
00:05:00,534 --> 00:05:04,505
始终绑定顾客的
Apple ID 和 App Store

87
00:05:04,538 --> 00:05:07,274
为了维护顾客的交易状态

88
00:05:07,307 --> 00:05:12,012
您需要将原始交易 ID
与您系统的帐户关联

89
00:05:12,045 --> 00:05:14,147
它可以是匿名帐户

90
00:05:14,181 --> 00:05:17,017
或用户通过您的系统创建的帐户

91
00:05:17,050 --> 00:05:20,053
原始交易 ID 对于
充分利用 App Store

92
00:05:20,087 --> 00:05:23,290
服务器通知的强大功能非常重要

93
00:05:23,323 --> 00:05:27,194
能够使您的服务器始终
保持最新的交易状态

94
00:05:27,227 --> 00:05:30,397
需要强调的情况是 当顾客的订阅

95
00:05:30,430 --> 00:05:32,199
未能自动续订

96
00:05:32,232 --> 00:05:35,836
就进入了所谓的计费重试状态

97
00:05:35,869 --> 00:05:39,740
在该情况下 我们将努力在至多
60 天内恢复订阅

98
00:05:39,773 --> 00:05:43,544
如果您在 App Store Connect 中
选择了计费宽限期功能

99
00:05:43,577 --> 00:05:46,046
进入计费重试状态
但处于宽限期内的订阅者

100
00:05:46,079 --> 00:05:48,949
可以在我们努力恢复订阅的同时

101
00:05:48,982 --> 00:05:52,119
继续访问订阅服务

102
00:05:52,152 --> 00:05:54,688
虽然订阅者仍可以访问您的服务

103
00:05:54,721 --> 00:05:57,291
请务必为其展示简单的行为召唤

104
00:05:57,324 --> 00:05:59,459
来解决订阅者的付款问题

105
00:05:59,493 --> 00:06:02,596
如果您想详细了解
计费重试和计费宽限期

106
00:06:02,629 --> 00:06:04,598
请查看我们有关于
减少非自愿订户损失的

107
00:06:04,631 --> 00:06:08,569
讲座和资源

108
00:06:08,602 --> 00:06:13,574
最后一个核心状态是
不活跃购买或不活跃订阅者

109
00:06:13,607 --> 00:06:17,678
此状态代表顾客曾进行过 App 内购买

110
00:06:17,711 --> 00:06:20,747
但由于到期或被撤销

111
00:06:20,781 --> 00:06:23,984
不再有产品或服务使用权限的顾客

112
00:06:24,017 --> 00:06:28,188
这些交易始终存在
并包含原始交易 ID

113
00:06:28,222 --> 00:06:32,893
您因此能够跨设备和平台维护状态

114
00:06:32,926 --> 00:06:37,130
对于订阅 其非活跃状态
是由到期日期确定的

115
00:06:37,164 --> 00:06:38,966
对于所有 App 内购买项目类型

116
00:06:38,999 --> 00:06:42,135
如果存在撤销日期
就可能会处于非活跃状态

117
00:06:42,169 --> 00:06:44,638
会出现该状态的情况包括
交易已退款时

118
00:06:44,671 --> 00:06:48,575
或者通过家庭共享授予的
访问权限已被撤销时

119
00:06:48,609 --> 00:06:52,746
对于由于到期或被撤销
产生的非活动订阅者

120
00:06:52,779 --> 00:06:56,250
您可以考虑提供订阅优惠
来让顾客回归

121
00:06:56,283 --> 00:06:58,519
对于处于计费重试状态的顾客

122
00:06:58,552 --> 00:07:01,221
别忘记向他们展示同样的行为召唤

123
00:07:01,255 --> 00:07:03,891
来解决顾客的付款细节问题

124
00:07:03,924 --> 00:07:08,562
回顾一下 以下是
在主动恢复 App 内购买状态

125
00:07:08,595 --> 00:07:11,465
并为顾客量身定制 App 体验时

126
00:07:11,498 --> 00:07:15,068
App 将使用的三个
核心顾客产品状态

127
00:07:15,102 --> 00:07:19,473
接下来看看“海洋日志”是
怎样应用这些体验的吧

128
00:07:21,475 --> 00:07:26,146
新顾客将看到最新产品和试销优惠

129
00:07:26,180 --> 00:07:29,616
而活跃顾客会觉得
App 运行一如往常

130
00:07:29,650 --> 00:07:33,187
因为 App 在该类顾客的
所有设备上

131
00:07:33,220 --> 00:07:35,289
简化了对产品和服务的访问流程

132
00:07:35,322 --> 00:07:37,257
对于非活跃订阅者

133
00:07:37,291 --> 00:07:39,826
您可以用优惠代码或促销优惠

134
00:07:39,860 --> 00:07:42,763
向其展示最新的回归优惠

135
00:07:43,363 --> 00:07:46,967
到此我们已经介绍了
三个核心顾客产品状态

136
00:07:47,000 --> 00:07:50,971
也说明了为什么根据状态提供服务
能够为顾客带来良好体验

137
00:07:51,004 --> 00:07:54,775
但是当然 我们还有更进一步的空间

138
00:07:54,808 --> 00:07:57,611
您的 App 可以扩展或
改进顾客体验

139
00:07:57,644 --> 00:08:00,414
来适合您的产品供应 商业模式

140
00:08:00,447 --> 00:08:02,883
策略和优先事项

141
00:08:02,916 --> 00:08:04,885
但您在 App 中实施主动恢复时

142
00:08:04,918 --> 00:08:08,655
还有几件事需要考虑

143
00:08:09,756 --> 00:08:12,726
如果您支持多个产品或订阅组

144
00:08:12,759 --> 00:08:18,098
顾客状态是基于各产品
和订阅组分别确定的

145
00:08:18,131 --> 00:08:20,567
因此 您可能需要考虑混合状态

146
00:08:20,601 --> 00:08:23,937
或其他可能的依赖项

147
00:08:23,971 --> 00:08:26,240
请思考一下非平台活动

148
00:08:26,273 --> 00:08:30,377
以及该类活动会如何影响
顾客的产品状态

149
00:08:30,410 --> 00:08:33,280
以及 请务必查看
App Store 服务器通知

150
00:08:33,313 --> 00:08:36,683
因为这对于在服务器间同步

151
00:08:36,717 --> 00:08:39,319
所有 App 内购买项目类型的状态非常重要

152
00:08:39,353 --> 00:08:43,090
在版本 2 中 新的通知类型和
子类型

153
00:08:43,123 --> 00:08:45,292
能够近乎实时地
将 28 个独特事件

154
00:08:45,325 --> 00:08:48,929
安全发送到您的服务器

155
00:08:48,962 --> 00:08:52,399
如果您想深入了解
版本 2 的集成或迁移

156
00:08:52,432 --> 00:08:56,970
可以观看主题为
“探索 App 内购买的集成和迁移”的视频

157
00:08:57,004 --> 00:09:00,274
在视频中 Alex 和 Gabriel
还介绍了 StoreKit 2 的兼容性

158
00:09:00,307 --> 00:09:04,278
原始的 StoreKit 框架
以及最佳实践方式

159
00:09:04,311 --> 00:09:07,614
到目前为止 我们已经讨论了
支持的顾客产品状态

160
00:09:07,648 --> 00:09:11,151
以及这种体验可以
为您的顾客带来什么

161
00:09:11,185 --> 00:09:14,221
现在让我们来看看实现细节

162
00:09:14,254 --> 00:09:16,323
我将使用 StoreKit 演示 App

163
00:09:16,356 --> 00:09:20,027
演示 App 已经更新了
StoreKit 2 的主动恢复功能

164
00:09:20,060 --> 00:09:24,565
请注意 StoreKit 演示 App
可在本期视频中下载

165
00:09:24,598 --> 00:09:28,569
让我们看看 StoreKit 演示
为新顾客提供的默认体验

166
00:09:28,602 --> 00:09:31,405
也就是还没有进行任何 App 内购买的顾客

167
00:09:31,438 --> 00:09:34,942
为了查看产品
需要点击“商店”按钮

168
00:09:34,975 --> 00:09:38,045
屏幕上方展示了当前可用汽车库存

169
00:09:38,078 --> 00:09:41,114
这些术语非消耗型 App 内购买项目产品

170
00:09:41,148 --> 00:09:45,519
然后将导航服务设为
每月自动续期订阅服务

171
00:09:45,552 --> 00:09:50,190
提供三种不同级别的服务供顾客选择

172
00:09:50,224 --> 00:09:53,293
下方有一个非续订订阅选项

173
00:09:53,327 --> 00:09:55,729
允许一次性的访问

174
00:09:55,762 --> 00:09:58,398
以上就是我们 App

175
00:09:58,432 --> 00:10:00,901
提供给未消费顾客的新顾客体验

176
00:10:00,934 --> 00:10:03,904
现在让我们看看 App 如何确定

177
00:10:03,937 --> 00:10:07,708
该顾客在当前或过去是否有购买记录

178
00:10:07,741 --> 00:10:10,310
App 需要在启动后

179
00:10:10,344 --> 00:10:12,646
立即执行三个步骤

180
00:10:12,679 --> 00:10:15,649
最重要的是 在“购买”按钮
出现在顾客界面前

181
00:10:15,682 --> 00:10:19,119
这些步骤就全部完成了

182
00:10:19,853 --> 00:10:22,456
第一步 App 需要开始监听

183
00:10:22,489 --> 00:10:25,425
来自 App Store 的交易

184
00:10:25,459 --> 00:10:30,430
这是 App Store 的最佳使用方法
因为交易记录可能因为

185
00:10:30,464 --> 00:10:33,166
家庭共享询问购买、
代码兑换、订阅自动续订、

186
00:10:33,200 --> 00:10:35,936
或者中断购买等情况

187
00:10:35,969 --> 00:10:38,539
随时显示

188
00:10:38,572 --> 00:10:41,975
此外 由于退款而失去访问权限

189
00:10:42,009 --> 00:10:44,211
或不再通过家庭共享而撤销的交易

190
00:10:44,244 --> 00:10:47,347
也可以被 App 接收

191
00:10:47,381 --> 00:10:49,883
等被授予访问权限后

192
00:10:49,917 --> 00:10:52,152
且顾客状态
从活跃变为不活跃的过程中

193
00:10:52,186 --> 00:10:56,356
App 能在启动时更多应用此功能

194
00:10:56,390 --> 00:11:00,527
交易被发现后
会被判定为未完成交易

195
00:11:00,561 --> 00:11:03,330
需要经过验证 交付给顾客

196
00:11:03,363 --> 00:11:05,599
并标记为已完成

197
00:11:05,632 --> 00:11:08,435
由此 您的 App 可以保证
不错过任何交易

198
00:11:08,468 --> 00:11:10,971
并提供出色的顾客体验

199
00:11:11,004 --> 00:11:16,043
现在来看看 StoreKit 演示 App
是如何监听 StoreKit 2 交易的

200
00:11:16,076 --> 00:11:18,946
这里用了函数 listenForTransactions
即“监听交易”

201
00:11:18,979 --> 00:11:23,684
该函数将为已登录的
App Store 顾客

202
00:11:23,717 --> 00:11:26,787
返回任何未完成交易或更新交易

203
00:11:26,820 --> 00:11:28,622
对于发现的交易

204
00:11:28,655 --> 00:11:32,626
StoreKit 2 将验证交易
的真实性

205
00:11:32,659 --> 00:11:35,696
接着 在我的 App 交付内容后

206
00:11:35,729 --> 00:11:38,765
授予访问权限或更新顾客产品状态

207
00:11:38,799 --> 00:11:40,667
然后完成交易

208
00:11:40,701 --> 00:11:44,872
向 App Store 表明
购买已送达

209
00:11:44,905 --> 00:11:48,642
一旦交易完成
它将不会在任何设备上

210
00:11:48,675 --> 00:11:51,812
通过 StoreKit 返回到您的 App

211
00:11:51,845 --> 00:11:54,448
这第一个步骤对
所有 App 都非常重要

212
00:11:54,481 --> 00:11:58,185
此后每次 App 启动时
都会重复这一步骤

213
00:11:58,218 --> 00:12:01,922
第二步是确定顾客产品状态

214
00:12:01,955 --> 00:12:06,326
也就是要通过使用 currentEntitlements
即“当前授权”

215
00:12:06,360 --> 00:12:08,529
来主动请求顾客的活跃交易

216
00:12:08,562 --> 00:12:11,365
特别是自动续期订阅

217
00:12:11,398 --> 00:12:13,367
此类订阅会改变顾客状态

218
00:12:13,400 --> 00:12:16,737
例如已取消 计费重试或待降级

219
00:12:16,770 --> 00:12:22,576
这种情况下 您可以使用函数
Product.SubscriptionInfo.RenewalState

220
00:12:22,609 --> 00:12:27,214
来通过 StoreKit 演示
App 看看我们是如何做到这一点的

221
00:12:27,247 --> 00:12:30,651
从函数 updateCustomerProductStatus
即“更新顾客产品状态”开始

222
00:12:30,684 --> 00:12:33,687
该函数能够为每种长期 App 内购买项目类型

223
00:12:33,720 --> 00:12:37,758
跟踪顾客产品状态

224
00:12:37,791 --> 00:12:40,427
然后使用 StoreKit 2 的
currentEntitlements 方法

225
00:12:40,460 --> 00:12:43,997
遍历每种购买类型

226
00:12:44,031 --> 00:12:49,603
顾客所有可能获得产品授权
的交易都会被返回

227
00:12:49,636 --> 00:12:52,940
我们根据产品类型记录交易

228
00:12:52,973 --> 00:12:55,642
这是非消耗品的代码

229
00:12:55,676 --> 00:12:58,846
这是非续订订阅产品的

230
00:12:58,879 --> 00:13:03,350
为了确定顾客是活跃订阅者
还是非活跃订阅者

231
00:13:03,383 --> 00:13:06,553
我为非续订订阅添加了额外的逻辑

232
00:13:06,587 --> 00:13:09,423
来计算到期日期

233
00:13:09,456 --> 00:13:14,294
最后 我要检查一个
活跃的自动续期订阅

234
00:13:14,328 --> 00:13:17,731
并将该状态应用于订阅组

235
00:13:17,764 --> 00:13:22,202
考虑到非活动状态
例如计费重试、过期和撤销

236
00:13:22,236 --> 00:13:24,738
可变订阅组状态使用的是

237
00:13:24,771 --> 00:13:29,176
Product.SubscriptionInfo.RenewalState 函数

238
00:13:29,209 --> 00:13:31,411
现在我们已经检索了用户的交易

239
00:13:31,445 --> 00:13:35,682
并确定了各产品或订阅组的顾客状态

240
00:13:35,716 --> 00:13:38,519
我们的 App 获得了
能够支持为各种用例

241
00:13:38,552 --> 00:13:40,687
定制体验的逻辑

242
00:13:40,721 --> 00:13:44,791
让我们看看 StoreKit
演示 App 的源代码

243
00:13:44,825 --> 00:13:46,994
如果对于三种 App 内购买项目产品类型

244
00:13:47,027 --> 00:13:49,796
都没有发现活跃交易

245
00:13:49,830 --> 00:13:52,900
顾客将进行默认的新顾客体验

246
00:13:52,933 --> 00:13:54,868
就像我们之前看过的那样

247
00:13:54,902 --> 00:13:58,672
顾客将在“商店”页面
看到简单的行为召唤

248
00:13:58,705 --> 00:14:01,175
如果顾客有活跃交易的记录

249
00:14:01,208 --> 00:14:04,144
App 启动时 此类顾客将
看到已购买的服务

250
00:14:04,178 --> 00:14:08,015
各产品上的“购买”按钮
也会相对进行更新

251
00:14:08,048 --> 00:14:11,585
所以 对于非消耗品
我们将展示已购买产品与服务

252
00:14:11,618 --> 00:14:14,421
而 App 将显示已购的非消耗品

253
00:14:14,454 --> 00:14:16,190
或提供行动号召

254
00:14:16,223 --> 00:14:19,092
让顾客看到购买选项

255
00:14:19,126 --> 00:14:21,695
这里是对于活跃产品的处理方式

256
00:14:21,728 --> 00:14:25,199
在此情境下 顾客是导航服务

257
00:14:25,232 --> 00:14:29,102
非自动续期订阅与自动续期订阅
的活跃订阅者

258
00:14:29,136 --> 00:14:32,439
最后是不活跃的订阅者

259
00:14:32,472 --> 00:14:35,676
那些订阅项已过期、被撤销

260
00:14:35,709 --> 00:14:38,612
或处于计费重试状态的顾客

261
00:14:38,645 --> 00:14:41,915
接下来让我们进入
StoreKit 演示 App

262
00:14:41,949 --> 00:14:44,184
来模拟一位非消耗型和

263
00:14:44,218 --> 00:14:48,422
自动续期订阅活跃顾客

264
00:14:48,455 --> 00:14:52,226
假设我购买了赛车并订阅了专业导航

265
00:14:52,259 --> 00:14:54,595
演示 App 将应用绿色复选标记

266
00:14:54,628 --> 00:14:59,132
表示确认这些购买已成功、已验证

267
00:14:59,166 --> 00:15:01,068
且已启用

268
00:15:01,101 --> 00:15:03,570
通过购买以上产品与服务
我对于该非消耗品的顾客产品状态

269
00:15:03,604 --> 00:15:06,440
变为了已购买

270
00:15:06,473 --> 00:15:10,177
对于订阅项来说 我是活跃的订阅者

271
00:15:10,210 --> 00:15:12,546
现在 如果我将 App
安装在了新设备上

272
00:15:12,579 --> 00:15:15,349
当我第一次启动
StoreKit 演示 App 时

273
00:15:15,382 --> 00:15:19,720
它将主动执行步骤一、二、三

274
00:15:19,753 --> 00:15:24,324
在这里 您可以看到演示 App
已主动恢复了我的两项交易

275
00:15:24,358 --> 00:15:26,360
而且根本不需要我来操作

276
00:15:26,393 --> 00:15:27,828
由于这是一个演示 App

277
00:15:27,861 --> 00:15:30,597
产品的同步范围只能到这里了

278
00:15:30,631 --> 00:15:33,800
但在您的 App 中
此过程将确保不会给活跃顾客

279
00:15:33,834 --> 00:15:37,337
推送已购产品的购买信息

280
00:15:37,371 --> 00:15:41,308
还会自动为顾客启用这些产品和服务

281
00:15:41,875 --> 00:15:44,111
这对于您已有的顾客来说
是很棒的功能

282
00:15:44,144 --> 00:15:48,015
顾客无需登录或点击“恢复购买”

283
00:15:48,048 --> 00:15:49,316
简简单单就能起效

284
00:15:49,349 --> 00:15:53,921
您的 App 可以使用
现成的 API 和数据

285
00:15:53,954 --> 00:15:57,391
目前为止已经介绍了用 StoreKit 2
实现该功能的三个步骤

286
00:15:57,424 --> 00:16:01,328
接下来 我想说说该如何在
无法运用 StoreKit 2 强大功能的

287
00:16:01,361 --> 00:16:03,430
旧版本 iOS 上也为您的顾客

288
00:16:03,463 --> 00:16:05,999
带来同样的良好体验

289
00:16:06,800 --> 00:16:10,437
您需要在旧版 StoreKit 中执行
与 StoreKit 2 相同的步骤

290
00:16:10,470 --> 00:16:12,172
来确定顾客产品状态

291
00:16:12,206 --> 00:16:17,411
在 iOS 7 或更高版本上
主动恢复 App 内购买

292
00:16:17,444 --> 00:16:22,015
为此 您的服务器需要使用
verifyReceipt 端点

293
00:16:22,049 --> 00:16:25,352
来验证和检索最新交易

294
00:16:25,385 --> 00:16:29,556
以确定顾客的产品状态

295
00:16:29,590 --> 00:16:34,294
App Store 安装 App 时
设备上会显示 App 收据

296
00:16:34,328 --> 00:16:37,998
但请记住 在使用 Sandbox
或 TestFlight 进行测试时

297
00:16:38,031 --> 00:16:39,867
App 收据仅存在于

298
00:16:39,900 --> 00:16:43,704
App 内购买完成或恢复后

299
00:16:43,737 --> 00:16:48,509
App 无法找到 App 收据的情况
应该只发生在 Sandbox 中

300
00:16:48,542 --> 00:16:52,312
您的 App 可以将这种情况
等同于新顾客状态

301
00:16:52,346 --> 00:16:55,883
即没有发现 App 内购买记录的情况

302
00:16:55,916 --> 00:16:58,252
过去创建的 App 收据就足够

303
00:16:58,285 --> 00:17:01,555
从 App Store 检索最新交易了

304
00:17:01,588 --> 00:17:04,424
因此 就不需要
顾客的操作来“恢复购买”

305
00:17:04,458 --> 00:17:06,693
或者刷新收据

306
00:17:06,727 --> 00:17:10,631
只需在 verifyReceipt 请求中
包含共享密钥

307
00:17:10,664 --> 00:17:13,367
就能够接收最新的非消耗型订阅

308
00:17:13,400 --> 00:17:16,136
非续订订阅

309
00:17:16,170 --> 00:17:19,006
和自动续期订阅的交易

310
00:17:19,039 --> 00:17:23,610
让我们回顾一下三个实施步骤

311
00:17:23,644 --> 00:17:25,712
区别在于第二步

312
00:17:25,746 --> 00:17:29,683
也就是识别顾客产品状态的步骤

313
00:17:29,716 --> 00:17:34,121
确定顾客产品状态的流程
从设备上的 App 收据开始

314
00:17:34,154 --> 00:17:38,992
您的服务器也会用 App Store 的
verifyReceipt 端点验证收据

315
00:17:39,026 --> 00:17:41,528
我们来看看这个过程

316
00:17:41,562 --> 00:17:44,031
首先 我们需要检索 App 收据

317
00:17:44,064 --> 00:17:48,335
请您确保使用的是
appStoreReceiptURL 属性

318
00:17:48,368 --> 00:17:52,706
以开发者文档中的示例为准

319
00:17:52,739 --> 00:17:55,976
有了 App 收据
来看看设备从设备发送到

320
00:17:56,009 --> 00:18:00,047
您的服务器和 App Store 的过程

321
00:18:00,080 --> 00:18:02,683
左侧是您在设备上的 App

322
00:18:02,716 --> 00:18:05,686
它会首先检索 App 收据

323
00:18:05,719 --> 00:18:08,088
并将其发送到您的服务器

324
00:18:08,121 --> 00:18:12,159
然后使用 App Store verifyReceipt
端点对其进行验证

325
00:18:12,192 --> 00:18:16,129
验证结果将确定顾客产品状态

326
00:18:16,163 --> 00:18:19,867
状态信息会被发送到您的 App

327
00:18:19,900 --> 00:18:22,002
为了确定顾客产品状态

328
00:18:22,035 --> 00:18:23,904
我们使用了 WWDC20 大会的

329
00:18:23,937 --> 00:18:26,673
授权引擎

330
00:18:26,707 --> 00:18:31,011
该引擎现已更新
可支持非消耗型和非自动续期订阅

331
00:18:31,044 --> 00:18:35,182
在没有 App 内购买记录时
也能处理新顾客状态

332
00:18:36,517 --> 00:18:39,119
如果您想要了解授权引擎的更多信息

333
00:18:39,152 --> 00:18:42,990
建议您查看 WWDC20 的
“订阅服务架构”视频

334
00:18:43,023 --> 00:18:45,092
并下载示例项目

335
00:18:45,125 --> 00:18:50,364
您可以通过本视频的资源
找到该视频链接以及更多内容

336
00:18:50,864 --> 00:18:52,533
这样就完成了第二步

337
00:18:52,566 --> 00:18:55,769
在这一步 App 将从您的服务器
接收顾客产品状态

338
00:18:56,336 --> 00:19:00,507
现在 您的 App 将在启动时使用
StoreKit 2 和旧版 StoreKit 框架

339
00:19:00,541 --> 00:19:05,345
立即个性化 App 体验

340
00:19:05,379 --> 00:19:08,148
最后 我还想分享一些最佳实践方法

341
00:19:08,182 --> 00:19:12,653
首先 请在您的 App 中
保留“恢复购买”按钮

342
00:19:12,686 --> 00:19:13,854
虽然很少用到

343
00:19:13,887 --> 00:19:16,723
但在出现问题 或者顾客
使用了其他 Apple ID 时

344
00:19:16,757 --> 00:19:20,694
该按钮能够让顾客

345
00:19:20,727 --> 00:19:24,831
强制 App 恢复其 Apple ID 的交易

346
00:19:24,865 --> 00:19:29,770
当您的 App 首次在设备上
主动恢复顾客的 App 内购买时

347
00:19:29,803 --> 00:19:33,574
建议您优化 App 并安全存储数据

348
00:19:33,607 --> 00:19:36,643
这有助于确定顾客产品状态

349
00:19:36,677 --> 00:19:40,647
CloudKit 具有相当的灵活性 安全性
以及跨设备同步的能力

350
00:19:40,681 --> 00:19:45,052
是个值得应用的功能

351
00:19:45,085 --> 00:19:48,388
使用 StoreKit 时
进行实现测试非常重要

352
00:19:48,422 --> 00:19:52,259
有了 StoreKit 2 您可以使用 Sandbox
TestFlight 和 Xcode StoreKit

353
00:19:52,292 --> 00:19:57,364
测试主动恢复的效果

354
00:19:57,397 --> 00:19:59,766
如果您使用的是旧版 StoreKit

355
00:19:59,800 --> 00:20:03,070
请务必记住 在 Sandbox 和
TestFlight 中进行测试时

356
00:20:03,103 --> 00:20:06,206
可能无法检索到 App 收据

357
00:20:06,240 --> 00:20:10,077
而在 App Store 安装 App 后
必然产生 App 收据

358
00:20:10,110 --> 00:20:11,945
如果没有 App 收据

359
00:20:11,979 --> 00:20:16,083
建议您的 App 使用
默认的新顾客体验

360
00:20:16,116 --> 00:20:20,220
以及 请确保您备有
随时可用的“恢复购买”按钮

361
00:20:20,254 --> 00:20:23,857
总之 请您更新 App
主动检查交易记录

362
00:20:23,891 --> 00:20:28,529
此过程中 顾客无需点击
或验证等任何操作

363
00:20:28,562 --> 00:20:33,300
请您允许 App
在启动时定制顾客体验

364
00:20:33,333 --> 00:20:38,839
以分别适应新顾客 活跃顾客
和非活跃顾客的产品状态

365
00:20:38,872 --> 00:20:42,009
请在服务器间维护好
针对所有 App 内购买项目类型的

366
00:20:42,042 --> 00:20:45,145
顾客交易状态

367
00:20:45,179 --> 00:20:49,583
实现 App Store 服务器通知
版本 2 就能实现该功能

368
00:20:49,616 --> 00:20:52,886
由此 您的后端能够近乎实时地了解

369
00:20:52,920 --> 00:20:55,556
交易发生的任何变化

370
00:20:55,589 --> 00:20:58,625
比如退款或撤销交易

371
00:20:58,659 --> 00:21:02,963
或订阅续订 计费重试和服务到期

372
00:21:03,597 --> 00:21:05,933
感谢您的收看 请务必查看

373
00:21:05,966 --> 00:21:09,069
另一个视频 主题为
“App 内购买的新功能”

374
00:21:09,102 --> 00:21:11,772
在该视频中 Dani 和 Ian 将
向您介绍有关 App 内购买的所有重大更新

375
00:21:11,805 --> 00:21:15,776
包括 StoreKit、Server API
和 Server Notifications Version 2

376
00:21:16,243 --> 00:21:18,111
感谢收看 祝您一切顺利

377
00:21:18,145 --> 00:21:21,148
[欢快的音乐]

