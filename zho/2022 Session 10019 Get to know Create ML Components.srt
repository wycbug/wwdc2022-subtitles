1
00:00:00,033 --> 00:00:03,003
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,003 --> 00:00:09,276
♪

3
00:00:09,276 --> 00:00:11,011
您好 我是 Alejandro

4
00:00:11,011 --> 00:00:13,247
我是
CreateML 团队的工程师

5
00:00:13,247 --> 00:00:15,582
今天我要介绍一个

6
00:00:15,582 --> 00:00:19,453
基于组件构建
机器学习模型的全新 API

7
00:00:19,453 --> 00:00:21,655
Create ML 提供一种
简单的 API

8
00:00:21,655 --> 00:00:23,957
来训练机器学习的模型

9
00:00:23,957 --> 00:00:25,826
它基于一组支持的任务

10
00:00:25,826 --> 00:00:31,198
比如图像分类 声音分类等等

11
00:00:31,198 --> 00:00:33,567
在 WWDC 2021

12
00:00:33,567 --> 00:00:36,937
我们就 Create ML 框架
进行了两场精彩的演讲

13
00:00:36,937 --> 00:00:39,873
如果您还没看过
请务必查看这些内容

14
00:00:39,873 --> 00:00:42,943
但现在我想谈谈
如何超越预定义任务

15
00:00:42,943 --> 00:00:44,611
如果您想自定义

16
00:00:44,611 --> 00:00:48,115
Create ML 解决方案
以外的任务 该怎么办？

17
00:00:48,115 --> 00:00:51,752
又或者 如果您想构建
其他类型的任务 该怎么办？

18
00:00:51,752 --> 00:00:54,254
使用组件 您就可以
用新的创造性方式

19
00:00:54,254 --> 00:00:56,056
进行任务编写

20
00:00:56,056 --> 00:00:58,325
让我们进一步探讨

21
00:00:58,325 --> 00:01:00,427
我将从分解机器学习任务

22
00:01:00,427 --> 00:01:03,397
并解释每个组件的作用开始

23
00:01:03,397 --> 00:01:07,234
然后讨论应该如何将组件拼合起来

24
00:01:07,234 --> 00:01:10,404
接下来是自定义图像任务的示例

25
00:01:10,404 --> 00:01:13,507
之后 我将讨论表列任务

26
00:01:13,507 --> 00:01:16,610
最后以部署策略结束今天的讲座

27
00:01:16,610 --> 00:01:18,378
就让我从探讨一项机器学习任务的

28
00:01:18,378 --> 00:01:20,781
内部细节入手 以便让您了解

29
00:01:20,781 --> 00:01:23,217
它的内容和工作原理

30
00:01:23,217 --> 00:01:25,652
这样一来
当我们开始构建自定义任务时

31
00:01:25,652 --> 00:01:27,421
您就会更容易理解我在说什么

32
00:01:27,421 --> 00:01:31,158
我将以图像分类器为例

33
00:01:31,158 --> 00:01:34,094
图像分类器使用标记图像列表

34
00:01:34,094 --> 00:01:36,096
对模型进行训练

35
00:01:36,096 --> 00:01:38,799
在这个例子当中
我有一系列猫和狗的图像

36
00:01:38,799 --> 00:01:41,235
各自带有标签

37
00:01:41,235 --> 00:01:45,339
但让我们先来研究一下
图像在每一步是如何转换的

38
00:01:45,339 --> 00:01:48,208
为此 我将展开图像分类任务

39
00:01:48,208 --> 00:01:50,711
看看里面有些什么

40
00:01:50,711 --> 00:01:53,280
从概念上看 图像分类器非常简单

41
00:01:53,280 --> 00:01:56,650
它由特征提取器和分类器组成

42
00:01:56,650 --> 00:01:59,987
重要的一点
是 Create ML 组件

43
00:01:59,987 --> 00:02:02,890
让您可以独立访问这些组件

44
00:02:02,890 --> 00:02:07,761
您可以通过添加 移除
或切换组件来编写新任务

45
00:02:07,761 --> 00:02:10,664
我将用方框来代表组件

46
00:02:10,664 --> 00:02:12,900
用箭头代表数据流

47
00:02:12,900 --> 00:02:15,669
让我们关注图像分类器的第一步

48
00:02:15,669 --> 00:02:18,272
特征提取

49
00:02:18,272 --> 00:02:21,308
通常 特征提取器
会对输入进行降维处理

50
00:02:21,308 --> 00:02:24,278
只保留有趣的关键部分

51
00:02:24,278 --> 00:02:25,646
即“特征”

52
00:02:25,646 --> 00:02:26,980
处理图像时

53
00:02:26,980 --> 00:02:31,018
特征提取器从图像中寻找模式

54
00:02:31,018 --> 00:02:33,687
Create ML 使用
Vision Feature Print

55
00:02:33,687 --> 00:02:36,223
它是由 Vision 框架提供的

56
00:02:36,223 --> 00:02:39,459
出色的图像特征提取器

57
00:02:39,459 --> 00:02:41,528
现在 让我们再来谈谈第二部分

58
00:02:41,528 --> 00:02:42,930
分类器

59
00:02:42,930 --> 00:02:45,199
分类器使用一组示例

60
00:02:45,199 --> 00:02:47,668
来学习分类

61
00:02:47,668 --> 00:02:50,771
常见的实现方式包括逻辑回归算法

62
00:02:50,771 --> 00:02:54,241
提升树算法和神经网络算法

63
00:02:54,241 --> 00:02:57,711
也就是说 图像分类器的训练
从带注释的图像开始

64
00:02:57,711 --> 00:03:02,249
接下来是带注释的特征
并以分类器结束

65
00:03:02,249 --> 00:03:05,118
那我们为什么要对它进行拆解呢？

66
00:03:05,118 --> 00:03:08,689
因为我们想扩展可能性

67
00:03:08,689 --> 00:03:10,657
也许您想通过增加对比度

68
00:03:10,657 --> 00:03:12,860
对图像做一些预处理

69
00:03:12,860 --> 00:03:15,062
也许您想对所有图像进行归一化处理

70
00:03:15,062 --> 00:03:19,533
以确保提取特征前
它们具有统一的亮度

71
00:03:19,533 --> 00:03:22,803
也许您想尝试不同的特征提取器

72
00:03:22,803 --> 00:03:25,639
也许您想尝试不同的分类器

73
00:03:25,639 --> 00:03:27,975
可能性永无止境

74
00:03:27,975 --> 00:03:30,644
这些只是其中的几个选项

75
00:03:30,644 --> 00:03:33,113
因此我们在 macOS iOS
iPadOS 和 tvOS 中

76
00:03:33,113 --> 00:03:37,718
添加了对 ML 组件的支持

77
00:03:37,718 --> 00:03:40,053
我们希望您能创建出新的模型

78
00:03:40,053 --> 00:03:41,722
使用我们提供的部分组件

79
00:03:41,722 --> 00:03:43,457
与您自己的组件配合

80
00:03:43,457 --> 00:03:46,226
甚至是和社群中其他人
创建的组件一同使用

81
00:03:46,226 --> 00:03:49,730
您可以在我们所有的平台上使用它

82
00:03:49,730 --> 00:03:54,835
以下是 Create ML Components 中
内置的一些组件

83
00:03:54,835 --> 00:03:58,238
但让我先回过头来介绍一些概念

84
00:03:58,238 --> 00:03:59,706
组件分为两种类型

85
00:03:59,706 --> 00:04:02,176
转换器和估算器

86
00:04:02,176 --> 00:04:04,011
转换器仅仅是一种

87
00:04:04,011 --> 00:04:07,014
能够执行部分转换的类型

88
00:04:07,014 --> 00:04:10,350
它定义输入类型和输出类型

89
00:04:10,350 --> 00:04:14,221
例如 图像特征提取器获取输入图像

90
00:04:14,221 --> 00:04:17,691
并产出特征整形数组

91
00:04:17,691 --> 00:04:21,628
而估算器则需要从数据中学习

92
00:04:21,628 --> 00:04:25,098
它获取输入示例 进行一些处理后

93
00:04:25,098 --> 00:04:27,267
生成转换器

94
00:04:27,267 --> 00:04:30,370
我们称这个过程为“拟合”

95
00:04:30,370 --> 00:04:33,140
很好 解决了这些概念

96
00:04:33,140 --> 00:04:35,609
接下来我会说明
Create ML 组件

97
00:04:35,609 --> 00:04:37,711
如何通过合成各个组件

98
00:04:37,711 --> 00:04:41,181
创建处图像分类器

99
00:04:41,181 --> 00:04:44,084
这是一个使用组件的图像分类器

100
00:04:44,084 --> 00:04:46,954
它将 ImageFeaturePrint
作为特征提取器

101
00:04:46,954 --> 00:04:50,290
将 LogisticRegressionClassifier
作为分类器

102
00:04:50,290 --> 00:04:52,159
无论一个组件

103
00:04:52,159 --> 00:04:54,428
是转换器还是估算器

104
00:04:54,428 --> 00:04:58,999
都可以用
appending 方法进行组合

105
00:04:58,999 --> 00:05:02,503
这就是为什么说
组件可以带来无限的可能性

106
00:05:02,503 --> 00:05:05,272
您可以使用全连接神经网络
作为分类器

107
00:05:05,272 --> 00:05:09,443
而不是简单更改逻辑回归算法

108
00:05:09,443 --> 00:05:13,413
您也可以在 CoreML 模型中
使用自定义特征提取器

109
00:05:13,413 --> 00:05:16,450
例如 可以在模型库中找到的

110
00:05:16,450 --> 00:05:19,786
无头 ResNet-50 模型

111
00:05:19,786 --> 00:05:21,688
合成两个组件时

112
00:05:21,688 --> 00:05:23,390
第一个组件的输出类型

113
00:05:23,390 --> 00:05:25,759
必须和第二个组件的输入类型匹配

114
00:05:25,759 --> 00:05:27,995
就我们的图像分类器来说

115
00:05:27,995 --> 00:05:30,831
特征提取器的输出是一个
来自 CoreML 框架的

116
00:05:30,831 --> 00:05:32,666
Shaped 数组

117
00:05:32,666 --> 00:05:36,503
这也是逻辑回归分类器的输入

118
00:05:36,503 --> 00:05:39,740
如果在使用附加法时
遇到编译器错误

119
00:05:39,740 --> 00:05:41,909
首先要检查这里

120
00:05:41,909 --> 00:05:44,444
确保类型匹配

121
00:05:44,444 --> 00:05:48,415
但我要澄清一个
跟拟合有关的重要观点

122
00:05:48,415 --> 00:05:50,551
我之前说过 拟合是

123
00:05:50,551 --> 00:05:53,487
从估算器到转换器的过程

124
00:05:53,487 --> 00:05:55,088
让我们从组合估算器的角度

125
00:05:55,088 --> 00:05:57,524
来看一看

126
00:05:57,524 --> 00:05:58,825
当组合估算器中

127
00:05:58,825 --> 00:06:01,061
既有转换器又有估算器时

128
00:06:01,061 --> 00:06:03,330
例如在图像分类器的案例中

129
00:06:03,330 --> 00:06:05,933
仅对估算器的部分进行拟合

130
00:06:05,933 --> 00:06:09,002
但转换器是该过程的重要组成部分

131
00:06:09,002 --> 00:06:11,271
因为它们被用于向估算器的拟合方法

132
00:06:11,271 --> 00:06:14,308
馈送正确的特征

133
00:06:14,308 --> 00:06:15,509
这是代码

134
00:06:15,509 --> 00:06:16,877
图像分类器

135
00:06:16,877 --> 00:06:19,446
需要一个带注释的特征集合

136
00:06:19,446 --> 00:06:24,251
其中特征是图像 注释是字符串

137
00:06:24,251 --> 00:06:25,886
我们将在进入演示时

138
00:06:25,886 --> 00:06:28,956
讨论特征的加载

139
00:06:28,956 --> 00:06:32,326
一旦有了数据 就可以调用拟合法

140
00:06:32,326 --> 00:06:37,264
它将返回经过训练的模型
即一个转换器

141
00:06:37,264 --> 00:06:39,933
要重点注意的是 拟合时使用的类型

142
00:06:39,933 --> 00:06:42,269
与生成转换器的类型

143
00:06:42,269 --> 00:06:44,972
相互关联 但并不相同

144
00:06:44,972 --> 00:06:47,774
尤其是拟合法中使用的类型

145
00:06:47,774 --> 00:06:49,643
始终是集合

146
00:06:49,643 --> 00:06:52,045
在使用监督估算器的情况下

147
00:06:52,045 --> 00:06:55,415
特征必须包括注释

148
00:06:55,415 --> 00:06:58,485
Create ML Components
使用 AnnotatedFeature 类型

149
00:06:58,485 --> 00:07:03,056
来表述特征及其注释

150
00:07:03,056 --> 00:07:06,226
一旦有了模型 就可以进行预测

151
00:07:06,226 --> 00:07:08,462
无论是用我刚刚拟合的模型

152
00:07:08,462 --> 00:07:11,765
还是从硬盘加载的参数

153
00:07:11,765 --> 00:07:15,702
两者采用的 API 都是相同的

154
00:07:15,702 --> 00:07:17,571
由于我训练的是分类器

155
00:07:17,571 --> 00:07:20,874
结果就是分类分布

156
00:07:20,874 --> 00:07:25,312
该分布包含了每个标签的概率

157
00:07:25,312 --> 00:07:27,681
在这种情况下 我只为图像打印

158
00:07:27,681 --> 00:07:30,817
可能性最高的标签

159
00:07:30,817 --> 00:07:33,320
拟合法还提供了一种机制

160
00:07:33,320 --> 00:07:37,457
用于观察训练事件 包括验证指标

161
00:07:37,457 --> 00:07:39,826
在这个例子中 我传送验证数据

162
00:07:39,826 --> 00:07:43,096
并打印验证准确性

163
00:07:43,096 --> 00:07:44,798
请注意 只有监督估算器

164
00:07:44,798 --> 00:07:48,402
才提供验证指标

165
00:07:48,402 --> 00:07:50,003
一旦完成了模型的训练

166
00:07:50,003 --> 00:07:52,372
您可以保存学习的参数

167
00:07:52,372 --> 00:07:56,009
既可以在将来重新使用
也可以部署到 App 中

168
00:07:56,009 --> 00:07:58,545
您可以使用 write 方法
进行这项操作

169
00:07:58,545 --> 00:08:02,249
之后可以通过 read 方法
进行数据读取

170
00:08:02,249 --> 00:08:04,184
这就是合成

171
00:08:04,184 --> 00:08:06,653
从这里开始就变得有趣了

172
00:08:06,653 --> 00:08:08,755
先来谈谈新任务的编写吧

173
00:08:08,755 --> 00:08:11,758
这是 Create ML
刚刚开始支持的功能

174
00:08:13,727 --> 00:08:17,598
假使您想训练模型
对图像进行评分该怎么做？

175
00:08:17,598 --> 00:08:19,633
假设您有一些水果的照片

176
00:08:19,633 --> 00:08:21,602
但不是要对水果进行分类

177
00:08:21,602 --> 00:08:23,670
而是要评价它

178
00:08:23,670 --> 00:08:26,607
根据它的成熟程度进行评分

179
00:08:26,607 --> 00:08:28,809
为此 您需要使用回归

180
00:08:28,809 --> 00:08:30,944
而不是分类

181
00:08:30,944 --> 00:08:33,046
所以我来写一个图像回归器

182
00:08:33,046 --> 00:08:37,551
根据成熟度为香蕉图像打分

183
00:08:37,551 --> 00:08:43,090
我会给每张图片一个
介于 1 到 10 之间的成熟度值

184
00:08:43,090 --> 00:08:47,594
图像回归器与图像分类器很相似

185
00:08:47,594 --> 00:08:49,696
唯一的区别是估算器

186
00:08:49,696 --> 00:08:54,168
将成为回归器而不是分类器

187
00:08:54,168 --> 00:08:55,869
您可能已经猜到了

188
00:08:55,869 --> 00:08:58,238
这将会很容易

189
00:08:58,238 --> 00:09:01,875
帮您回忆一下
这是我们的图像分类器

190
00:09:01,875 --> 00:09:04,411
而这是一个图像回归器

191
00:09:04,411 --> 00:09:07,181
我用线性回归器替换了

192
00:09:07,181 --> 00:09:09,583
逻辑回归分类器

193
00:09:09,583 --> 00:09:12,786
这一简单的改变也使拟合法的

194
00:09:12,786 --> 00:09:15,122
预期输入发生了变化

195
00:09:15,122 --> 00:09:17,791
之前 它预期的是图像和标签

196
00:09:17,791 --> 00:09:20,961
现在 它预期的是图像和分数

197
00:09:20,961 --> 00:09:22,429
概念说到这里就足够了

198
00:09:22,429 --> 00:09:25,899
让我用实际的代码来演示一下

199
00:09:28,502 --> 00:09:31,538
让我向您展示如何
编写自定义图像回归器

200
00:09:31,538 --> 00:09:33,640
我将从定义
ImageRegressor 结构

201
00:09:33,640 --> 00:09:36,443
以封装代码开始

202
00:09:38,445 --> 00:09:40,547
我有一个包含不同成熟度的

203
00:09:40,547 --> 00:09:42,716
香蕉图像的文件夹

204
00:09:42,716 --> 00:09:46,119
我将首先定义这个 URL

205
00:09:48,121 --> 00:09:51,124
下一步是添加 train 方法

206
00:09:51,124 --> 00:09:52,292
在这里您可以使用

207
00:09:52,292 --> 00:09:56,230
训练数据来生成模型

208
00:09:56,230 --> 00:09:59,266
我将在返回类型上
使用“some”关键字

209
00:09:59,266 --> 00:10:00,968
这样一来 当我在组合估算器中

210
00:10:00,968 --> 00:10:05,138
添加或修改步骤时
返回类型就不会改变

211
00:10:05,138 --> 00:10:07,341
现在 我要定义估算器

212
00:10:07,341 --> 00:10:09,042
它只是简单地在特征提取器上

213
00:10:09,042 --> 00:10:14,047
附加了线性回归器

214
00:10:14,047 --> 00:10:16,316
现在 我需要加载训练用的图像

215
00:10:16,316 --> 00:10:17,584
以及它们的分数

216
00:10:17,584 --> 00:10:19,820
我可以使用 AnnotatedFiles
它是一个

217
00:10:19,820 --> 00:10:24,157
包含 URL 和字符串标签的
AnnotatedFeatures 集合

218
00:10:24,157 --> 00:10:29,730
它提供了一个满足我需求的
方便的初始设定式

219
00:10:29,730 --> 00:10:32,599
我的文件都有一个名称
后面跟一个破折号

220
00:10:32,599 --> 00:10:34,201
后面跟着成熟度值

221
00:10:34,201 --> 00:10:37,604
所以我要指定分隔符为破折号

222
00:10:37,604 --> 00:10:39,306
并且指定注释位于

223
00:10:39,306 --> 00:10:41,308
文件名组件的 index: 1

224
00:10:41,308 --> 00:10:42,543
我还准备通过

225
00:10:42,543 --> 00:10:46,146
使用类型参数 仅请求图像文件

226
00:10:46,146 --> 00:10:49,683
现在有了 URL
我就需要加载图像

227
00:10:49,683 --> 00:10:51,385
这可以通过
mapFeatures 方法

228
00:10:51,385 --> 00:10:56,690
和 ImageReader
来实现

229
00:10:56,690 --> 00:10:58,725
我还需要将分数

230
00:10:58,725 --> 00:11:01,662
从字符串转换为浮点值

231
00:11:01,662 --> 00:11:05,599
这可以通过
mapAnnotations 方法来实现

232
00:11:08,936 --> 00:11:12,005
这样一来 我就获得了训练数据

233
00:11:12,005 --> 00:11:15,175
但我想把其中一些拿出来用于验证

234
00:11:15,175 --> 00:11:17,911
这可以使用
randomSplit 方法来实现

235
00:11:17,911 --> 00:11:19,446
我将保留 80% 的数据用于训练

236
00:11:19,446 --> 00:11:25,219
并使用剩余的进行验证

237
00:11:25,219 --> 00:11:27,221
现在 我准备好进行拟合了

238
00:11:29,957 --> 00:11:32,025
我还要保存训练好的参数

239
00:11:32,025 --> 00:11:33,827
以便部署到我的 App 中

240
00:11:33,827 --> 00:11:36,129
我要选择一个保存的位置

241
00:11:40,033 --> 00:11:42,236
我将调用 write 方法

242
00:11:44,671 --> 00:11:46,940
最后 我将返回转换器

243
00:11:50,944 --> 00:11:53,514
这是使用组件定义和训练模型的

244
00:11:53,514 --> 00:11:55,249
本质所在

245
00:11:55,249 --> 00:11:57,651
我定义了组合估算器

246
00:11:57,651 --> 00:12:00,921
加载了训练数据 调用了拟合方法

247
00:12:00,921 --> 00:12:03,257
用 write 方法来保存参数

248
00:12:03,257 --> 00:12:05,592
但还有些地方是可以改进的

249
00:12:05,592 --> 00:12:08,562
首先 我正在传递验证数据集

250
00:12:08,562 --> 00:12:11,231
但并没有观察验证错误

251
00:12:11,231 --> 00:12:12,933
所以我会这样做

252
00:12:12,933 --> 00:12:15,135
拟合法需要一个事件处理程序

253
00:12:15,135 --> 00:12:17,237
可以用于收集指标

254
00:12:21,375 --> 00:12:23,777
现在 我将只打印训练

255
00:12:23,777 --> 00:12:26,914
和验证的最大误差值

256
00:12:26,914 --> 00:12:30,751
我还想要最终模型的平均绝对误差

257
00:12:33,987 --> 00:12:36,356
我的计算方法是将拟合转换器

258
00:12:36,356 --> 00:12:37,991
用于验证特征

259
00:12:37,991 --> 00:12:40,594
然后将它与实际分数一起传递给

260
00:12:40,594 --> 00:12:44,565
meanAbsoluteError 函数

261
00:12:44,565 --> 00:12:46,800
运行之后 我并没有
获得一个出色的模型

262
00:12:46,800 --> 00:12:49,136
错误率很高

263
00:12:49,136 --> 00:12:52,206
这是因为我没有足够多的香蕉图像

264
00:12:52,206 --> 00:12:54,808
我应该去获取更多图像
但在这样做之前

265
00:12:54,808 --> 00:12:57,244
我可以尝试增强数据集

266
00:12:57,244 --> 00:13:00,514
我可以对图像进行旋转和缩放
以获得更多示例

267
00:13:00,514 --> 00:13:02,482
为此 我将编写一个新方法

268
00:13:02,482 --> 00:13:05,586
使用带注释的图像并对其进行增强

269
00:13:05,586 --> 00:13:08,155
它会返回一个带注释的图像数组

270
00:13:13,827 --> 00:13:17,664
我要实现的第一种增强是旋转

271
00:13:20,801 --> 00:13:23,704
我会在 -pi 和 pi 之间
随机选取一个角度

272
00:13:23,704 --> 00:13:26,073
并以这个角度旋转图像

273
00:13:26,073 --> 00:13:28,542
我还设置了随机缩放

274
00:13:31,144 --> 00:13:32,713
之后会返回三个图像

275
00:13:32,713 --> 00:13:36,083
原始的 旋转的和缩放的

276
00:13:39,119 --> 00:13:40,687
现在有了增强函数

277
00:13:40,687 --> 00:13:44,691
我将使用它来借助
flatMap 增强我的训练图像

278
00:13:49,429 --> 00:13:53,367
我的数据集中
每个元素都将转换为一个数组

279
00:13:53,367 --> 00:13:56,937
FlatMap 将该数组集合
平铺为单个数组

280
00:13:56,937 --> 00:13:59,606
这是拟合法所需要的

281
00:13:59,606 --> 00:14:02,409
请注意 增强仅适用于拟合

282
00:14:02,409 --> 00:14:04,945
而不适用于预测

283
00:14:04,945 --> 00:14:07,481
好的 这样我的准确性就提高了

284
00:14:07,481 --> 00:14:09,383
让我来谈谈另一项

285
00:14:09,383 --> 00:14:12,219
可以进一步改善我的模型的措施

286
00:14:12,219 --> 00:14:13,620
我想使用 Vision 框架

287
00:14:13,620 --> 00:14:16,924
将图像裁剪到只剩突出对象

288
00:14:16,924 --> 00:14:19,326
这是我的训练数据中的一张图片

289
00:14:19,326 --> 00:14:23,096
一个人拿着香蕉 背景中有其他水果

290
00:14:23,096 --> 00:14:27,301
模型可能会混淆照片中的其他物体

291
00:14:27,301 --> 00:14:29,269
使用 Vision 框架 API

292
00:14:29,269 --> 00:14:31,004
可以实现自动裁剪图像

293
00:14:31,004 --> 00:14:33,574
仅突出最显著的对象

294
00:14:33,574 --> 00:14:38,745
查看 WWDC 2019 上
关于 Vision 的演讲以了解

295
00:14:38,745 --> 00:14:41,949
如果写一个自定义转换器

296
00:14:41,949 --> 00:14:44,184
就可以轻松地将
这种转换应用于所有图像

297
00:14:44,184 --> 00:14:46,420
在拟合和预测时均可使用

298
00:14:46,420 --> 00:14:47,988
让我告诉您该怎么做

299
00:14:47,988 --> 00:14:49,423
为了符合转换器协议

300
00:14:49,423 --> 00:14:51,425
我唯一需要做的

301
00:14:51,425 --> 00:14:53,660
就是实现应用的方法

302
00:14:53,660 --> 00:14:55,896
在这个案例里
我想要它获取一张图片

303
00:14:55,896 --> 00:14:57,698
并返回一张图片

304
00:14:57,698 --> 00:14:59,266
我就不详细解释这段代码了

305
00:14:59,266 --> 00:15:02,236
但还是提一句
如果得不到显著的对象

306
00:15:02,236 --> 00:15:06,306
只需要返回原始图像

307
00:15:06,306 --> 00:15:08,141
现在有了自定义转换器

308
00:15:08,141 --> 00:15:10,077
我要将它添加到我的图像回归器中

309
00:15:16,416 --> 00:15:18,218
我只需要在特征提取之前

310
00:15:18,218 --> 00:15:19,987
使用自定义转换器即可

311
00:15:28,695 --> 00:15:31,431
现在显著性成了
我任务定义的一部分

312
00:15:31,431 --> 00:15:34,134
它将用于裁剪每个训练图像

313
00:15:34,134 --> 00:15:37,070
进行推理时也会用到它

314
00:15:37,070 --> 00:15:39,706
这是将任务定义
同时分配给训练和推理的

315
00:15:39,706 --> 00:15:42,142
优势之一

316
00:15:42,142 --> 00:15:44,378
在继续下一个任务之前

317
00:15:44,378 --> 00:15:46,813
我要强调几个重点事项

318
00:15:46,813 --> 00:15:50,651
使用组件 我可以创建自定义任务

319
00:15:50,651 --> 00:15:53,453
我通过使用 appending 方法
来实现这一点

320
00:15:53,453 --> 00:15:55,956
我使用 AnnotatedFiles 来加载

321
00:15:55,956 --> 00:15:58,125
带有注释名称的文件

322
00:15:58,125 --> 00:16:01,428
也可以加载由目录注释的文件

323
00:16:01,428 --> 00:16:04,665
我使用 ImageReader
将 URL 映射到图像

324
00:16:04,665 --> 00:16:08,602
并将注释从字符串映射到值

325
00:16:08,602 --> 00:16:12,239
我使用 randomSplit
留出一个验证数据集

326
00:16:12,239 --> 00:16:15,409
还保存了训练好的参数供以后使用

327
00:16:15,409 --> 00:16:18,278
然后我添加了增强功能
并定义了一个自定义转换器

328
00:16:18,278 --> 00:16:20,314
来改进我的模型

329
00:16:20,314 --> 00:16:23,250
但这不仅仅适用于图像

330
00:16:23,250 --> 00:16:26,320
我要换个方向
谈谈另一种类型的任务

331
00:16:26,320 --> 00:16:28,188
表列任务

332
00:16:28,188 --> 00:16:30,958
它们是使用表列数据的任务

333
00:16:30,958 --> 00:16:33,493
表列数据的特点是拥有

334
00:16:33,493 --> 00:16:35,295
不同类型的多种特征

335
00:16:35,295 --> 00:16:37,130
它既包含了数值数据

336
00:16:37,130 --> 00:16:39,333
也包含了分类数据

337
00:16:39,333 --> 00:16:42,402
房价数据就是一个受欢迎的例子

338
00:16:42,402 --> 00:16:44,905
既涉及面积和房龄之类的数据

339
00:16:44,905 --> 00:16:46,507
也包含了街区位置

340
00:16:46,507 --> 00:16:48,742
建筑类型等信息

341
00:16:48,742 --> 00:16:51,111
现在您想学习预测一个值

342
00:16:51,111 --> 00:16:53,780
比如说 销售价格

343
00:16:53,780 --> 00:16:58,352
2021 年 我们引入了
TabularData 框架

344
00:16:58,352 --> 00:17:00,153
现在您可以使用
TabularData 框架

345
00:17:00,153 --> 00:17:02,356
配合 Create ML 组件

346
00:17:02,356 --> 00:17:06,927
来创建和训练表列分类器和回归器

347
00:17:06,927 --> 00:17:09,696
我还推荐您查看
关于 TabularData 的 Tech Talk

348
00:17:09,696 --> 00:17:12,232
它对数据探索进行了精彩的介绍

349
00:17:12,232 --> 00:17:15,269
您在构建表列任务时可能会需要

350
00:17:15,269 --> 00:17:17,971
让我们了解一下吧

351
00:17:17,971 --> 00:17:21,408
在处理表列数据时 表列的每一列

352
00:17:21,408 --> 00:17:23,877
都包含不同类型的特征

353
00:17:23,877 --> 00:17:26,413
您可能希望基于每一列

354
00:17:26,413 --> 00:17:28,448
包含的信息类型

355
00:17:28,448 --> 00:17:30,150
比如分布 数值范围

356
00:17:30,150 --> 00:17:32,352
和其他因素分别进行处理

357
00:17:32,352 --> 00:17:36,323
Create ML Components 提供了
ColumnSelector 来执行此操作

358
00:17:36,323 --> 00:17:38,492
来看看这个例子

359
00:17:38,492 --> 00:17:42,029
我刚才提到了房价 但房价太离谱了

360
00:17:42,029 --> 00:17:44,765
我将改用鳄梨价格来举例

361
00:17:44,765 --> 00:17:47,267
这里有一张鳄梨价格表

362
00:17:47,267 --> 00:17:49,236
我想创建一个表列回归器

363
00:17:49,236 --> 00:17:52,105
基于表列数据预测鳄梨价格

364
00:17:52,105 --> 00:17:54,241
表列里既有包含数值数据的列

365
00:17:54,241 --> 00:17:56,643
例如袋数 年份和总量

366
00:17:56,643 --> 00:18:01,715
也有包含类型和
区域等分类数据的列

367
00:18:01,715 --> 00:18:03,450
有些回归器受益于

368
00:18:03,450 --> 00:18:06,620
对这些值更好的表述

369
00:18:06,620 --> 00:18:08,088
比如说

370
00:18:08,088 --> 00:18:11,658
这是数据集中总量值的分布

371
00:18:11,658 --> 00:18:14,094
它接近正态分布

372
00:18:14,094 --> 00:18:17,698
但较大的值大多
在 15,000 附近

373
00:18:17,698 --> 00:18:20,234
我认为这是数据集可以

374
00:18:20,234 --> 00:18:23,036
受益于归一化的绝佳范例

375
00:18:23,036 --> 00:18:27,274
所以我要做的第一件事
就是将这些值归一化

376
00:18:27,274 --> 00:18:30,978
为此 我可以将希望归一化的列名

377
00:18:30,978 --> 00:18:35,082
传递给 ColumnSelector
然后使用标准缩放器

378
00:18:35,082 --> 00:18:37,084
这是代码

379
00:18:37,084 --> 00:18:39,520
首先 我创建一个列选取器

380
00:18:39,520 --> 00:18:42,789
然后传递我想要缩放的列名

381
00:18:42,789 --> 00:18:45,492
所有列必须包含相同类型的元素

382
00:18:45,492 --> 00:18:47,761
在个例子中是 Double

383
00:18:47,761 --> 00:18:50,130
然后我解析可选类型

384
00:18:50,130 --> 00:18:53,133
之所以这样做
是因为我知道没有缺失值

385
00:18:53,133 --> 00:18:56,904
但也可以使用 imputer
来替换缺失值

386
00:18:56,904 --> 00:18:58,805
然后 我在解析代码上

387
00:18:58,805 --> 00:19:01,308
附加 StandardScaler

388
00:19:01,308 --> 00:19:02,676
所以 一开始的这张表列中

389
00:19:02,676 --> 00:19:05,612
袋数达到好几万

390
00:19:05,612 --> 00:19:08,415
总量达到几十万

391
00:19:08,415 --> 00:19:10,083
在对这几列进行缩放后

392
00:19:10,083 --> 00:19:13,187
最终得到的值规模接近于 1

393
00:19:13,187 --> 00:19:16,723
这可以提升模型的性能

394
00:19:16,723 --> 00:19:20,427
更具体来说
这些值现在的平均数为 0

395
00:19:20,427 --> 00:19:24,064
标准差为 1

396
00:19:24,064 --> 00:19:27,067
这是一个类似的例子
但在这个例子中

397
00:19:27,067 --> 00:19:29,603
我选择了类型和区域列

398
00:19:29,603 --> 00:19:34,074
它们是字符串类型并执行独热编码

399
00:19:34,074 --> 00:19:37,377
独热编码是指对分类数据进行编码

400
00:19:37,377 --> 00:19:42,149
使用数组来指示类别

401
00:19:42,149 --> 00:19:44,451
这个例子中有三个类别

402
00:19:44,451 --> 00:19:47,588
铜 银和金

403
00:19:47,588 --> 00:19:50,157
每个类别在数组中
都拥有唯一的位置

404
00:19:50,157 --> 00:19:54,194
由处于该位置的 1 表示

405
00:19:54,194 --> 00:19:57,331
另一种方法是使用序数编码器

406
00:19:57,331 --> 00:20:01,034
为每个类别分配一个连续的数字

407
00:20:01,034 --> 00:20:04,204
仅有几个类别时
更适合使用独热编码器

408
00:20:04,204 --> 00:20:07,941
类别较多时 则应当使用序数编码器

409
00:20:07,941 --> 00:20:13,447
现在让我把这些结合起来
创建一个表列回归器

410
00:20:17,217 --> 00:20:19,453
和之前一样 我将以创建结构开始

411
00:20:19,453 --> 00:20:23,957
并定义数据 URL
和参数 URL

412
00:20:25,792 --> 00:20:27,761
我还想定义一个列 ID

413
00:20:27,761 --> 00:20:30,364
用于我要预测的列 即价格

414
00:20:32,966 --> 00:20:35,702
我将单独定义我的任务 以便

415
00:20:35,702 --> 00:20:38,539
对它应用 train
和 predict 两种方法

416
00:20:41,208 --> 00:20:44,011
就像之前提到的那样
我要把总量归一化

417
00:20:46,780 --> 00:20:49,049
然后 我将使用增强树回归器

418
00:20:49,049 --> 00:20:53,153
来预测价格

419
00:20:53,153 --> 00:20:55,189
它先获取注释列的名称

420
00:20:55,189 --> 00:20:58,025
这也就是结果预测列

421
00:20:58,025 --> 00:21:01,762
然后获取所有三个特征列的名称

422
00:21:01,762 --> 00:21:03,931
我就从这三列开始

423
00:21:03,931 --> 00:21:07,367
然后我会使用
appending 方法组合这些段落

424
00:21:07,367 --> 00:21:08,836
并返回任务

425
00:21:13,540 --> 00:21:15,475
现在有了任务定义

426
00:21:15,475 --> 00:21:17,644
我就像之前一样
添加 train 方法

427
00:21:20,547 --> 00:21:23,083
和之前一样 我想确保返回类型

428
00:21:23,083 --> 00:21:26,453
不取决于我模型的细节

429
00:21:26,453 --> 00:21:32,392
第一步是将 CSV 文件
加载到dataFrame中

430
00:21:32,392 --> 00:21:35,028
我使用 TabularData
框架来执行此操作

431
00:21:35,028 --> 00:21:37,364
和之前一样 我想拆分一些数据

432
00:21:37,364 --> 00:21:39,399
用于验证

433
00:21:43,704 --> 00:21:46,039
我将训练和验证数据集传递给

434
00:21:46,039 --> 00:21:47,608
拟合法

435
00:21:50,511 --> 00:21:53,514
我也会像之前一样报告验证错误

436
00:21:53,514 --> 00:21:55,883
并保存训练好的参数供以后使用

437
00:21:59,553 --> 00:22:01,755
最后 我会返回转换器

438
00:22:04,892 --> 00:22:06,627
有了训练好的转换器

439
00:22:06,627 --> 00:22:09,763
就可以用它来基于
dataFrame进行价格预测

440
00:22:09,763 --> 00:22:13,967
我需要写一个
predict 方法来实现预测

441
00:22:17,404 --> 00:22:19,740
首先 我将从任务定义中加载模型

442
00:22:19,740 --> 00:22:22,109
和参数 URL

443
00:22:24,978 --> 00:22:27,581
我需要确保用于预测的dataFrame

444
00:22:27,581 --> 00:22:30,884
包含我用作特征的列

445
00:22:30,884 --> 00:22:35,155
类型 区域和总量

446
00:22:35,155 --> 00:22:38,325
预测值将出现在价格列中

447
00:22:38,325 --> 00:22:40,661
我将使用我在顶部定义的列 ID

448
00:22:44,565 --> 00:22:46,700
我的表列回归器这样就完成了

449
00:22:46,700 --> 00:22:48,936
我写了一个 train 方法
只需要调用一次

450
00:22:48,936 --> 00:22:50,370
就可以生成训练好的参数

451
00:22:50,370 --> 00:22:52,606
还有一个 predict 方法

452
00:22:52,606 --> 00:22:54,575
可以基于类型 地区以及

453
00:22:54,575 --> 00:22:56,977
鳄梨的总量 返回鳄梨价格的预测

454
00:22:56,977 --> 00:22:59,346
这就是我需要在
App 中使用的全部内容

455
00:22:59,346 --> 00:23:01,014
在处理表列任务时

456
00:23:01,014 --> 00:23:03,350
还有几点需要牢记

457
00:23:03,350 --> 00:23:04,985
您可以使用 ColumnSelector 操作

458
00:23:04,985 --> 00:23:07,287
来处理特定的列

459
00:23:07,287 --> 00:23:10,257
值得注意的是 树形分类器和回归器

460
00:23:10,257 --> 00:23:13,961
都是表列类的 但您也可以
使用非表列估算器

461
00:23:13,961 --> 00:23:15,529
例如线性回归器

462
00:23:15,529 --> 00:23:19,366
来处理使用
AnnotatedFeatureProvider 的表列任务

463
00:23:19,366 --> 00:23:22,169
请参阅相关文档

464
00:23:22,169 --> 00:23:23,470
在进行预测时

465
00:23:23,470 --> 00:23:26,039
请创建一个包含所需列的dataFrame

466
00:23:26,039 --> 00:23:29,142
确保使用的类型正确

467
00:23:29,142 --> 00:23:31,745
现在您已经知道应该
如何创建自定义任务了

468
00:23:31,745 --> 00:23:34,781
那就让我们来谈谈部署

469
00:23:34,781 --> 00:23:38,785
到目前为止 我都在使用相同的
API 进行训练和推理

470
00:23:38,785 --> 00:23:41,655
我想指出的是
在使用 Create ML Components 时

471
00:23:41,655 --> 00:23:43,657
您的模型就是代码

472
00:23:43,657 --> 00:23:45,058
您需要任务定义

473
00:23:45,058 --> 00:23:48,962
即使只是从文件加载训练好的参数

474
00:23:48,962 --> 00:23:50,998
这在部分情况下很有用

475
00:23:50,998 --> 00:23:55,169
但有时您也许希望
使用 Core ML 进行部署

476
00:23:55,169 --> 00:23:58,105
使用 Core ML 时
就必须将代码抛在脑后

477
00:23:58,105 --> 00:24:01,508
模型完全由模型文件表述

478
00:24:01,508 --> 00:24:03,210
如果您已经
准备好使用 Core ML

479
00:24:03,210 --> 00:24:05,045
那么这一工作流可能会很顺畅

480
00:24:05,045 --> 00:24:08,749
还具备优化张量操作的优势

481
00:24:08,749 --> 00:24:10,050
但还有一些注意事项

482
00:24:10,050 --> 00:24:12,252
您应该记住

483
00:24:12,252 --> 00:24:15,055
Core ML 并不支持所有操作

484
00:24:15,055 --> 00:24:17,558
具体来说 它不支持自定义转换器

485
00:24:17,558 --> 00:24:19,293
和估算器

486
00:24:19,293 --> 00:24:21,261
而且 Core ML
只支持几种类型

487
00:24:21,261 --> 00:24:24,131
比如图像和整形数组

488
00:24:24,131 --> 00:24:25,866
如果您使用自定义类型

489
00:24:25,866 --> 00:24:27,835
您可能需要
在使用 Core ML 模型时

490
00:24:27,835 --> 00:24:30,103
在 App 中进行转换

491
00:24:30,103 --> 00:24:33,640
这就是将转换器导出为
Core ML 模型的方法

492
00:24:33,640 --> 00:24:36,376
如果转换器中包含不受支持的操作

493
00:24:36,376 --> 00:24:39,079
将会引发错误

494
00:24:39,079 --> 00:24:41,748
如果您更希望将任务定义

495
00:24:41,748 --> 00:24:43,584
连同训练参数一同进行部署

496
00:24:43,584 --> 00:24:46,887
应当考虑将它们
捆绑在一个 Swift 软件包中

497
00:24:46,887 --> 00:24:49,556
这样一来 您就可以提供
简单的方法来加载参数

498
00:24:49,556 --> 00:24:51,458
和执行预测

499
00:24:51,458 --> 00:24:53,927
有关 Swift 软件包资源的
更多信息

500
00:24:53,927 --> 00:24:58,198
请查看 WWDC 2020
关于 Swift 软件包的演讲

501
00:24:58,198 --> 00:24:59,833
我想说的就这么多

502
00:24:59,833 --> 00:25:01,235
要记住的重点是

503
00:25:01,235 --> 00:25:04,638
您现在可以通过合成
创建自定义任务

504
00:25:04,638 --> 00:25:06,673
可能性永无止境

505
00:25:06,673 --> 00:25:08,775
我期待看到您的创造

506
00:25:08,775 --> 00:25:09,943
如想了解更高阶的技巧

507
00:25:09,943 --> 00:25:12,579
包括音频和视频任务 请查看

508
00:25:12,579 --> 00:25:15,516
“使用 Create ML Components
创建高阶模型”讲座

509
00:25:15,516 --> 00:25:17,251
我的同事 David 将展示

510
00:25:17,251 --> 00:25:20,287
更高阶的自定义任务

511
00:25:20,287 --> 00:25:24,291
谢谢 希望您享受
WWDC 2022 的其他内容

512
00:25:24,291 --> 00:25:29,062
♪

