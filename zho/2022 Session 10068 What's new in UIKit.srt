1
00:00:00,501 --> 00:00:06,507
[欢快的音乐]

2
00:00:09,309 --> 00:00:14,214
欢迎收看 iOS 16 的
“What's New in UIKit”

3
00:00:14,248 --> 00:00:18,785
我是 Dima
是 UIKit 团队的工程经理

4
00:00:19,586 --> 00:00:23,757
UIKit 是App 开发用到的一个强大的核心框架

5
00:00:23,790 --> 00:00:28,529
它已经更新
以支持 iOS 16 中的新功能

6
00:00:29,663 --> 00:00:35,636
在这个视频中 我将介绍
为提升效率进行的 UI 改进

7
00:00:35,669 --> 00:00:37,838
控件增强

8
00:00:37,871 --> 00:00:40,374
API 的改进

9
00:00:40,407 --> 00:00:43,644
我还将谈到令人振奋的

10
00:00:43,677 --> 00:00:48,048
同步使用 UIKit 和 SwiftUI 的新方法

11
00:00:50,684 --> 00:00:57,124
我们让在 UIKit 中开发出
精简 可发现的用户界面更容易

12
00:00:57,157 --> 00:01:01,395
它有着改进过的导航栏
包含新的标题菜单

13
00:01:01,428 --> 00:01:05,265
查找和替换
以及重新定义编辑交互用户界面的

14
00:01:05,299 --> 00:01:07,134
剪切 复制和粘贴

15
00:01:07,167 --> 00:01:10,704
你将能够增强基于文档的应用程序

16
00:01:11,405 --> 00:01:15,809
我会先从仔细研究导航栏开始

17
00:01:15,843 --> 00:01:20,113
它经过了更新
以支持桌面类工具栏功能

18
00:01:22,416 --> 00:01:28,055
在 iOS 16 中
UIKit 引入了两种新的导航样式

19
00:01:28,088 --> 00:01:31,291
以更好地支持基于文档的 App

20
00:01:31,325 --> 00:01:34,494
浏览器和编辑器

21
00:01:35,729 --> 00:01:41,335
浏览器风格是为使用历史记录
或文件夹结构导航的 App

22
00:01:41,368 --> 00:01:45,539
如网页和文档浏览器而设计的

23
00:01:47,040 --> 00:01:53,280
该编辑器主要用于
以编辑文档为中心的界面

24
00:01:55,148 --> 00:02:00,721
在 iOS 16 中 你可以在 App 中
添加各种各样的栏按钮项

25
00:02:00,754 --> 00:02:06,059
它们的一个子集会显示在
导航栏中心

26
00:02:07,294 --> 00:02:10,998
点击菜单中的
“customize toolbar”条目

27
00:02:11,031 --> 00:02:16,436
就可以通过拖拽
来重新排列弹出的项目

28
00:02:17,871 --> 00:02:22,409
由此产生的新配置
在 App 启动时持续存在

29
00:02:25,312 --> 00:02:28,615
例如 为了适应大小的变化

30
00:02:28,649 --> 00:02:32,519
当使用另一个 App
进入并排模式时

31
00:02:32,553 --> 00:02:36,857
系统会自动提供一个悬浮菜单

32
00:02:36,890 --> 00:02:40,794
来访问任何不适合的项目

33
00:02:42,796 --> 00:02:47,467
我们添加了一个标题菜单
它与新的导航样式一起运作

34
00:02:47,501 --> 00:02:50,704
并支持一些标准功能

35
00:02:50,737 --> 00:02:54,007
复制 移动 重命名

36
00:02:54,041 --> 00:02:56,844
导出和打印

37
00:02:57,711 --> 00:03:00,981
当要实施相应的委托方法时

38
00:03:01,014 --> 00:03:05,185
这些将自动显示在菜单中

39
00:03:05,219 --> 00:03:10,624
也可以在标题菜单中
添加完全自定义的条目

40
00:03:15,028 --> 00:03:18,832
此外 使用 Mac Catalyst 构建的 App

41
00:03:18,866 --> 00:03:21,869
无需额外的代码便可与

42
00:03:21,902 --> 00:03:25,005
NSToolbar 无缝集成

43
00:03:25,038 --> 00:03:28,108
充分利用了改进的导航栏

44
00:03:29,309 --> 00:03:34,214
iOS 16 引入了在不同的 App 中

45
00:03:34,248 --> 00:03:37,384
一致地操作文本的新方法

46
00:03:37,417 --> 00:03:41,588
第一个是新的查找和替换

47
00:03:41,622 --> 00:03:46,760
从概念上讲
它不同于对数据模型对象

48
00:03:46,793 --> 00:03:52,966
如照片或日历事件进行操作的
更高级的 App 内搜索项目

49
00:03:53,000 --> 00:03:58,705
相反 查找与替换
是专门用于处理文本的

50
00:03:58,739 --> 00:04:02,409
它只需要设置一个标志
来激活如 UITextView

51
00:04:02,442 --> 00:04:08,448
和 WKWebView 的内置 UIKit 视图功能

52
00:04:09,650 --> 00:04:14,254
此外 它无缝地跨越了
选入该系统的多个视图

53
00:04:14,288 --> 00:04:16,490
和文档工作

54
00:04:17,891 --> 00:04:22,729
接下来 编辑菜单进行了重大升级

55
00:04:22,763 --> 00:04:26,934
它现在因输入法不同而有所区别

56
00:04:26,967 --> 00:04:30,771
在触摸交互方面
重新设计的菜单

57
00:04:30,804 --> 00:04:33,373
更具互动性

58
00:04:35,209 --> 00:04:37,211
当使用指针时

59
00:04:37,244 --> 00:04:41,081
你会得到一个
功能更全面的快捷菜单

60
00:04:42,382 --> 00:04:46,420
为了无缝提供这两种体验

61
00:04:46,453 --> 00:04:50,224
我们引入了 UIEditMenuInteraction

62
00:04:50,257 --> 00:04:55,329
完全替代现在已弃用的
UIMenuController

63
00:04:56,496 --> 00:05:01,768
还有新的 API 可以将操作
插入到文本视图的菜单中

64
00:05:03,537 --> 00:05:06,673
你可以观看 “Adopt desktop class
editing interactions”

65
00:05:06,707 --> 00:05:10,944
来学习新编辑菜单上的所有细节

66
00:05:10,978 --> 00:05:15,015
并学习如何为自定义视图
采用查找交互

67
00:05:17,718 --> 00:05:21,188
我还想说说一个可视化 UI 更新

68
00:05:22,055 --> 00:05:26,026
在 iOS 16 中 侧边栏会在

69
00:05:26,059 --> 00:05:28,395
滑动模式下自动显示

70
00:05:28,428 --> 00:05:31,298
不需要任何额外的代码

71
00:05:31,331 --> 00:05:36,170
为了实现这一点
UIKit 会代你管理一组私有视图

72
00:05:38,005 --> 00:05:41,575
这些是 UIKit 中
用于提高生产力的新功能

73
00:05:41,608 --> 00:05:44,811
新的可自定义导航栏

74
00:05:44,845 --> 00:05:48,448
查找与替换 编辑交互

75
00:05:48,482 --> 00:05:52,119
以及强大的标题菜单

76
00:05:52,152 --> 00:05:54,621
我只是提到了皮毛

77
00:05:54,655 --> 00:05:59,293
要了解更多 请查看课程
“Meet desktop class iPad”

78
00:05:59,326 --> 00:06:03,830
以及更深入的
“Build a desktop class iPad app”

79
00:06:03,864 --> 00:06:07,134
在那里 你将通过
一个示例 App 的改进

80
00:06:07,167 --> 00:06:11,572
了解 iOS 16 中新的高级 UIKit 功能

81
00:06:13,106 --> 00:06:17,211
现在 我将介绍我们添加的
两个新控件

82
00:06:17,244 --> 00:06:21,782
谈谈对 UIPageControl 的一些增强

83
00:06:22,983 --> 00:06:28,488
UIDatePicker 的内联日历样式

84
00:06:28,522 --> 00:06:31,158
现在作为一个独立的全功能组件

85
00:06:31,191 --> 00:06:34,628
以 UICalendarView 的形式提供

86
00:06:34,661 --> 00:06:39,533
UICalendarView
支持不同类型的选择行为

87
00:06:39,566 --> 00:06:41,535
如可选单个日期

88
00:06:41,568 --> 00:06:44,972
也支持选择多个日期

89
00:06:45,005 --> 00:06:47,407
除了可用日期范围

90
00:06:47,441 --> 00:06:52,513
它还支持禁用个别日期选择

91
00:06:53,647 --> 00:06:58,919
此外 你可以用装饰来注释单个日期

92
00:07:00,287 --> 00:07:03,657
UICalendarView 和 UIDatePicker
之间的一个主要区别

93
00:07:03,690 --> 00:07:08,662
在于 UICalendarView
将日期表示为

94
00:07:08,695 --> 00:07:13,400
NSDateComponents 而不是 NSDate

95
00:07:13,433 --> 00:07:16,937
与 NSDate 不同 日期组件是更好的

96
00:07:16,970 --> 00:07:20,507
更正确的日期表示

97
00:07:20,541 --> 00:07:25,712
而 NSDate 是时间点的表示

98
00:07:27,381 --> 00:07:31,151
因为 NSDateComponents
提供了很大的灵活性

99
00:07:31,185 --> 00:07:33,220
你应该能明确组件

100
00:07:33,253 --> 00:07:37,591
是由哪个 NSCalendar 来表示的

101
00:07:38,692 --> 00:07:43,530
注意 你不应该对当前日历的类型
做出假设

102
00:07:43,564 --> 00:07:45,966
如果你需要将日历设置为公历

103
00:07:45,999 --> 00:07:50,137
请明确指定公历

104
00:07:53,040 --> 00:07:57,277
要像前面显示的那样
配置 Calendar 视图

105
00:07:57,311 --> 00:08:02,816
首先创建 Calendar 视图
并设置其委托

106
00:08:02,850 --> 00:08:08,188
要确保 Calendar
有 Gregorian NSCalendar 支持

107
00:08:08,222 --> 00:08:11,625
将 calendarView 上的 Calendar 属性

108
00:08:11,658 --> 00:08:14,528
设置为 Gregorian NSCalendar

109
00:08:15,829 --> 00:08:19,733
接下来 要配置多日期选择

110
00:08:19,766 --> 00:08:24,304
创建一个
UICalendarSelectionMultiDate 对象

111
00:08:24,338 --> 00:08:26,473
并将选择对象上的选定日期属性

112
00:08:26,507 --> 00:08:31,979
设置为数据模型中
显示在 Calendar 视图里的

113
00:08:32,012 --> 00:08:34,481
现有日期

114
00:08:35,782 --> 00:08:41,922
然后 将选择对象设置为
日历视图的选择行为

115
00:08:44,892 --> 00:08:49,229
为了防止日历中单个日期的选择

116
00:08:49,263 --> 00:08:53,467
执行 multidateselect:
canSelectDate: method

117
00:08:53,500 --> 00:08:56,170
通过日历选择委托

118
00:08:56,203 --> 00:08:59,273
控制哪些日期可以被选择

119
00:09:00,607 --> 00:09:06,213
无法选择的日期
将在日历视图中显示为灰色

120
00:09:07,748 --> 00:09:11,552
要用装饰来注释单个日期

121
00:09:11,585 --> 00:09:14,021
执行日历委托的

122
00:09:14,054 --> 00:09:17,691
calendarView:
decorationForDateComponents:Method

123
00:09:19,426 --> 00:09:22,462
如果不要装饰 只需返回 nil 即可

124
00:09:23,564 --> 00:09:28,235
对于默认的灰圆 返回默认装饰

125
00:09:29,670 --> 00:09:35,909
你还可以通过自定义颜色选项
来创建图像装饰

126
00:09:35,943 --> 00:09:40,247
如果你需要做到更多
可以使用 customView 装饰

127
00:09:40,280 --> 00:09:43,083
并在视图提供程序中返回你的视图

128
00:09:44,484 --> 00:09:48,889
请注意 自定义视图装饰不允许交互

129
00:09:48,922 --> 00:09:52,226
并会被裁剪到可用空间

130
00:09:53,594 --> 00:09:56,697
页面控件也得到了改进

131
00:09:56,730 --> 00:10:01,268
我们为当前页面添加了
支持自定义指示器图像

132
00:10:01,301 --> 00:10:03,737
这样你现在就可以根据页面
是否被选中

133
00:10:03,770 --> 00:10:06,773
来选择不同的图像

134
00:10:08,308 --> 00:10:12,479
你现在还可以完全自定义

135
00:10:12,513 --> 00:10:14,748
页面控件的方位和方向

136
00:10:16,450 --> 00:10:20,888
下面是配置垂直页控件的示例

137
00:10:20,921 --> 00:10:26,126
该控件的指示器
在当前页与非当前页之间更改

138
00:10:27,794 --> 00:10:31,765
我将页面控件的方向
设置为从上到下

139
00:10:31,798 --> 00:10:36,670
并设置了首选指示器图像
首选当前指示器图像

140
00:10:36,703 --> 00:10:38,338
这样就大功告成了

141
00:10:41,241 --> 00:10:46,580
Apple 致力于保护用户隐私和安全

142
00:10:46,613 --> 00:10:49,950
在 iOS 15 中
当 App 以编程方式访问粘贴板

143
00:10:49,983 --> 00:10:54,788
而不使用系统提供的 Paste 接口时

144
00:10:54,821 --> 00:10:59,359
将出现一个横幅
表明该粘贴板已被访问

145
00:11:00,594 --> 00:11:04,831
在新的 iOS 16 中
系统行为发生了变化

146
00:11:04,865 --> 00:11:06,800
现在 我们会显示

147
00:11:06,834 --> 00:11:11,738
请求使用粘贴板许可的提示
而不是横幅

148
00:11:13,073 --> 00:11:16,810
与用户交互的系统粘贴接口

149
00:11:16,844 --> 00:11:19,780
提供了对粘贴板的隐式访问

150
00:11:19,813 --> 00:11:22,349
从而避免了提示

151
00:11:23,817 --> 00:11:26,253
如果你有自定义的粘贴控件

152
00:11:26,286 --> 00:11:30,023
就可以用新的 UIPasteControl
替换它们

153
00:11:30,057 --> 00:11:33,560
它的外观和行为
都像一个填充过的 UIButton

154
00:11:34,895 --> 00:11:39,266
当粘贴板获得与控件的粘贴目标
兼容的内容时

155
00:11:39,299 --> 00:11:42,202
将启用该选项

156
00:11:43,670 --> 00:11:47,007
这些是新的强大的 UICalendarView

157
00:11:47,040 --> 00:11:49,643
改进过的 UIPageControl

158
00:11:49,676 --> 00:11:53,814
以及重视安全的 UIPasteControl

159
00:11:53,847 --> 00:11:56,783
去试试吧

160
00:11:57,718 --> 00:12:01,955
现在 我将向你介绍
我们所做的一些 API 改进

161
00:12:03,690 --> 00:12:07,528
在 iOS 15 中
锁止器被添加到了工作表中

162
00:12:07,561 --> 00:12:11,765
这能支持构建灵活 动态的 UI

163
00:12:11,798 --> 00:12:16,770
在 iOS 16 中
我们增加了支持自定义锁止器

164
00:12:16,803 --> 00:12:20,007
这样你就可以制作任意大小的工作表

165
00:12:21,308 --> 00:12:26,446
要利用这个功能
请使用新的 “.custom” 锁止器

166
00:12:26,480 --> 00:12:31,885
并在关联块中
以点为单位指定工作表的高度

167
00:12:31,919 --> 00:12:35,055
你可以返回一个常量值

168
00:12:35,088 --> 00:12:39,459
或最大锁止高度的百分比

169
00:12:42,396 --> 00:12:47,134
如果你需要从其他 API 引用它

170
00:12:47,167 --> 00:12:50,103
也可以为自己的自定义锁止器
提供一个标识符

171
00:12:50,137 --> 00:12:54,575
例如禁用超越自定义锁止器的调光

172
00:12:57,444 --> 00:13:01,148
请注意 从自定义块返回的值

173
00:13:01,181 --> 00:13:05,352
不应该包含底部嵌入式安全区域

174
00:13:05,385 --> 00:13:11,725
因此浮动和
侧附加工作表的计算方法相同

175
00:13:13,894 --> 00:13:19,700
要了解更多关于有系统锁止器
和其他选项的自定义工作表

176
00:13:19,733 --> 00:13:24,872
请观看视频“Customize
and resize sheets in UIKit”

177
00:13:24,905 --> 00:13:28,609
那个视频的示例代码也进行了更新

178
00:13:28,642 --> 00:13:31,879
以展示这些新的自定义锁止器 API

179
00:13:33,547 --> 00:13:37,851
UIKit 中的 SF 符号有新功能

180
00:13:38,785 --> 00:13:41,655
符号支持四种呈现模式

181
00:13:41,688 --> 00:13:44,057
单色 多色

182
00:13:44,091 --> 00:13:47,928
分层和调色

183
00:13:47,961 --> 00:13:51,164
UIKit 会默认使用单色呈现

184
00:13:51,198 --> 00:13:55,769
除非符号被配置为不同的呈现模式

185
00:13:55,802 --> 00:13:59,940
在 iOS 16 中
如果没有指定呈现模式

186
00:13:59,973 --> 00:14:02,376
UIKit 可以使用单色以外的模式

187
00:14:02,409 --> 00:14:05,279
呈现单个符号

188
00:14:07,047 --> 00:14:10,284
以这些设备符号为例

189
00:14:10,317 --> 00:14:13,453
在 iOS 15 及之前的版本中

190
00:14:13,487 --> 00:14:16,456
如果没有指定呈现模式

191
00:14:16,490 --> 00:14:19,226
这些符号将使用单色呈现

192
00:14:20,427 --> 00:14:25,699
在 iOS 16 中
这些符号默认为分层呈现

193
00:14:26,867 --> 00:14:29,736
通常 符号的默认呈现模式

194
00:14:29,770 --> 00:14:33,473
是展示该符号的首选方式

195
00:14:33,507 --> 00:14:38,245
因此在这种情况下
你应该允许默认的分层呈现

196
00:14:38,278 --> 00:14:40,781
生效

197
00:14:40,814 --> 00:14:45,786
不过 单色呈现可以通过新的

198
00:14:45,819 --> 00:14:51,825
UIImage.SymbolConfiguration.
preferringMonochrome() API 来明确请求

199
00:14:55,596 --> 00:14:58,765
UIKit 增加了对可变符号的支持

200
00:14:58,799 --> 00:15:02,169
它允许 App 根据从 0 到 1 的值

201
00:15:02,202 --> 00:15:06,173
显示符号的变化

202
00:15:06,206 --> 00:15:10,978
假设一个 App 想要用一个符号
描述当前音量级别

203
00:15:11,011 --> 00:15:15,682
该 App 可以使用
speaker.3.wave.fill 符号

204
00:15:15,716 --> 00:15:20,254
它已被更新 以支持变量呈现

205
00:15:20,287 --> 00:15:24,758
在值为 0 时 扬声器波逐渐消失

206
00:15:24,791 --> 00:15:27,861
表示最低音量水平

207
00:15:27,895 --> 00:15:30,430
当该值增加到 1 时

208
00:15:30,464 --> 00:15:33,800
扬声器的波形逐渐填充

209
00:15:33,834 --> 00:15:36,170
表明更高的音量水平

210
00:15:37,471 --> 00:15:40,307
如果一个符号支持变量呈现

211
00:15:40,340 --> 00:15:43,477
那么 App 就可以请求一个

212
00:15:43,510 --> 00:15:47,247
反映 0 到 1 之间值的版本的符号

213
00:15:48,982 --> 00:15:53,687
使用变量符号很直白

214
00:15:53,720 --> 00:15:57,457
你可以通过标准的 SF Symbols API

215
00:15:57,491 --> 00:16:02,095
在 UIImage 上获得一个
常规非变量版符号

216
00:16:03,830 --> 00:16:07,634
要获得带有特定变量值的该符号版本

217
00:16:07,668 --> 00:16:10,771
只需添加 variableValue 参数

218
00:16:12,039 --> 00:16:15,943
你甚至可以将变量呈现
与其他呈现模式

219
00:16:15,976 --> 00:16:19,279
如调色 混合
以进一步设计符号的样式

220
00:16:20,914 --> 00:16:25,686
许多系统符号现在支持可变呈现

221
00:16:25,719 --> 00:16:30,757
并且 App 可以
更新它们的自定义符号来支持可变性

222
00:16:32,192 --> 00:16:35,529
要学习如何创建自定义变量符号

223
00:16:35,562 --> 00:16:40,267
记得观看“Adopt variable color
in SF Symbols”

224
00:16:40,300 --> 00:16:43,604
和 “What's new in SF Symbols 4”
这两个课程

225
00:16:45,439 --> 00:16:49,877
我们已经更新了 UIKit 以和新的
Swift Concurrency 功能同时使用

226
00:16:49,910 --> 00:16:52,045
包括使不可变类型

227
00:16:52,079 --> 00:16:56,216
如 UIImage 和 UIColor
符合 Sendable

228
00:16:56,250 --> 00:16:58,986
这样你就可以在 MainActor

229
00:16:59,019 --> 00:17:02,456
和自定义 actor 之间发送它们
而不会收到编译器警告

230
00:17:03,957 --> 00:17:09,930
例如 我们有一个叫做处理器的
自定义 actor

231
00:17:09,963 --> 00:17:12,900
以及一个被绑定到 MainActor 的

232
00:17:12,933 --> 00:17:15,969
叫做 ImageViewer 的视图控制器

233
00:17:16,003 --> 00:17:18,572
在 sendImageForProcessing 方法中

234
00:17:18,605 --> 00:17:24,077
ImageViewer 将图像发送给
处理器 actor 进行处理

235
00:17:24,111 --> 00:17:28,448
使其看起来
像添加了闪光和彩虹一样漂亮

236
00:17:28,482 --> 00:17:32,386
这是安全的 因为 UIImage 是不可变的

237
00:17:32,419 --> 00:17:34,755
处理器必须创建新的拷贝

238
00:17:34,788 --> 00:17:36,990
来添加彩虹和闪光

239
00:17:38,358 --> 00:17:41,862
任何引用原始图像的代码

240
00:17:41,895 --> 00:17:44,364
都不会显示这些修改

241
00:17:44,398 --> 00:17:48,135
共享状态也不会发生不安全的变化

242
00:17:49,870 --> 00:17:52,973
对比一下因为可变

243
00:17:53,006 --> 00:17:56,543
而不可发送的 UIBezierPath

244
00:17:57,845 --> 00:18:02,082
以前只能在文档中表示的东西
现在可以

245
00:18:02,115 --> 00:18:06,753
由编译器进行检查 这多棒啊

246
00:18:09,056 --> 00:18:12,693
要了解更多关于 Sendable
和 Swift Concurrency 的知识

247
00:18:12,726 --> 00:18:17,464
请查看视频“Eliminate data races
using Swift Concurrency”

248
00:18:17,497 --> 00:18:23,337
和“Visualize
and optimize Swift Concurrency”

249
00:18:25,405 --> 00:18:30,644
iOS 16 对外部显示器
提供了新的强大支持

250
00:18:31,245 --> 00:18:36,583
好消息是
你不需要更新你的 App 来利用它

251
00:18:36,617 --> 00:18:40,487
除非你使用的是旧版 UIScreen API

252
00:18:41,588 --> 00:18:45,459
你不能再默认你的 App 在主屏幕上

253
00:18:46,260 --> 00:18:49,763
相反 你要遵从更具体的 API

254
00:18:49,796 --> 00:18:53,000
比如 trait collection
和 UIScene API

255
00:18:53,033 --> 00:18:55,702
来获得你需要的信息

256
00:18:55,736 --> 00:18:58,438
如果你的 App 仍未使用 UIScene

257
00:18:58,472 --> 00:19:03,911
现在你有了更多的理由升级
以支持多窗口

258
00:19:05,445 --> 00:19:08,115
UICollectionView
和 UITableView 中的

259
00:19:08,148 --> 00:19:12,586
自定大小单元格受到了重大升级

260
00:19:12,619 --> 00:19:16,523
现在单元格也可以自我调整大小了

261
00:19:16,557 --> 00:19:21,595
在 iOS 16 中
当可见单元格内的内容发生变化时

262
00:19:21,628 --> 00:19:26,633
单元格将自动调整大小
以适应新内容

263
00:19:28,235 --> 00:19:31,371
这个新行为是默认启用的

264
00:19:31,405 --> 00:19:34,141
UICollectionView 和 UITableView

265
00:19:34,174 --> 00:19:38,178
各有一个新的
selfSizingInvalidation 属性

266
00:19:38,212 --> 00:19:41,548
让你能控制这个新功能

267
00:19:43,016 --> 00:19:44,785
以下是它的运作方式

268
00:19:46,220 --> 00:19:49,690
当启用 selfSizingInvalidation 时

269
00:19:49,723 --> 00:19:52,259
单元格可以请求通过其包含的集合

270
00:19:52,292 --> 00:19:55,162
或表视图来调整大小

271
00:19:56,930 --> 00:20:01,768
如果你用了 UIListContentConfiguration
配置单元格

272
00:20:01,802 --> 00:20:04,204
那么每当单元格的配置发生更改时

273
00:20:04,238 --> 00:20:07,474
失效就会自动发生

274
00:20:08,942 --> 00:20:11,011
对于任何其他情况

275
00:20:11,044 --> 00:20:14,915
你都可以调用单元格
invalidateIntrinsicContentSize 方法

276
00:20:14,948 --> 00:20:19,086
或它的 contentView
来调整单元格的大小

277
00:20:20,888 --> 00:20:24,558
默认情况下
单元格会随着动画而调整大小

278
00:20:24,591 --> 00:20:28,428
但是你可以用
performWithoutAnimation 中的

279
00:20:28,462 --> 00:20:33,734
invalidateIntrinsicContentSize 绕过指令
从而不使用动画调整大小

280
00:20:33,767 --> 00:20:38,539
UICollectionView 和 UITableView
将单元格的

281
00:20:38,572 --> 00:20:40,474
大小无效智能合并为

282
00:20:40,507 --> 00:20:44,645
在最佳时间执行的单个更新

283
00:20:47,247 --> 00:20:49,950
如果你在单元格中使用 Auto Layout

284
00:20:49,983 --> 00:20:53,754
你可以通过选择
enabledinclingconstraints

285
00:20:53,787 --> 00:20:57,691
来完成一个更全面的行为

286
00:20:57,724 --> 00:21:03,564
这意味着当一个单元格检测到它的
contentView 内部的任何自动布局变化时

287
00:21:03,597 --> 00:21:08,702
它将自动调用
invalidateIntrinsicContentSize

288
00:21:08,735 --> 00:21:14,074
这样包含的集合或表格视图
就可以在必要时调整它的大小

289
00:21:15,008 --> 00:21:17,044
这使得单元格

290
00:21:17,077 --> 00:21:20,147
随内容或布局更新自动调整大小

291
00:21:20,180 --> 00:21:23,450
变得非常容易

292
00:21:25,419 --> 00:21:28,689
UIKit 强大而灵活

293
00:21:28,722 --> 00:21:32,125
你也可以利用通过 SwiftUI

294
00:21:32,159 --> 00:21:36,330
来执行 UI 的可表达性

295
00:21:36,363 --> 00:21:41,935
我们已经使在同一个 App 中
合并这两个框架容易了很多

296
00:21:43,971 --> 00:21:50,177
在iOS 16 中 有一种全新的
使用 SwiftUI 为集合和表格视图

297
00:21:50,210 --> 00:21:53,647
构建单元格的方式

298
00:21:55,048 --> 00:21:59,520
这是通过一个名为
UIHostingConfiguration 的

299
00:21:59,553 --> 00:22:03,290
新内容配置类型实现的

300
00:22:03,323 --> 00:22:05,592
只需一行代码

301
00:22:05,626 --> 00:22:10,063
你就可以在单元格中
开始编写 SwiftUI

302
00:22:10,097 --> 00:22:14,001
完全不需要额外的视图
或视图控制器

303
00:22:15,869 --> 00:22:19,540
下面是一个在 SwiftUI 中
使用 UIHostingConfiguration 编写的

304
00:22:19,573 --> 00:22:22,476
简单的自定义单元格

305
00:22:22,509 --> 00:22:25,646
构建这个单元格非常容易

306
00:22:27,147 --> 00:22:33,587
这不仅是开始将 SwiftUI
集成到你的 App 中的一个很好的方式

307
00:22:33,620 --> 00:22:39,426
而且 SwiftUI 的表达力意味着
前所未有的 在 UIKit 中

308
00:22:39,459 --> 00:22:42,996
构建自定义单元格的强大方式

309
00:22:43,797 --> 00:22:46,266
关于这个话题还有很多值得讨论

310
00:22:46,300 --> 00:22:49,169
所以一定要看看视频

311
00:22:49,203 --> 00:22:53,674
“Use SwiftUI with UIKit”来深入了解

312
00:22:56,643 --> 00:23:02,249
有几个微小但重要的变化
你应该知道

313
00:23:02,983 --> 00:23:06,286
为了防止用户被指纹识别

314
00:23:06,320 --> 00:23:10,123
UIDevice.name 现在会报告模型名称

315
00:23:10,157 --> 00:23:14,027
而非用户自定义的设备名称

316
00:23:14,061 --> 00:23:18,799
现在使用自定义名称需要获得授权

317
00:23:20,534 --> 00:23:24,805
不再支持设置 UIDevice.orientation

318
00:23:24,838 --> 00:23:28,509
相反 要使用 UIViewController API

319
00:23:28,542 --> 00:23:31,512
如 preferredInterfaceOrientation

320
00:23:31,545 --> 00:23:35,516
来表达你界面的预期方向

321
00:23:36,783 --> 00:23:38,785
接下来是什么

322
00:23:38,819 --> 00:23:43,690
使用 iOS 16 SDK 编译你的 App

323
00:23:43,724 --> 00:23:47,594
测试新功能 如文本编辑菜单

324
00:23:47,628 --> 00:23:50,197
查找和替换

325
00:23:50,230 --> 00:23:55,002
采用新的 UIKit API
来使用新的加强控件

326
00:23:55,035 --> 00:23:57,571
和用于提高生产力的新功能

327
00:23:57,604 --> 00:24:00,507
并尝试在你的 UIKit app 中

328
00:24:00,541 --> 00:24:04,311
加入 SwiftUI 的新方式

329
00:24:05,179 --> 00:24:06,680
谢谢大家

