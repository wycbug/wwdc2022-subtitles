1
00:00:00,033 --> 00:00:03,003
♪ ♪

2
00:00:03,003 --> 00:00:09,276
♪

3
00:00:09,276 --> 00:00:12,079
大家好！
我叫 Ankur Soni

4
00:00:12,079 --> 00:00:14,882
我是 Apple 地图服务团队的

5
00:00:14,882 --> 00:00:16,416
工程经理

6
00:00:16,416 --> 00:00:19,353
今天 我们要看一下即将进入
地图开发者生态系统的

7
00:00:19,353 --> 00:00:21,255
一些令人兴奋的新功能

8
00:00:21,255 --> 00:00:23,223
让我们现在开始吧

9
00:00:23,223 --> 00:00:26,326
我们的“地图”App
可以为全球 Apple 用户

10
00:00:26,326 --> 00:00:28,195
提供多样的终端用户体验

11
00:00:28,195 --> 00:00:30,264
我们授权开发者
通过 MapKit 和 MapKit JS

12
00:00:30,264 --> 00:00:33,534
去搭建属于他们的

13
00:00:33,534 --> 00:00:38,205
体验优秀的
地理定位 App 和网站

14
00:00:38,205 --> 00:00:41,108
并且 我们的
Apple 地图开发者服务

15
00:00:41,108 --> 00:00:43,911
一直坚持以用户为中心

16
00:00:43,911 --> 00:00:47,214
我们会悉心聆听所有反馈和建议

17
00:00:47,214 --> 00:00:50,817
您会希望在不影响性能
或增加功耗的前提下

18
00:00:50,817 --> 00:00:54,388
在 MapKit 上扩充您的数据

19
00:00:54,388 --> 00:00:56,156
因此 为了完善我们的生态系统

20
00:00:56,156 --> 00:01:01,128
我现在很高兴向您介绍
Apple Maps Server API

21
00:01:01,128 --> 00:01:04,398
我们正在增加
四个新的 Server API

22
00:01:04,398 --> 00:01:08,335
分别是 Geocode (地理编码)
Reverse Geocoding (反向地理编码)

23
00:01:08,335 --> 00:01:12,306
Search (搜索)
以及 ETA (预计到达时间)

24
00:01:12,306 --> 00:01:15,843
在把地图合并
导入到您的 App 中时

25
00:01:15,843 --> 00:01:20,047
这些 API
将帮助您处理各种用例

26
00:01:20,047 --> 00:01:23,150
使用 Geocode API
您可以将地址

27
00:01:23,150 --> 00:01:26,486
转换为地理坐标 纬度和经度

28
00:01:26,486 --> 00:01:28,956
同理 使用 Reverse Geocoding API

29
00:01:28,956 --> 00:01:30,257
您可以通过一个逆向的过程

30
00:01:30,257 --> 00:01:33,861
得到从地理坐标到地址的信息

31
00:01:33,861 --> 00:01:37,431
借助 Search API
您可以为用户提供

32
00:01:37,431 --> 00:01:40,367
输入企业名称 兴趣点等关键词

33
00:01:40,367 --> 00:01:43,637
查找地点的功能

34
00:01:43,637 --> 00:01:45,672
也许您想覆盖一些您自己的数据

35
00:01:45,672 --> 00:01:47,774
并将其呈现给用户

36
00:01:47,774 --> 00:01:51,078
通过 ETA API
您可以帮助您的用户

37
00:01:51,078 --> 00:01:53,680
了解您的业务离他们有多远

38
00:01:53,680 --> 00:01:56,717
或进行一些计算以找到最近的商店

39
00:01:56,717 --> 00:02:00,287
可能性是无限的！

40
00:02:00,287 --> 00:02:05,526
您很可能会因为三个重要原因
而喜欢上我们的 Server API

41
00:02:05,526 --> 00:02:08,862
首先 您现在可以
体验到 MapKit、MapKit JS

42
00:02:08,862 --> 00:02:13,367
和全新的 Apple Maps Server API
实现功能上的无缝衔接

43
00:02:13,367 --> 00:02:15,736
这在简化您的 App 架构的同时

44
00:02:15,736 --> 00:02:18,572
还能为您提供
更多的 Apple Maps 堆栈

45
00:02:18,572 --> 00:02:20,574
这将使您的生活更轻松

46
00:02:20,574 --> 00:02:21,909
当然 它也帮助了我

47
00:02:21,909 --> 00:02:24,611
但是 嘿 可能我
对它有偏爱滤镜

48
00:02:24,611 --> 00:02:27,881
其次 我们的 Server API
可以减少网络调用

49
00:02:27,881 --> 00:02:30,651
很多时候 我们经常
会陷入这样一种情况

50
00:02:30,651 --> 00:02:33,086
我们在诸如
iPad、iPhone 和网站等

51
00:02:33,086 --> 00:02:36,790
用户设备上不断地提出

52
00:02:36,790 --> 00:02:38,692
重复和冗余的请求

53
00:02:38,692 --> 00:02:41,862
也许您也曾经试过
在不同的设备的同一个 App 上

54
00:02:41,862 --> 00:02:44,798
一遍又一遍地查找同一个地址

55
00:02:44,798 --> 00:02:48,268
这大大增加了网络调用
造成带宽浪费

56
00:02:48,268 --> 00:02:51,171
但如果将此常见操作
委托给您的服务器

57
00:02:51,171 --> 00:02:55,242
并且只在后端
使用 Server API 执行一次

58
00:02:55,242 --> 00:02:58,812
那么就能实现
减少 App 带宽消耗的目的

59
00:02:58,812 --> 00:03:02,082
并且 通过委托
使用 Apple Maps Server API

60
00:03:02,082 --> 00:03:05,786
实现您的 App 的一些功能

61
00:03:05,786 --> 00:03:09,223
就能进一步减少
您 App 的功耗了

62
00:03:09,223 --> 00:03:12,292
现在让我们来看看
其中一些 API 的接口吧

63
00:03:12,292 --> 00:03:14,828
假设我们正在为您的定位 App

64
00:03:14,828 --> 00:03:17,397
创建地图名片

65
00:03:17,397 --> 00:03:20,300
这里我们看到三个商店及其地址

66
00:03:20,300 --> 00:03:22,736
以及与用户位置的距离

67
00:03:22,736 --> 00:03:25,772
在本例中 我们假设用户

68
00:03:25,772 --> 00:03:29,109
提供了他们的位置

69
00:03:29,109 --> 00:03:32,846
现在 让我们开始着手
创建其中一张地图名片

70
00:03:32,846 --> 00:03:35,415
我们假设
包括这家漫画书店在内的地址信息

71
00:03:35,415 --> 00:03:41,121
已经储存在服务器上
并且可以随时进行调用

72
00:03:41,121 --> 00:03:44,191
我们现在有很多方法
可以创建 但等一下

73
00:03:44,191 --> 00:03:47,261
假设我们现在
没有这些新的 Server API

74
00:03:47,261 --> 00:03:49,763
那么 App 的基本架构
会是什么样子？

75
00:03:49,763 --> 00:03:52,666
您的 App
将如何获取这些数据？

76
00:03:52,666 --> 00:03:56,570
在此图中 我们的
App 先向服务器发送请求

77
00:03:56,570 --> 00:03:58,972
以获取漫画书店地址列表

78
00:03:58,972 --> 00:04:01,742
后端服务器返回漫画书店地址列表

79
00:04:01,742 --> 00:04:04,511
到您的客户端设备

80
00:04:04,511 --> 00:04:07,514
由于我们在此示例中
没有新的 Server API

81
00:04:07,514 --> 00:04:10,717
所以我们的 App
在创建一张地图名片

82
00:04:10,717 --> 00:04:13,520
就必须执行大量操作

83
00:04:13,520 --> 00:04:15,355
每执行一次任务

84
00:04:15,355 --> 00:04:17,758
用户可能都需要多次

85
00:04:17,758 --> 00:04:20,127
向后端服务器发送请求

86
00:04:20,127 --> 00:04:23,697
在这里您可以看到客户端正在

87
00:04:23,697 --> 00:04:25,866
直接向 Apple Maps Server
发送请求

88
00:04:25,866 --> 00:04:29,570
或者通过 MapKit
或 MapKit JS

89
00:04:29,570 --> 00:04:32,773
客户端和后端服务器之间的这种互动

90
00:04:32,773 --> 00:04:35,075
会对 App 的性能和大小

91
00:04:35,075 --> 00:04:36,643
产生负面影响

92
00:04:36,643 --> 00:04:39,780
在通常具有高延迟的蜂窝网络上

93
00:04:39,780 --> 00:04:43,517
以这种方式使用单个请求

94
00:04:43,517 --> 00:04:45,586
效率很低 甚至可能导致连接中断

95
00:04:45,586 --> 00:04:47,487
或数据丢失

96
00:04:47,487 --> 00:04:50,190
当每个请求可以并行完成时

97
00:04:50,190 --> 00:04:53,093
App 必须
在单独的连接上发送 等待

98
00:04:53,093 --> 00:04:55,896
和处理每个请求的数据

99
00:04:55,896 --> 00:04:58,232
而这将增加失败的可能

100
00:04:58,232 --> 00:05:02,436
最后 您将必须
合并客户端上的所有响应

101
00:05:02,436 --> 00:05:04,738
当所有这些调用发生时

102
00:05:04,738 --> 00:05:07,341
您正在向用户展示一个微调器

103
00:05:07,341 --> 00:05:10,077
另外 客户端设备
需要为这些额外的调用

104
00:05:10,077 --> 00:05:12,079
使用更多的带宽和功耗

105
00:05:12,079 --> 00:05:14,848
这样的用户体验并不好

106
00:05:14,848 --> 00:05:17,284
现在 让我们来看一下使用了

107
00:05:17,284 --> 00:05:20,120
Apple Maps Server API
的模型架构

108
00:05:20,120 --> 00:05:23,156
您可以开始使用后端服务器作为网关

109
00:05:23,156 --> 00:05:27,895
以减少客户端和服务器之间的互动

110
00:05:27,895 --> 00:05:31,198
和以前一样 这里我们从您的客户端

111
00:05:31,198 --> 00:05:34,368
向后端服务器发送一个
显示漫画店列表的请求

112
00:05:34,368 --> 00:05:39,740
接下来 我们
从服务器发出请求以进行地理编码

113
00:05:39,740 --> 00:05:42,843
然后我们会收到
来自 Apple Maps Server 的

114
00:05:42,843 --> 00:05:45,846
每个 API 的响应

115
00:05:45,846 --> 00:05:50,217
漫画书服务器组合
来自每个服务的响应

116
00:05:50,217 --> 00:05:52,920
并将响应发送给 App

117
00:05:52,920 --> 00:05:55,656
此模式可以减少 App

118
00:05:55,656 --> 00:05:58,458
对后端服务的请求数量

119
00:05:58,458 --> 00:06:00,093
并在高延迟网络上

120
00:06:00,093 --> 00:06:02,162
提高 App 的性能

121
00:06:02,162 --> 00:06:05,899
总而言之
您的客户端仅向您的服务器

122
00:06:05,899 --> 00:06:07,868
发送了一次获取存储列表的请求

123
00:06:07,868 --> 00:06:10,337
然后您的服务器完成繁重的工作

124
00:06:10,337 --> 00:06:13,941
进行了相应的 API 调用并组成

125
00:06:13,941 --> 00:06:16,810
最符合用户需求的响应呈现给用户

126
00:06:16,810 --> 00:06:19,780
所以 让我们回到
这里的案例研究示例

127
00:06:19,780 --> 00:06:22,249
我们将使用地理编码
和 ETA API

128
00:06:22,249 --> 00:06:24,918
来获取到商店的距离

129
00:06:24,918 --> 00:06:29,256
我们可以使用地理编码
API 来查找纬度和经度

130
00:06:29,256 --> 00:06:31,825
我们稍后将使用商店地址

131
00:06:31,825 --> 00:06:33,627
用于预计到达时间计算

132
00:06:33,627 --> 00:06:36,430
在这个例子中 首先 我们将采取

133
00:06:36,430 --> 00:06:42,102
漫画书店的地址
和 URL 对其进行编码

134
00:06:42,102 --> 00:06:45,339
接下来 我们将使用
Geocode API

135
00:06:45,339 --> 00:06:50,077
并将这个 URL 编码的地址
作为查询参数传递

136
00:06:50,077 --> 00:06:52,746
我们现在暂时跳过认证的细节

137
00:06:52,746 --> 00:06:55,749
在几张幻灯片中再来讨论它

138
00:06:55,749 --> 00:06:58,852
在响应中 可以看到

139
00:06:58,852 --> 00:07:01,555
返回的地址的经纬度

140
00:07:01,555 --> 00:07:03,724
我们将重复相同的流程来找到

141
00:07:03,724 --> 00:07:06,994
客户地址的经纬度

142
00:07:06,994 --> 00:07:10,063
这将在稍后用于预计到达时间计算

143
00:07:10,063 --> 00:07:13,600
如您所见 响应中有更多字段

144
00:07:13,600 --> 00:07:15,269
我会在下方的资源部分

145
00:07:15,269 --> 00:07:18,438
链接详细的文档

146
00:07:18,438 --> 00:07:23,110
现在 我们可以
用从 Geocode API 获得的数据

147
00:07:23,110 --> 00:07:26,947
在 ETA API 上
设置起点和终点

148
00:07:26,947 --> 00:07:31,585
正如我之前提到的
我们有起点纬度 经度

149
00:07:31,585 --> 00:07:34,121
以及目的地的纬度 经度

150
00:07:34,121 --> 00:07:38,125
如果需要 我们最多可以
在此处指定 10 个目的地

151
00:07:38,125 --> 00:07:41,628
我们以 URL 编码的格式

152
00:07:41,628 --> 00:07:45,299
把起点信息和终点信息

153
00:07:45,299 --> 00:07:47,701
提供给 ETA API

154
00:07:47,701 --> 00:07:50,971
我们可以通过 API
输出每个目的地

155
00:07:50,971 --> 00:07:53,040
的预计到达时间列表

156
00:07:53,040 --> 00:07:55,142
在这个案例中
因为我们只提供了一个目的地

157
00:07:55,142 --> 00:07:58,679
所以我们只有
一个预计到达时间反馈信息

158
00:07:58,679 --> 00:08:02,416
这是我们的示例 假设我们

159
00:08:02,416 --> 00:08:04,918
想使用 distanceMeters
计算到商店的距离

160
00:08:04,918 --> 00:08:07,921
有了这些 我们就有了所需的

161
00:08:07,921 --> 00:08:10,757
所有信息：商店地址和

162
00:08:10,757 --> 00:08:12,626
用户与商店的距离

163
00:08:12,626 --> 00:08:15,829
您还可以选择使用个性化的商店信息

164
00:08:15,829 --> 00:08:19,666
扩充或修改此数据 如商店营业时间

165
00:08:19,666 --> 00:08:23,136
通过这种方式
您可以利用不同的 Server API

166
00:08:23,136 --> 00:08:25,239
构建您的 App

167
00:08:25,239 --> 00:08:28,041
其他 API 请参考

168
00:08:28,041 --> 00:08:29,910
在本视频下方的文档链接

169
00:08:29,910 --> 00:08:33,814
我们尚未讨论的
一个关键部分是身份验证

170
00:08:33,814 --> 00:08:37,451
所有 Apple Maps Server API
都经过了身份验证

171
00:08:37,451 --> 00:08:41,154
如果您使用的是 MapKit JS
那么您已经完成了一半

172
00:08:41,154 --> 00:08:45,225
Apple Maps Server API
使用与 MapKit JS 相同的机制

173
00:08:45,225 --> 00:08:47,327
进行身份验证

174
00:08:47,327 --> 00:08:49,630
首先 您将从您的开发者帐户

175
00:08:49,630 --> 00:08:51,565
下载您的私钥

176
00:08:51,565 --> 00:08:53,300
然后 您将使用此私钥

177
00:08:53,300 --> 00:08:56,703
生成 JWT 格式的地图身份
验证令牌

178
00:08:56,703 --> 00:08:59,039
下方链接有如何生成

179
00:08:59,039 --> 00:09:00,874
该令牌的详细文档

180
00:09:00,874 --> 00:09:03,076
然后 您可以
使用令牌 API 交换这个

181
00:09:03,076 --> 00:09:06,713
地图认证令牌来获得地图访问令牌

182
00:09:06,713 --> 00:09:10,417
我们将在后端验证地图身份验证令牌

183
00:09:10,417 --> 00:09:13,053
并发回地图访问令牌

184
00:09:13,053 --> 00:09:15,422
这是 JWT 格式

185
00:09:15,422 --> 00:09:18,792
将用于所有 API 交互

186
00:09:18,792 --> 00:09:22,329
此访问令牌需要通过重复此处

187
00:09:22,329 --> 00:09:25,632
突出显示的过程
每 30 分钟刷新一次

188
00:09:25,632 --> 00:09:29,236
现在我们看到了
身份验证流程是什么样的

189
00:09:29,236 --> 00:09:33,106
这是一个如何使用令牌 API

190
00:09:33,106 --> 00:09:35,776
来获取访问令牌的简单示例

191
00:09:35,776 --> 00:09:39,079
我们在这里使用的是令牌 API

192
00:09:39,079 --> 00:09:43,050
我们将地图认证令牌
作为头文件传递

193
00:09:43,050 --> 00:09:46,019
您将收到一个地图访问令牌

194
00:09:46,019 --> 00:09:48,555
可用于访问 API

195
00:09:48,555 --> 00:09:52,159
它将采用 JWT 格式
并具有标准字段

196
00:09:52,159 --> 00:09:55,562
如 expiry、issuedAt 等

197
00:09:55,562 --> 00:09:58,298
为方便起见
expiresInSeconds 字段

198
00:09:58,298 --> 00:10:01,001
显示令牌的有效时间

199
00:10:01,001 --> 00:10:04,738
在这种情况下
有效时间是 30 分钟

200
00:10:04,738 --> 00:10:07,207
请记住地图身份验证令牌

201
00:10:07,207 --> 00:10:10,310
与地图访问令牌不同

202
00:10:10,310 --> 00:10:12,713
您交换地图认证令牌

203
00:10:12,713 --> 00:10:15,649
以获得一个
时效为 30 分钟的地图访问令牌

204
00:10:15,649 --> 00:10:18,252
来访问 Server API

205
00:10:18,252 --> 00:10:21,054
让我们快速看看有地图访问令牌的

206
00:10:21,054 --> 00:10:24,958
API 交互是怎么样的

207
00:10:24,958 --> 00:10:29,096
我们将通过 Server API 调用
传递地图访问令牌

208
00:10:29,096 --> 00:10:31,932
它作为头文件
添加到 API 调用中

209
00:10:31,932 --> 00:10:34,368
就像我们之前
看到的几张幻灯片一样

210
00:10:34,368 --> 00:10:37,971
Apple Maps Server
将验证地图访问令牌

211
00:10:37,971 --> 00:10:40,073
验证成功后

212
00:10:40,073 --> 00:10:44,578
Apple Maps Server
将会响应 API 的请求

213
00:10:44,578 --> 00:10:47,848
现在我已经
介绍了 API 和身份验证

214
00:10:47,848 --> 00:10:50,417
让我谈谈使用限制

215
00:10:50,417 --> 00:10:53,153
能力越大 责任越大

216
00:10:53,153 --> 00:10:55,389
所以请明智地使用您的配额

217
00:10:55,389 --> 00:10:59,359
每天可以进行的 API 调用
是有上限的

218
00:10:59,359 --> 00:11:01,094
但这个上限值很高

219
00:11:01,094 --> 00:11:05,632
每天您总共将获得
25,000 个请求配额

220
00:11:05,632 --> 00:11:09,736
请记住 通过 MapKit JS
和 Server API

221
00:11:09,736 --> 00:11:11,371
调用服务都使用相同的配额

222
00:11:11,371 --> 00:11:14,508
如果您需要更多配额 请与我们联系

223
00:11:14,508 --> 00:11:18,011
那么 您如何跟踪这一切呢？

224
00:11:18,011 --> 00:11:23,083
您可以在地图开发者主页中
查看使用情况

225
00:11:23,083 --> 00:11:24,885
有人正在使用 MapKit JS 吗？

226
00:11:24,885 --> 00:11:27,788
这对您来说会很熟悉

227
00:11:27,788 --> 00:11:31,191
Server API 的使用
被归类为服务

228
00:11:31,191 --> 00:11:34,962
您可以在此处突出显示

229
00:11:34,962 --> 00:11:37,431
当超过每日配额时

230
00:11:37,431 --> 00:11:41,869
也就是超过 25,000 个
Server API 调用

231
00:11:41,869 --> 00:11:44,371
我们将开始拒绝新的服务调用

232
00:11:44,371 --> 00:11:47,407
并以 HTTP 429 状态响应

233
00:11:47,407 --> 00:11:50,177
这表示有太多的请求

234
00:11:50,177 --> 00:11:52,446
在这种情况下 您应该确保

235
00:11:52,446 --> 00:11:55,382
App 产生的数据
可以被有效地压缩

236
00:11:55,382 --> 00:11:57,484
在极少数情况下 当您的服务

237
00:11:57,484 --> 00:12:00,521
发出不寻常的请求量时

238
00:12:00,521 --> 00:12:03,490
可能是由于代码
或基础结构中的一些 Bug

239
00:12:03,490 --> 00:12:07,227
也可能是
得到 HTTP 429 状态

240
00:12:07,227 --> 00:12:10,397
当您接收
HTTP 429 状态时

241
00:12:10,397 --> 00:12:13,667
请尽量避免
再重复机械地继续发送请求

242
00:12:13,667 --> 00:12:16,570
更好的方法是

243
00:12:16,570 --> 00:12:18,105
稍后再进行重试

244
00:12:18,105 --> 00:12:21,775
这种方法称为指数避退

245
00:12:21,775 --> 00:12:24,878
那么 我们今天了解到了什么？

246
00:12:24,878 --> 00:12:27,548
我们发布了
四个新的 Server API

247
00:12:27,548 --> 00:12:30,784
这些 API 分别是
Geocode、Reverse Geocoding

248
00:12:30,784 --> 00:12:33,687
Search 和 ETA

249
00:12:33,687 --> 00:12:38,025
将这些 API 与 MapKit
和 MapKit JS 结合使用

250
00:12:38,025 --> 00:12:40,027
将帮助您更好地
使用 Apple Maps 堆栈

251
00:12:40,027 --> 00:12:42,896
构建您的 App

252
00:12:42,896 --> 00:12:45,866
您可以通过
使用 Apple Maps Server API

253
00:12:45,866 --> 00:12:48,335
将这些任务委派给您的后端服务器

254
00:12:48,335 --> 00:12:51,872
以此优化冗余 减少重复调用

255
00:12:51,872 --> 00:12:55,542
这些 API 的每日配额
为 25,000 次

256
00:12:55,542 --> 00:12:58,745
并与您的 MapKit JS 服务
使用共享

257
00:12:58,745 --> 00:13:01,849
这就是为您而设的
全新 Apple Maps Server API

258
00:13:01,849 --> 00:13:04,551
请务必观看我们提及的
关联讲座

259
00:13:04,551 --> 00:13:07,020
以及下面链接的详细文档

260
00:13:07,020 --> 00:13:10,123
我们期待看到您
充分利用这些 API

261
00:13:10,123 --> 00:13:11,458
感谢收看！

262
00:13:11,458 --> 00:13:15,462
♪

