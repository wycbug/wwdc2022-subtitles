1
00:00:00,767 --> 00:00:06,773
[迷幻音乐]

2
00:00:09,309 --> 00:00:11,078
Boris：嗨 我是 Boris

3
00:00:11,111 --> 00:00:13,714
欢迎来到“创建
Swift 软件包插件”讲座

4
00:00:14,848 --> 00:00:18,252
我们在 Xcode 11 中
引入了对 Swift 软件包的支持

5
00:00:18,285 --> 00:00:21,588
提供一种以源代码形式
直接发布软件库的方法

6
00:00:22,523 --> 00:00:26,527
在 Xcode 14 中
我们希望将这种架构和分享组件的

7
00:00:26,560 --> 00:00:28,729
出色方式带入开发工作流中

8
00:00:28,762 --> 00:00:31,765
例如通过
Swift 软件包插件生成源代码

9
00:00:31,798 --> 00:00:33,834
或自动发布任务

10
00:00:34,701 --> 00:00:36,870
首先 我将简单概述今天的讲座内容

11
00:00:36,904 --> 00:00:38,839
在了解插件的基础信息后

12
00:00:38,872 --> 00:00:42,242
我们将演示如何创建第一个
自定义命令插件

13
00:00:42,276 --> 00:00:45,612
接下来 我们将了解
更多关于创建插件的细节

14
00:00:45,646 --> 00:00:49,416
随后继续演示如何创建构建中

15
00:00:49,449 --> 00:00:50,751
和构建前命令插件

16
00:00:51,818 --> 00:00:56,356
软件包插件是一种使用
PackagePlugin API 的

17
00:00:56,390 --> 00:00:58,725
类似于
软件包清单的 Swift 代码

18
00:00:58,759 --> 00:01:01,028
插件可以通过定义明确的扩展点

19
00:01:01,061 --> 00:01:04,598
扩展 Xcode 或
Swift 软件包管理器的功能

20
00:01:06,567 --> 00:01:09,002
软件包插件是如何运行的呢？

21
00:01:09,036 --> 00:01:12,539
Xcode 将编译和运行您的插件

22
00:01:12,573 --> 00:01:15,709
能够使用相关可用可执行文件

23
00:01:15,742 --> 00:01:18,178
和输入文件的信息来创建命令

24
00:01:18,212 --> 00:01:19,913
它将这些命令返回 Xcode

25
00:01:19,947 --> 00:01:22,182
根据需要执行命令

26
00:01:24,718 --> 00:01:27,254
软件包插件可以
帮助完成构建前或构建中

27
00:01:27,287 --> 00:01:29,556
运行的自定义构建任务

28
00:01:29,590 --> 00:01:32,226
比如可以生成源代码或资源文件

29
00:01:33,493 --> 00:01:37,030
它们也可以新增自定义命令
到 SwiftPM 的命令行界面

30
00:01:37,064 --> 00:01:39,666
或将菜单项添加到 Xcode

31
00:01:39,700 --> 00:01:43,103
如想了解更多关于插件的基础信息
我推荐您先观看

32
00:01:43,136 --> 00:01:44,938
“认识 Swift 软件包插件”讲座

33
00:01:44,972 --> 00:01:47,841
如果您此前对软件包没有任何了解

34
00:01:47,875 --> 00:01:51,645
可以观看 WWDC19 的
“创建 Swift 软件包”讲座

35
00:01:53,547 --> 00:01:57,084
我们来看看如何创建
第一个自定义命令插件

36
00:01:58,886 --> 00:02:01,388
我正在 Swift 开放源码中

37
00:02:01,421 --> 00:02:02,723
参与核心支持工具软件包的工作

38
00:02:02,756 --> 00:02:04,224
我想要新增一个

39
00:02:04,258 --> 00:02:06,793
列出项目所有贡献者的文本文件

40
00:02:06,827 --> 00:02:10,731
我还想根据需要从软件包的
Git 历史中重新生成它

41
00:02:12,065 --> 00:02:13,967
从前 我可能会
写一个 shell 脚本

42
00:02:14,001 --> 00:02:15,536
或 makefile

43
00:02:15,569 --> 00:02:17,804
但现在我要创建一个自定义命令插件

44
00:02:17,838 --> 00:02:20,807
让我不需要离开 Xcode
就能重新生成文件

45
00:02:22,943 --> 00:02:26,813
首先 我们必须为插件创建目录架构

46
00:02:26,847 --> 00:02:31,018
打开软件包的上下文菜单

47
00:02:31,051 --> 00:02:33,887
选择“新文件夹”

48
00:02:33,921 --> 00:02:38,792
来创建名为 “Plugins” 的顶层文件夹

49
00:02:38,825 --> 00:02:41,862
与现有的源码与测试文件夹类似

50
00:02:43,697 --> 00:02:48,535
接下来 我们要为插件目标创建

51
00:02:48,569 --> 00:02:51,505
另一个嵌套文件夹
命名为 “GenerateContributors”

52
00:02:57,110 --> 00:03:00,747
在这个文件夹里创建一个新文件
命名为 “plugin.swift”

53
00:03:12,426 --> 00:03:15,629
接下来 我们要对
软件包清单进行一些更改

54
00:03:15,662 --> 00:03:18,298
来声明我们的新目标

55
00:03:18,332 --> 00:03:22,336
但首先 我们必须将
软件包工具版本升到 5.6

56
00:03:22,369 --> 00:03:25,205
因为插件从这一版本开始才可用

57
00:03:33,046 --> 00:03:35,516
接下来就可以插入插件目标了

58
00:03:44,791 --> 00:03:47,761
我们来看一看新的清单 API

59
00:03:49,496 --> 00:03:50,931
我们将创建一个对应于

60
00:03:50,964 --> 00:03:53,567
“Plugins” 文件夹中
某一文件夹的插件目标

61
00:03:53,600 --> 00:03:55,402
与源码模块的目标类似

62
00:03:56,904 --> 00:03:59,940
它得到一个既与命名文件夹有关

63
00:03:59,973 --> 00:04:02,209
又是 Xcode 中菜单项的名称

64
00:04:03,477 --> 00:04:05,145
我们需要指定功能

65
00:04:05,179 --> 00:04:07,648
也就是我们想用什么类型的扩展点

66
00:04:07,681 --> 00:04:10,417
在这个案例中
我们是在创建自定义命令

67
00:04:12,119 --> 00:04:15,522
intent 可以为
SwiftPM 命令行定义一个动词

68
00:04:15,556 --> 00:04:19,459
以及描述该插件的作用

69
00:04:19,493 --> 00:04:22,729
最后 我们可以声明
该插件需要的权限

70
00:04:24,264 --> 00:04:27,467
在这个案例中 我们要将
新文件写到软件包的根目录

71
00:04:27,501 --> 00:04:30,304
所以需要写入该目录的权限

72
00:04:30,337 --> 00:04:33,106
reason 字符串会显示给插件使用者

73
00:04:33,140 --> 00:04:35,909
让他们知道是否已获得权限

74
00:04:35,943 --> 00:04:39,179
和 OS 自身权限的管理方式类似

75
00:04:39,213 --> 00:04:43,650
声明了插件之后
让我们返回进行实施

76
00:04:45,686 --> 00:04:49,890
插件会运行调用 Git 获取提交历史

77
00:04:49,923 --> 00:04:52,793
它会从外部 Git 命令的
标准输出中读取历史

78
00:04:52,826 --> 00:04:55,229
并解析结果

79
00:04:55,262 --> 00:04:57,998
最后将其写出为文本文件

80
00:04:59,399 --> 00:05:04,571
我们需要打开之前创建的插件源文件

81
00:05:04,605 --> 00:05:06,173
导入 PackagePlugin

82
00:05:09,109 --> 00:05:10,377
这是一个内置模块

83
00:05:10,410 --> 00:05:13,614
和 PackageDescription 很像

84
00:05:13,647 --> 00:05:15,816
可以获取实施插件
需要用到的 API

85
00:05:17,751 --> 00:05:24,491
我们来定义一个结构体
GenerateContributors

86
00:05:24,525 --> 00:05:26,360
使其符合 CommandPlugin

87
00:05:32,165 --> 00:05:35,369
接受这里的修订

88
00:05:35,402 --> 00:05:39,506
来获取实施协议所缺的代码片段

89
00:05:39,540 --> 00:05:42,042
我们还需要将
结构体标记为 @main

90
00:05:42,075 --> 00:05:44,945
因为它将是插件
可执行文件的 main 函数

91
00:05:46,180 --> 00:05:49,016
performCommand
是我们命令的进入点

92
00:05:49,049 --> 00:05:50,984
我们会收到两个参数

93
00:05:51,018 --> 00:05:54,788
一个是 context 它让我们
能够获取经过解析的软件包图

94
00:05:54,821 --> 00:05:58,292
和其他关于执行的上下文信息

95
00:05:58,325 --> 00:06:00,427
包括参数

96
00:06:00,460 --> 00:06:03,597
由于是用户发起了自定义命令

97
00:06:03,630 --> 00:06:06,567
用户可以用参数形式提供输入信息

98
00:06:06,600 --> 00:06:08,735
我们来创建一个简单命令

99
00:06:08,769 --> 00:06:10,571
在这个时候不向用户

100
00:06:10,604 --> 00:06:12,039
提供任何选择

101
00:06:20,113 --> 00:06:21,582
因为我们要运行调用 Git

102
00:06:21,615 --> 00:06:24,251
获取关于提交历史的信息

103
00:06:24,284 --> 00:06:25,586
就要导入 Foundation

104
00:06:25,619 --> 00:06:28,255
因为我们需要用到 Process API

105
00:06:35,329 --> 00:06:39,333
接下来 我们将定义一个进程实例
并通过一些格式化参数

106
00:06:39,366 --> 00:06:41,401
使它执行 git log

107
00:06:45,239 --> 00:06:48,509
我们需要创建管道来捕获进程输出值

108
00:06:48,542 --> 00:06:51,144
然后就可以运行并等待它退出

109
00:06:55,015 --> 00:06:56,617
这个过程完成后

110
00:06:56,650 --> 00:06:58,819
我们从管道中读取所有数据

111
00:06:58,852 --> 00:07:01,822
并将它转化为字符串
其中包含所有版本记录输出值

112
00:07:05,926 --> 00:07:07,828
我们可以对字符串进行操作

113
00:07:07,861 --> 00:07:10,697
将输出数据修整为无重复值的列表

114
00:07:10,731 --> 00:07:12,232
最后 我们就可以将它写成文件

115
00:07:12,266 --> 00:07:14,168
命名为 “CONTRIBUTORS.txt”

116
00:07:14,201 --> 00:07:16,503
因为自定义命令是在

117
00:07:16,537 --> 00:07:18,105
软件包的根目录中执行的

118
00:07:18,138 --> 00:07:19,506
我们也将文件存储在那里

119
00:07:22,276 --> 00:07:24,778
现在 如果我们先保存
然后在项目导航器中

120
00:07:24,811 --> 00:07:29,049
右键点击软件包

121
00:07:29,082 --> 00:07:32,085
上下文菜单中就会出现
一条对应我们命令的项目

122
00:07:32,119 --> 00:07:33,520
来执行它吧！

123
00:07:37,391 --> 00:07:40,427
在接下来的对话框中
我们可以选择应为

124
00:07:40,460 --> 00:07:43,997
插件输入项的软件包或目标
以及任何参数

125
00:07:44,031 --> 00:07:47,234
但由于我们的插件并不回应这些选项
我们可以点按“运行”

126
00:07:51,538 --> 00:07:55,609
接下来 我们会被要求授权
因为之前在清单中定义的就是这样

127
00:07:55,642 --> 00:07:59,379
由于插件是我们刚才自己写的
可以直接运行

128
00:07:59,413 --> 00:08:03,116
但请确保您只向
信任的插件进行额外授权

129
00:08:08,288 --> 00:08:11,992
运行后 CONTRIBUTORS.txt
文件出现在项目导航器中

130
00:08:14,828 --> 00:08:18,198
在使用第一个插件
扩展了 Xcode 之后

131
00:08:18,232 --> 00:08:20,334
让我们更深入地探讨插件的运作方式

132
00:08:20,367 --> 00:08:22,736
以及创建插件时的注意事项

133
00:08:26,240 --> 00:08:28,342
软件包插件在沙盒中运行

134
00:08:28,375 --> 00:08:31,912
和软件包清单本身的解释运行类似

135
00:08:31,945 --> 00:08:34,915
网络连接 以及写入
除插件自身运行目录之外的

136
00:08:34,948 --> 00:08:38,218
非临时位置都将被禁止

137
00:08:38,252 --> 00:08:41,722
像之前演示的那样 自定义命令可以

138
00:08:41,755 --> 00:08:44,525
选择性声明是否写入软件包根目录

139
00:08:45,459 --> 00:08:47,895
如果您要包装已有的第三方工具

140
00:08:47,928 --> 00:08:51,098
必须考虑如何将其限制在沙盒模式中

141
00:08:51,131 --> 00:08:54,234
比如说 可以通过配置
生成文件的写入位置来实现

142
00:08:55,669 --> 00:08:58,338
我在介绍中谈到了不同类型的插件

143
00:08:58,372 --> 00:09:00,607
一个问题是由自定义命令
还是构建工具来解决更好

144
00:09:00,641 --> 00:09:02,476
这一点应该已经清楚了

145
00:09:02,509 --> 00:09:05,546
但我们还是来看一看
构建工具插件的结构

146
00:09:07,014 --> 00:09:09,283
这些插件允许您可以通过
描述一次构建中可运行

147
00:09:09,316 --> 00:09:13,086
哪些可执行文件
并指定其输入和输出内容

148
00:09:13,120 --> 00:09:15,155
来扩展构建系统

149
00:09:15,189 --> 00:09:18,725
这可以帮助您在
构建期间合适的时机规划任务

150
00:09:19,726 --> 00:09:21,562
如果您在 Xcode 项目中
创建过 run script phase

151
00:09:21,595 --> 00:09:23,263
就应该对这部分涉及的

152
00:09:23,297 --> 00:09:24,498
基础内容很熟悉了

153
00:09:26,400 --> 00:09:29,469
构建工具插件分为两种不同类型

154
00:09:29,503 --> 00:09:33,273
区分要点在于您的
工具是否定义了的输出集

155
00:09:34,541 --> 00:09:37,411
如果有 您就应该创建构建中命令

156
00:09:37,444 --> 00:09:39,980
如果输出与输入相比已经过时

157
00:09:40,013 --> 00:09:43,684
它将由构建系统自动重新运行

158
00:09:43,717 --> 00:09:47,154
如果您没有明确的输出集
可以创建构建前命令

159
00:09:47,187 --> 00:09:49,556
它将在每次构建开始时运行

160
00:09:49,590 --> 00:09:51,625
正因为如此 您应当
避免在构建前命令中

161
00:09:51,658 --> 00:09:53,794
进行代价高昂的工作

162
00:09:53,827 --> 00:09:56,630
或想一个适合您用例的

163
00:09:56,663 --> 00:09:58,532
自定义策略来缓存结果

164
00:10:02,336 --> 00:10:04,972
在第二项演示中
我打算创建一个新软件库

165
00:10:05,005 --> 00:10:08,942
其中包含了我想在
手头不同的工具中共享的图标

166
00:10:11,044 --> 00:10:13,447
首先通过模板创建新的软件包

167
00:10:13,480 --> 00:10:15,115
命名为 “IconLibrary”

168
00:10:15,148 --> 00:10:19,987
我现在要把一些已有的图标资产
拖到我软件库的目标中

169
00:10:20,020 --> 00:10:24,591
让我们再给软件库加上
基础 SwiftUI 视图和预览

170
00:10:24,625 --> 00:10:28,328
首先 我们要将必需的
最低部署目标添加到清单

171
00:10:33,800 --> 00:10:37,171
接下来 我们来添加基础视图和预览

172
00:10:37,204 --> 00:10:40,407
在这里我们可以使用之前拖入的资产

173
00:10:44,978 --> 00:10:46,380
我觉得 比较理想的做法

174
00:10:46,413 --> 00:10:48,815
是用一种类型安全的方式
来引用这些图片

175
00:10:48,849 --> 00:10:52,252
而不是非得在这里处理字符串

176
00:10:52,286 --> 00:10:55,289
这似乎是构建中
命令插件的绝佳使用案例

177
00:10:55,322 --> 00:10:56,924
因为这一插件考虑资产目录

178
00:10:56,957 --> 00:10:59,560
并以此为基础生成 Swift 代码

179
00:10:59,593 --> 00:11:01,995
让我们在 Finder 中
看一看资产目录

180
00:11:02,029 --> 00:11:05,432
来了解我们应该
如何提取插件需要的信息

181
00:11:06,466 --> 00:11:11,338
每张图片都有自己的图集目录
包含资产名称

182
00:11:15,709 --> 00:11:18,946
还有一个用于描述
基础内容的 JSON 文件

183
00:11:21,815 --> 00:11:24,284
构建中命令
与自定义命令的运行方式有所不同

184
00:11:24,318 --> 00:11:27,120
它们除了提供用于
运行的可执行文件描述

185
00:11:27,154 --> 00:11:28,589
还有提供输入和输出

186
00:11:30,157 --> 00:11:32,559
可执行文件可以由系统或

187
00:11:32,593 --> 00:11:36,463
第三方软件包提供
您也可以专门为插件定制可执行文件

188
00:11:36,496 --> 00:11:38,298
我们选择第三种途径

189
00:11:40,300 --> 00:11:42,569
插件在构建过程开始时运行

190
00:11:42,603 --> 00:11:45,239
以参与构件图的计算

191
00:11:46,807 --> 00:11:50,577
以此为基础 可执行文件
作为构建执行的一部分进行排期

192
00:11:52,279 --> 00:11:54,915
现在回到我们构建的可执行文件

193
00:11:54,948 --> 00:11:59,453
我们要资产目录中的每张图
都有一个编译期常量

194
00:11:59,486 --> 00:12:03,123
这样一来就不需要
记住每张图片的正确字符串

195
00:12:03,156 --> 00:12:05,392
而是可以让它们
作为 Swift 符号自动完成

196
00:12:07,294 --> 00:12:09,229
我们将循环遍历资产目录的内容

197
00:12:09,263 --> 00:12:12,366
来找到所有的图集

198
00:12:12,399 --> 00:12:15,469
我们将解析每个图集的元数据来确定

199
00:12:15,502 --> 00:12:17,137
它是否真的包含图片

200
00:12:17,171 --> 00:12:19,740
以及是否应当为其生成代码

201
00:12:21,408 --> 00:12:24,278
然后我们就可以
生成代码并写入到一个文件

202
00:12:24,311 --> 00:12:27,381
由于我们声明这些文件
为插件的输出内容

203
00:12:27,414 --> 00:12:30,417
它们将自动并入插件

204
00:12:30,450 --> 00:12:31,919
所应用的目标的构建之中

205
00:12:33,887 --> 00:12:35,789
我们需要想办法处理参数

206
00:12:35,822 --> 00:12:39,126
因为这是插件和
可执行文件沟通的方式

207
00:12:40,827 --> 00:12:46,200
第一个参数是指向我们
正在处理的资产目录的路径

208
00:12:46,233 --> 00:12:49,903
第二个是插件为
生成的代码提供的路径

209
00:12:51,605 --> 00:12:55,976
接下来 我们需要模型对象来
对 contents.json 文件进行解码

210
00:12:57,010 --> 00:13:00,948
可以使用 Decodable 来充分
利用 Swift 内置的 JSON 解码功能

211
00:13:02,416 --> 00:13:06,720
我们唯一感兴趣的信息是图像列表

212
00:13:06,753 --> 00:13:09,990
和它们的文件名 但这是可选的
因为可能不是每一种

213
00:13:10,023 --> 00:13:13,493
像素密度都有对应的图像

214
00:13:13,527 --> 00:13:15,762
这里我们以一种极其
简化的方式来生成代码

215
00:13:15,796 --> 00:13:17,898
只需要建立一个字符串

216
00:13:17,931 --> 00:13:20,234
我们首先导入需要的框架

217
00:13:20,267 --> 00:13:21,735
Foundation 和 SwiftUI

218
00:13:23,637 --> 00:13:25,506
我们要循环遍历资产目录的

219
00:13:25,539 --> 00:13:26,773
全部内容

220
00:13:26,807 --> 00:13:29,543
来找到所有的图集

221
00:13:29,576 --> 00:13:32,546
下一步是解析 JSON

222
00:13:32,579 --> 00:13:35,916
文件名使用了输入参数

223
00:13:35,949 --> 00:13:39,353
我们使用 Foundation 的
JSONDecoder API 进行解码

224
00:13:41,121 --> 00:13:43,357
我们感兴趣的主要信息是

225
00:13:43,390 --> 00:13:47,728
是否存在针对
给定图集进行定义的图像

226
00:13:47,761 --> 00:13:50,631
我们可以通过检查是否至少有一个

227
00:13:50,664 --> 00:13:53,967
图像拥有非空的文件名来确认

228
00:13:54,001 --> 00:13:55,903
如果给定图集中有图像

229
00:13:55,936 --> 00:13:57,838
我们就需要生成 SwiftUI 图像

230
00:13:57,871 --> 00:14:00,307
从软件包中载入该图像

231
00:14:02,109 --> 00:14:05,579
实现的方式是通过每个图片
的 basename 创建字符串

232
00:14:05,612 --> 00:14:07,748
从模块包中载入相应的图片

233
00:14:07,781 --> 00:14:10,184
此模块包就是构建系统
为每个带资源的软件包

234
00:14:10,217 --> 00:14:12,186
创建的资源包

235
00:14:13,620 --> 00:14:17,824
我们可以通过将生成的代码
写入文件 为可执行文件的工作收尾

236
00:14:17,858 --> 00:14:19,426
以参数所指定的方式

237
00:14:21,528 --> 00:14:24,231
我们回到 Xcode 中
创建可执行文件

238
00:14:30,904 --> 00:14:33,473
将它命名为 “AssetConstantsExec”

239
00:14:40,447 --> 00:14:41,782
并添加主文件

240
00:14:51,358 --> 00:14:53,961
现在我们要在软件包清单中声明它

241
00:15:00,067 --> 00:15:03,070
我们可以将刚才讨论的
代码添加到它的主文件中

242
00:15:09,243 --> 00:15:11,945
现在有了可以生成代码的可执行文件

243
00:15:11,979 --> 00:15:14,681
我们可以通过插件将它带入构建系统

244
00:15:41,408 --> 00:15:43,076
我们从软件库目标中添加必需的目标

245
00:15:43,110 --> 00:15:46,380
以及插件的使用方法

246
00:16:09,436 --> 00:16:13,473
像之前一样 我们导入
PackagePlugin 软件库

247
00:16:13,507 --> 00:16:14,808
并创建结构体

248
00:16:14,842 --> 00:16:17,578
这一次要使它符合
BuildTool 插件协议

249
00:16:37,564 --> 00:16:41,068
入口点看上去很类似
但这里我们得到的是一个目标

250
00:16:41,101 --> 00:16:42,903
而非用户参数

251
00:16:42,936 --> 00:16:45,739
这就是插件应用的目标

252
00:16:45,772 --> 00:16:49,643
每个使用给定插件的目标
都会对入口点调用一次

253
00:16:55,649 --> 00:16:59,353
这个插件会尤其关注源模块目标

254
00:16:59,386 --> 00:17:02,256
指那些实际携带源文件的目标

255
00:17:02,289 --> 00:17:05,492
区别于与其他目标
比如说二进制目标

256
00:17:05,526 --> 00:17:07,561
为了创建构建命令的数组

257
00:17:07,594 --> 00:17:11,164
我们需要循环遍历
目标中所有 xcasset 包

258
00:17:11,198 --> 00:17:13,534
我们要为之后要显示在构建日志中的

259
00:17:13,567 --> 00:17:15,469
显示名称提取字符串

260
00:17:15,502 --> 00:17:18,705
并建立合适的输入和输出路径

261
00:17:19,473 --> 00:17:23,544
我们也可以使用插件 API
来查找可执行文件

262
00:17:23,577 --> 00:17:25,579
然后将构建命令合在一起

263
00:17:27,047 --> 00:17:29,950
这样 我们就准备好
再次构建这个项目了

264
00:17:29,983 --> 00:17:32,719
我们可以通过构建日志
查看新的构建步骤

265
00:17:32,753 --> 00:17:33,754
看看发生了什么

266
00:17:40,727 --> 00:17:44,598
插件在构建开始时编译和运行

267
00:17:44,631 --> 00:17:47,601
从那里 它将生成的所有
命令都添加到构建图中

268
00:17:52,472 --> 00:17:55,342
再来看看目标
我们的新构建命令已经运行了

269
00:17:59,279 --> 00:18:02,015
最后 生成的源文件作为

270
00:18:02,049 --> 00:18:04,451
Swift 编译文件的一部分出现

271
00:18:05,919 --> 00:18:12,359
现在回到预览

272
00:18:12,392 --> 00:18:16,430
在这里我们可以用新常量
来替代字符串类型的图像创建

273
00:18:20,000 --> 00:18:23,203
其他图像名称也自动补完了

274
00:18:28,141 --> 00:18:30,344
很好 我们几乎没用什么代码

275
00:18:30,377 --> 00:18:32,479
只使用熟悉的 Swift API

276
00:18:32,513 --> 00:18:36,683
没有离开 Xcode 就改善了工作流

277
00:18:39,386 --> 00:18:42,289
到这里 我们已经探讨了如何将插件

278
00:18:42,322 --> 00:18:45,125
作为我们
已有软件库的一部分为自己所用

279
00:18:45,158 --> 00:18:47,461
但插件的另一项强大的属性是

280
00:18:47,494 --> 00:18:49,696
我们可以像软件库那样

281
00:18:49,730 --> 00:18:51,198
直接共享它们

282
00:18:53,033 --> 00:18:54,968
在下一个演示中 我将展示如何

283
00:18:55,002 --> 00:18:56,336
使用随 Xcode 发布的
genstrings 工具

284
00:18:56,370 --> 00:18:58,705
自动化某些构建前的处理工作

285
00:18:59,473 --> 00:19:02,042
这一工具可以从您的代码中
提取本地化字符串

286
00:19:02,075 --> 00:19:05,078
进入本地化目录 供未来使用

287
00:19:05,112 --> 00:19:07,014
由于这个插件看起来很有用

288
00:19:07,047 --> 00:19:09,249
我想让它成为独立的软件包

289
00:19:09,283 --> 00:19:11,251
以便进行单独分享

290
00:19:12,886 --> 00:19:14,054
如果您想了解更多

291
00:19:14,087 --> 00:19:16,523
软件包中的资源和本地化的相关信息

292
00:19:16,557 --> 00:19:20,661
我推荐您观看
WWDC20 中关于此话题的讲座

293
00:19:20,694 --> 00:19:23,263
如果想了解更多本地化的总体信息

294
00:19:23,297 --> 00:19:26,633
请查看 WWDC21 的
“本地化您的 SwiftUI App” 讲座

295
00:19:28,936 --> 00:19:32,272
针对这个插件 我们首先
对用于本地化的输出目录

296
00:19:32,306 --> 00:19:34,942
进行计算

297
00:19:34,975 --> 00:19:36,343
我们需要计算输入文件

298
00:19:36,376 --> 00:19:41,215
它们全都是给定目标中的
Swift 或 Objective-C 源文件

299
00:19:41,248 --> 00:19:42,783
之后我们要创建构建前命令

300
00:19:42,816 --> 00:19:46,220
来执行 Xcode 提供的
genstrings 工具

301
00:19:46,253 --> 00:19:49,323
请注意 构建前和构建中命令的
最大区别在于

302
00:19:49,356 --> 00:19:52,059
我们没有对明确定义的
输出集进行声明

303
00:19:52,092 --> 00:19:54,528
也就是说这些命令
将在每一项构建上运行

304
00:19:56,063 --> 00:19:58,532
工具会从用户的源代码中

305
00:19:58,565 --> 00:20:00,834
提取所有本地化字符串

306
00:20:00,868 --> 00:20:04,371
然后将所有字符串都
写入本地化目录

307
00:20:04,404 --> 00:20:07,407
此目录可以作为用户项目实际的

308
00:20:07,441 --> 00:20:08,408
本地化工作的基础进行使用

309
00:20:11,078 --> 00:20:13,847
开始之前 我已经创建好了整体架构

310
00:20:13,881 --> 00:20:16,383
现在 在软件包清单中

311
00:20:16,416 --> 00:20:21,255
我们像之前一样添加插件目标

312
00:20:21,288 --> 00:20:23,724
但我们还需要添加插件产品

313
00:20:29,296 --> 00:20:32,299
与软件库产品类似 这是一种将插件

314
00:20:32,332 --> 00:20:35,536
作为软件包让客户可用
而不仅仅是自己使用

315
00:20:38,572 --> 00:20:42,276
我们可以写下之前讨论过的代码

316
00:20:50,384 --> 00:20:51,818
现在我们已经构建好了插件

317
00:20:51,852 --> 00:20:55,155
需要将其作为单独
示例软件包进行测试

318
00:21:00,694 --> 00:21:03,297
为此 让我们从模板
创建一个新软件包

319
00:21:04,731 --> 00:21:08,268
我们将添加一个为软件包提供
本地化字符串的 API

320
00:21:14,608 --> 00:21:17,578
再在生成的测试中添加其用法

321
00:21:35,729 --> 00:21:40,701
正如预想的那样 测试成功了
我们的 API 返回了字符串 “World”

322
00:21:40,734 --> 00:21:44,271
让我们为插件包添加
一个基于路径的依赖项

323
00:21:51,745 --> 00:21:54,348
再向软件库目标添加插件的用法

324
00:22:03,757 --> 00:22:05,492
现在我们可以再运行一次

325
00:22:10,864 --> 00:22:17,804
如果我们看一看构建日志

326
00:22:17,838 --> 00:22:23,410
就会发现插件在构建一开始就执行了

327
00:22:23,443 --> 00:22:26,547
生成的文件添加到了我们的目标中

328
00:22:26,580 --> 00:22:30,017
因此我们将资源包构建好

329
00:22:30,050 --> 00:22:34,288
并生成了一个资源存取器

330
00:22:34,321 --> 00:22:38,859
好像资源从一开始
就是我们目标的一部分

331
00:22:38,892 --> 00:22:42,462
现在让我们改写代码
来实际使用资源包

332
00:22:53,073 --> 00:22:55,075
最后 如果我们修改代码

333
00:23:10,757 --> 00:23:12,993
并看一下生成的资源包

334
00:23:26,974 --> 00:23:29,343
可以看到修改反映在这里

335
00:23:30,811 --> 00:23:32,946
现在我们有了插件的测试环境

336
00:23:32,980 --> 00:23:34,314
就可以完善测试套件

337
00:23:34,348 --> 00:23:36,583
并最终将插件包与他人共享

338
00:23:37,184 --> 00:23:42,456
回顾一下 插件可以用于
对开发者工具进行自动化和共享

339
00:23:42,489 --> 00:23:46,293
自定义命令提供了一种
对普通任务进行自动化的方法

340
00:23:46,326 --> 00:23:47,561
构建工具则可以用于

341
00:23:47,594 --> 00:23:51,465
在构建过程中生成文件

342
00:23:51,498 --> 00:23:53,400
感谢您的聆听！

343
00:23:53,433 --> 00:23:56,236
[迷幻音乐]

