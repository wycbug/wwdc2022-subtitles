1
00:00:00,100 --> 00:00:03,003
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,003 --> 00:00:09,810
♪

3
00:00:09,810 --> 00:00:11,979
您好
我是 Adam Bradford

4
00:00:11,979 --> 00:00:13,981
是 VisionKit 团队的
工程师

5
00:00:13,981 --> 00:00:16,316
如果您想在您的 App 中
添加实时文本

6
00:00:16,316 --> 00:00:18,652
那么本视频将能够为您提供帮助

7
00:00:18,652 --> 00:00:21,588
但首先 什么是实时文本？

8
00:00:21,588 --> 00:00:24,958
实时文本能够分析图像
并为用户提供各种功能

9
00:00:24,958 --> 00:00:29,663
如选择和复制文本等
与其内容进行交互

10
00:00:29,663 --> 00:00:33,133
执行查找和翻译

11
00:00:33,133 --> 00:00:34,801
提供包括映射地址 拨号

12
00:00:34,801 --> 00:00:37,070
或跳转到 URL 的

13
00:00:37,070 --> 00:00:39,940
数据检测工作流程等操作

14
00:00:39,940 --> 00:00:43,177
实时文本甚至允许二维码交互

15
00:00:43,177 --> 00:00:45,913
想象一下
如何将它应用于您的 App 中？

16
00:00:45,913 --> 00:00:49,550
想了解更多吗？请继续观看

17
00:00:49,550 --> 00:00:52,519
在本次讲座中 首先我将介绍

18
00:00:52,519 --> 00:00:54,721
实时文本 API 的一般概述

19
00:00:54,721 --> 00:00:57,724
然后探讨在现有的 App 中

20
00:00:57,724 --> 00:01:00,460
如何实现此 API

21
00:01:00,460 --> 00:01:02,930
在此之后
我将深入探讨在您的 App 中

22
00:01:02,930 --> 00:01:06,733
添加实时文本时
可能会有所帮助的一些技巧和窍门

23
00:01:06,733 --> 00:01:10,704
那么让我们开始
实时文本 API 概述

24
00:01:10,704 --> 00:01:14,908
在高级别下 在 Swift 中
可使用实时文本 API

25
00:01:14,908 --> 00:01:17,010
它在静态图像上效果很好

26
00:01:17,010 --> 00:01:20,414
并且可适用于暂停的视频帧

27
00:01:20,414 --> 00:01:23,250
如果您需要分析
实时视频流媒体的视频

28
00:01:23,250 --> 00:01:25,819
来搜索文本或二维码等项目

29
00:01:25,819 --> 00:01:28,856
VisionKit 也有
一个可用的数据扫描仪

30
00:01:28,856 --> 00:01:33,594
可从我同事 Ron 的相关讲座中
了解更多信息

31
00:01:33,594 --> 00:01:37,231
实时文本 API
在配备了 Apple 神经网络引擎

32
00:01:37,231 --> 00:01:39,566
操作系统为 iOS 16
以及上的设备中可用

33
00:01:39,566 --> 00:01:44,104
并在所有支持
macOS 13 的设备中可用

34
00:01:44,104 --> 00:01:46,240
它由四个主要类别组成

35
00:01:46,240 --> 00:01:49,176
若要使用它 首先 您需要一张图像

36
00:01:49,176 --> 00:01:51,945
然后将该图像

37
00:01:51,945 --> 00:01:54,515
导入执行异步分析的
ImageAnalyzer

38
00:01:54,515 --> 00:01:56,216
分析完成后

39
00:01:56,216 --> 00:01:58,018
根据您所用的平台
将生成的 ImageAnalysis 对象

40
00:01:58,018 --> 00:02:00,721
提供给 ImageAnalysisInteraction

41
00:02:00,721 --> 00:02:05,526
或 ImageAnalysisOverlayView

42
00:02:05,526 --> 00:02:08,428
到目前为止看起来比较简单 对吧？

43
00:02:08,428 --> 00:02:10,564
现在 我将演示如何将它

44
00:02:10,564 --> 00:02:13,600
添加到现有的 App 中

45
00:02:13,600 --> 00:02:16,003
这是我们的App

46
00:02:16,003 --> 00:02:17,437
是一个简单的图像查看器

47
00:02:17,437 --> 00:02:21,175
它在滚动视图内有一个图像视图

48
00:02:21,175 --> 00:02:24,745
请注意 我可以缩放和平移

49
00:02:24,745 --> 00:02:27,648
但是无论我如何尝试
我也无法选择任何文本

50
00:02:27,648 --> 00:02:30,384
或激活任何这些数据检测器

51
00:02:30,384 --> 00:02:33,120
它没有此功能

52
00:02:33,120 --> 00:02:35,455
这是 Xcode 中的项目

53
00:02:35,455 --> 00:02:37,624
要将实时文本添加到此 App 中

54
00:02:37,624 --> 00:02:40,861
我将修改视图控制器子类

55
00:02:40,861 --> 00:02:43,964
首先 我需要一个 ImageAnalyzer

56
00:02:43,964 --> 00:02:48,235
和一个 ImageAnalysisInteraction

57
00:02:48,235 --> 00:02:50,470
在这里
我简单重写了 viewDidLoad

58
00:02:50,470 --> 00:02:54,975
并在 imageview 中
添加了 interaction

59
00:02:54,975 --> 00:02:58,979
接下来 我需要知道何时执行分析

60
00:03:01,849 --> 00:03:03,517
请注意 当设置了新图像后

61
00:03:03,517 --> 00:03:05,853
我首先重置了
preferredInteractionTypes

62
00:03:05,853 --> 00:03:10,290
和 analysis
其修改的是旧图像

63
00:03:10,290 --> 00:03:13,827
现在在写新 analysis 前
所需的内容都已完成

64
00:03:13,827 --> 00:03:17,164
接下来 我将创建将使用的函数

65
00:03:17,164 --> 00:03:19,833
然后检查我们的图像是否存在

66
00:03:23,003 --> 00:03:28,542
如果存在 则创建一个 Task

67
00:03:28,542 --> 00:03:31,845
接下来 创建一个
configuration 来告诉分析器

68
00:03:31,845 --> 00:03:34,181
它应该检索什么

69
00:03:34,181 --> 00:03:39,653
在这种情况下 我将使用 text
和 machineReadableCode

70
00:03:39,653 --> 00:03:41,555
生成 analysis 可抛出

71
00:03:41,555 --> 00:03:43,690
所以酌情处理

72
00:03:43,690 --> 00:03:46,226
最后 我已准备好调用

73
00:03:46,226 --> 00:03:48,195
analyzeImageWithConfiguration 方法

74
00:03:48,195 --> 00:03:51,698
这将开始分析过程

75
00:03:51,698 --> 00:03:53,700
分析完成后

76
00:03:53,700 --> 00:03:56,170
已经过去了一段时间

77
00:03:56,170 --> 00:03:59,006
App 的状态可能也已经改变

78
00:03:59,006 --> 00:04:01,975
所以我会检查分析是否已成功

79
00:04:01,975 --> 00:04:05,145
显示的图像是否未改变

80
00:04:05,145 --> 00:04:07,080
如果所有这些检查都通过

81
00:04:07,080 --> 00:04:09,683
我可以简单地在 interaction 中
设置 analysis

82
00:04:09,683 --> 00:04:12,219
并设置
preferredInteractionTypes

83
00:04:12,219 --> 00:04:13,787
我在这里
使用 .automatic

84
00:04:13,787 --> 00:04:17,824
它会提供默认的系统行为

85
00:04:17,824 --> 00:04:20,894
我觉得可以进行测试了

86
00:04:20,894 --> 00:04:22,896
哦 看那个

87
00:04:22,896 --> 00:04:26,099
我看到实时文本按钮出现了没错

88
00:04:26,099 --> 00:04:28,368
我现在可以选择文本了

89
00:04:28,368 --> 00:04:30,304
注意 这些界面元素

90
00:04:30,304 --> 00:04:32,406
会自动定位

91
00:04:32,406 --> 00:04:35,108
并将它们的位置保持在图像边界内

92
00:04:35,108 --> 00:04:39,780
和可见区域中 无需我额外操作

93
00:04:39,780 --> 00:04:42,282
好的 请注意 点击实时文本按钮

94
00:04:42,282 --> 00:04:44,451
将能够突出显示任何可选项目

95
00:04:44,451 --> 00:04:48,021
为数据检测器显示下划线
并显示快速操作

96
00:04:48,021 --> 00:04:51,024
我点击此快速操作 即可拨打电话

97
00:04:51,024 --> 00:04:54,394
甚至可以通过长按查看更多选项

98
00:04:54,394 --> 00:04:58,665
不得不说 这很酷

99
00:04:58,665 --> 00:05:01,101
只需这几行代码

100
00:05:01,101 --> 00:05:04,404
我使用了一张普通的图像
并实现了诸多功能

101
00:05:04,404 --> 00:05:06,740
这个简单的 App 现在能够

102
00:05:06,740 --> 00:05:10,210
选择图像上的文本 激活数据检测器

103
00:05:10,210 --> 00:05:14,114
二维码 查找 翻译文本等

104
00:05:14,114 --> 00:05:16,717
在我看来

105
00:05:16,717 --> 00:05:18,652
这区区几行代码实现的功能
也还不错

106
00:05:18,652 --> 00:05:21,355
现在您已经了解了
如何实现实时文本

107
00:05:21,355 --> 00:05:23,891
我将介绍一些技巧和窍门

108
00:05:23,891 --> 00:05:26,560
可能能帮助您更好地操作

109
00:05:26,560 --> 00:05:29,096
我将从探索交互类型开始

110
00:05:29,096 --> 00:05:30,931
大多数开发人员
会使用 .automatic

111
00:05:30,931 --> 00:05:33,467
它提供文本选择 但也会

112
00:05:33,467 --> 00:05:36,737
在启用实时文本按钮后
突出显示数据检测器

113
00:05:36,737 --> 00:05:40,407
这将在所检测到的
任何适用项目下方画一条线

114
00:05:40,407 --> 00:05:43,510
并允许一键访问来激活

115
00:05:43,510 --> 00:05:45,746
这与常见的内置 App 的行为

116
00:05:45,746 --> 00:05:48,148
完全相同

117
00:05:48,148 --> 00:05:50,884
如果您的 App 只用文本选择

118
00:05:50,884 --> 00:05:54,388
而无需使用数据检测器
您可以将类型设置为 .textSelection

119
00:05:54,388 --> 00:05:59,159
它不会随着实时文本
按钮状态的改变而改变

120
00:05:59,159 --> 00:06:00,827
如果您的 App 只用数据检测器

121
00:06:00,827 --> 00:06:04,031
而无需使用文本选择

122
00:06:04,031 --> 00:06:06,133
将类型设置为
.dataDetectors

123
00:06:06,133 --> 00:06:09,269
请注意 在此模式下禁用选择

124
00:06:09,269 --> 00:06:11,205
因此您不会看到实时文本按钮

125
00:06:11,205 --> 00:06:13,674
但数据检测器将添加下划线

126
00:06:13,674 --> 00:06:17,211
并可一键访问

127
00:06:17,211 --> 00:06:18,812
将一个空集设置为
preferredInteractionTypes

128
00:06:18,812 --> 00:06:21,715
将禁用交互

129
00:06:21,715 --> 00:06:26,053
最后一点 无论在文本选择
还是在自动模式下

130
00:06:26,053 --> 00:06:28,622
长按

131
00:06:28,622 --> 00:06:31,258
仍然可以激活数据检测器

132
00:06:31,258 --> 00:06:32,726
此功能受

133
00:06:32,726 --> 00:06:35,829
allowLongPressForDataDetectorsInTextMode
属性控制

134
00:06:35,829 --> 00:06:39,766
设置为 true 时
将启用功能 其为默认设置

135
00:06:39,766 --> 00:06:43,270
如有必要 设置为 false
即可禁用功能

136
00:06:43,270 --> 00:06:44,438
我想稍微花点时间

137
00:06:44,438 --> 00:06:46,573
讲一下底部的这些按钮

138
00:06:46,573 --> 00:06:49,309
它们统称为补充接口

139
00:06:49,309 --> 00:06:51,278
其中包括实时文本按钮

140
00:06:51,278 --> 00:06:53,447
通常位于右下角

141
00:06:53,447 --> 00:06:56,517
快速操作位于左下角

142
00:06:56,517 --> 00:06:59,987
快速操作代表
analysis 中的任何数据检测器

143
00:06:59,987 --> 00:07:02,923
并在实时文本按钮启用时可见

144
00:07:02,923 --> 00:07:05,092
大小、位置和可见性

145
00:07:05,092 --> 00:07:07,094
由 interaction 控制

146
00:07:07,094 --> 00:07:10,297
默认位置和外观与系统匹配

147
00:07:10,297 --> 00:07:12,366
您的 App 可能有
自定义界面元素

148
00:07:12,366 --> 00:07:15,102
这可能会干扰或使用不同的字体

149
00:07:15,102 --> 00:07:16,470
和符号权重

150
00:07:16,470 --> 00:07:20,307
让我们来看看如何自定义此界面

151
00:07:20,307 --> 00:07:23,877
首先是
isSupplementaryInterfaceHidden 属性

152
00:07:23,877 --> 00:07:26,914
如果我想
让我的 App 仍然可选择文本

153
00:07:26,914 --> 00:07:29,983
但不显示实时文本按钮

154
00:07:29,983 --> 00:07:31,752
当我设置
SupplementaryInterfaceHidden

155
00:07:31,752 --> 00:07:34,321
为 true 您的实时文本按钮

156
00:07:34,321 --> 00:07:37,090
或快速操作都不会显示

157
00:07:37,090 --> 00:07:40,127
还有一个的 ContentInsets 属性

158
00:07:40,127 --> 00:07:42,496
如果您的界面元素

159
00:07:42,496 --> 00:07:43,997
会重叠在补充接口上

160
00:07:43,997 --> 00:07:46,033
您可以调整
ContentInsets

161
00:07:46,033 --> 00:07:48,769
那么在可见的状态下
实时文本按钮和快速操作都能

162
00:07:48,769 --> 00:07:52,840
完美适应您现有的 App 内容

163
00:07:52,840 --> 00:07:54,441
如果您的 App 使用自定义字体

164
00:07:54,441 --> 00:07:56,276
您希望界面能够与之适应

165
00:07:56,276 --> 00:07:58,245
设置 SupplementaryInterfaceFont

166
00:07:58,245 --> 00:08:00,547
可为实时文本按钮和快速操作

167
00:08:00,547 --> 00:08:02,516
设置指定字体

168
00:08:02,516 --> 00:08:04,651
和指定的符号字体粗细

169
00:08:04,651 --> 00:08:06,987
请注意 为了按钮大小的一致性

170
00:08:06,987 --> 00:08:10,090
实时文本将忽略磅值

171
00:08:10,090 --> 00:08:12,025
换个话题

172
00:08:12,025 --> 00:08:14,428
如果您没有使用 UIImageview

173
00:08:14,428 --> 00:08:18,532
您可能会发现
突出显示并不能匹配您的图像

174
00:08:18,532 --> 00:08:20,601
这是因为使用 UIImageView 后

175
00:08:20,601 --> 00:08:22,970
VisionKit 可以使用
其 ContentMode 属性

176
00:08:22,970 --> 00:08:26,673
为您自动计算 contentsRect

177
00:08:26,673 --> 00:08:29,776
在这里 交互的视图边界

178
00:08:29,776 --> 00:08:32,145
比其图像内容的边界更大

179
00:08:32,145 --> 00:08:36,049
但应用的却是
默认的内容矩形 一个单位矩形

180
00:08:36,049 --> 00:08:39,152
这很容易通过实现委托方法

181
00:08:39,152 --> 00:08:41,054
contentsRectForInteraction 来解决

182
00:08:41,054 --> 00:08:43,590
且会在单位坐标空间中返回一个矩形

183
00:08:43,590 --> 00:08:46,159
描述图像内容

184
00:08:46,159 --> 00:08:49,830
与交互边界的关系 来纠正这个问题

185
00:08:49,830 --> 00:08:52,132
例如 返回一个标示这些值的矩形

186
00:08:52,132 --> 00:08:53,600
能够纠正这个问题

187
00:08:53,600 --> 00:08:55,903
但请基于
您 App 的当前内容和布局

188
00:08:55,903 --> 00:08:59,940
来返回正确的标准化矩形

189
00:08:59,940 --> 00:09:01,842
但每当交互的边界发生变化时

190
00:09:01,842 --> 00:09:04,811
将调用 contentsRectForInteraction

191
00:09:04,811 --> 00:09:06,547
如果您的 contentsRect 已更改

192
00:09:06,547 --> 00:09:08,882
但交互边界未更改

193
00:09:08,882 --> 00:09:11,285
您可以通过调用
setContentsRectNeedsUpdate()

194
00:09:11,285 --> 00:09:15,122
来使交互更新

195
00:09:15,122 --> 00:09:18,825
采用实时文本时
您可能会遇到的另一个问题是

196
00:09:18,825 --> 00:09:21,562
放置此交互的最佳位置是哪里？

197
00:09:21,562 --> 00:09:24,965
理想情况 实时文本交互直接放置在

198
00:09:24,965 --> 00:09:27,167
托管您的图像内容视图上

199
00:09:27,167 --> 00:09:30,003
如前所述 UIImageView 将计算

200
00:09:30,003 --> 00:09:32,606
contentsRect

201
00:09:32,606 --> 00:09:36,076
虽然不是必需的 但还是首选的

202
00:09:36,076 --> 00:09:38,178
如果您使用的
是 UIImageview

203
00:09:38,178 --> 00:09:40,347
只需在 ImageView 上设置交互

204
00:09:40,347 --> 00:09:43,450
VisionKit 将处理其他的内容

205
00:09:43,450 --> 00:09:45,986
但如果 您的 ImageView 位于

206
00:09:45,986 --> 00:09:47,487
在 ScrollView 内部

207
00:09:47,487 --> 00:09:50,591
您可能很想 将交互
放在 ScrollView 上

208
00:09:50,591 --> 00:09:54,294
但不建议这样做 且因它将有一个
不断变化的 contentsRect

209
00:09:54,294 --> 00:09:58,765
可能难以管理

210
00:09:58,765 --> 00:10:00,601
此处的解决方案是相同的

211
00:10:00,601 --> 00:10:02,269
将交互放在

212
00:10:02,269 --> 00:10:04,104
托管您的图像内容的视图上

213
00:10:04,104 --> 00:10:05,839
即使它在应用缩放的

214
00:10:05,839 --> 00:10:08,942
ScrollView 内

215
00:10:08,942 --> 00:10:11,144
接下来我将谈一下手势

216
00:10:11,144 --> 00:10:14,548
至少可以说

217
00:10:14,548 --> 00:10:16,016
实时文本有一套
非常非常丰富的手势识别器

218
00:10:16,016 --> 00:10:18,085
根据您的 App 的结构

219
00:10:18,085 --> 00:10:20,654
您可能会发现交互

220
00:10:20,654 --> 00:10:22,523
响应您的 App 应该处理的

221
00:10:22,523 --> 00:10:25,559
手势和事件
或 App 响应交互的

222
00:10:25,559 --> 00:10:26,593
不要担心

223
00:10:26,593 --> 00:10:29,263
如果发生了这些问题

224
00:10:29,263 --> 00:10:31,498
这里有一些技巧可以用来帮助纠正

225
00:10:31,498 --> 00:10:33,367
纠正此问题的一种常见方法

226
00:10:33,367 --> 00:10:35,169
就是实现委托方法

227
00:10:35,169 --> 00:10:39,006
interaction shouldBeginAt point
for interactionType

228
00:10:39,006 --> 00:10:42,843
如果返回 false
则不会执行该操作

229
00:10:42,843 --> 00:10:44,978
一个比较好的切入点
是检查 interaction

230
00:10:44,978 --> 00:10:47,548
在 at: point 是否有可交互项

231
00:10:47,548 --> 00:10:50,284
或者 是否有
活动中的 text seleciton

232
00:10:50,284 --> 00:10:52,286
此处使用文本选择检查

233
00:10:52,286 --> 00:10:55,489
所以您能够点击文本

234
00:10:55,489 --> 00:10:58,258
来取消选择

235
00:10:58,258 --> 00:11:01,195
另一方面 如果您发现您的交互

236
00:11:01,195 --> 00:11:03,297
似乎对手势没有反应

237
00:11:03,297 --> 00:11:05,666
可能是因为您的 App 中

238
00:11:05,666 --> 00:11:08,836
有手势识别器来处理手势

239
00:11:08,836 --> 00:11:11,738
在这种情况下
您可以制定类似的解决方案

240
00:11:11,738 --> 00:11:15,676
使用您的 gestureRecognizer 的
gestureRecognizerShouldBegin

241
00:11:15,676 --> 00:11:17,044
委托方法

242
00:11:17,044 --> 00:11:21,014
在这里 我执行了类似的检查

243
00:11:21,014 --> 00:11:23,250
如果该位置有交互式项目

244
00:11:23,250 --> 00:11:25,385
或者启用文本选择
会返回 false

245
00:11:25,385 --> 00:11:26,520
还有一点需要注意

246
00:11:26,520 --> 00:11:28,589
在这个例子中
我首先通过传入 nil

247
00:11:28,589 --> 00:11:32,025
将 gestureRecognizer 的位置

248
00:11:32,025 --> 00:11:33,327
转换成窗口坐标空间位置

249
00:11:33,327 --> 00:11:36,663
然后将其转换为交互的视图

250
00:11:36,663 --> 00:11:39,099
如果您的交互
位于应用缩放的 ScrollView 内

251
00:11:39,099 --> 00:11:42,870
这可能是必要的

252
00:11:42,870 --> 00:11:44,638
如果发现您的定点不匹配

253
00:11:44,638 --> 00:11:46,907
则可尝试此技巧

254
00:11:46,907 --> 00:11:49,343
我认为有用的另一类似方法

255
00:11:49,343 --> 00:11:52,446
是重写 UIView 中的
hitTest: WithEvent

256
00:11:52,446 --> 00:11:54,815
这里也是类似的操作

257
00:11:54,815 --> 00:11:57,150
我执行与之前相同类型的检查

258
00:11:57,150 --> 00:12:00,721
在这种情况下 返回适当的视图

259
00:12:00,721 --> 00:12:05,158
一如既往 我们希望
您的 App 尽可能响应迅速

260
00:12:05,158 --> 00:12:06,894
神经网络引擎的分析非常高效

261
00:12:06,894 --> 00:12:10,130
在此基础之上 我想分享有一些
ImageAnalyzer 的提示

262
00:12:10,130 --> 00:12:12,366
以获得最佳性能

263
00:12:12,366 --> 00:12:14,768
理想情况下 您的 App 只需

264
00:12:14,768 --> 00:12:16,436
共享一个 ImageAnalyzer

265
00:12:16,436 --> 00:12:19,139
此外 我们支持多种类型的图像

266
00:12:19,139 --> 00:12:21,675
您应该始终通过
传入您拥有的本机类型

267
00:12:21,675 --> 00:12:24,011
来尽量减少图像转换

268
00:12:24,011 --> 00:12:27,114
但如果您恰好
有一个 CVPixelBuffer

269
00:12:27,114 --> 00:12:29,349
将会是最高效的

270
00:12:29,349 --> 00:12:32,886
此外 为了最好地利用系统资源

271
00:12:32,886 --> 00:12:36,390
您应仅在图像出现在屏幕上时
或在此之前

272
00:12:36,390 --> 00:12:38,959
开始分析

273
00:12:38,959 --> 00:12:41,428
如果您的 App 包含内容滚动

274
00:12:41,428 --> 00:12:43,530
例如 包含了一个时间轴

275
00:12:43,530 --> 00:12:47,568
仅在滚动停止后再开始分析

276
00:12:47,568 --> 00:12:51,004
现在 实时文本
并不仅仅出现在此 API 中

277
00:12:51,004 --> 00:12:52,739
在您的 App 使用的系统中

278
00:12:52,739 --> 00:12:56,543
已自动为部分架构
提供实时文本支持

279
00:12:56,543 --> 00:13:00,547
例如 UITextField
或 UITextView 的

280
00:13:00,547 --> 00:13:04,251
实时文本支持
使用相机进行键盘输入

281
00:13:04,251 --> 00:13:08,288
WebKit 和 Quick Look
也支持实时文本

282
00:13:08,288 --> 00:13:12,159
如想了解更多信息 请查看这些讲座

283
00:13:12,159 --> 00:13:14,161
iOS 16 今年的新功能

284
00:13:14,161 --> 00:13:16,964
我们在 AVKit 中
添加了实时文本支持

285
00:13:16,964 --> 00:13:20,400
AVPlayerView
和 ViewController

286
00:13:20,400 --> 00:13:22,903
默认通过
allowsVideoFrameAnalysis 属性

287
00:13:22,903 --> 00:13:25,739
在暂停的帧中

288
00:13:25,739 --> 00:13:27,708
自动支持实时文本

289
00:13:27,708 --> 00:13:29,543
请注意 这仅适用于

290
00:13:29,543 --> 00:13:32,980
非 FairPlay 保护的内容

291
00:13:32,980 --> 00:13:35,282
如果您使用的是
AVPlayerLayer

292
00:13:35,282 --> 00:13:37,684
那么您负责的是管理分析

293
00:13:37,684 --> 00:13:40,988
和交互 使用

294
00:13:40,988 --> 00:13:43,223
currentlyDisplayedPixelBuffer 属性

295
00:13:43,223 --> 00:13:45,092
来获取当前帧非常重要

296
00:13:45,092 --> 00:13:46,660
这是保证

297
00:13:46,660 --> 00:13:49,830
分析正确框架的唯一途径

298
00:13:49,830 --> 00:13:51,598
如果视频播放速率为零

299
00:13:51,598 --> 00:13:55,969
这将仅返回一个有效值 此为浅拷贝

300
00:13:55,969 --> 00:13:58,672
写入将极不安全

301
00:13:58,672 --> 00:14:00,741
而且 仅适用于

302
00:14:00,741 --> 00:14:04,211
非 FairPlay 保护的内容

303
00:14:04,211 --> 00:14:06,747
我们很高兴能帮助实现

304
00:14:06,747 --> 00:14:07,848
您的 App 的实时文本功能

305
00:14:07,848 --> 00:14:10,851
代表实时文本团队的每一位成员

306
00:14:10,851 --> 00:14:12,953
感谢您参加本次讲座

307
00:14:12,953 --> 00:14:16,223
非常期待看到您如何将它
用于您 App 中的图像

308
00:14:16,223 --> 00:14:18,692
一如既往地 祝您从中获得乐趣

309
00:14:18,692 --> 00:14:23,096
♪

