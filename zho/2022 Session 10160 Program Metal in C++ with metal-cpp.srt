1
00:00:00,100 --> 00:00:03,003
♪ 柔和乐器演奏的嘻哈音乐 ♪

2
00:00:03,003 --> 00:00:09,676
♪

3
00:00:09,676 --> 00:00:11,311
大家好 我叫 Keyi Yu

4
00:00:11,311 --> 00:00:14,014
是 Metal Ecosystem
团队的工程师

5
00:00:14,014 --> 00:00:17,017
很高兴今天能在此
为您介绍 metal-cpp

6
00:00:17,017 --> 00:00:21,955
metal-cpp 专门服务于想要
在 Apple 平台

7
00:00:21,955 --> 00:00:25,058
创作 Metal App 的 C++ 用户

8
00:00:25,058 --> 00:00:27,594
metal-cpp 是一个低开销库

9
00:00:27,594 --> 00:00:31,698
可以将 C++ App 连接到 Metal

10
00:00:31,698 --> 00:00:35,702
首先大致介绍一下 metal-cpp

11
00:00:35,702 --> 00:00:39,706
及其工作原理
然后我还会详细介绍下

12
00:00:39,706 --> 00:00:43,310
Objective-C 对象的生命周期

13
00:00:43,310 --> 00:00:47,781
C++ 和 Objective-C 处理
生命周期的方式有些差异

14
00:00:47,781 --> 00:00:52,219
我会介绍该如何处理这些差异

15
00:00:52,219 --> 00:00:55,756
Xcode 和 metal-cpp
有些很棒的实用程序

16
00:00:55,756 --> 00:00:58,392
可以帮助您管理 App 中的

17
00:00:58,392 --> 00:01:01,094
对象生命周期

18
00:01:01,094 --> 00:01:05,098
最后 我将展示如何集成 C++ 代码

19
00:01:05,098 --> 00:01:09,102
和 Objective-C 类

20
00:01:09,102 --> 00:01:13,340
首先来说说 metal-cpp
及其工作原理

21
00:01:13,340 --> 00:01:16,343
Metal 为 Apple 平台上
加速图形处理和运算

22
00:01:16,343 --> 00:01:20,314
奠定了基础 使您的 App 和游戏得以

23
00:01:20,314 --> 00:01:23,317
充分利用 GPU 的强大功能

24
00:01:23,317 --> 00:01:26,553
最初设计 metal-cpp 时使用的是

25
00:01:26,553 --> 00:01:29,323
Objective-C 的强大功能及惯例

26
00:01:29,323 --> 00:01:34,061
但如果您的代码库用的是 C++
则可能需要另外桥接（bridge）

27
00:01:34,061 --> 00:01:37,464
您的代码和
Metal 的 Objective-C 代码

28
00:01:37,464 --> 00:01:40,000
metal-cpp 应运而生！

29
00:01:40,000 --> 00:01:43,337
metal-cpp 能够充当
C++ App 和 Objective-C Metal

30
00:01:43,337 --> 00:01:45,606
之间的枢纽

31
00:01:45,606 --> 00:01:48,208
当 App 中应用了 metal-cpp

32
00:01:48,208 --> 00:01:51,678
您就可以在 C++ 中
使用 Metal 类和函数

33
00:01:51,678 --> 00:01:54,915
此外 在运行时
metal-cpp 也可以帮助

34
00:01:54,915 --> 00:01:56,450
调用 Objective-C 函数

35
00:01:56,450 --> 00:02:00,521
metal-cpp 是轻量级的
Metal C++ 包装器

36
00:02:00,521 --> 00:02:03,657
之所以说轻量级
是因为 metal-cpp 已经成为了

37
00:02:03,657 --> 00:02:07,628
带有内联函数调用的仅头文件库

38
00:02:07,628 --> 00:02:11,331
能够通过达到 C++

39
00:02:11,331 --> 00:02:14,835
调用 Objective-C API
的一对一映射

40
00:02:14,835 --> 00:02:16,770
实现 100% Metal API 覆盖率

41
00:02:16,770 --> 00:02:20,007
为此 metal-cpp 包装了 Foundation

42
00:02:20,007 --> 00:02:22,442
和 CoreAnimation 框架的部分内容

43
00:02:22,442 --> 00:02:24,711
由于 metal-cpp 已
在 Apache 2 许可下开源

44
00:02:24,711 --> 00:02:27,214
因此您可以修改库并轻松将其

45
00:02:27,214 --> 00:02:29,650
添加到您的 App

46
00:02:29,650 --> 00:02:32,853
metal-cpp 能够使用 C

47
00:02:32,853 --> 00:02:35,622
直接调用 Objective-C 运行时

48
00:02:35,622 --> 00:02:38,959
该机制与 Objective-C 编译器用于

49
00:02:38,959 --> 00:02:42,963
执行 Objective-C 方法
的机制完全相同

50
00:02:42,963 --> 00:02:47,167
所以这个包装器增加的开销不多

51
00:02:47,167 --> 00:02:51,438
由于 metal-cpp 实现了
C++ 对 Objective-C 调用的

52
00:02:51,438 --> 00:02:53,440
一对一映射

53
00:02:53,440 --> 00:02:57,077
它也遵循相同的
Cocoa 内存管理规则

54
00:02:57,077 --> 00:02:59,947
这个问题稍后会详谈

55
00:02:59,947 --> 00:03:02,216
这种一对一映射还能够让

56
00:03:02,216 --> 00:03:05,319
连贯衔接所有开发者工具

57
00:03:05,319 --> 00:03:10,791
包括 GPU 帧捕获和 Xcode 调试器

58
00:03:10,791 --> 00:03:13,760
屏幕上是用 metal-cpp 绘制三角形

59
00:03:13,760 --> 00:03:15,696
所需的一系列调用

60
00:03:15,696 --> 00:03:19,499
如果您已熟悉掌握 C++
现在正是学习 Metal 的好时机

61
00:03:19,499 --> 00:03:22,870
语言语法不会成为您的学习障碍

62
00:03:22,870 --> 00:03:26,306
如果您已经
在 Objective-C 中使用过 Metal

63
00:03:26,306 --> 00:03:29,443
在函数调用方面

64
00:03:29,443 --> 00:03:31,912
Metal 的 Objective-C 接口
和 metal-cpp

65
00:03:31,912 --> 00:03:33,780
两者差别很小

66
00:03:33,780 --> 00:03:38,852
让我来演示下
metal-cpp 的操作有多简便

67
00:03:38,852 --> 00:03:41,555
首先 创建一个命令缓冲区

68
00:03:41,555 --> 00:03:45,259
填写供 GPU 执行的命令

69
00:03:45,259 --> 00:03:48,495
可以简单将 C++ 原始指针

70
00:03:48,495 --> 00:03:51,665
作为 Objective-C ID 的映射

71
00:03:51,665 --> 00:03:54,234
然后创建一个渲染命令编码器

72
00:03:54,234 --> 00:03:57,504
用命令缓冲区编写渲染命令

73
00:03:57,504 --> 00:04:00,541
C++ 函数渲染命令编码器

74
00:04:00,541 --> 00:04:02,643
和 Objective-C 函数中的

75
00:04:02,643 --> 00:04:06,980
带描述符的渲染命令编码器
是一样的

76
00:04:06,980 --> 00:04:09,750
唯一的区别是编程语言的

77
00:04:09,750 --> 00:04:11,552
名称惯例

78
00:04:11,552 --> 00:04:14,321
接着设置一个渲染管道状态对象

79
00:04:14,321 --> 00:04:17,257
其中包含顶点 片段着色器

80
00:04:17,257 --> 00:04:19,860
以及其他各种渲染状态

81
00:04:19,860 --> 00:04:24,631
然后 对绘制调用进行编码
以绘制三角形

82
00:04:24,631 --> 00:04:25,999
然后给出指示

83
00:04:25,999 --> 00:04:29,403
表明渲染命令的编码已经完成

84
00:04:29,403 --> 00:04:33,340
我展示了可绘制对象
因此三角形会显示在屏幕上

85
00:04:33,340 --> 00:04:36,410
最后 提交了命令缓冲区

86
00:04:36,410 --> 00:04:40,848
来告诉 GPU 可以开始执行命令了

87
00:04:40,848 --> 00:04:43,784
显然 metal-cpp 和
Objective-C Metal

88
00:04:43,784 --> 00:04:45,485
两者几乎一模一样

89
00:04:45,485 --> 00:04:48,155
有了 metal-cpp 您无需担心

90
00:04:48,155 --> 00:04:49,957
语言语法会带来问题

91
00:04:49,957 --> 00:04:52,726
您可以直接查看 Metal 文档

92
00:04:52,726 --> 00:04:56,463
来学习 Metal 的概念和用法

93
00:04:56,463 --> 00:04:58,098
您可能已经测试过

94
00:04:58,098 --> 00:05:00,501
之前用过的这个延迟光照示例了

95
00:05:00,501 --> 00:05:03,704
现在 该延迟光照示例有了新版本

96
00:05:03,704 --> 00:05:06,206
支持使用 metal-cpp

97
00:05:06,206 --> 00:05:09,510
希望这可以帮助您在实践中学习
如何使用 metal-cpp

98
00:05:09,510 --> 00:05:11,078
进行编码

99
00:05:11,078 --> 00:05:13,380
我也很高兴为您带来

100
00:05:13,380 --> 00:05:17,851
一系列应用了 Metal API 的
渐进的 C++ 示例

101
00:05:17,851 --> 00:05:21,488
让我来展示如何用它完成不同的任务

102
00:05:25,158 --> 00:05:28,695
现在您对 metal-cpp 有了一点了解

103
00:05:28,695 --> 00:05:30,464
您该如何在实践中应用呢？

104
00:05:30,464 --> 00:05:32,933
我们去年发布了 metal-cpp

105
00:05:32,933 --> 00:05:35,302
您可以在这个网页找到下载资料

106
00:05:35,302 --> 00:05:36,937
和说明

107
00:05:36,937 --> 00:05:39,907
让我来为您示范一下步骤

108
00:05:39,907 --> 00:05:41,909
下载 metal-cpp 后

109
00:05:41,909 --> 00:05:44,878
您需要告知 Xcode 其路径

110
00:05:44,878 --> 00:05:49,616
请看 我把 metal-cpp
放到了当前项目下

111
00:05:49,616 --> 00:05:53,020
然后 需要将 C++17 或更高版本

112
00:05:53,020 --> 00:05:56,990
设置为 C++ 语言方言

113
00:05:56,990 --> 00:05:59,860
接下来 在项目中添加三个框架

114
00:05:59,860 --> 00:06:03,997
Foundation QuartzCore 和 Metal

115
00:06:03,997 --> 00:06:05,532
还有最后一件事

116
00:06:05,532 --> 00:06:09,336
完成后才能使用
这些框架的 C++ 接口

117
00:06:09,336 --> 00:06:12,139
metal-cpp 中有三个头文件

118
00:06:12,139 --> 00:06:14,842
由于 metal-cpp 是只有头文件的库

119
00:06:14,842 --> 00:06:17,444
您需要在导入头文件之前

120
00:06:17,444 --> 00:06:19,847
生成头文件的实现

121
00:06:19,847 --> 00:06:24,985
为此需要定义三个宏：
NS_PRIVATE_IMPLEMENTATION

122
00:06:24,985 --> 00:06:29,656
CA_PRIVATE_IMPLEMENTATION
和 MTL_PRIVATE_IMPLEMENTATION

123
00:06:29,656 --> 00:06:32,693
如果您好奇 metal-cpp 在后台

124
00:06:32,693 --> 00:06:33,994
对宏的作用

125
00:06:33,994 --> 00:06:37,631
请查看 metal-cpp 文件夹
中的桥接头文件

126
00:06:37,631 --> 00:06:39,499
头文件可以单独使用

127
00:06:39,499 --> 00:06:42,169
也可被放入一个单独的头文件

128
00:06:42,169 --> 00:06:45,072
您可以随时在需要时导入头文件

129
00:06:45,072 --> 00:06:48,909
但请记住 不要重复定义 NS、CA

130
00:06:48,909 --> 00:06:52,746
或 MTL_PRIVATE_IMPLEMENTATION 宏

131
00:06:52,746 --> 00:06:56,950
否则可能导致重复定义错误

132
00:06:56,950 --> 00:06:59,286
为了高效使用 metal-cpp

133
00:06:59,286 --> 00:07:02,322
您需要了解 Cocoa 的内存管理规则

134
00:07:02,322 --> 00:07:05,425
学习如何利用功能强大的实用程序来

135
00:07:05,425 --> 00:07:07,995
管理对象生命周期
以及学习如何设计

136
00:07:07,995 --> 00:07:10,497
与其他框架接口时

137
00:07:10,497 --> 00:07:12,733
的 App 架构

138
00:07:12,733 --> 00:07:16,336
先说对象生命周期管理

139
00:07:16,336 --> 00:07:18,639
在 App 运行期间

140
00:07:18,639 --> 00:07:21,909
您通常需要分配和释放内存

141
00:07:21,909 --> 00:07:24,811
还需要管理命令缓冲区

142
00:07:24,811 --> 00:07:27,214
管道对象和资源

143
00:07:27,214 --> 00:07:29,183
为了辅助管理这段内存

144
00:07:29,183 --> 00:07:33,020
Objective-C 和 Cocoa 对象
包含了一个引用计数

145
00:07:33,020 --> 00:07:36,089
metal-cpp 中也是同样

146
00:07:36,089 --> 00:07:39,026
引用计数可以帮助您管理内存

147
00:07:39,026 --> 00:07:40,627
应用引用计数之后

148
00:07:40,627 --> 00:07:43,597
所有对象都将包含
一个 retainCount 属性

149
00:07:43,597 --> 00:07:45,732
App 中的组件能够增加计数

150
00:07:45,732 --> 00:07:48,569
使其正在交互的对象保持活跃

151
00:07:48,569 --> 00:07:51,305
等完成后再减少对象

152
00:07:51,305 --> 00:07:53,473
当 retainCount 达到 0 时

153
00:07:53,473 --> 00:07:56,176
运行时将释放对象

154
00:07:56,176 --> 00:07:59,279
Objective-C 中有两类引用计数

155
00:07:59,279 --> 00:08:02,616
一种称为手动引用计数（Manual Retain-Release）
即 MRR

156
00:08:02,616 --> 00:08:06,253
另一个是自动引用计数 （Automatic Reference Counting）
即 ARC

157
00:08:06,253 --> 00:08:08,689
使用 ARC 功能编译代码时

158
00:08:08,689 --> 00:08:11,258
编译器将采用您创建的引用

159
00:08:11,258 --> 00:08:13,293
并自动将调用插入到

160
00:08:13,293 --> 00:08:16,430
底层的内存管理机制

161
00:08:16,430 --> 00:08:20,234
metal-cpp 对象需要手动保留和释放

162
00:08:20,234 --> 00:08:23,303
因此 您需要了解 Cocoa 惯例

163
00:08:23,303 --> 00:08:26,974
才能知道保留和释放对象的时机

164
00:08:26,974 --> 00:08:31,478
与在 C++ 中创建对象不同
metal-cpp 对象

165
00:08:31,478 --> 00:08:34,948
既不会被用 new 创建
也不会被用 delete 销毁

166
00:08:34,948 --> 00:08:38,785
在 Cocoa 惯例中
您创建的任何对象

167
00:08:38,785 --> 00:08:43,423
凡是以 alloc、new、copy
mutableCopy 或 create 开头的方法创建

168
00:08:43,423 --> 00:08:45,893
都归您所有

169
00:08:45,893 --> 00:08:49,563
您可以行使所有权来保留获得对象

170
00:08:49,563 --> 00:08:53,333
当您不再需要该对象时
则必须放弃对这一对象

171
00:08:53,333 --> 00:08:54,868
的所有权

172
00:08:54,868 --> 00:08:58,972
您可以立即或稍后释放该对象

173
00:08:58,972 --> 00:09:02,476
对于不归您所有的对象
您不能放弃其所有权

174
00:09:02,476 --> 00:09:05,913
否则可能导致 double free 漏洞

175
00:09:05,913 --> 00:09:08,081
接下来 我将进行展示一个

176
00:09:08,081 --> 00:09:10,150
Cocoa 惯例的示例

177
00:09:10,150 --> 00:09:14,154
在 A 类中 某个方法
使用了 alloc 来创建对象

178
00:09:14,154 --> 00:09:16,757
并用 init 初始化此对象

179
00:09:16,757 --> 00:09:20,961
请注意 永远不要
在一个对象上两次调用 init

180
00:09:20,961 --> 00:09:22,896
A 类取得所有权

181
00:09:22,896 --> 00:09:25,832
获得了释放该对象的权力

182
00:09:25,832 --> 00:09:29,303
现在 该对象的 retainCount 为 1

183
00:09:29,303 --> 00:09:33,373
接下来 B 类
使用 retain 来获取对象

184
00:09:33,373 --> 00:09:35,976
并获得了该对象的所有权

185
00:09:35,976 --> 00:09:39,279
到目前为止 这里有两个对象共享着

186
00:09:39,279 --> 00:09:42,583
这个橙色方块对象的所有权

187
00:09:42,583 --> 00:09:44,651
retainCount 增加 1

188
00:09:46,520 --> 00:09:49,356
A 类不再需要这个对象

189
00:09:49,356 --> 00:09:53,126
所以 A 类应该手动调用释放

190
00:09:53,126 --> 00:09:56,830
结果 retainCount 减 1

191
00:09:56,830 --> 00:10:00,067
现在 拥有该对象的只有 B 类了

192
00:10:00,067 --> 00:10:03,670
好的 最后 B 类也想释放这个对象

193
00:10:03,670 --> 00:10:08,375
现在 retainCount 为 0
于是运行时释放对象

194
00:10:08,375 --> 00:10:11,144
换一种情况 假设 B 类的方法

195
00:10:11,144 --> 00:10:13,514
返回了一个对象

196
00:10:13,514 --> 00:10:16,617
但在其余程序中 您仍然需要此对象

197
00:10:16,617 --> 00:10:19,553
换句话说 虽然您想放弃

198
00:10:19,553 --> 00:10:22,222
B 类方法对象的所有权

199
00:10:22,222 --> 00:10:26,226
但您不希望该对象被立即释放

200
00:10:26,226 --> 00:10:30,264
在这种情况下 则需要
在 B 类中调用 autorelease

201
00:10:30,264 --> 00:10:33,333
调用 autorelease 后
retainCount 仍为 1

202
00:10:33,333 --> 00:10:36,837
也就是说 之后仍然可以使用该对象

203
00:10:36,837 --> 00:10:38,238
来思考一下：

204
00:10:38,238 --> 00:10:41,575
既然 B 类不再拥有该对象

205
00:10:41,575 --> 00:10:44,578
那么该由谁来释放呢？

206
00:10:44,578 --> 00:10:47,581
Foundation 框架
提供了一个重要对象

207
00:10:47,581 --> 00:10:49,650
也就是 AutoreleasePool

208
00:10:49,650 --> 00:10:54,388
Autorelease API 将对象
放入 AutoreleasePool

209
00:10:54,388 --> 00:10:58,992
于是现在 AutoreleasePool
获得了对象的所有权

210
00:10:58,992 --> 00:11:02,029
当 AutoreleasePool 被销毁时

211
00:11:02,029 --> 00:11:04,798
会减少接收者的 retainCount

212
00:11:04,798 --> 00:11:08,836
您不一定需要手动创建自动释放对象

213
00:11:08,836 --> 00:11:11,305
Metal 本身便自带了几个

214
00:11:11,305 --> 00:11:13,473
自动释放对象

215
00:11:13,473 --> 00:11:16,176
所有创建临时对象的方法

216
00:11:16,176 --> 00:11:18,212
都可以将它们添加到 AutoreleasePool

217
00:11:18,212 --> 00:11:21,014
只需在后台调用 autorelease 即可

218
00:11:21,014 --> 00:11:24,718
AutoreleasePool 会负责释放对象

219
00:11:24,718 --> 00:11:27,321
换句话说 有了 AutoreleasePool 的帮助

220
00:11:27,321 --> 00:11:30,157
您可以更从容地进行编码

221
00:11:30,157 --> 00:11:33,527
您可以为主 App 设置 AutoreleasePool

222
00:11:33,527 --> 00:11:36,430
我们也鼓励您在较小范围内

223
00:11:36,430 --> 00:11:38,932
创建和管理额外的 AutoreleasePool

224
00:11:38,932 --> 00:11:41,401
来减少您程序的工作集

225
00:11:41,401 --> 00:11:45,205
您还需要为创建的每个线程
使用AutoreleasePool

226
00:11:45,205 --> 00:11:48,509
这是一个使用 AutoreleasePool

227
00:11:48,509 --> 00:11:51,078
和自动释放对象的示例

228
00:11:51,078 --> 00:11:53,680
在该示例中 一个 AutoreleasePool

229
00:11:53,680 --> 00:11:57,918
由 alloc 创建
此时您拥有其所有权

230
00:11:57,918 --> 00:12:00,587
且需要您手动释放

231
00:12:00,587 --> 00:12:03,290
现在我们有了一个 AutoreleasePool

232
00:12:03,290 --> 00:12:05,125
正如之前说过的

233
00:12:05,125 --> 00:12:07,928
您需要创建一个命令缓冲区

234
00:12:07,928 --> 00:12:11,131
由于不是用 alloc 或 create 创建

235
00:12:11,131 --> 00:12:13,567
您对其没有所有权

236
00:12:13,567 --> 00:12:19,706
相反 它是由 Metal 创建的+
自动释放对象

237
00:12:19,706 --> 00:12:22,943
该命令缓冲区将被放入 AutoreleasePool

238
00:12:22,943 --> 00:12:26,613
由 AutoreleasePool 来负责释放

239
00:12:26,613 --> 00:12:28,182
直到释放 AutoreleasePool 之前

240
00:12:28,182 --> 00:12:31,552
您都可以随意使用它

241
00:12:31,552 --> 00:12:35,656
接着 您需要创建一个
RenderPassDescriptor

242
00:12:35,656 --> 00:12:39,193
该 RenderPassDescriptor 也将同样被放入

243
00:12:39,193 --> 00:12:40,394
AutoreleasePool

244
00:12:40,394 --> 00:12:43,197
与 RenderCommandEncoder 相同

245
00:12:43,197 --> 00:12:46,900
它也是一个由 Metal 创建的
自动释放对象

246
00:12:46,900 --> 00:12:49,937
不要忘记这个 currentDrawable 对象

247
00:12:49,937 --> 00:12:53,607
它也会被放入 AutoreleasePool 中

248
00:12:53,607 --> 00:12:56,944
在这段代码的最后
我使用了 pPool-release

249
00:12:56,944 --> 00:12:59,112
来释放 AutoreleasePool

250
00:12:59,112 --> 00:13:02,115
在被释放之前 AutoreleasePool

251
00:13:02,115 --> 00:13:04,651
会释放拥有的所有对象

252
00:13:04,651 --> 00:13:07,921
在这种情况下 它会释放
CommandBuffer

253
00:13:07,921 --> 00:13:12,059
RenderPassDescriptor
RenderCommandEncoder

254
00:13:12,059 --> 00:13:14,061
和当前可绘制对象

255
00:13:14,061 --> 00:13:16,864
最后再释放 AutoreleasePool

256
00:13:16,864 --> 00:13:19,533
目前为止 您已经了解了 Cocoa 惯例

257
00:13:19,533 --> 00:13:22,669
自动释放对象和 AutoreleasePool

258
00:13:22,669 --> 00:13:26,440
只有正确管理对象生命周期

259
00:13:26,440 --> 00:13:29,843
才能避免内存泄漏和僵尸对象

260
00:13:29,843 --> 00:13:32,613
而我们恰好为您提供了合适的工具

261
00:13:32,613 --> 00:13:35,015
可以避免及排除这些问题

262
00:13:35,015 --> 00:13:37,184
我将专注于两个实用程序：

263
00:13:37,184 --> 00:13:40,587
NS::SharedPtr 和 NSZombie

264
00:13:40,587 --> 00:13:44,458
NS::SharedPtr 是新增的实用程序
可以帮助您管理

265
00:13:44,458 --> 00:13:46,627
对象生命周期

266
00:13:46,627 --> 00:13:48,996
可以在 Foundation 框架下的

267
00:13:48,996 --> 00:13:51,064
metal-cpp 文件夹中找到它

268
00:13:51,064 --> 00:13:53,333
请注意 它和 std:shared_ptr

269
00:13:53,333 --> 00:13:55,269
并不完全相同

270
00:13:55,269 --> 00:13:59,640
它不依赖于 C++ 标准库

271
00:13:59,640 --> 00:14:03,043
且没有额外的存储引用计数的成本

272
00:14:03,043 --> 00:14:05,779
这就是 NS::SharedPtr

273
00:14:05,779 --> 00:14:08,615
其转移和保留函数能够清晰表达

274
00:14:08,615 --> 00:14:11,485
消耗一个对象的意图

275
00:14:11,485 --> 00:14:13,921
转移函数能够在
不增加指针引 referenceCount 的情况下

276
00:14:13,921 --> 00:14:16,757
创建一个 SharedPtr

277
00:14:16,757 --> 00:14:21,028
来将所有权高效转移到 SharedPtr

278
00:14:21,028 --> 00:14:25,532
保留函数能够向传入的对象
发送保留命令

279
00:14:25,532 --> 00:14:28,101
您可以使用此功能来让

280
00:14:28,101 --> 00:14:29,937
AutoreleasePool 中的对象保持活动

281
00:14:29,937 --> 00:14:32,539
并用其来表示 指针所有者

282
00:14:32,539 --> 00:14:36,543
在被指对象的生命周期内
拥有既得利益

283
00:14:36,543 --> 00:14:38,412
您可以如您所想
通过 get 和 operator-

284
00:14:38,412 --> 00:14:42,749
来访问底层对象

285
00:14:42,749 --> 00:14:45,752
SharedPtr 也能够按您所需

286
00:14:45,752 --> 00:14:48,789
复制、移动构造及赋值

287
00:14:48,789 --> 00:14:51,525
复制操作会增加 retainCount

288
00:14:51,525 --> 00:14:54,561
而移动操作速度迅速
且不影响 retainCount

289
00:14:54,561 --> 00:14:56,430
一般情况下

290
00:14:56,430 --> 00:14:59,600
SharedPtrs 只会向被指对象

291
00:14:59,600 --> 00:15:02,035
发送一个释放命令

292
00:15:02,035 --> 00:15:03,704
只要您想 也可以通过调用分离函数

293
00:15:03,704 --> 00:15:06,240
避免这种情况

294
00:15:06,240 --> 00:15:07,708
回到正题

295
00:15:07,708 --> 00:15:10,177
了解传输或保留这两种指针创建方法

296
00:15:10,177 --> 00:15:14,748
之间的区别非常重要

297
00:15:14,748 --> 00:15:17,084
对于 TransferPtr 来说

298
00:15:17,084 --> 00:15:22,789
假设这里有一个 MRR 对象
引用计数为 1

299
00:15:22,789 --> 00:15:25,359
在将它传递给 TransferPtr 函数后

300
00:15:25,359 --> 00:15:28,328
SharedPtr 将取得对象的所有权

301
00:15:28,328 --> 00:15:30,964
但它的 retainCount 不会改变

302
00:15:30,964 --> 00:15:32,799
当指针超出范围时

303
00:15:32,799 --> 00:15:34,868
SharedPtr 的析构函数便会运行

304
00:15:34,868 --> 00:15:37,638
并在 MRR 对象上调用释放函数

305
00:15:37,638 --> 00:15:40,140
将 retainCount 减为 0

306
00:15:40,140 --> 00:15:43,277
另一个函数是 NS::RetainPtr

307
00:15:43,277 --> 00:15:46,013
当您想将对象留下备用

308
00:15:46,013 --> 00:15:47,781
而不是现在释放时

309
00:15:47,781 --> 00:15:50,217
就应该使用 NS::RetainPtr

310
00:15:50,217 --> 00:15:55,389
以这个 MRR 对象为例
retainCount 数是 1

311
00:15:55,389 --> 00:15:58,025
在将它传递给 RetainPtr 函数之后

312
00:15:58,025 --> 00:16:00,727
retainCount 加一

313
00:16:00,727 --> 00:16:02,262
超出范围后

314
00:16:02,262 --> 00:16:06,500
该 RetainPtr 调用
释放此 MRR 对象的函数

315
00:16:06,500 --> 00:16:09,102
所以 retainCount 是 1

316
00:16:09,102 --> 00:16:12,406
一般来说
NS::TransferPtr 会为您

317
00:16:12,406 --> 00:16:13,941
取得一个对象的所有权

318
00:16:13,941 --> 00:16:17,444
而 NS::RetainPtr 会帮您

319
00:16:17,444 --> 00:16:20,747
在不想释放对象时保留该对象

320
00:16:20,747 --> 00:16:24,017
当您将对象传递给这两个函数

321
00:16:24,017 --> 00:16:27,321
NS::TransferPtr
不会改变引用计数

322
00:16:27,321 --> 00:16:31,558
但是 NS::RetainPtr 将
使引用计数增加 1

323
00:16:31,558 --> 00:16:34,494
因为 NS::RetainPtr 会在后台
为您调用保留函数

324
00:16:34,494 --> 00:16:36,830
这两个函数的析构函数

325
00:16:36,830 --> 00:16:39,499
都为传入的对象调用释放

326
00:16:39,499 --> 00:16:43,270
因此 引用计数减 1

327
00:16:43,270 --> 00:16:45,572
如果引用计数为 0

328
00:16:45,572 --> 00:16:48,208
该对象将在运行时被释放

329
00:16:48,208 --> 00:16:51,745
这是 NS::TransferPtr 的示例

330
00:16:51,745 --> 00:16:53,480
说起渲染通道

331
00:16:53,480 --> 00:16:55,682
我之前用它画了个三角形

332
00:16:55,682 --> 00:16:58,485
我需要这个渲染管道状态

333
00:16:58,485 --> 00:17:02,356
以下是创建渲染管道状态对象的调用

334
00:17:02,356 --> 00:17:05,792
这些是渲染管道描述符需要的属性

335
00:17:05,792 --> 00:17:07,928
根据 Cocoa 惯例

336
00:17:07,928 --> 00:17:12,199
凡是以 new 和 alloc 开头的调用

337
00:17:12,199 --> 00:17:14,067
其对象都归我所有

338
00:17:14,067 --> 00:17:17,604
所以我需要为这些对象手动调用释放

339
00:17:17,604 --> 00:17:20,941
但使用 NS::SharedPtr 后
就不需要我来为这些 MRR 对象

340
00:17:20,941 --> 00:17:23,043
调用释放了

341
00:17:23,043 --> 00:17:27,748
因为 NS::SharedPtrs
拥有这些对象的所有权

342
00:17:27,748 --> 00:17:33,220
看这里 我将原始指针传递
给了 TransferPtr 函数

343
00:17:33,220 --> 00:17:36,290
完成后 我在上一页中
示范的操作就没有必要了

344
00:17:36,290 --> 00:17:38,725
现在无需我来调用释放

345
00:17:38,725 --> 00:17:40,661
如果您熟悉 ARC

346
00:17:40,661 --> 00:17:44,364
可能会发现 一起使用
MRR 与 NS::SharedPtr

347
00:17:44,364 --> 00:17:46,400
体验和使用 ARC 十分相似

348
00:17:46,400 --> 00:17:48,468
您可能会在手动处理内存时

349
00:17:48,468 --> 00:17:50,537
遇到释放后使用错误

350
00:17:50,537 --> 00:17:52,840
如果您尝试使用已经释放的对象

351
00:17:52,840 --> 00:17:55,209
就有可能出现这类报错

352
00:17:55,209 --> 00:17:58,312
NSZombie 可以有效检查出这类错误

353
00:17:58,312 --> 00:18:00,314
当出现释放后使用错误时

354
00:18:00,314 --> 00:18:04,451
NSZombie 将触发断点
为您提供堆栈跟踪

355
00:18:04,451 --> 00:18:06,486
您可以很容易地运用带有环境变量

356
00:18:06,486 --> 00:18:08,322
来启用 Zombies

357
00:18:08,322 --> 00:18:11,225
只需将 NSZombieEnabled
设为 YES 即可

358
00:18:11,225 --> 00:18:13,827
或者 如果您使用的是 Xcode

359
00:18:13,827 --> 00:18:16,029
则可以在 scheme 中
启用 Zombies

360
00:18:16,029 --> 00:18:18,432
让我来演示一下工作原理

361
00:18:18,432 --> 00:18:21,835
我现在想创建一个
具有相同渲染管道设置的

362
00:18:21,835 --> 00:18:25,072
新渲染管道状态对象

363
00:18:25,072 --> 00:18:28,842
所以在这个
newRenderPipelineState 函数中

364
00:18:28,842 --> 00:18:32,813
我重用了 pDesc 对象

365
00:18:34,815 --> 00:18:38,685
点击运行后 Xcode 触发断点

366
00:18:38,685 --> 00:18:40,888
并显示堆栈跟踪

367
00:18:40,888 --> 00:18:43,724
这意味着有哪里出了问题

368
00:18:43,724 --> 00:18:47,194
嗯 出什么问题了？

369
00:18:47,194 --> 00:18:54,001
也许 NSZombie 可以帮上忙
于是我在 scheme 中启用了 NSZombie

370
00:18:57,004 --> 00:19:01,308
当我再次运行程序时
NSZombie 会触发断点

371
00:19:01,308 --> 00:19:04,244
在控制台输出中有了些新东西：

372
00:19:04,244 --> 00:19:09,183
“message sent to deallocated instance”
（消息已发送到已释放实例）

373
00:19:09,183 --> 00:19:12,886
哦 原来是因为我重用了
一个已经释放的对象

374
00:19:12,886 --> 00:19:16,256
这个对象就是渲染管道描述符

375
00:19:16,256 --> 00:19:19,026
所以我只能在释放之前

376
00:19:19,026 --> 00:19:21,228
使用这个渲染管道描述符

377
00:19:21,228 --> 00:19:24,097
顺着这样的步骤 问题就解决了

378
00:19:24,097 --> 00:19:28,035
收看今年的演讲
“Profile and optimize your game’s memory”

379
00:19:28,035 --> 00:19:31,271
您可以了解更多工具和细节

380
00:19:31,271 --> 00:19:34,608
比如说 该如何在
Instruments 内存分配中

381
00:19:34,608 --> 00:19:37,144
跟踪 retainCount

382
00:19:37,144 --> 00:19:40,547
欢迎您随时查看 Apple
平台上的其他工具

383
00:19:40,547 --> 00:19:43,450
您会找到不是可以 帮助您调试游戏

384
00:19:43,450 --> 00:19:45,619
提高性能的工具

385
00:19:45,619 --> 00:19:50,457
您已经了解了该如何在 metal-cpp
中管理对象生命周期

386
00:19:50,457 --> 00:19:53,493
但您可能仍有与其他框架交互的需求

387
00:19:53,493 --> 00:19:56,697
比如说 游戏控制器和音频

388
00:19:56,697 --> 00:19:59,233
Objective-C 也同样可以实现

389
00:19:59,233 --> 00:20:01,535
该如何与这些 API 交互

390
00:20:01,535 --> 00:20:05,706
并设计出简明的 App 架构呢？

391
00:20:05,706 --> 00:20:09,176
假设您用 Objective-C
写了一个 ViewController

392
00:20:09,176 --> 00:20:13,280
而编写渲染器时却用了
C++ 和 metal-cpp

393
00:20:13,280 --> 00:20:16,316
那么您需要就需要
从 ViewController

394
00:20:16,316 --> 00:20:18,318
调用渲染器方法 比如绘制

395
00:20:18,318 --> 00:20:22,222
挑战之处在于
需要将两种语言分开的同时

396
00:20:22,222 --> 00:20:25,626
让两种语言协同工作

397
00:20:25,626 --> 00:20:29,029
想要解决 就需要创建一个适配器类

398
00:20:29,029 --> 00:20:32,966
使其从 Objective-C
文件中调用 C++

399
00:20:32,966 --> 00:20:37,137
这样做之后 您便可以
在想要实现功能的文件中

400
00:20:37,137 --> 00:20:40,440
专门使用 Objective-C 或 C++

401
00:20:40,440 --> 00:20:41,642
举个例子

402
00:20:41,642 --> 00:20:45,579
在 Objective-C 中
创建一个 RendererAdapter

403
00:20:45,579 --> 00:20:48,048
在执行过程中

404
00:20:48,048 --> 00:20:51,451
我添加了一个 Objective-C 方法
方便我从 ViewController 里

405
00:20:51,451 --> 00:20:53,887
直接调用它

406
00:20:53,887 --> 00:20:55,622
在界面内

407
00:20:55,622 --> 00:21:00,460
我声明了一个指向
渲染器对象的 C++ 指针

408
00:21:00,460 --> 00:21:02,796
在方法主体内部

409
00:21:02,796 --> 00:21:07,000
我直接调用了渲染器的 C++ 方法

410
00:21:07,000 --> 00:21:10,003
该方法需要将 MTK:View

411
00:21:10,003 --> 00:21:13,674
作为 C++ 对象放入绘制方法中

412
00:21:13,674 --> 00:21:18,011
也就是说
通过使用 __bridge 关键字

413
00:21:18,011 --> 00:21:20,113
视图被强制转换成了 C++ 类型

414
00:21:20,113 --> 00:21:23,417
关于这个强制转换
我会之后再详细说明

415
00:21:23,417 --> 00:21:27,888
与之相对 您需要做的
则是调用 MTKView

416
00:21:27,888 --> 00:21:32,626
其编写工具是渲染器的 Objective-C
而渲染器则由 C++ 编写

417
00:21:32,626 --> 00:21:35,062
这也同样具有挑战性

418
00:21:35,062 --> 00:21:39,132
想要解决 同样需要
创建一个适配器类

419
00:21:39,132 --> 00:21:41,969
有了这个类 在 C++ 文件中

420
00:21:41,969 --> 00:21:47,040
您可以使用 C++ 接口
调用 Objective-C 方法

421
00:21:47,040 --> 00:21:50,944
比如说 创建一个 ViewAdapter 类

422
00:21:50,944 --> 00:21:53,881
这个接口我是用 C++ 编写的

423
00:21:53,881 --> 00:21:55,549
所以在渲染器类中

424
00:21:55,549 --> 00:21:58,919
我可以轻松调用 C++ 视图方法

425
00:21:58,919 --> 00:22:00,554
在执行过程中

426
00:22:00,554 --> 00:22:03,757
我从 MTKView 调用了
Objective-C 方法

427
00:22:03,757 --> 00:22:08,395
包括 currentDrawable
和 depthStencilTexture

428
00:22:08,395 --> 00:22:11,698
您可能看到了
这里有些 __bridge 关键字

429
00:22:11,698 --> 00:22:14,401
是用来在 metal-cpp 对象
和 Objective-C 对象

430
00:22:14,401 --> 00:22:16,403
之间进行转换的

431
00:22:16,403 --> 00:22:18,005
正如在一开始说过的

432
00:22:18,005 --> 00:22:21,441
metal-cpp 对象需要
手动保留和释放

433
00:22:21,441 --> 00:22:24,178
而 Objective-C 创建的对象

434
00:22:24,178 --> 00:22:27,047
使用的是自动引用计数

435
00:22:27,047 --> 00:22:30,817
您需要在 MRR 和 ARC 之间

436
00:22:30,817 --> 00:22:33,787
来回移动对象

437
00:22:33,787 --> 00:22:35,522
以下是三种类型的桥式转换

438
00:22:35,522 --> 00:22:39,560
可以帮助您在 Objective-C
和 C++ 之间进行转换

439
00:22:39,560 --> 00:22:42,563
还可以帮助您转移对象所有权

440
00:22:42,563 --> 00:22:45,465
_bridge 转换可以在 Objective-C
和 metal cpp 对象之间

441
00:22:45,465 --> 00:22:47,734
进行强制转换

442
00:22:47,734 --> 00:22:52,105
之间不进行所有权转移

443
00:22:52,105 --> 00:22:55,742
__bridge_retained 可以将
Objective-C 指针

444
00:22:55,742 --> 00:23:00,747
强制转换为 metal-cpp 指针
并从 ARC 获得所有权

445
00:23:00,747 --> 00:23:03,750
__bridge_transfer 能够
将 metal cpp 指针

446
00:23:03,750 --> 00:23:07,754
移动到 Objective-C 并
将所有权转移给 ARC

447
00:23:07,754 --> 00:23:10,190
回到我们的问题
您需要在 metal-cpp 对象

448
00:23:10,190 --> 00:23:13,794
和 Objective-C 对象之间进行转换

449
00:23:13,794 --> 00:23:16,263
如果所有权没有发生转移

450
00:23:16,263 --> 00:23:18,732
您可以使用 __bridge 转换

451
00:23:18,732 --> 00:23:23,003
如果您想将对象从 metal-cpp
转换为 Objective-C

452
00:23:23,003 --> 00:23:25,706
并将所有权转移给 Objective-C

453
00:23:25,706 --> 00:23:29,076
则应该使用
__bridge_transfer 转换

454
00:23:29,076 --> 00:23:32,446
如果您想将对象从 Objective-C
转换为 metal-cpp

455
00:23:32,446 --> 00:23:34,915
并从 ARC 中移出所有权

456
00:23:34,915 --> 00:23:37,284
则应该使用
__bridge_retained 转换

457
00:23:37,284 --> 00:23:40,087
假设一个情景中
我必须使用 MetalKit

458
00:23:40,087 --> 00:23:42,389
来利用资产加载代码

459
00:23:42,389 --> 00:23:45,492
也就是说 在我的 C++ App 中

460
00:23:45,492 --> 00:23:49,162
我需要一个纹理
来充当 metal-cpp 对象

461
00:23:49,162 --> 00:23:53,467
但它是由 Objective-C 方法创建的

462
00:23:53,467 --> 00:23:57,137
我需要想办法将所有权转出 ARC

463
00:23:57,137 --> 00:23:59,606
方便我手动释放它

464
00:23:59,606 --> 00:24:00,841
在这种情况下

465
00:24:00,841 --> 00:24:06,046
我需要选用
__bridge_retained 转移

466
00:24:06,046 --> 00:24:10,017
这有个从目录加载纹理的 C++ 函数

467
00:24:10,017 --> 00:24:13,820
我现在想返回一个 metal-cpp 纹理

468
00:24:13,820 --> 00:24:16,823
但在里面 我在 MetalKit 中调用了

469
00:24:16,823 --> 00:24:19,760
一些 Objective-C 函数

470
00:24:19,760 --> 00:24:23,931
我需要定义纹理加载器所需的选项

471
00:24:23,931 --> 00:24:29,069
接着 我通过从 MetalKit
调用 Objective-C 方法

472
00:24:29,069 --> 00:24:31,171
创建了一个纹理加载器

473
00:24:31,171 --> 00:24:35,475
有了加载器之后
我可以创建一个纹理对象

474
00:24:35,475 --> 00:24:38,378
并从目录中加载纹理

475
00:24:38,378 --> 00:24:41,348
这个方法也属于 MetalKit 的

476
00:24:41,348 --> 00:24:43,217
Objective-C 方法

477
00:24:43,217 --> 00:24:46,453
现在 我有了一个
Objective-C 类型的纹理

478
00:24:46,453 --> 00:24:49,923
我需要将其转换为 metal-cpp 对象

479
00:24:49,923 --> 00:24:52,192
并将其从 ARC 中取出

480
00:24:52,192 --> 00:24:54,995
将步骤都铭记于心后
就可以动手编写代码了

481
00:24:54,995 --> 00:24:58,665
让我来展示一下桥式转换
的工作原理吧

482
00:24:58,665 --> 00:25:01,668
第一步是定义纹理加载器需要的

483
00:25:01,668 --> 00:25:03,904
纹理加载器选项

484
00:25:03,904 --> 00:25:07,808
可以放心将 metal-cpp
存储模式和使用方法

485
00:25:07,808 --> 00:25:09,743
转换为 Objective-C 类型

486
00:25:09,743 --> 00:25:13,947
因为 metal-cpp 类型
对它们的定义为相同值

487
00:25:13,947 --> 00:25:16,850
请看 我现在创建了一个纹理加载器

488
00:25:16,850 --> 00:25:20,254
我有了一个 metal-cpp 对象的设备

489
00:25:20,254 --> 00:25:24,758
现在需要将它传递
给 initWithDevice 方法

490
00:25:24,758 --> 00:25:28,962
由于 metal-cpp 对象
属于 Objective-C 对象

491
00:25:28,962 --> 00:25:31,732
因此可以像 toll-free 对象
一样进行转换

492
00:25:31,732 --> 00:25:35,202
所有权没有进行转让

493
00:25:35,202 --> 00:25:37,304
现在我使用了纹理加载器选项

494
00:25:37,304 --> 00:25:39,940
和一个纹理加载器来创建纹理

495
00:25:39,940 --> 00:25:44,478
我想将加载的纹理
作为 metal-cpp 对象返回

496
00:25:44,478 --> 00:25:46,813
因此 我需要将其转出 ARC

497
00:25:46,813 --> 00:25:50,617
并转换为相应的指针类型

498
00:25:50,617 --> 00:25:53,253
可以通过 __bridge_retained
转换完成

499
00:25:53,253 --> 00:25:55,289
之后 我就可以将这个纹理

500
00:25:55,289 --> 00:25:57,424
作为任意 metal-cpp 对象

501
00:25:57,424 --> 00:26:00,027
我要负责释放该对象

502
00:26:00,027 --> 00:26:03,931
在本节视频
我介绍了可以在您的程序中

503
00:26:03,931 --> 00:26:06,433
帮助您处理两种不同语言的

504
00:26:06,433 --> 00:26:08,302
适配器模式

505
00:26:08,302 --> 00:26:13,040
我还展示了如何通过
三种类型的桥接转换

506
00:26:13,040 --> 00:26:15,175
实现 Objective-C 和 C++ 交互

507
00:26:15,175 --> 00:26:18,712
总的说来 metal-cpp
是一个非常高效的

508
00:26:18,712 --> 00:26:22,583
轻量级 Metal C++ 包装器

509
00:26:22,583 --> 00:26:26,286
我还介绍了 在使用 metal-cpp 时

510
00:26:26,286 --> 00:26:29,022
该如何管理对象生命周期

511
00:26:29,022 --> 00:26:31,558
又该如何用简便的方式

512
00:26:31,558 --> 00:26:32,960
与 Objective-C 交互

513
00:26:32,960 --> 00:26:37,164
以及我们的开发者工具
能为您的调试提供哪些帮助

514
00:26:37,164 --> 00:26:41,568
请下载 metal-cpp
体验众多效果惊人的范例吧！

515
00:26:41,568 --> 00:26:44,204
看看在 Metal 的辅助下
您能做出怎样的创造

516
00:26:44,204 --> 00:26:47,207
我们期待能看到您的 C++ App

517
00:26:47,207 --> 00:26:49,576
在所有 Apple 平台上运行

518
00:26:49,576 --> 00:26:51,411
感谢收看！

519
00:26:51,411 --> 00:26:55,616
♪

